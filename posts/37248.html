<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>二叉堆详解实现优先级队列 | Shio</title><meta name="keywords" content="算法"><meta name="author" content="Shio,muzhi567@qq.com"><meta name="copyright" content="Shio"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f2b94b"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="二叉堆详解实现优先级队列"><meta name="application-name" content="二叉堆详解实现优先级队列"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f2b94b"><meta property="og:type" content="article"><meta property="og:title" content="二叉堆详解实现优先级队列"><meta property="og:url" content="http://www.zhshio.cn/posts/37248.html"><meta property="og:site_name" content="Shio"><meta property="og:description" content="二叉堆详解实现优先级队列"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://www.toopic.cn/public/uploads/small/17102202974171022029789.jpg?_r_=51e6b011-4754-6662-9bb7-4bdfcedc8574"><meta property="article:author" content="Shio"><meta property="article:tag" content="Shio,zhshio,张帅,博客,一个有趣的博客,技术,Java,张,帅,后端,Spring"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.toopic.cn/public/uploads/small/17102202974171022029789.jpg?_r_=51e6b011-4754-6662-9bb7-4bdfcedc8574"><meta name="description" content="二叉堆详解实现优先级队列"><link rel="shortcut icon" href="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202311091058032.ico"><link rel="canonical" href="http://www.zhshio.cn/posts/37248"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="316AAC6F338B2BA69CD36EE8EB638425"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: 'https://twikoo.zhshio.cn/.netlify/functions/twikoo',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"","mailMd5":""},
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: {"mode":"api","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: {"skills":["🏃 脚踏实地行动派"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Shio","link":"链接: ","source":"来源: Shio","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Shio',
  title: '二叉堆详解实现优先级队列',
  postAI: '',
  pageFillDescription: '二叉堆详解实现优先级队列, 一、二叉堆概览, 二、优先级队列概览, 三、实现 swim 和 sink, 四、实现 delMax 和 insert, 五、最后总结, 经典练习题, , 基本思路, 解法代码, , 基本思路, 解法代码, , 基本思路, 解法代码, , 基本思路, 解法代码, , 基本思路, 解法代码, , 基本思路, 解法代码, , 基本思路, 解法代码, , 基本思路, 解法代码, , 基本思路, 解法代码, , 基本思路, 解法代码, , 基本思路, 解法代码, , 基本思路, 解法代码, , 基本思路, 解法代码, , 基本思路, 解法代码二叉堆详解实现优先级队列二叉堆没什么神秘性质比二叉搜索树还简单其主要操作就两个下沉和上浮用以维护二叉堆的性质其主要应用有两个首先是一种排序方法堆排序第二是一种很有用的数据结构优先级队列那么本文以实现优先级队列为例来讲讲一下二叉堆怎么运作的一二叉堆概览首先二叉堆和二叉树有啥关系呢为什么人们总是把二叉堆画成一棵二叉树因为二叉堆在逻辑上其实是一种特殊的二叉树完全二叉树只不过存储在数组里一般的链表二叉树我们操作节点的指针而在数组里我们把数组索引作为指针父节点的索引左孩子的索引右孩子的索引画个图你立即就能理解了比如是一个字符数组注意数组的第一个索引空着不用你看到了因为这棵二叉树是完全二叉树所以把作为整棵树的根的话每个节点的父节点和左右孩子的索引都可以通过简单的运算得到这就是二叉堆设计的一个巧妙之处为了方便讲解下面都会画的图都是二叉树结构相信你能把树和数组对应起来二叉堆还分为最大堆和最小堆最大堆的性质是每个节点都大于等于它的两个子节点类似的最小堆的性质是每个节点都小于等于它的子节点两种堆核心思路都是一样的本文以最大堆为例讲解对于一个最大堆根据其性质显然堆顶也就是一定是所有元素中最大的元素二优先级队列概览优先级队列这种数据结构有一个很有用的功能你插入或者删除元素的时候元素会自动排序这底层的原理就是二叉堆的操作数据结构的功能无非增删查改优先级队列有两个主要分别是插入一个元素和删除最大元素如果底层用最小堆那么就是删除最小元素注刚才说到二叉堆本质上是一棵二叉树而优先级队列这种数据结构底层是二叉堆那么为啥它的名字又和队列扯上了关系呢因为优先级队列的操作和队列比较像普通队列有个从队尾插入元素从队头移出元素出队顺序就是入队的时间顺序你也可以认为优先级队列是一种特殊的队列从队尾插入元素从队头移出元素只不过出队顺序是按照元素的大小顺序这么一看是不是觉得这种数据结构有队列内味儿了下面我们实现一个简化的优先级队列先看下代码框架存储元素的数组当前中的元素个数索引不用所以多分配一个空间返回当前队列中最大元素插入元素删除并返回当前队列中最大元素上浮第个元素以维护最大堆性质下沉第个元素以维护最大堆性质交换数组的两个元素是否比小还有三个方法提示这里用到的泛型可以是任何一种可比较大小的数据类型实现了方法比如等类型当然你自己练习时可以适度变通比如说在构造函数中传入一个比较函数这样就可以实现自定义排序逻辑了我这里为了简化就实现一个最大堆即每次删除都是队列中最大的元素空出来的四个方法是二叉堆和优先级队列的奥妙所在下面用图文来逐个理解三实现和为什么要有上浮和下沉的操作呢为了维护二叉堆结构我们要讲的是最大堆每个节点都比它的两个子节点大但是在插入元素和删除元素时难免破坏堆的性质这就需要通过这两个操作来恢复堆的性质了对于最大堆会破坏堆性质的有两种情况如果某个节点比它的子节点中的一个小那么就不配做父节点应该下去下面那个更大的节点上来做父节点这就是对进行下沉如果某个节点比它的父节点大那么不应该做子节点应该把父节点换下来自己去做父节点这就是对的上浮当然错位的节点可能要上浮或下沉很多次才能到达正确的位置恢复堆的性质所以代码中肯定有一个循环细心的读者也许会问这两个操作不是互逆吗所以上浮的操作一定能用下沉来完成为什么我还要费劲写两个方法是的操作是互逆等价的但是最终我们的操作只会在堆底和堆顶进行等会讲原因显然堆底的错位元素需要上浮堆顶的错位元素需要下沉上浮的代码实现为了节约篇幅省略上文给出的代码部分如果浮到堆顶就不能再上浮了如果第个元素比上层大将换上去画个看一眼就明白了下沉的代码实现下沉比上浮略微复杂一点因为上浮某个节点只需要和其父节点比较大小即可但是下沉某个节点需要和其两个子节点比较大小如果不是最大的就需要调整位置要把较大的那个子节点和交换为了节约篇幅省略上文给出的代码部分如果沉到堆底就沉不下去了先假设左边节点较大如果右边节点存在比一下大小结点比俩孩子都大就不必下沉了否则不符合最大堆的结构下沉结点画个看下就明白了至此二叉堆的主要操作就讲完了一点都不难吧代码加起来也就十行明白了和的行为下面就可以实现优先级队列了四实现和这两个方法就是建立在和上的方法先把要插入的元素添加到堆底的最后然后让其上浮到正确位置为了节约篇幅省略上文给出的代码部分先把新元素加到最后然后让它上浮到正确的位置方法先把堆顶元素和堆底最后的元素对调然后删除最后让下沉到正确位置为了节约篇幅省略上文给出的代码部分最大堆的堆顶就是最大元素把这个最大元素换到最后删除之让下沉到正确位置至此一个优先级队列就实现了插入和删除元素的时间复杂度为为当前二叉堆优先级队列中的元素总数因为我们时间复杂度主要花费在或者上而不管上浮还是下沉最多也就树堆的高度也就是级别五最后总结二叉堆就是一种完全二叉树所以适合存储在数组中而且二叉堆拥有一些特殊性质二叉堆的操作很简单主要就是上浮和下沉来维护堆的性质堆有序核心代码也就十行优先级队列是基于二叉堆实现的主要操作是插入和删除插入是先插到最后然后上浮到正确位置删除是调换位置后再删除然后下沉到正确位置核心代码也就十行也许这就是数据结构的威力简单的操作就能实现巧妙的功能真心佩服发明二叉堆算法的人最后更多二叉堆优先级队列相关的题目练习见二叉堆优先级队列的经典习题经典练习题二叉堆的主要应用是优先级队列而优先级队列的特色是动态排序插入的元素可以自动维护正确的顺序当然后文讲的二叉搜索树也可以做到动态排序优先级队列的限制是只能从队头和队尾操作元素一般来说用到优先级队列的题目主要分两类一类是合并多个有序链表这类题另一类是寻找第个最大元素这类题我们分别来看先来看第一类合并有序链表这样的题目合并个升序链表标签二叉堆数据结构链表链表双指针给你一个链表数组每个链表都已经按升序排列请你将这些链表合并成一个升序链表返回合并后的链表示例输入输出解释链表数组如下将它们合并到一个有序链表中得到基本思路本文有视频版链表双指针技巧全面汇总合并两个有序链表的延伸利用优先级队列二叉堆进行节点排序即可详细题解双指针技巧秒杀七道链表题目解法代码虚拟头结点优先级队列最小堆将个链表的头结点加入最小堆获取最小节点接到结果链表中指针不断前进类似题目环形链表环形链表相交链表删除链表的倒数第个结点合并两个有序链表超级丑数设计推特查找和最小的对数字有序矩阵中第小的元素分隔链表链表的中间结点剑指链表中倒数第个节点剑指合并两个排序的链表剑指两个链表的第一个公共节点剑指删除链表的倒数第个结点剑指链表中环的入口节点剑指两个链表的第一个重合节点剑指和最小的个数对剑指合并排序链表查找和最小的对数字标签二叉堆链表双指针给定两个以升序排列的整数数组和以及一个整数定义一对值其中第一个元素来自第二个元素来自请找到和最小的个数对示例输入输出解释返回序列中的前对数基本思路这道题其实是前文单链表的六大解题套路中讲过的合并个升序链表的变体怎么把这道题变成合并多个有序链表呢就比如说题目输入的用例组合出的所有数对儿这就可以抽象成三个有序链表这三个链表中每个元素数对之和是递增的所以就可以按照合并个升序链表的思路来合并取出前个作为答案即可解法代码存储三元组记录元素的索引位置用于生成下一个节点按照数对的元素和升序排序按照题的逻辑初始化优先级队列执行合并多个有序链表的逻辑链表中的下一个节点加入优先级队列类似题目剑指和最小的个数对有序矩阵中第小的元素标签二叉堆链表双指针给你一个矩阵其中每行和每列元素均按升序排序找到矩阵中第小的元素请注意它是排序后的第小元素而不是第个不同的元素你必须找到一个内存复杂度优于的解决方案示例输入输出解释矩阵中的元素为第小元素是基本思路这道题其实是前文单链表的六大解题套路中讲过的合并个升序链表的变体矩阵中的每一行都是排好序的就好比多条有序链表你用优先级队列施展合并多条有序链表的逻辑就能找到第小的元素了解法代码存储二元组记录当前元素的索引位置用于生成下一个节点按照元素大小升序排序初始化优先级队列把每一行的第一个元素装进去执行合并多个有序链表的逻辑找到第小的元素链表中的下一个节点加入优先级队列超级丑数标签二叉堆链表双指针超级丑数是一个正整数并满足其所有质因数都出现在质数数组中给你一个整数和一个整数数组返回第个超级丑数示例输入输出解释给定长度为的质数数组前个超级丑数序列为基本思路这题是丑数的进阶版第题是合并两个有序链表简单的变体而这道题是合并个升序链表困难的变体我在双指针技巧秒杀七道链表题目中都讲过你一定要先做下题注意那里我们抽象出了三条链表需要作为三条有序链表上的指针同时需要记录指针所指节点的值用函数计算最小头结点这道题相当于输入了条有序链表我们不能用函数计算最小头结点了而是要用优先级队列来计算最小头结点同时依然要维护链表指针指针所指节点的值我们把这些信息用一个三元组来保存结合第题的解法逻辑你应该能够看懂这道题的解法代码了详细题解一文秒杀所有丑数系列问题解法代码优先队列中装三元组其中代表链表节点的值是计算下一个节点所需的质数因子代表链表上的指针把多条链表的头结点加入优先级队列可以理解为最终合并的有序链表结果链表可以理解为结果链表上的指针取三个链表的最小结点避免结果链表出现重复元素接到结果链表上生成下一个节点加入优先级队列类似题目丑数丑数丑数剑指丑数设计推特标签数据结构设计设计一个简化版的推特可以让用户实现发送推文关注取消关注其他用户能够看见关注人包括自己的最近条推文实现类根据给定的和创建一条新推文每次调用此函数都会使用一个不同的检索当前用户新闻推送中最近条推文的新闻推送中的每一项都必须是由用户关注的人或者是用户自己发布的推文推文必须按照时间顺序由最近到最远排序为的用户开始关注为的用户为的用户不再关注为的用户示例输入输出解释用户发送了一条新推文用户推文用户的获取推文应当返回一个列表其中包含一个为的推文用户关注了用户用户发送了一个新推文推文用户的获取推文应当返回一个列表其中包含两个推文分别为推文应当在推文之前因为它是在之后发送的用户取消关注了用户用户获取推文应当返回一个列表其中包含一个为的推文因为用户已经不再关注用户基本思路这道题比较经典在特定场景下让你设计算法其难点在于方法要按照时间线顺序展示所有关注用户的推文这个方法要用到我在单链表的六大解题套路解决合并个升序链表的合并多个有序链表的技巧你把一个用户发布的所有推文做成一条有序链表靠近头部的推文是最近发布的那么只要合并关注用户的推文链表即可获得按照时间线顺序排序的信息流具体看代码吧我注释比较详细详细题解设计朋友圈时间线功能解法代码全局时间戳记录用户到用户示例的映射类时间戳用于对信息流按照时间排序指向下一条类似单链表结构新建一条时记录并更新时间戳用户类记录该用户的以及发布的记录该用户的关注者关注其他人取关其他人发布一条把新发布的作为链表头节点如果这个用户还不存在新建用户获取该用户关注的用户列表每个用户的是一条按时间排序的链表现在执行合并多条有序链表的逻辑找出时间线中的最近条动态按照每条的发布时间降序排序最近发布的排在事件流前面该用户自己的也在时间线内合并多条有序链表如果用户还不存在则新建用户关注者关注被关注者关注者取关被关注者再来看第二类寻找第个最大元素这类题数组中的第个最大元素标签二叉堆快速选择算法数组给定整数数组和整数请返回数组中第个最大的元素请注意你需要找的是数组排序后的第个最大的元素而不是第个不同的元素示例输入和输出示例输入和输出基本思路二叉堆的解法比较简单实际写算法题的时候推荐大家写这种解法可以把小顶堆理解成一个筛子较大的元素会沉淀下去较小的元素会浮上来当堆大小超过的时候我们就删掉堆顶的元素因为这些元素比较小而我们想要的是前个最大元素嘛当中的所有元素都过了一遍之后筛子里面留下的就是最大的个元素而堆顶元素是堆中最小的元素也就是第个最大的元素二叉堆插入和删除的时间复杂度和堆中的元素个数有关在这里我们堆的大小不会超过所以插入和删除元素的复杂度是再套一层循环总的时间复杂度就是当然这道题可以有效率更高的解法叫快速选择算法只需要的时间复杂度快速选择算法不用借助二叉堆结构而是稍微改造了快速排序的算法思路有兴趣的读者可以看详细题解详细题解快速排序详解及应用解法代码小顶堆堆顶是最小元素每个元素都要过一遍二叉堆堆中元素多于个时删除堆顶元素中剩下的是中个最大元素堆顶是最小的那个即第个最大元素类似题目前个高频元素数据流中的第大元素排序数组剑指最小的个数剑指数据流的第大数值剑指出现频率最高的个数字剑指数组中的第大的数字根据字符出现频率排序标签二叉堆排序给定一个字符串根据字符出现的频率对其进行降序排序一个字符出现的频率是它出现在字符串中的次数返回已排序的字符串如果有多个答案返回其中任何一个示例输入输出解释出现两次和都只出现一次因此必须出现在和之前此外也是一个有效的答案基本思路做这道题肯定需要计算每个字符出现的频率然后你可以用很多种其他方法把字符按照频率排序我这里用优先级队列来实现排序的效果详细看代码解法代码中的字符该字符出现的频率队列按照键值对中的值字符出现频率从大到小排序按照字符频率排序把频率最高的字符排在前面数据流中的第大元素标签二叉堆数据结构设计一个找到数据流中第大元素的类注意是排序后的第大元素不是第个不同的元素请实现类使用整数和整数流初始化对象将插入数据流后返回当前数据流中第大的元素示例输入输出解释基本思路这题考察优先级队列的使用可以先做下这道类似的题目数组中的第个最大元素优先级队列的实现原理详见图文详解二叉堆实现优先级队列解法代码默认是小顶堆将装入小顶堆保留下前大的元素维护小顶堆只保留前大的元素堆顶就是第大元素即倒数第小的元素类似题目剑指数据流的第大数值前个高频元素标签二叉堆哈希表快速选择给你一个整数数组和一个整数请你返回其中出现频率前高的元素你可以按任意顺序返回答案示例输入输出基本思路首先肯定要用一个哈希表把每个元素出现的频率计算出来然后这道题就变成了数组中的第个最大元素只不过第题让你求数组中元素值排在第大的那个元素这道题让你求数组中元素值排在前个的元素我在快速排序详解及运用中讲过第题可以用优先级队列或者快速选择算法解决这道题这里稍微改一下优先级队列的比较函数或者改一下快速选择算法中的逻辑即可这里我再加一种解法用计数排序的方式找到前个高频元素见代码解法代码用优先级队列解决这道题中的元素该元素出现的频率队列按照键值对中的值元素出现频率从小到大排序弹出最小元素维护队列内是个频率最大的元素数组中存储前个最大元素用计数排序的方法解决这道题中的元素该元素出现的频率频率这个频率有哪些元素从后往前存储着出现最多的元素将出现次数最多的个元素装入类似题目前个高频单词剑指出现频率最高的个数字前个高频单词标签二叉堆哈希表给定一个单词列表和一个整数返回前个出现次数最多的单词返回的答案应该按单词出现频率由高到低排序如果不同的单词有相同出现频率按字典顺序排序示例输入输出解析和为出现次数最多的两个单词均为次注意按字母顺序在之前基本思路这道题可以认为是前个高频元素的进阶版整体思路还哈希表计数然后用优先级队列维护出现频率最高的个单词只是我们需要注意题目要求在的比较器中正确处理频率相同的单词的字典序解法代码字符串该字符串出现的频率如果出现频率相同按照字符串字典序排序队列按照字符串出现频率从小到大排序按照字符串频率升序排序维护出现频率最多的个单词把出现次数最多的个字符串返回最后再看一看优先级队列的其他运用吧座位预约管理系统标签二叉堆数据结构设计请你设计一个管理个座位预约的系统座位编号从到请你实现类初始化一个对象它管理从到编号的个座位所有座位初始都是可预约的返回可以预约座位的最小编号此座位变为不可预约将给定编号对应的座位变成可以预约示例输入输出解释初始化有个座位所有座位都可以预约所以返回最小编号的座位也就是可以预约的座位为返回最小编号的座位也就是将座位变为可以预约现在可预约的座位为可以预约的座位为返回最小编号的座位也就是可以预约的座位为返回最小编号的座位也就是可以预约的座位为返回最小编号的座位也就是唯一可以预约的是座位所以返回将座位变为可以预约现在可预约的座位为基本思路这题是电话目录管理系统的进阶版那一道题返回的空闲号码可以随意而这道题要求返回最小的座位编号其实很思路是一样的只是这里需要用到能够按照元素大小自动排序的数据结构优先级队列二叉堆直接看代码吧解法代码利用优先级队列自动排序队头的元素就是最小的初始化所有空闲座位拿出队头元素最小数据流的中位数标签二叉堆数学中位数是有序列表中间的数如果列表长度是偶数中位数则是中间两个数的平均值设计一个支持以下两种操作的数据结构从数据流中添加一个整数到数据结构中返回目前所有元素的中位数示例基本思路本题的核心思路是使用两个优先级队列小的倒三角就是个大顶堆梯形就是个小顶堆中位数可以通过它们的堆顶元素算出来详细题解一道求中位数的算法题把我整不会了解法代码小顶堆大顶堆如果元素不一样多多的那个堆的堆顶元素就是中位数如果元素一样多两个堆堆顶元素的平均数是中位数类似题目剑指数据流中的中位数优势洗牌标签数组数组双指针给定两个大小相等的数组和相对于的优势可以用满足的索引的数目来描述请你返回的任意排列使其相对于的优势最大化示例输入输出基本思路这题就像田忌赛马的情景就是田忌的马就是齐王的马数组中的元素就是马的战斗力你就是谋士孙膑请你帮田忌安排赛马顺序使胜场最多最优策略是将齐王和田忌的马按照战斗力排序然后按照战斗力排名一一对比如果田忌的马能赢那就比赛如果赢不了那就换个垫底的来送人头保存实力具体分析见详细题解详细题解田忌赛马背后的算法决策解法代码给降序排序给升序排序是最小值是最大值是中的最大值是对应索引如果能胜过那就自己上否则用最小值混一下养精蓄锐单线程标签二叉堆排序给你一个二维数组用于表示项从到编号的任务其中意味着第项任务将会于时进入任务队列需要的时长完成执行现有一个单线程同一时间只能执行最多一项任务该将会按照下述方式运行如果空闲且任务队列中没有需要执行的任务则保持空闲状态如果空闲但任务队列中有需要执行的任务则将会选择执行时间最短的任务开始执行如果多个任务具有同样的最短执行时间则选择下标最小的任务开始执行一旦某项任务开始执行在执行完整个任务前都不会停止可以在完成一项任务后立即开始执行一项新任务返回处理任务的顺序示例输入输出解释事件按下述流程运行任务进入任务队列可执行任务项同样在空闲状态的开始执行任务可执行任务项任务进入任务队列可执行任务项任务进入任务队列可执行任务项同样在完成任务并开始执行队列中用时最短的任务可执行任务项任务进入任务队列可执行任务项完成任务并开始执行队列中用时最短的任务可执行任务项完成任务并开始执行任务可执行任务项完成任务并进入空闲状态基本思路这题的难度不算大就是有些复杂难点在于你要同时控制三个变量开始时间处理时间索引的有序性而且这三个变量还有优先级首先应该考虑开始时间因为只要到了开始时间任务才进入可执行状态其次应该考虑任务的处理时间在所有可以执行的任务中优先选择处理时间最短的如果存在处理时间相同的任务那么优先选择索引最小的所以这道题的思路是先根据任务开始时间排序维护一个时间线变量来判断哪些任务到了可执行状态然后借助一个优先级队列对处理时间和索引进行动态排序利用优先级队列动态排序是有必要的因为每完成一个任务时间线就要更新进而产生新的可执行任务解法代码把原始索引也添加上方便后面排序用数组先按照任务的开始时间排序按照任务的处理时间排序如果处理时间相同按照原始索引排序比较处理时间比较原始索引记录完成任务的时间线完成队列中的一个任务每完成一个任务就要推进时间线队列为空可能因为还没到开始时间直接把时间线推进到最近任务的开始时间由于时间线的推进会产生可以开始执行的任务语言特性将转化成格式',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-25 10:19:15',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f2b94b')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202311071525033.webp"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="http://www.zhshio.cn/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202311091058032.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/zhshio/micro-spring" title="micro-spring"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202312101409146.png" alt="micro-spring"/><span class="back-menu-item-text">micro-spring</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/zhshio/tinydb" title="tinydb"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202312101413777.jpg" alt="tinydb"/><span class="back-menu-item-text">tinydb</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Shio</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202311072150771.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202311072150771.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202311072150143.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202311072150143.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AQS/" style="font-size: 1.05rem;">AQS<sup>1</sup></a><a href="/tags/ArrayLists/" style="font-size: 1.05rem;">ArrayLists<sup>1</sup></a><a href="/tags/CountDownLatch/" style="font-size: 1.05rem;">CountDownLatch<sup>1</sup></a><a href="/tags/Docker/" style="font-size: 1.05rem;">Docker<sup>1</sup></a><a href="/tags/JAVA/" style="font-size: 1.05rem;">JAVA<sup>1</sup></a><a href="/tags/JUC/" style="font-size: 1.05rem;">JUC<sup>2</sup></a><a href="/tags/JVM/" style="font-size: 1.05rem;">JVM<sup>5</sup></a><a href="/tags/Java/" style="font-size: 1.05rem;">Java<sup>1</sup></a><a href="/tags/Java%E6%BA%90%E7%A0%81/" style="font-size: 1.05rem;">Java源码<sup>1</sup></a><a href="/tags/Jottings/" style="font-size: 1.05rem;">Jottings<sup>1</sup></a><a href="/tags/MQ/" style="font-size: 1.05rem;">MQ<sup>1</sup></a><a href="/tags/MYSQL/" style="font-size: 1.05rem;">MYSQL<sup>3</sup></a><a href="/tags/SPring/" style="font-size: 1.05rem;">SPring<sup>1</sup></a><a href="/tags/Spr/" style="font-size: 1.05rem;">Spr<sup>1</sup></a><a href="/tags/Spring/" style="font-size: 1.05rem;">Spring<sup>21</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/" style="font-size: 1.05rem;">代码模板<sup>1</sup></a><a href="/tags/%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">学习工具<sup>3</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 1.05rem;">操作系统<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.05rem;">数据结构<sup>1</sup></a><a href="/tags/%E6%B8%90%E8%BF%9B%E5%BC%8F%E5%AE%9E%E7%8E%B0Spring/" style="font-size: 1.05rem;">渐进式实现Spring<sup>16</sup></a><a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size: 1.05rem;">生活<sup>5</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>41</sup></a><a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 1.05rem;">编译原理<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">计算机基础<sup>4</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">设计模式<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/" style="font-size: 1.05rem;">设计模式之美<sup>3</sup></a><a href="/tags/%E8%BD%AC%E8%BD%BD/" style="font-size: 1.05rem;">转载<sup>35</sup></a><a href="/tags/%E9%87%8D%E5%90%AF%E4%BA%BA%E7%94%9F/" style="font-size: 1.05rem;">重启人生<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>1</sup></a><a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 1.05rem;">项目<sup>2</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">20</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/02/"><span class="card-archive-list-date">二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/12/"><span class="card-archive-list-date">十二月 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/08/"><span class="card-archive-list-date">八月 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">47</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">转载</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url">算法</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>算法</span></a><a class="article-meta__tags" href="/tags/%E8%BD%AC%E8%BD%BD/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>转载</span></a></span></div></div><h1 class="post-title" itemprop="name headline">二叉堆详解实现优先级队列</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2022-08-14T15:40:00.000Z" title="发表于 2022-08-14 23:40:00">2022-08-14</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-03-25T02:19:15.621Z" title="更新于 2024-03-25 10:19:15">2024-03-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">11.8k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>46分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="二叉堆详解实现优先级队列"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为晋中"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>晋中</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://www.toopic.cn/public/uploads/small/17102202974171022029789.jpg?_r_=51e6b011-4754-6662-9bb7-4bdfcedc8574"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://labuladong.online/"><header><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url">算法</a><a href="/tags/%E7%AE%97%E6%B3%95/" tabindex="-1" itemprop="url">算法</a><a href="/tags/%E8%BD%AC%E8%BD%BD/" tabindex="-1" itemprop="url">转载</a><h1 id="CrawlerTitle" itemprop="name headline">二叉堆详解实现优先级队列</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">labuladong</span><time itemprop="dateCreated datePublished" datetime="2022-08-14T15:40:00.000Z" title="发表于 2022-08-14 23:40:00">2022-08-14</time><time itemprop="dateCreated datePublished" datetime="2024-03-25T02:19:15.621Z" title="更新于 2024-03-25 10:19:15">2024-03-25</time></header><h1>二叉堆详解实现优先级队列</h1>
<p>二叉堆（Binary Heap）没什么神秘，性质比二叉搜索树 BST 还简单。</p>
<p>其主要操作就两个，<code>sink</code>（下沉）和 <code>swim</code>（上浮），用以维护二叉堆的性质。其主要应用有两个，首先是一种排序方法「堆排序」，第二是一种很有用的数据结构「优先级队列」。</p>
<p>那么本文以实现优先级队列（Priority Queue）为例，来讲讲一下二叉堆怎么运作的。</p>
<h3 id="一、二叉堆概览"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/data-structure/binary-heap-priority-queue/#%E4%B8%80%E3%80%81%E4%BA%8C%E5%8F%89%E5%A0%86%E6%A6%82%E8%A7%88">#</a>一、二叉堆概览</h3>
<p>首先，二叉堆和二叉树有啥关系呢，为什么人们总是把二叉堆画成一棵二叉树？</p>
<p>因为，二叉堆在逻辑上其实是一种特殊的二叉树（完全二叉树），只不过存储在数组里。一般的链表二叉树，我们操作节点的指针，而在数组里，我们把数组索引作为指针：</p>
<p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父节点的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parent</span><span class="params">(<span class="type">int</span> root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> root / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左孩子的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">left</span><span class="params">(<span class="type">int</span> root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> root * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右孩子的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span> root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> root * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>画个图你立即就能理解了，比如 <code>arr</code> 是一个字符数组，注意数组的第一个索引 0 空着不用：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://labuladong.online/algo/images/heap/1.png" alt="img"></p>
<p>你看到了，因为这棵二叉树是「完全二叉树」，所以把 <code>arr[1]</code> 作为整棵树的根的话，每个节点的父节点和左右孩子的索引都可以通过简单的运算得到，这就是二叉堆设计的一个巧妙之处。</p>
<p>为了方便讲解，下面都会画的图都是二叉树结构，相信你能把树和数组对应起来。</p>
<p>二叉堆还分为最大堆和最小堆。<strong>最大堆的性质是：每个节点都大于等于它的两个子节点</strong>。类似的，最小堆的性质是：每个节点都小于等于它的子节点。</p>
<p>两种堆核心思路都是一样的，本文以最大堆为例讲解。</p>
<p>对于一个最大堆，根据其性质，显然堆顶，也就是 <code>arr[1]</code> 一定是所有元素中最大的元素。</p>
<h3 id="二、优先级队列概览"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/data-structure/binary-heap-priority-queue/#%E4%BA%8C%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E6%A6%82%E8%A7%88">#</a>二、优先级队列概览</h3>
<p>优先级队列这种数据结构有一个很有用的功能，你插入或者删除元素的时候，元素会自动排序，这底层的原理就是二叉堆的操作。</p>
<p>数据结构的功能无非增删查改，优先级队列有两个主要 API，分别是 <code>insert</code> 插入一个元素和 <code>delMax</code> 删除最大元素（如果底层用最小堆，那么就是 <code>delMin</code>，删除最小元素）。</p>
<p>注</p>
<p>刚才说到二叉堆本质上是一棵二叉树，而优先级队列这种数据结构底层是二叉堆，那么为啥它的名字又和「队列」扯上了关系呢？</p>
<p>因为优先级队列的操作和队列比较像。普通队列有个从队尾插入元素，从队头移出元素，出队顺序就是入队的时间顺序；你也可以认为优先级队列是一种特殊的队列，从队尾插入元素，从队头移出元素，只不过出队顺序是按照元素的大小顺序。</p>
<p>这么一看，是不是觉得这种数据结构有队列内味儿了？</p>
<p>下面我们实现一个简化的优先级队列，先看下代码框架：</p>
<p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxPQ</span></span><br><span class="line">    &lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// 存储元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> Key[] pq;</span><br><span class="line">    <span class="comment">// 当前 Priority Queue 中的元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxPQ</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">        <span class="comment">// 索引 0 不用，所以多分配一个空间</span></span><br><span class="line">        pq = (Key[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[cap + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回当前队列中最大元素 */</span></span><br><span class="line">    <span class="keyword">public</span> Key <span class="title function_">max</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pq[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 插入元素 e */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Key e)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除并返回当前队列中最大元素 */</span></span><br><span class="line">    <span class="keyword">public</span> Key <span class="title function_">delMax</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 上浮第 x 个元素，以维护最大堆性质 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> x)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 下沉第 x 个元素，以维护最大堆性质 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> x)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 交换数组的两个元素 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">Key</span> <span class="variable">temp</span> <span class="operator">=</span> pq[i];</span><br><span class="line">        pq[i] = pq[j];</span><br><span class="line">        pq[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pq[i] 是否比 pq[j] 小？ */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 还有 left, right, parent 三个方法 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提示</p>
<p>这里用到 Java 的泛型，<code>Key</code> 可以是任何一种可比较大小的数据类型（实现了 <code>compareTo</code> 方法），比如 Integer 等类型。</p>
<p>当然，你自己练习时可以适度变通，比如说在构造函数中传入一个比较函数，这样就可以实现自定义排序逻辑了。</p>
<p>我这里为了简化，就实现一个最大堆 <code>MaxPQ</code>，即每次删除都是队列中最大的元素。</p>
<p>空出来的四个方法是二叉堆和优先级队列的奥妙所在，下面用图文来逐个理解。</p>
<h3 id="三、实现-swim-和-sink"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/data-structure/binary-heap-priority-queue/#%E4%B8%89%E3%80%81%E5%AE%9E%E7%8E%B0-swim-%E5%92%8C-sink">#</a>三、实现 swim 和 sink</h3>
<p>为什么要有上浮 <code>swim</code> 和下沉 <code>sink</code> 的操作呢？为了维护二叉堆结构。</p>
<p>我们要讲的是最大堆，每个节点都比它的两个子节点大，但是在插入元素和删除元素时，难免破坏堆的性质，这就需要通过这两个操作来恢复堆的性质了。</p>
<p>对于最大堆，会破坏堆性质的有两种情况：</p>
<p>1、如果某个节点 A 比它的子节点（中的一个）小，那么 A 就不配做父节点，应该下去，下面那个更大的节点上来做父节点，这就是对 A 进行<strong>下沉</strong>。</p>
<p>2、如果某个节点 A 比它的父节点大，那么 A 不应该做子节点，应该把父节点换下来，自己去做父节点，这就是对 A 的<strong>上浮</strong>。</p>
<p>当然，错位的节点 A 可能要上浮（或下沉）很多次，才能到达正确的位置，恢复堆的性质。所以代码中肯定有一个 <code>while</code> 循环。</p>
<p>细心的读者也许会问，这两个操作不是互逆吗，所以上浮的操作一定能用下沉来完成，为什么我还要费劲写两个方法？</p>
<p>是的，操作是互逆等价的，但是最终我们的操作只会在堆底和堆顶进行（等会讲原因），显然堆底的「错位」元素需要上浮，堆顶的「错位」元素需要下沉。</p>
<p><strong>上浮的代码实现：</strong></p>
<p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxPQ</span> &lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// 为了节约篇幅，省略上文给出的代码部分...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果浮到堆顶，就不能再上浮了</span></span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">1</span> &amp;&amp; less(parent(x), x)) &#123;</span><br><span class="line">            <span class="comment">// 如果第 x 个元素比上层大</span></span><br><span class="line">            <span class="comment">// 将 x 换上去</span></span><br><span class="line">            swap(parent(x), x);</span><br><span class="line">            x = parent(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>画个 GIF 看一眼就明白了：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://labuladong.online/algo/images/heap/swim.gif" alt="img"></p>
<p><strong>下沉的代码实现：</strong></p>
<p>下沉比上浮略微复杂一点，因为上浮某个节点 A，只需要 A 和其父节点比较大小即可；但是下沉某个节点 A，需要 A 和其<strong>两个子节点</strong>比较大小，如果 A 不是最大的就需要调整位置，要把较大的那个子节点和 A 交换。</p>
<p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxPQ</span> &lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// 为了节约篇幅，省略上文给出的代码部分...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果沉到堆底，就沉不下去了</span></span><br><span class="line">        <span class="keyword">while</span> (left(x) &lt;= size) &#123;</span><br><span class="line">            <span class="comment">// 先假设左边节点较大</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> left(x);</span><br><span class="line">            <span class="comment">// 如果右边节点存在，比一下大小</span></span><br><span class="line">            <span class="keyword">if</span> (right(x) &lt;= size &amp;&amp; less(max, right(x)))</span><br><span class="line">                max = right(x);</span><br><span class="line">            <span class="comment">// 结点 x 比俩孩子都大，就不必下沉了</span></span><br><span class="line">            <span class="keyword">if</span> (less(max, x)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 否则，不符合最大堆的结构，下沉 x 结点</span></span><br><span class="line">            swap(x, max);</span><br><span class="line">            x = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>画个 GIF 看下就明白了：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://labuladong.online/algo/images/heap/sink.gif" alt="img"></p>
<p>至此，二叉堆的主要操作就讲完了，一点都不难吧，代码加起来也就十行。明白了 <code>sink</code> 和 <code>swim</code> 的行为，下面就可以实现优先级队列了。</p>
<h3 id="四、实现-delMax-和-insert"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/data-structure/binary-heap-priority-queue/#%E5%9B%9B%E3%80%81%E5%AE%9E%E7%8E%B0-delmax-%E5%92%8C-insert">#</a>四、实现 delMax 和 insert</h3>
<p>这两个方法就是建立在 <code>swim</code> 和 <code>sink</code> 上的。</p>
<p><strong><code>insert</code> 方法先把要插入的元素添加到堆底的最后，然后让其上浮到正确位置</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://labuladong.online/algo/images/heap/insert.gif" alt="img"></p>
<p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxPQ</span> &lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// 为了节约篇幅，省略上文给出的代码部分...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Key e)</span> &#123;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="comment">// 先把新元素加到最后</span></span><br><span class="line">        pq[size] = e;</span><br><span class="line">        <span class="comment">// 然后让它上浮到正确的位置</span></span><br><span class="line">        swim(size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>delMax</code> 方法先把堆顶元素 <code>A</code> 和堆底最后的元素 <code>B</code> 对调，然后删除 <code>A</code>，最后让 <code>B</code> 下沉到正确位置</strong>。</p>
<p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxPQ</span> &lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// 为了节约篇幅，省略上文给出的代码部分...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Key <span class="title function_">delMax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 最大堆的堆顶就是最大元素</span></span><br><span class="line">        <span class="type">Key</span> <span class="variable">max</span> <span class="operator">=</span> pq[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 把这个最大元素换到最后，删除之</span></span><br><span class="line">        swap(<span class="number">1</span>, size);</span><br><span class="line">        pq[size] = <span class="literal">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="comment">// 让 pq[1] 下沉到正确位置</span></span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://labuladong.online/algo/images/heap/delete.gif" alt="img"></p>
<p>至此，一个优先级队列就实现了，插入和删除元素的时间复杂度为 <code>O(logK)</code>，<code>K</code> 为当前二叉堆（优先级队列）中的元素总数。因为我们时间复杂度主要花费在 <code>sink</code> 或者 <code>swim</code> 上，而不管上浮还是下沉，最多也就树（堆）的高度，也就是 log 级别。</p>
<h3 id="五、最后总结"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/data-structure/binary-heap-priority-queue/#%E4%BA%94%E3%80%81%E6%9C%80%E5%90%8E%E6%80%BB%E7%BB%93">#</a>五、最后总结</h3>
<p>二叉堆就是一种完全二叉树，所以适合存储在数组中，而且二叉堆拥有一些特殊性质。</p>
<p>二叉堆的操作很简单，主要就是上浮和下沉，来维护堆的性质（堆有序），核心代码也就十行。</p>
<p>优先级队列是基于二叉堆实现的，主要操作是插入和删除。插入是先插到最后，然后上浮到正确位置；删除是调换位置后再删除，然后下沉到正确位置。核心代码也就十行。</p>
<p>也许这就是数据结构的威力，简单的操作就能实现巧妙的功能，真心佩服发明二叉堆算法的人！</p>
<p>最后，更多二叉堆/优先级队列相关的题目练习见 <a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e">二叉堆（优先级队列）的经典习题open in new window</a>。</p>
<h1>经典练习题</h1>
<p>二叉堆的主要应用是优先级队列，而优先级队列的特色是<strong>动态排序</strong>，插入的元素可以自动维护正确的顺序。当然，后文讲的 <a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--60928/treemap-yu-a003e/">二叉搜索树open in new window</a> 也可以做到动态排序，优先级队列的限制是只能从队头和队尾操作元素。</p>
<p>一般来说，用到优先级队列的题目主要分两类，一类是合并多个有序链表这类题，另一类是寻找第 <code>k</code> 个最大元素这类题，我们分别来看。</p>
<hr>
<p>先来看第一类，合并有序链表这样的题目：</p>
<hr>
<h2 id="23-合并-K-个升序链表open-in-new-window"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#_23-%E5%90%88%E5%B9%B6-k-%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8">#</a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists">23. 合并 K 个升序链表open in new window</a></h2>
<ul>
<li><strong>标签：二叉堆，数据结构，链表，链表双指针</strong></li>
</ul>
<p>给你一个链表数组，每个链表都已经按升序排列，请你将这些链表合并成一个升序链表，返回合并后的链表。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：lists = [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>
<h3 id="基本思路"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF">#</a>基本思路</h3>
<blockquote>
<p>本文有视频版：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1q94y1X7vy">链表双指针技巧全面汇总open in new window</a></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists">21. 合并两个有序链表open in new window</a> 的延伸，利用 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/article/fname.html?fname=%E4%BA%8C%E5%8F%89%E5%A0%86%E8%AF%A6%E8%A7%A3%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97">优先级队列（二叉堆）open in new window</a> 进行节点排序即可。</p>
<ul>
<li><strong>详细题解：<a target="_blank" rel="noopener" href="https://labuladong.gitee.io/article/fname.html?fname=%E9%93%BE%E8%A1%A8%E6%8A%80%E5%B7%A7">双指针技巧秒杀七道链表题目open in new window</a></strong></li>
</ul>
<h3 id="解法代码"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81">#</a>解法代码</h3>
<p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 虚拟头结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">// 优先级队列，最小堆</span></span><br><span class="line">        PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">            lists.length, (a, b)-&gt;(a.val - b.val));</span><br><span class="line">        <span class="comment">// 将 k 个链表的头结点加入最小堆</span></span><br><span class="line">        <span class="keyword">for</span> (ListNode head : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head != <span class="literal">null</span>)</span><br><span class="line">                pq.add(head);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 获取最小节点，接到结果链表中</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            p.next = node;</span><br><span class="line">            <span class="keyword">if</span> (node.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                pq.add(node.next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// p 指针不断前进</span></span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>类似题目</p>
<p>：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle">141. 环形链表 🟢open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii">142. 环形链表 II 🟠open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists">160. 相交链表 🟢open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list">19. 删除链表的倒数第 N 个结点 🟠open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists">21. 合并两个有序链表 🟢open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/super-ugly-number">313. 超级丑数 🟠open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-twitter">355. 设计推特 🟠open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums">373. 查找和最小的 K 对数字 🟠open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix">378. 有序矩阵中第 K 小的元素 🟠open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-list">86. 分隔链表 🟠open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/middle-of-the-linked-list">876. 链表的中间结点 🟢open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof">剑指 Offer 22. 链表中倒数第k个节点 🟢open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof">剑指 Offer 25. 合并两个排序的链表 🟢open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof">剑指 Offer 52. 两个链表的第一个公共节点 🟢open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/SLwz0R">剑指 Offer II 021. 删除链表的倒数第 n 个结点 🟠open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/c32eOV">剑指 Offer II 022. 链表中环的入口节点 🟠open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3u1WK4">剑指 Offer II 023. 两个链表的第一个重合节点 🟢open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/qn8gGX">剑指 Offer II 061. 和最小的 k 个数对 🟠open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/vvXgSW">剑指 Offer II 078. 合并排序链表 🔴open in new window</a></li>
</ul>
</li>
</ul>
<h2 id="373-查找和最小的-K-对数字open-in-new-window"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#_373-%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84-k-%E5%AF%B9%E6%95%B0%E5%AD%97">#</a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums">373. 查找和最小的 K 对数字open in new window</a></h2>
<ul>
<li><strong>标签：二叉堆，链表双指针</strong></li>
</ul>
<p>给定两个以 <strong>升序排列</strong> 的整数数组 <code>nums1</code> 和 <code>nums2</code>, 以及一个整数 <code>k</code>。</p>
<p>定义一对值 <code>(u,v)</code>，其中第一个元素来自 <code>nums1</code>，第二个元素来自 <code>nums2</code>。</p>
<p>请找到<strong>和</strong>最小的 <code>k</code> 个数对 <code>(u1,v1)</code>, <code>(u2,v2)</code> … <code>(uk,vk)</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,7,11], nums2 = [2,4,6], k = 3</span><br><span class="line">输出：[1,2],[1,4],[1,6]</span><br><span class="line">解释：返回序列中的前 3 对数：</span><br><span class="line">     [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]</span><br></pre></td></tr></table></figure>
<h3 id="基本思路-v2"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1">#</a>基本思路</h3>
<p>这道题其实是前文 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/article/fname.html?fname=%E9%93%BE%E8%A1%A8%E6%8A%80%E5%B7%A7">单链表的六大解题套路open in new window</a> 中讲过的 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists">23. 合并K个升序链表open in new window</a> 的变体。</p>
<p>怎么把这道题变成合并多个有序链表呢？就比如说题目输入的用例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>,<span class="number">7</span>,<span class="number">11</span>], nums2 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<p>组合出的所有数对儿这就可以抽象成三个有序链表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>] -&gt; [<span class="number">1</span>, <span class="number">4</span>] -&gt; [<span class="number">1</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">7</span>, <span class="number">2</span>] -&gt; [<span class="number">7</span>, <span class="number">4</span>] -&gt; [<span class="number">7</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">11</span>, <span class="number">2</span>] -&gt; [<span class="number">11</span>, <span class="number">4</span>] -&gt; [<span class="number">11</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<p>这三个链表中每个元素（数对之和）是递增的，所以就可以按照 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists">23. 合并K个升序链表open in new window</a> 的思路来合并，取出前 <code>k</code> 个作为答案即可。</p>
<h3 id="解法代码-v2"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-1">#</a>解法代码</h3>
<p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">kSmallestPairs</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 存储三元组 (num1[i], nums2[i], i)</span></span><br><span class="line">        <span class="comment">// i 记录 nums2 元素的索引位置，用于生成下一个节点</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 按照数对的元素和升序排序</span></span><br><span class="line">            <span class="keyword">return</span> (a[<span class="number">0</span>] + a[<span class="number">1</span>]) - (b[<span class="number">0</span>] + b[<span class="number">1</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 按照 23 题的逻辑初始化优先级队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nums1[i], nums2[<span class="number">0</span>], <span class="number">0</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 执行合并多个有序链表的逻辑</span></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span>[] cur = pq.poll();</span><br><span class="line">            k--;</span><br><span class="line">            <span class="comment">// 链表中的下一个节点加入优先级队列</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">next_index</span> <span class="operator">=</span> cur[<span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (next_index &lt; nums2.length) &#123;</span><br><span class="line">                pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;cur[<span class="number">0</span>], nums2[next_index], next_index&#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List&lt;Integer&gt; pair = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            pair.add(cur[<span class="number">0</span>]);</span><br><span class="line">            pair.add(cur[<span class="number">1</span>]);</span><br><span class="line">            res.add(pair);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>类似题目</p>
<p>：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/qn8gGX">剑指 Offer II 061. 和最小的 k 个数对 🟠open in new window</a></li>
</ul>
</li>
</ul>
<h2 id="378-有序矩阵中第-K-小的元素open-in-new-window"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#_378-%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%AC-k-%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0">#</a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix">378. 有序矩阵中第 K 小的元素open in new window</a></h2>
<ul>
<li><strong>标签：二叉堆，链表双指针</strong></li>
</ul>
<p>给你一个 <code>n x n</code> 矩阵 <code>matrix</code>，其中每行和每列元素均按升序排序，找到矩阵中第 <code>k</code> 小的元素。<br>
请注意，它是 <strong>排序后</strong> 的第 <code>k</code> 小元素，而不是第 <code>k</code> 个 <strong>不同</strong>的元素。</p>
<p>你必须找到一个内存复杂度优于 <code>O(n2)</code> 的解决方案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8</span><br><span class="line">输出：13</span><br><span class="line">解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13</span><br></pre></td></tr></table></figure>
<h3 id="基本思路-v3"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-2">#</a>基本思路</h3>
<p>这道题其实是前文 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/article/fname.html?fname=%E9%93%BE%E8%A1%A8%E6%8A%80%E5%B7%A7">单链表的六大解题套路open in new window</a> 中讲过的 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists">23. 合并K个升序链表open in new window</a> 的变体。</p>
<p>矩阵中的每一行都是排好序的，就好比多条有序链表，你用优先级队列施展合并多条有序链表的逻辑就能找到第 <code>k</code> 小的元素了。</p>
<h3 id="解法代码-v3"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-2">#</a>解法代码</h3>
<p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 存储二元组 (matrix[i][j], i, j)</span></span><br><span class="line">        <span class="comment">// i, j 记录当前元素的索引位置，用于生成下一个节点</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 按照元素大小升序排序</span></span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化优先级队列，把每一行的第一个元素装进去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;matrix[i][<span class="number">0</span>], i, <span class="number">0</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 执行合并多个有序链表的逻辑，找到第 k 小的元素</span></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span>[] cur = pq.poll();</span><br><span class="line">            res = cur[<span class="number">0</span>];</span><br><span class="line">            k--;</span><br><span class="line">            <span class="comment">// 链表中的下一个节点加入优先级队列</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cur[<span class="number">1</span>], j = cur[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; matrix[i].length) &#123;</span><br><span class="line">                pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;matrix[i][j + <span class="number">1</span>], i, j + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="313-超级丑数open-in-new-window"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#_313-%E8%B6%85%E7%BA%A7%E4%B8%91%E6%95%B0">#</a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/super-ugly-number">313. 超级丑数open in new window</a></h2>
<ul>
<li><strong>标签：二叉堆，链表双指针</strong></li>
</ul>
<p><strong>超级丑数</strong> 是一个正整数，并满足其所有质因数都出现在质数数组 <code>primes</code> 中。给你一个整数 <code>n</code> 和一个整数数组 <code>primes</code>，返回第 <code>n</code> 个 <strong>超级丑数</strong>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 12, primes = [2,7,13,19]</span><br><span class="line">输出：32 </span><br><span class="line">解释：给定长度为 4 的质数数组 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32]。</span><br></pre></td></tr></table></figure>
<h3 id="基本思路-v4"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-3">#</a>基本思路</h3>
<p>这题是 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ugly-number-ii">264. 丑数 IIopen in new window</a> 的进阶版，第 264 题是 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists">21. 合并两个有序链表（简单）open in new window</a> 的变体，而这道题是 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists">23. 合并K个升序链表（困难）open in new window</a> 的变体，我在 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/article/fname.html?fname=%E9%93%BE%E8%A1%A8%E6%8A%80%E5%B7%A7">双指针技巧秒杀七道链表题目open in new window</a> 中都讲过。</p>
<p>你一定要先做下 264 题，注意那里我们抽象出了三条链表，需要 <code>p2, p3, p5</code> 作为三条有序链表上的指针，同时需要 <code>product2, product3, product5</code> 记录指针所指节点的值，用 <code>min</code> 函数计算最小头结点。</p>
<p>这道题相当于输入了 <code>len(primes)</code> 条有序链表，我们不能用 <code>min</code> 函数计算最小头结点了，而是要用优先级队列来计算最小头结点，同时依然要维护链表指针、指针所指节点的值，我们把这些信息用一个三元组来保存。</p>
<p>结合第 23 题的解法逻辑，你应该能够看懂这道题的解法代码了。</p>
<ul>
<li><strong>详细题解：<a target="_blank" rel="noopener" href="https://labuladong.gitee.io/article/fname.html?fname=%E4%B8%91%E6%95%B0">一文秒杀所有丑数系列问题open in new window</a></strong></li>
</ul>
<h3 id="解法代码-v4"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-3">#</a>解法代码</h3>
<p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthSuperUglyNumber</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] primes)</span> &#123;</span><br><span class="line">        <span class="comment">// 优先队列中装三元组 int[] &#123;product, prime, pi&#125;</span></span><br><span class="line">        <span class="comment">// 其中 product 代表链表节点的值，prime 是计算下一个节点所需的质数因子，pi 代表链表上的指针</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把多条链表的头结点加入优先级队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; primes.length; i++) &#123;</span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123; <span class="number">1</span>, primes[i], <span class="number">1</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以理解为最终合并的有序链表（结果链表）</span></span><br><span class="line">        <span class="type">int</span>[] ugly = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 可以理解为结果链表上的指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p &lt;= n) &#123;</span><br><span class="line">            <span class="comment">// 取三个链表的最小结点</span></span><br><span class="line">            <span class="type">int</span>[] pair = pq.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> pair[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">prime</span> <span class="operator">=</span> pair[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> pair[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 避免结果链表出现重复元素</span></span><br><span class="line">            <span class="keyword">if</span> (product != ugly[p - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 接到结果链表上</span></span><br><span class="line">                ugly[p] = product;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生成下一个节点加入优先级队列</span></span><br><span class="line">            <span class="type">int</span>[] nextPair = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;ugly[index] * prime, prime, index + <span class="number">1</span>&#125;;</span><br><span class="line">            pq.offer(nextPair);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ugly[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>类似题目</p>
<p>：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ugly-number-iii">1201. 丑数 III 🟠open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ugly-number">263. 丑数 🟢open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ugly-number-ii">264. 丑数 II 🟠open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/chou-shu-lcof">剑指 Offer 49. 丑数 🟠open in new window</a></li>
</ul>
</li>
</ul>
<h2 id="355-设计推特open-in-new-window"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#_355-%E8%AE%BE%E8%AE%A1%E6%8E%A8%E7%89%B9">#</a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-twitter">355. 设计推特open in new window</a></h2>
<ul>
<li><strong>标签：数据结构，设计</strong></li>
</ul>
<p>设计一个简化版的推特 (Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近 <code>10</code> 条推文。</p>
<p>实现 <code>Twitter</code> 类：</p>
<ul>
<li><code>void postTweet(int userId, int tweetId)</code> 根据给定的 <code>tweetId</code> 和 <code>userId</code> 创建一条新推文。每次调用此函数都会使用一个不同的 <code>tweetId</code>。</li>
<li><code>List&lt;Integer&gt; getNewsFeed(int userId)</code> 检索当前用户新闻推送中最近 <code>10</code> 条推文的 ID。新闻推送中的每一项都必须是由用户关注的人或者是用户自己发布的推文。推文必须<strong>按照时间顺序由最近到最远排序</strong>。</li>
<li><code>void follow(int followerId, int followeeId)</code> ID 为 <code>followerId</code> 的用户开始关注 ID 为 <code>followeeId</code> 的用户。</li>
<li><code>void unfollow(int followerId, int followeeId)</code> ID 为 <code>followerId</code> 的用户不再关注 ID 为 <code>followeeId</code> 的用户。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;Twitter&quot;, &quot;postTweet&quot;, &quot;getNewsFeed&quot;, &quot;follow&quot;, &quot;postTweet&quot;, &quot;getNewsFeed&quot;, &quot;unfollow&quot;, &quot;getNewsFeed&quot;]</span><br><span class="line">[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]</span><br><span class="line">输出</span><br><span class="line">[null, null, [5], null, null, [6, 5], null, [5]]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">Twitter twitter = new Twitter();</span><br><span class="line">twitter.postTweet(1, 5); // 用户 1 发送了一条新推文 (用户 id = 1, 推文 id = 5)</span><br><span class="line">twitter.getNewsFeed(1);  // 用户 1 的获取推文应当返回一个列表，其中包含一个 id 为 5 的推文</span><br><span class="line">twitter.follow(1, 2);    // 用户 1 关注了用户 2</span><br><span class="line">twitter.postTweet(2, 6); // 用户 2 发送了一个新推文 (推文 id = 6)</span><br><span class="line">twitter.getNewsFeed(1);  // 用户 1 的获取推文应当返回一个列表，其中包含两个推文，id 分别为 -&gt; [6, 5]。推文 id 6 应当在推文 id 5 之前，因为它是在 5 之后发送的</span><br><span class="line">twitter.unfollow(1, 2);  // 用户 1 取消关注了用户 2</span><br><span class="line">twitter.getNewsFeed(1);  // 用户 1 获取推文应当返回一个列表，其中包含一个 id 为 5 的推文。因为用户 1 已经不再关注用户 2</span><br></pre></td></tr></table></figure>
<h3 id="基本思路-v5"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-4">#</a>基本思路</h3>
<p>这道题比较经典，在特定场景下让你设计算法。其难点在于 <code>getNewsFeed</code> 方法，要按照时间线顺序展示所有关注用户的推文，这个方法要用到我在 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/article/fname.html?fname=%E9%93%BE%E8%A1%A8%E6%8A%80%E5%B7%A7">单链表的六大解题套路open in new window</a> 解决 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists">23. 合并K个升序链表open in new window</a> 的合并多个有序链表的技巧：</p>
<p>你把一个用户发布的所有推文做成一条有序链表（靠近头部的推文是最近发布的），那么只要合并关注用户的推文链表，即可获得按照时间线顺序排序的信息流。</p>
<p>具体看代码吧，我注释比较详细。</p>
<ul>
<li><strong>详细题解：<a target="_blank" rel="noopener" href="https://labuladong.gitee.io/article/fname.html?fname=%E8%AE%BE%E8%AE%A1Twitter">设计朋友圈时间线功能open in new window</a></strong></li>
</ul>
<h3 id="解法代码-v5"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-4">#</a>解法代码</h3>
<p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Twitter</span> &#123;</span><br><span class="line">    <span class="comment">// 全局时间戳</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">globalTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录用户 ID 到用户示例的映射</span></span><br><span class="line">    HashMap&lt;Integer, User&gt; idToUser = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tweet 类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="comment">// 时间戳用于对信息流按照时间排序</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> timestamp;</span><br><span class="line">        <span class="comment">// 指向下一条 tweet，类似单链表结构</span></span><br><span class="line">        <span class="keyword">private</span> Tweet next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Tweet</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="comment">// 新建一条 tweet 时记录并更新时间戳 </span></span><br><span class="line">            <span class="built_in">this</span>.timestamp = globalTime++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTimestamp</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> timestamp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Tweet <span class="title function_">getNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Tweet next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="comment">// 记录该用户的 id 以及发布的 tweet</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">private</span> Tweet tweetHead;</span><br><span class="line">        <span class="comment">// 记录该用户的关注者</span></span><br><span class="line">        <span class="keyword">private</span> HashSet&lt;User&gt; followedUserSet;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="built_in">this</span>.tweetHead = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.followedUserSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Tweet <span class="title function_">getTweetHead</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> tweetHead;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> HashSet&lt;User&gt; <span class="title function_">getFollowedUserSet</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> followedUserSet;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(User other)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.id == other.id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关注其他人</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">follow</span><span class="params">(User other)</span> &#123;</span><br><span class="line">            followedUserSet.add(other);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取关其他人</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unfollow</span><span class="params">(User other)</span> &#123;</span><br><span class="line">            followedUserSet.remove(other);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布一条 tweet</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">post</span><span class="params">(Tweet tweet)</span> &#123;</span><br><span class="line">            <span class="comment">// 把新发布的 tweet 作为链表头节点</span></span><br><span class="line">            tweet.setNext(tweetHead);</span><br><span class="line">            tweetHead = tweet;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postTweet</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> tweetId)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果这个用户还不存在，新建用户</span></span><br><span class="line">        <span class="keyword">if</span> (!idToUser.containsKey(userId)) &#123;</span><br><span class="line">            idToUser.put(userId, <span class="keyword">new</span> <span class="title class_">User</span>(userId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> idToUser.get(userId);</span><br><span class="line">        user.post(<span class="keyword">new</span> <span class="title class_">Tweet</span>(tweetId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getNewsFeed</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (!idToUser.containsKey(userId)) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取该用户关注的用户列表</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> idToUser.get(userId);</span><br><span class="line">        Set&lt;User&gt; followedUserSet = user.getFollowedUserSet();</span><br><span class="line">        <span class="comment">// 每个用户的 tweet 是一条按时间排序的链表</span></span><br><span class="line">        <span class="comment">// 现在执行合并多条有序链表的逻辑，找出时间线中的最近 10 条动态</span></span><br><span class="line">        PriorityQueue&lt;Tweet&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 按照每条 tweet 的发布时间降序排序（最近发布的排在事件流前面）</span></span><br><span class="line">            <span class="keyword">return</span> b.timestamp - a.timestamp;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 该用户自己的 tweet 也在时间线内</span></span><br><span class="line">        <span class="keyword">if</span> (user.getTweetHead() != <span class="literal">null</span>) &#123;</span><br><span class="line">            pq.offer(user.getTweetHead());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (User other : followedUserSet) &#123;</span><br><span class="line">            <span class="keyword">if</span> (other.getTweetHead() != <span class="literal">null</span>) &#123;</span><br><span class="line">                pq.offer(other.tweetHead);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 合并多条有序链表</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="type">Tweet</span> <span class="variable">tweet</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            res.add(tweet.getId());</span><br><span class="line">            <span class="keyword">if</span> (tweet.getNext() != <span class="literal">null</span>) &#123;</span><br><span class="line">                pq.offer(tweet.getNext());</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">follow</span><span class="params">(<span class="type">int</span> followerId, <span class="type">int</span> followeeId)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果用户还不存在，则新建用户</span></span><br><span class="line">        <span class="keyword">if</span> (!idToUser.containsKey(followerId)) &#123;</span><br><span class="line">            idToUser.put(followerId, <span class="keyword">new</span> <span class="title class_">User</span>(followerId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!idToUser.containsKey(followeeId)) &#123;</span><br><span class="line">            idToUser.put(followeeId, <span class="keyword">new</span> <span class="title class_">User</span>(followeeId));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">follower</span> <span class="operator">=</span> idToUser.get(followerId);</span><br><span class="line">        <span class="type">User</span> <span class="variable">followee</span> <span class="operator">=</span> idToUser.get(followeeId);</span><br><span class="line">        <span class="comment">// 关注者关注被关注者</span></span><br><span class="line">        follower.follow(followee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unfollow</span><span class="params">(<span class="type">int</span> followerId, <span class="type">int</span> followeeId)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!idToUser.containsKey(followerId) || !idToUser.containsKey(followeeId)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">User</span> <span class="variable">follower</span> <span class="operator">=</span> idToUser.get(followerId);</span><br><span class="line">        <span class="type">User</span> <span class="variable">followee</span> <span class="operator">=</span> idToUser.get(followeeId);</span><br><span class="line">        <span class="comment">// 关注者取关被关注者</span></span><br><span class="line">        follower.unfollow(followee);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>再来看第二类，寻找第 <code>k</code> 个最大元素这类题：</p>
<hr>
<h2 id="215-数组中的第-K-个最大元素open-in-new-window"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#_215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%AC-k-%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0">#</a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array">215. 数组中的第 K 个最大元素open in new window</a></h2>
<ul>
<li><strong>标签：二叉堆，快速选择算法，数组</strong></li>
</ul>
<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[3,2,1,5,6,4] 和 k = 2</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[3,2,3,1,2,4,5,5,6] 和 k = 4</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>
<h3 id="基本思路-v6"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-5">#</a>基本思路</h3>
<p>二叉堆的解法比较简单，实际写算法题的时候，推荐大家写这种解法。</p>
<p>可以把小顶堆 <code>pq</code> 理解成一个筛子，较大的元素会沉淀下去，较小的元素会浮上来；当堆大小超过 <code>k</code> 的时候，我们就删掉堆顶的元素，因为这些元素比较小，而我们想要的是前 <code>k</code> 个最大元素嘛。</p>
<p>当 <code>nums</code> 中的所有元素都过了一遍之后，筛子里面留下的就是最大的 <code>k</code> 个元素，而堆顶元素是堆中最小的元素，也就是「第 <code>k</code> 个最大的元素」。</p>
<p>二叉堆插入和删除的时间复杂度和堆中的元素个数有关，在这里我们堆的大小不会超过 <code>k</code>，所以插入和删除元素的复杂度是 <code>O(logK)</code>，再套一层 for 循环，总的时间复杂度就是 <code>O(NlogK)</code>。</p>
<p>当然，这道题可以有效率更高的解法叫「快速选择算法」，只需要 <code>O(N)</code> 的时间复杂度。</p>
<p>快速选择算法不用借助二叉堆结构，而是稍微改造了快速排序的算法思路，有兴趣的读者可以看详细题解。</p>
<ul>
<li><strong>详细题解：<a target="_blank" rel="noopener" href="https://labuladong.gitee.io/article/fname.html?fname=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序详解及应用open in new window</a></strong></li>
</ul>
<h3 id="解法代码-v6"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-5">#</a>解法代码</h3>
<p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 小顶堆，堆顶是最小元素</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e : nums) &#123;</span><br><span class="line">            <span class="comment">// 每个元素都要过一遍二叉堆</span></span><br><span class="line">            pq.offer(e);</span><br><span class="line">            <span class="comment">// 堆中元素多于 k 个时，删除堆顶元素</span></span><br><span class="line">            <span class="keyword">if</span> (pq.size() &gt; k) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pq 中剩下的是 nums 中 k 个最大元素，</span></span><br><span class="line">        <span class="comment">// 堆顶是最小的那个，即第 k 个最大元素</span></span><br><span class="line">        <span class="keyword">return</span> pq.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>类似题目</p>
<p>：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements">347. 前 K 个高频元素 🟠open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-a-stream">703. 数据流中的第 K 大元素 🟢open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-an-array">912. 排序数组 🟠open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof">剑指 Offer 40. 最小的k个数 🟢open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jBjn9C">剑指 Offer II 059. 数据流的第 K 大数值 🟢open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/g5c51o">剑指 Offer II 060. 出现频率最高的 k 个数字 🟠open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/xx4gT2">剑指 Offer II 076. 数组中的第 k 大的数字 🟠open in new window</a></li>
</ul>
</li>
</ul>
<h2 id="451-根据字符出现频率排序open-in-new-window"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#_451-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F">#</a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-characters-by-frequency">451. 根据字符出现频率排序open in new window</a></h2>
<ul>
<li><strong>标签：二叉堆，排序</strong></li>
</ul>
<p>给定一个字符串 <code>s</code>，根据字符出现的 <strong>频率</strong> 对其进行 <strong>降序排序</strong>。一个字符出现的 <strong>频率</strong> 是它出现在字符串中的次数，<strong>返回已排序的字符串</strong>。如果有多个答案，返回其中任何一个。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;tree&quot;</span><br><span class="line">输出：&quot;eert&quot;</span><br><span class="line">解释：&#x27;e&#x27; 出现两次，&#x27;r&#x27; 和 &#x27;t&#x27; 都只出现一次。</span><br><span class="line">因此 &#x27;e&#x27; 必须出现在 &#x27;r&#x27; 和 &#x27;t&#x27; 之前。此外，&quot;eetr&quot; 也是一个有效的答案。</span><br></pre></td></tr></table></figure>
<h3 id="基本思路-v7"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-6">#</a>基本思路</h3>
<p>做这道题肯定需要计算每个字符出现的频率，然后你可以用很多种其他方法把字符按照频率排序。我这里用 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/article/fname.html?fname=%E4%BA%8C%E5%8F%89%E5%A0%86%E8%AF%A6%E8%A7%A3%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97">优先级队列open in new window</a> 来实现排序的效果，详细看代码。</p>
<h3 id="解法代码-v7"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-6">#</a>解法代码</h3>
<p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">frequencySort</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="comment">// s 中的字符 -&gt; 该字符出现的频率</span></span><br><span class="line">        HashMap&lt;Character, Integer&gt; charToFreq = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : chars) &#123;</span><br><span class="line">            charToFreq.put(ch, charToFreq.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;Character, Integer&gt;&gt;</span><br><span class="line">                pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((entry1, entry2) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 队列按照键值对中的值（字符出现频率）从大到小排序</span></span><br><span class="line">            <span class="keyword">return</span> entry2.getValue().compareTo(entry1.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照字符频率排序</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : charToFreq.entrySet()) &#123;</span><br><span class="line">            pq.offer(entry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 把频率最高的字符排在前面</span></span><br><span class="line">            Map.Entry&lt;Character, Integer&gt; entry = pq.poll();</span><br><span class="line">            <span class="type">String</span> <span class="variable">part</span> <span class="operator">=</span> String.valueOf(entry.getKey()).repeat(entry.getValue());</span><br><span class="line">            sb.append(part);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="703-数据流中的第-K-大元素open-in-new-window"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#_703-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%AC-k-%E5%A4%A7%E5%85%83%E7%B4%A0">#</a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-a-stream">703. 数据流中的第 K 大元素open in new window</a></h2>
<ul>
<li><strong>标签：二叉堆，数据结构</strong></li>
</ul>
<p>设计一个找到数据流中第 <code>k</code> 大元素的类（class）。注意是排序后的第 <code>k</code> 大元素，不是第 <code>k</code> 个不同的元素。</p>
<p>请实现 <code>KthLargest</code> 类：</p>
<p>1、<code>KthLargest(int k, int[] nums)</code> 使用整数 <code>k</code> 和整数流 <code>nums</code> 初始化对象。</p>
<p>2、<code>int add(int val)</code> 将 <code>val</code> 插入数据流 <code>nums</code> 后，返回当前数据流中第 <code>k</code> 大的元素。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;KthLargest&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;]</span><br><span class="line">[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]</span><br><span class="line">输出：</span><br><span class="line">[null, 4, 5, 5, 8, 8]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);</span><br><span class="line">kthLargest.add(3);   // return 4</span><br><span class="line">kthLargest.add(5);   // return 5</span><br><span class="line">kthLargest.add(10);  // return 5</span><br><span class="line">kthLargest.add(9);   // return 8</span><br><span class="line">kthLargest.add(4);   // return 8</span><br></pre></td></tr></table></figure>
<h3 id="基本思路-v8"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-7">#</a>基本思路</h3>
<p>这题考察优先级队列的使用，可以先做下这道类似的题目 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array">215. 数组中的第 K 个最大元素open in new window</a>。</p>
<p>优先级队列的实现原理详见 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/article/fname.html?fname=%E4%BA%8C%E5%8F%89%E5%A0%86%E8%AF%A6%E8%A7%A3%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97">图文详解二叉堆，实现优先级队列open in new window</a>。</p>
<h3 id="解法代码-v8"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-7">#</a>解法代码</h3>
<p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KthLargest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> k;</span><br><span class="line">    <span class="comment">// 默认是小顶堆</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">KthLargest</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 将 nums 装入小顶堆，保留下前 k 大的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e : nums) &#123;</span><br><span class="line">            pq.offer(e);</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &gt; k) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 维护小顶堆只保留前 k 大的元素</span></span><br><span class="line">        pq.offer(val);</span><br><span class="line">        <span class="keyword">if</span> (pq.size() &gt; k) &#123;</span><br><span class="line">            pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 堆顶就是第 k 大元素（即倒数第 k 小的元素）</span></span><br><span class="line">        <span class="keyword">return</span> pq.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>类似题目</p>
<p>：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jBjn9C">剑指 Offer II 059. 数据流的第 K 大数值 🟢open in new window</a></li>
</ul>
</li>
</ul>
<h2 id="347-前-K-个高频元素open-in-new-window"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#_347-%E5%89%8D-k-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0">#</a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements">347. 前 K 个高频元素open in new window</a></h2>
<ul>
<li><strong>标签：二叉堆，哈希表，快速选择</strong></li>
</ul>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>
<h3 id="基本思路-v9"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-8">#</a>基本思路</h3>
<p>首先，肯定要用一个 <code>valToFreq</code> <a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/yong-la-li-3b08e/la-lian-fa-68d24/">哈希表open in new window</a> 把每个元素出现的频率计算出来。</p>
<p>然后，这道题就变成了 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array">215. 数组中的第 K 个最大元素open in new window</a>，只不过第 215 题让你求数组中元素值 <code>e</code> 排在第 <code>k</code> 大的那个元素，这道题让你求数组中元素值 <code>valToFreq[e]</code> 排在前 <code>k</code> 个的元素。</p>
<p>我在 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/article/fname.html?fname=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序详解及运用open in new window</a> 中讲过第 215 题，可以用 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/article/fname.html?fname=%E4%BA%8C%E5%8F%89%E5%A0%86%E8%AF%A6%E8%A7%A3%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97">优先级队列open in new window</a> 或者快速选择算法解决这道题。这里稍微改一下优先级队列的比较函数，或者改一下快速选择算法中的逻辑即可。</p>
<p>这里我再加一种解法，用计数排序的方式找到前 <code>k</code> 个高频元素，见代码。</p>
<h3 id="解法代码-v9"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-8">#</a>解法代码</h3>
<p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用优先级队列解决这道题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// nums 中的元素 -&gt; 该元素出现的频率</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; valToFreq = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : nums) &#123;</span><br><span class="line">            valToFreq.put(v, valToFreq.getOrDefault(v, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt;</span><br><span class="line">                pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((entry1, entry2) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 队列按照键值对中的值（元素出现频率）从小到大排序</span></span><br><span class="line">            <span class="keyword">return</span> entry1.getValue().compareTo(entry2.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : valToFreq.entrySet()) &#123;</span><br><span class="line">            pq.offer(entry);</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &gt; k) &#123;</span><br><span class="line">                <span class="comment">// 弹出最小元素，维护队列内是 k 个频率最大的元素</span></span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// res 数组中存储前 k 个最大元素</span></span><br><span class="line">            res[i] = pq.poll().getKey();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用计数排序的方法解决这道题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// nums 中的元素 -&gt; 该元素出现的频率</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; valToFreq = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : nums) &#123;</span><br><span class="line">            valToFreq.put(v, valToFreq.getOrDefault(v, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 频率 -&gt; 这个频率有哪些元素</span></span><br><span class="line">        ArrayList&lt;Integer&gt;[] freqToVals = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : valToFreq.keySet()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">freq</span> <span class="operator">=</span> valToFreq.get(val);</span><br><span class="line">            <span class="keyword">if</span> (freqToVals[freq] == <span class="literal">null</span>) &#123;</span><br><span class="line">                freqToVals[freq] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            freqToVals[freq].add(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// freqToVals 从后往前存储着出现最多的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> freqToVals.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; valList = freqToVals[i];</span><br><span class="line">            <span class="keyword">if</span> (valList == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; valList.size(); j++) &#123;</span><br><span class="line">                <span class="comment">// 将出现次数最多的 k 个元素装入 res</span></span><br><span class="line">                res[p] = valList.get(j);</span><br><span class="line">                p++;</span><br><span class="line">                <span class="keyword">if</span> (p == k) &#123;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>类似题目</p>
<p>：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-words">692. 前K个高频单词 🟠open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/g5c51o">剑指 Offer II 060. 出现频率最高的 k 个数字 🟠open in new window</a></li>
</ul>
</li>
</ul>
<h2 id="692-前K个高频单词open-in-new-window"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#_692-%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D">#</a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-words">692. 前K个高频单词open in new window</a></h2>
<ul>
<li><strong>标签：二叉堆，哈希表</strong></li>
</ul>
<p>给定一个单词列表 <code>words</code> 和一个整数 <code>k</code>，返回前 <code>k</code> 个出现次数最多的单词。返回的答案应该按单词出现频率由高到低排序，如果不同的单词有相同出现频率，<strong>按字典顺序</strong> 排序。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：words = [&quot;i&quot;, &quot;love&quot;, &quot;leetcode&quot;, &quot;i&quot;, &quot;love&quot;, &quot;coding&quot;], k = 2</span><br><span class="line">输出：[&quot;i&quot;, &quot;love&quot;]</span><br><span class="line">解析：&quot;i&quot; 和 &quot;love&quot; 为出现次数最多的两个单词，均为 2 次。</span><br><span class="line">    注意，按字母顺序 &quot;i&quot; 在 &quot;love&quot; 之前。</span><br></pre></td></tr></table></figure>
<h3 id="基本思路-v10"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-9">#</a>基本思路</h3>
<p>这道题可以认为是 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements">347. 前 K 个高频元素open in new window</a> 的进阶版。整体思路还哈希表计数，然后用 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/article/fname.html?fname=%E4%BA%8C%E5%8F%89%E5%A0%86%E8%AF%A6%E8%A7%A3%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97">优先级队列open in new window</a> 维护出现频率最高的 <code>k</code> 个单词。</p>
<p>只是我们需要注意题目要求，在 <code>PriorityQueue</code> 的比较器中正确处理频率相同的单词的字典序。</p>
<h3 id="解法代码-v10"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-9">#</a>解法代码</h3>
<p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">topKFrequent</span><span class="params">(String[] words, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 字符串 -&gt; 该字符串出现的频率</span></span><br><span class="line">        HashMap&lt;String, Integer&gt; wordToFreq = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            wordToFreq.put(word, wordToFreq.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;String, Integer&gt;&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">                (entry1, entry2) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (entry1.getValue().equals(entry2.getValue())) &#123;</span><br><span class="line">                        <span class="comment">// 如果出现频率相同，按照字符串字典序排序</span></span><br><span class="line">                        <span class="keyword">return</span> entry2.getKey().compareTo(entry1.getKey());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 队列按照字符串出现频率从小到大排序</span></span><br><span class="line">                    <span class="keyword">return</span> entry1.getValue().compareTo(entry2.getValue());</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照字符串频率升序排序</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : wordToFreq.entrySet()) &#123;</span><br><span class="line">            pq.offer(entry);</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &gt; k) &#123;</span><br><span class="line">                <span class="comment">// 维护出现频率最多的 k 个单词</span></span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把出现次数最多的 k 个字符串返回</span></span><br><span class="line">        LinkedList&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            res.addFirst(pq.poll().getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>最后，再看一看优先级队列的其他运用吧：</p>
<hr>
<h2 id="1845-座位预约管理系统open-in-new-window"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#_1845-%E5%BA%A7%E4%BD%8D%E9%A2%84%E7%BA%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">#</a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/seat-reservation-manager">1845. 座位预约管理系统open in new window</a></h2>
<ul>
<li><strong>标签：二叉堆，数据结构，设计</strong></li>
</ul>
<p>请你设计一个管理 <code>n</code> 个座位预约的系统，座位编号从 <code>1</code> 到 <code>n</code>。</p>
<p>请你实现 <code>SeatManager</code> 类：</p>
<ul>
<li><code>SeatManager(int n)</code> 初始化一个 <code>SeatManager</code> 对象，它管理从 <code>1</code> 到 <code>n</code> 编号的 <code>n</code> 个座位。所有座位初始都是可预约的。</li>
<li><code>int reserve()</code> 返回可以预约座位的<strong>最小编号</strong>，此座位变为不可预约。</li>
<li><code>void unreserve(int seatNumber)</code> 将给定编号 <code>seatNumber</code> 对应的座位变成可以预约。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;SeatManager&quot;, &quot;reserve&quot;, &quot;reserve&quot;, &quot;unreserve&quot;, &quot;reserve&quot;, &quot;reserve&quot;, &quot;reserve&quot;, &quot;reserve&quot;, &quot;unreserve&quot;]</span><br><span class="line">[[5], [], [], [2], [], [], [], [], [5]]</span><br><span class="line">输出：</span><br><span class="line">[null, 1, 2, null, 2, 3, 4, 5, null]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">SeatManager seatManager = new SeatManager(5); // 初始化 SeatManager，有 5 个座位。</span><br><span class="line">seatManager.reserve();    // 所有座位都可以预约，所以返回最小编号的座位，也就是 1。</span><br><span class="line">seatManager.reserve();    // 可以预约的座位为 [2,3,4,5]，返回最小编号的座位，也就是 2。</span><br><span class="line">seatManager.unreserve(2); // 将座位 2 变为可以预约，现在可预约的座位为 [2,3,4,5]。</span><br><span class="line">seatManager.reserve();    // 可以预约的座位为 [2,3,4,5]，返回最小编号的座位，也就是 2。</span><br><span class="line">seatManager.reserve();    // 可以预约的座位为 [3,4,5]，返回最小编号的座位，也就是 3。</span><br><span class="line">seatManager.reserve();    // 可以预约的座位为 [4,5]，返回最小编号的座位，也就是 4。</span><br><span class="line">seatManager.reserve();    // 唯一可以预约的是座位 5，所以返回 5。</span><br><span class="line">seatManager.unreserve(5); // 将座位 5 变为可以预约，现在可预约的座位为 [5]。</span><br></pre></td></tr></table></figure>
<h3 id="基本思路-v11"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-10">#</a>基本思路</h3>
<p>这题是 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-phone-directory">379. 电话目录管理系统open in new window</a> 的进阶版，那一道题返回的空闲号码可以随意，而这道题要求返回<strong>最小</strong>的座位编号。</p>
<p>其实很思路是一样的，只是这里需要用到能够按照元素大小自动排序的数据结构 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/article/fname.html?fname=%E4%BA%8C%E5%8F%89%E5%A0%86%E8%AF%A6%E8%A7%A3%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97">优先级队列（二叉堆）open in new window</a>，直接看代码吧。</p>
<h3 id="解法代码-v11"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-10">#</a>解法代码</h3>
<p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SeatManager</span> &#123;</span><br><span class="line">    <span class="comment">// 利用优先级队列自动排序，队头的元素就是最小的</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SeatManager</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化所有空闲座位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            pq.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reserve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 拿出队头元素（最小）</span></span><br><span class="line">        <span class="keyword">return</span> pq.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unreserve</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        pq.offer(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="295-数据流的中位数open-in-new-window"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#_295-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0">#</a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-median-from-data-stream">295. 数据流的中位数open in new window</a></h2>
<ul>
<li><strong>标签：二叉堆，数学</strong></li>
</ul>
<p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<p>1、<code>void addNum(int num)</code> 从数据流中添加一个整数到数据结构中。</p>
<p>2、<code>double findMedian()</code> 返回目前所有元素的中位数。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">addNum(1)</span><br><span class="line">addNum(2)</span><br><span class="line">findMedian() -&gt; 1.5</span><br><span class="line">addNum(3) </span><br><span class="line">findMedian() -&gt; 2</span><br></pre></td></tr></table></figure>
<h3 id="基本思路-v12"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-11">#</a>基本思路</h3>
<p>本题的核心思路是使用两个优先级队列。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="%E4%BA%8C%E5%8F%89%E5%A0%86%E8%AF%A6%E8%A7%A3%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/1.jpeg" alt="img"></p>
<p>小的倒三角就是个大顶堆，梯形就是个小顶堆，中位数可以通过它们的堆顶元素算出来：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="%E4%BA%8C%E5%8F%89%E5%A0%86%E8%AF%A6%E8%A7%A3%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/2.jpeg" alt="img"></p>
<ul>
<li><strong>详细题解：<a target="_blank" rel="noopener" href="https://labuladong.gitee.io/article/fname.html?fname=%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E4%BD%8D%E6%95%B0">一道求中位数的算法题把我整不会了open in new window</a></strong></li>
</ul>
<h3 id="解法代码-v12"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-11">#</a>解法代码</h3>
<p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; large;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; small;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MedianFinder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 小顶堆</span></span><br><span class="line">        large = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 大顶堆</span></span><br><span class="line">        small = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> b - a;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果元素不一样多，多的那个堆的堆顶元素就是中位数</span></span><br><span class="line">        <span class="keyword">if</span> (large.size() &lt; small.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> small.peek();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (large.size() &gt; small.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> large.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果元素一样多，两个堆堆顶元素的平均数是中位数</span></span><br><span class="line">        <span class="keyword">return</span> (large.peek() + small.peek()) / <span class="number">2.0</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (small.size() &gt;= large.size()) &#123;</span><br><span class="line">            small.offer(num);</span><br><span class="line">            large.offer(small.poll());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            large.offer(num);</span><br><span class="line">            small.offer(large.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>类似题目</p>
<p>：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof">剑指 Offer 41. 数据流中的中位数 🔴open in new window</a></li>
</ul>
</li>
</ul>
<h2 id="870-优势洗牌open-in-new-window"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#_870-%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C">#</a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/advantage-shuffle">870. 优势洗牌open in new window</a></h2>
<ul>
<li><strong>标签：数组，数组双指针</strong></li>
</ul>
<p>给定两个大小相等的数组 <code>A</code> 和 <code>B</code>，<code>A</code> 相对于 <code>B</code> 的<strong>优势</strong>可以用满足 <code>A[i] &gt; B[i]</code> 的索引 <code>i</code> 的数目来描述。</p>
<p>请你返回 <code>A</code> 的<strong>任意</strong>排列，使其相对于 <code>B</code> 的优势最大化。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：A = [2,7,11,15], B = [1,10,4,11]</span><br><span class="line">输出：[2,11,7,15]</span><br></pre></td></tr></table></figure>
<h3 id="基本思路-v13"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-12">#</a>基本思路</h3>
<p>这题就像田忌赛马的情景，<code>nums1</code> 就是田忌的马，<code>nums2</code> 就是齐王的马，数组中的元素就是马的战斗力，你就是谋士孙膑，请你帮田忌安排赛马顺序，使胜场最多。</p>
<p>最优策略是将齐王和田忌的马按照战斗力排序，然后按照战斗力排名一一对比：</p>
<p>如果田忌的马能赢，那就比赛，如果赢不了，那就换个垫底的来送人头，保存实力。</p>
<p>具体分析见详细题解。</p>
<ul>
<li><strong>详细题解：<a target="_blank" rel="noopener" href="https://labuladong.gitee.io/article/fname.html?fname=%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC">田忌赛马背后的算法决策open in new window</a></strong></li>
</ul>
<h3 id="解法代码-v13"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-12">#</a>解法代码</h3>
<p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] advantageCount(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="comment">// 给 nums2 降序排序</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; maxpq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">                (<span class="type">int</span>[] pair1, <span class="type">int</span>[] pair2) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> pair2[<span class="number">1</span>] - pair1[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            maxpq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, nums2[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 给 nums1 升序排序</span></span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// nums1[left] 是最小值，nums1[right] 是最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!maxpq.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] pair = maxpq.poll();</span><br><span class="line">            <span class="comment">// maxval 是 nums2 中的最大值，i 是对应索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> pair[<span class="number">0</span>], maxval = pair[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (maxval &lt; nums1[right]) &#123;</span><br><span class="line">                <span class="comment">// 如果 nums1[right] 能胜过 maxval，那就自己上</span></span><br><span class="line">                res[i] = nums1[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则用最小值混一下，养精蓄锐</span></span><br><span class="line">                res[i] = nums1[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1834-单线程-CPUopen-in-new-window"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#_1834-%E5%8D%95%E7%BA%BF%E7%A8%8B-cpu">#</a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/single-threaded-cpu">1834. 单线程 CPUopen in new window</a></h2>
<ul>
<li><strong>标签：二叉堆，排序</strong></li>
</ul>
<p>给你一个二维数组 <code>tasks</code>，用于表示 <code>n</code> 项从 <code>0</code> 到 <code>n - 1</code> 编号的任务。其中 <code>tasks[i] = [enqueueTime_i, processingTime_i]</code> 意味着第 <code>i</code> 项任务将会于 <code>enqueueTime_i</code> 时进入任务队列，需要 <code>processingTime_i</code> 的时长完成执行。</p>
<p>现有一个单线程 CPU，同一时间只能执行 <strong>最多一项</strong> 任务，该 CPU 将会按照下述方式运行：</p>
<ul>
<li>如果 CPU 空闲，且任务队列中没有需要执行的任务，则 CPU 保持空闲状态。</li>
<li>如果 CPU 空闲，但任务队列中有需要执行的任务，则 CPU 将会选择<strong>执行时间最短</strong>的任务开始执行。如果多个任务具有同样的最短执行时间，则选择下标最小的任务开始执行。</li>
<li>一旦某项任务开始执行，CPU 在 <strong>执行完整个任务</strong> 前都不会停止。</li>
<li>CPU 可以在完成一项任务后，立即开始执行一项新任务。</li>
</ul>
<p>返回 CPU 处理任务的顺序。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：tasks = [[1,2],[2,4],[3,2],[4,1]]</span><br><span class="line">输出：[0,2,3,1]</span><br><span class="line">解释：事件按下述流程运行： </span><br><span class="line">- time = 1，任务 0 进入任务队列，可执行任务项 = &#123;0&#125;</span><br><span class="line">- 同样在 time = 1，空闲状态的 CPU 开始执行任务 0，可执行任务项 = &#123;&#125;</span><br><span class="line">- time = 2，任务 1 进入任务队列，可执行任务项 = &#123;1&#125;</span><br><span class="line">- time = 3，任务 2 进入任务队列，可执行任务项 = &#123;1, 2&#125;</span><br><span class="line">- 同样在 time = 3，CPU 完成任务 0 并开始执行队列中用时最短的任务 2，可执行任务项 = &#123;1&#125;</span><br><span class="line">- time = 4，任务 3 进入任务队列，可执行任务项 = &#123;1, 3&#125;</span><br><span class="line">- time = 5，CPU 完成任务 2 并开始执行队列中用时最短的任务 3，可执行任务项 = &#123;1&#125;</span><br><span class="line">- time = 6，CPU 完成任务 3 并开始执行任务 1，可执行任务项 = &#123;&#125;</span><br><span class="line">- time = 10，CPU 完成任务 1 并进入空闲状态</span><br></pre></td></tr></table></figure>
<h3 id="基本思路-v14"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-13">#</a>基本思路</h3>
<p>这题的难度不算大，就是有些复杂，<strong>难点在于你要同时控制三个变量（开始时间、处理时间、索引）的有序性，而且这三个变量还有优先级</strong>：</p>
<p>首先应该考虑开始时间，因为只要到了开始时间，任务才进入可执行状态；</p>
<p>其次应该考虑任务的处理时间，在所有可以执行的任务中优先选择处理时间最短的；</p>
<p>如果存在处理时间相同的任务，那么优先选择索引最小的。</p>
<p>所以这道题的思路是：</p>
<p><strong>先根据任务「开始时间」排序，维护一个时间线变量 <code>now</code> 来判断哪些任务到了可执行状态，然后借助一个优先级队列 <code>pq</code> 对「处理时间」和「索引」进行动态排序</strong>。</p>
<p>利用优先级队列动态排序是有必要的，因为每完成一个任务，时间线 <code>now</code> 就要更新，进而产生新的可执行任务。</p>
<h3 id="解法代码-v14"><a target="_blank" rel="noopener" href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-13">#</a>解法代码</h3>
<p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getOrder(<span class="type">int</span>[][] tasks) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tasks.length;</span><br><span class="line">        <span class="comment">// 把原始索引也添加上，方便后面排序用</span></span><br><span class="line">        ArrayList&lt;<span class="type">int</span>[]&gt; triples = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tasks.length; i++) &#123;</span><br><span class="line">            triples.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;tasks[i][<span class="number">0</span>], tasks[i][<span class="number">1</span>], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数组先按照任务的开始时间排序</span></span><br><span class="line">        triples.sort((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照任务的处理时间排序，如果处理时间相同，按照原始索引排序</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">1</span>] != b[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 比较处理时间</span></span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 比较原始索引</span></span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">2</span>] - b[<span class="number">2</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 记录完成任务的时间线</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (res.size() &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pq.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 完成队列中的一个任务</span></span><br><span class="line">                <span class="type">int</span>[] triple = pq.poll();</span><br><span class="line">                res.add(triple[<span class="number">2</span>]);</span><br><span class="line">                <span class="comment">// 每完成一个任务，就要推进时间线</span></span><br><span class="line">                now += triple[<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; n &amp;&amp; triples.get(i)[<span class="number">0</span>] &gt; now) &#123;</span><br><span class="line">                <span class="comment">// 队列为空可能因为还没到开始时间，</span></span><br><span class="line">                <span class="comment">// 直接把时间线推进到最近任务的开始时间</span></span><br><span class="line">                now = triples.get(i)[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 由于时间线的推进，会产生可以开始执行的任务</span></span><br><span class="line">            <span class="keyword">for</span> (; i &lt; n &amp;&amp; triples.get(i)[<span class="number">0</span>] &lt;= now; i++) &#123;</span><br><span class="line">                pq.offer(triples.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Java 语言特性，将 List 转化成 int[] 格式</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            arr[j] = res.get(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202311071529290.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202311071529290.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">labuladong</div><div class="post-copyright__author_desc">纵有疾风起, 人生不言弃</div></div><div class="post-copyright__post__info"><a class="post-copyright__reprint" title="该文章为转载文章，注意版权协议" target="_blank" rel="noopener" href="https://labuladong.online/">转载</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://labuladong.online/')">二叉堆详解实现优先级队列</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202311072150771.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202311072150771.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202311072150143.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202311072150143.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://labuladong.online/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=二叉堆详解实现优先级队列&amp;url=https://labuladong.online/&amp;pic=https://www.toopic.cn/public/uploads/small/17102202974171022029789.jpg?_r_=51e6b011-4754-6662-9bb7-4bdfcedc8574" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">此文章版权归labuladong所有，如有转载，请注明来自原作者</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>算法<span class="tagsPageCount">41</span></a><a class="post-meta__box__tags" href="/tags/%E8%BD%AC%E8%BD%BD/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>转载<span class="tagsPageCount">35</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://www.toopic.cn/public/uploads/small/1642746863176164274686336.jpg?_r_=8454c8fc-966a-d52c-aa0b-6a944102a6ff" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/49870.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.toopic.cn/public/uploads/small/17102202974171022029789.jpg?_r_=d13e2611-a5de-d152-ddf9-317202eb150b" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">经典动态规划：最长公共子序列</div></div></a></div><div class="next-post pull-right"><a href="/posts/3749.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.toopic.cn/public/uploads/small/1642747923455164274792346.jpg?_r_=db5afb74-e792-9625-750a-a0c2b2c71f9c" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">一道求中位数的算法题把我整不会了</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/posts/36851.html" title="算法笔试「骗分」套路"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.toopic.cn/public/uploads/small/1642747923455164274792346.jpg?_r_=4bc55450-55dd-cf75-d111-f6979ed50c62" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-08-14</div><div class="title">算法笔试「骗分」套路</div></div></a></div><div><a href="/posts/44500.html" title="算法时空复杂度分析实用指南"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.toopic.cn/public/uploads/small/1658045003884165804500389.jpg?_r_=1bb20a7e-429f-4209-ae37-b6a5e5a5af6e" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-08-14</div><div class="title">算法时空复杂度分析实用指南</div></div></a></div><div><a href="/posts/44501.html" title="一个方法团灭 nSum 问题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.toopic.cn/public/uploads/small/1658045166469165804516695.png?_r_=962fd320-b314-16e4-75c3-52153f33accc" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-08-14</div><div class="title">一个方法团灭 nSum 问题</div></div></a></div><div><a href="/posts/56524.html" title="Git原理之最近公共祖先"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.toopic.cn/public/uploads/small/1642747775404164274777570.jpg?_r_=b5d8b919-6e77-1442-c04d-64d7a36644f9" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-08-14</div><div class="title">Git原理之最近公共祖先</div></div></a></div><div><a href="/posts/9364.html" title="如何同时寻找缺失和重复的元素"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.toopic.cn/public/uploads/small/1642747923455164274792346.jpg?_r_=62a08cb6-518f-6ae7-7e5e-8e0fcc7c4dcc" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-08-14</div><div class="title">如何同时寻找缺失和重复的元素</div></div></a></div><div><a href="/posts/42555.html" title="如何高效进行模幂运算"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.toopic.cn/public/uploads/small/1658044597567165804459797.jpg?_r_=3a8bc026-c382-ef94-560d-317d8eca2000" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-08-14</div><div class="title">如何高效进行模幂运算</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202311071529290.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2021/03/03/317b790a902ec.png" ait="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">后端, 算法, Java技术栈</b>相关的问题和看法，还有<b style="color:#fff">文章翻译</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Shio</h1><div class="author-info__desc">纵有疾风起, 人生不言弃</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/zhshio" target="_blank" title="GitHub"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-github"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://leetcode.cn/u/zhshio/" target="_blank" title="LeetCode"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-leetcode"></use></svg></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202311082256357.jpg) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">二叉堆详解实现优先级队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BA%8C%E5%8F%89%E5%A0%86%E6%A6%82%E8%A7%88"><span class="toc-number">1.0.1.</span> <span class="toc-text">一、二叉堆概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E6%A6%82%E8%A7%88"><span class="toc-number">1.0.2.</span> <span class="toc-text">二、优先级队列概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%AE%9E%E7%8E%B0-swim-%E5%92%8C-sink"><span class="toc-number">1.0.3.</span> <span class="toc-text">三、实现 swim 和 sink</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AE%9E%E7%8E%B0-delMax-%E5%92%8C-insert"><span class="toc-number">1.0.4.</span> <span class="toc-text">四、实现 delMax 和 insert</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%9C%80%E5%90%8E%E6%80%BB%E7%BB%93"><span class="toc-number">1.0.5.</span> <span class="toc-text">五、最后总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">经典练习题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%90%88%E5%B9%B6-K-%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8open-in-new-window"><span class="toc-number">2.1.</span> <span class="toc-text">23. 合并 K 个升序链表open in new window</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="toc-number">2.1.1.</span> <span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81"><span class="toc-number">2.1.2.</span> <span class="toc-text">解法代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#373-%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84-K-%E5%AF%B9%E6%95%B0%E5%AD%97open-in-new-window"><span class="toc-number">2.2.</span> <span class="toc-text">373. 查找和最小的 K 对数字open in new window</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-v2"><span class="toc-number">2.2.1.</span> <span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-v2"><span class="toc-number">2.2.2.</span> <span class="toc-text">解法代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#378-%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%AC-K-%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0open-in-new-window"><span class="toc-number">2.3.</span> <span class="toc-text">378. 有序矩阵中第 K 小的元素open in new window</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-v3"><span class="toc-number">2.3.1.</span> <span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-v3"><span class="toc-number">2.3.2.</span> <span class="toc-text">解法代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#313-%E8%B6%85%E7%BA%A7%E4%B8%91%E6%95%B0open-in-new-window"><span class="toc-number">2.4.</span> <span class="toc-text">313. 超级丑数open in new window</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-v4"><span class="toc-number">2.4.1.</span> <span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-v4"><span class="toc-number">2.4.2.</span> <span class="toc-text">解法代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#355-%E8%AE%BE%E8%AE%A1%E6%8E%A8%E7%89%B9open-in-new-window"><span class="toc-number">2.5.</span> <span class="toc-text">355. 设计推特open in new window</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-v5"><span class="toc-number">2.5.1.</span> <span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-v5"><span class="toc-number">2.5.2.</span> <span class="toc-text">解法代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%AC-K-%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0open-in-new-window"><span class="toc-number">2.6.</span> <span class="toc-text">215. 数组中的第 K 个最大元素open in new window</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-v6"><span class="toc-number">2.6.1.</span> <span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-v6"><span class="toc-number">2.6.2.</span> <span class="toc-text">解法代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#451-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8Fopen-in-new-window"><span class="toc-number">2.7.</span> <span class="toc-text">451. 根据字符出现频率排序open in new window</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-v7"><span class="toc-number">2.7.1.</span> <span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-v7"><span class="toc-number">2.7.2.</span> <span class="toc-text">解法代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#703-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%AC-K-%E5%A4%A7%E5%85%83%E7%B4%A0open-in-new-window"><span class="toc-number">2.8.</span> <span class="toc-text">703. 数据流中的第 K 大元素open in new window</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-v8"><span class="toc-number">2.8.1.</span> <span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-v8"><span class="toc-number">2.8.2.</span> <span class="toc-text">解法代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0open-in-new-window"><span class="toc-number">2.9.</span> <span class="toc-text">347. 前 K 个高频元素open in new window</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-v9"><span class="toc-number">2.9.1.</span> <span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-v9"><span class="toc-number">2.9.2.</span> <span class="toc-text">解法代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#692-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8Dopen-in-new-window"><span class="toc-number">2.10.</span> <span class="toc-text">692. 前K个高频单词open in new window</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-v10"><span class="toc-number">2.10.1.</span> <span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-v10"><span class="toc-number">2.10.2.</span> <span class="toc-text">解法代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1845-%E5%BA%A7%E4%BD%8D%E9%A2%84%E7%BA%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9Fopen-in-new-window"><span class="toc-number">2.11.</span> <span class="toc-text">1845. 座位预约管理系统open in new window</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-v11"><span class="toc-number">2.11.1.</span> <span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-v11"><span class="toc-number">2.11.2.</span> <span class="toc-text">解法代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#295-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0open-in-new-window"><span class="toc-number">2.12.</span> <span class="toc-text">295. 数据流的中位数open in new window</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-v12"><span class="toc-number">2.12.1.</span> <span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-v12"><span class="toc-number">2.12.2.</span> <span class="toc-text">解法代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#870-%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8Copen-in-new-window"><span class="toc-number">2.13.</span> <span class="toc-text">870. 优势洗牌open in new window</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-v13"><span class="toc-number">2.13.1.</span> <span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-v13"><span class="toc-number">2.13.2.</span> <span class="toc-text">解法代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1834-%E5%8D%95%E7%BA%BF%E7%A8%8B-CPUopen-in-new-window"><span class="toc-number">2.14.</span> <span class="toc-text">1834. 单线程 CPUopen in new window</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-v14"><span class="toc-number">2.14.1.</span> <span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-v14"><span class="toc-number">2.14.2.</span> <span class="toc-text">解法代码</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/29849.html" title="七天重启人生计划"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.toopic.cn/public/uploads/small/1642746863176164274686336.jpg?_r_=8454c8fc-966a-d52c-aa0b-6a944102a6ff" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="七天重启人生计划"/></a><div class="content"><a class="title" href="/posts/29849.html" title="七天重启人生计划">七天重启人生计划</a><time datetime="2024-07-10T03:45:14.000Z" title="发表于 2024-07-10 11:45:14">2024-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/11416.html" title="【从零构建Spring|第十六节】  三级缓存解决循环依赖问题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.toopic.cn/public/uploads/small/1710220321195171022032150.jpg?_r_=bbc8cbf3-790b-79b3-c706-5a69db7f3b5f" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【从零构建Spring|第十六节】  三级缓存解决循环依赖问题"/></a><div class="content"><a class="title" href="/posts/11416.html" title="【从零构建Spring|第十六节】  三级缓存解决循环依赖问题">【从零构建Spring|第十六节】  三级缓存解决循环依赖问题</a><time datetime="2024-04-15T15:40:00.000Z" title="发表于 2024-04-15 23:40:00">2024-04-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/11413.html" title="【从零构建Spring|第十三节】  加载,解析资源并注册Bean对象"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.toopic.cn/public/uploads/small/1642746863176164274686336.jpg?_r_=dfa89139-65f6-63e6-9e50-078a9b071bce" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【从零构建Spring|第十三节】  加载,解析资源并注册Bean对象"/></a><div class="content"><a class="title" href="/posts/11413.html" title="【从零构建Spring|第十三节】  加载,解析资源并注册Bean对象">【从零构建Spring|第十三节】  加载,解析资源并注册Bean对象</a><time datetime="2024-04-15T08:52:31.313Z" title="发表于 2024-04-15 16:52:31">2024-04-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/11414.html" title="【从零构建Spring|第十四节】  自动扫描并注册Bean"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.toopic.cn/public/uploads/small/1695609028811169560902782.jpg?_r_=12d843af-9dff-7fea-e567-d9bca5d3d87b" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【从零构建Spring|第十四节】  自动扫描并注册Bean"/></a><div class="content"><a class="title" href="/posts/11414.html" title="【从零构建Spring|第十四节】  自动扫描并注册Bean">【从零构建Spring|第十四节】  自动扫描并注册Bean</a><time datetime="2024-04-08T15:40:00.000Z" title="发表于 2024-04-08 23:40:00">2024-04-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/11415.html" title="【从零构建Spring|第十五节】  通过注解@Autowired注入属性信息"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.toopic.cn/public/uploads/small/1658044994475165804499423.jpg?_r_=fb74c936-758b-6b64-e376-5363b208144e" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【从零构建Spring|第十五节】  通过注解@Autowired注入属性信息"/></a><div class="content"><a class="title" href="/posts/11415.html" title="【从零构建Spring|第十五节】  通过注解@Autowired注入属性信息">【从零构建Spring|第十五节】  通过注解@Autowired注入属性信息</a><time datetime="2024-04-08T15:40:00.000Z" title="发表于 2024-04-08 23:40:00">2024-04-08</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站使用为Vercel提供评论搜索功能部署" title="本站使用为Vercel提供评论搜索功能部署"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Serverless-Vercel-blue" alt="本站使用为Vercel提供评论搜索功能部署"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2022 - 2024 By <a class="footer-bar-link" href="/" title="Shio" target="_blank">Shio</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/" title="晋ICP备-2024040094号">晋ICP备-2024040094号</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">97</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">18</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="http://www.zhshio.cn/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202311091058032.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/zhshio/micro-spring" title="micro-spring"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202312101409146.png" alt="micro-spring"/><span class="back-menu-item-text">micro-spring</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/zhshio/tinydb" title="tinydb"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202312101413777.jpg" alt="tinydb"/><span class="back-menu-item-text">tinydb</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AQS/" style="font-size: 0.88rem;">AQS<sup>1</sup></a><a href="/tags/ArrayLists/" style="font-size: 0.88rem;">ArrayLists<sup>1</sup></a><a href="/tags/CountDownLatch/" style="font-size: 0.88rem;">CountDownLatch<sup>1</sup></a><a href="/tags/Docker/" style="font-size: 0.88rem;">Docker<sup>1</sup></a><a href="/tags/JAVA/" style="font-size: 0.88rem;">JAVA<sup>1</sup></a><a href="/tags/JUC/" style="font-size: 0.88rem;">JUC<sup>2</sup></a><a href="/tags/JVM/" style="font-size: 0.88rem;">JVM<sup>5</sup></a><a href="/tags/Java/" style="font-size: 0.88rem;">Java<sup>1</sup></a><a href="/tags/Java%E6%BA%90%E7%A0%81/" style="font-size: 0.88rem;">Java源码<sup>1</sup></a><a href="/tags/Jottings/" style="font-size: 0.88rem;">Jottings<sup>1</sup></a><a href="/tags/MQ/" style="font-size: 0.88rem;">MQ<sup>1</sup></a><a href="/tags/MYSQL/" style="font-size: 0.88rem;">MYSQL<sup>3</sup></a><a href="/tags/SPring/" style="font-size: 0.88rem;">SPring<sup>1</sup></a><a href="/tags/Spr/" style="font-size: 0.88rem;">Spr<sup>1</sup></a><a href="/tags/Spring/" style="font-size: 0.88rem;">Spring<sup>21</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/" style="font-size: 0.88rem;">代码模板<sup>1</sup></a><a href="/tags/%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">学习工具<sup>3</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 0.88rem;">操作系统<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">数据结构<sup>1</sup></a><a href="/tags/%E6%B8%90%E8%BF%9B%E5%BC%8F%E5%AE%9E%E7%8E%B0Spring/" style="font-size: 0.88rem;">渐进式实现Spring<sup>16</sup></a><a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size: 0.88rem;">生活<sup>5</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>41</sup></a><a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 0.88rem;">编译原理<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">计算机基础<sup>4</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">设计模式<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/" style="font-size: 0.88rem;">设计模式之美<sup>3</sup></a><a href="/tags/%E8%BD%AC%E8%BD%BD/" style="font-size: 0.88rem;">转载<sup>35</sup></a><a href="/tags/%E9%87%8D%E5%90%AF%E4%BA%BA%E7%94%9F/" style="font-size: 0.88rem;">重启人生<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">面试<sup>1</sup></a><a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 0.88rem;">项目<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="1645775761" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/1645775761&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("05/01/2022 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2022 By 安知鱼 V1.6.9",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Shio 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const initWaline = () => {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://blog.zhshio.cn/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  const loadWaline = async () => {
    if (typeof Waline === 'object') initWaline()
    else {
      await getCSS('https://cdn.cbd.int/@waline/client@2.15.5/dist/waline.css')
      await getScript('https://cdn.cbd.int/@waline/client@2.15.5/dist/waline.js')
      initWaline()
    }
  }

  if ('Waline' === 'Waline' || !true) {
    if (true) anzhiyu.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = async () => {
    try {
      const res = await fetch('https://blog.zhshio.cn/api/comment?type=recent&count=6', { method: 'GET' })
      const result = await res.json()
      const walineArray = result.data.map(e => {
        return {
          'content': changeContent(e.comment),
          'avatar': e.avatar,
          'nick': e.nick,
          'url': e.url + '#' + e.objectId,
          'date': e.time || e.insertedAt
        }
      })
      saveToLocal.set('waline-newest-comments', JSON.stringify(walineArray), 10/(60*24))
      generateHtml(walineArray)
    } catch (err) {
      console.error(err)
      const $dom = document.querySelector('#card-newest-comments .aside-list')
      $dom.textContent= "无法获取评论，请确认相关配置是否正确"
    }
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('waline-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script async src="https://at.alicdn.com/t/c/font_4553851_th9nw4n1uwo.js?spm=a313x.manage_type_myprojects.i1.10.46983a81t6FYmK&amp;file=font_4553851_th9nw4n1uwo.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>