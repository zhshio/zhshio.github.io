<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>太原理工大学软工方向选择指南</title>
      <link href="/posts/14931.html"/>
      <url>/posts/14931.html</url>
      
        <content type="html"><![CDATA[<h1 id="太原理工大学软工方向选择指南"><a href="#太原理工大学软工方向选择指南" class="headerlink" title="太原理工大学软工方向选择指南"></a>太原理工大学软工方向选择指南</h1><p>大家好! 我是Shio, 国内白嫖的服务器过期了, 所以博客又回到了GitHub Page上, 访问速度会很慢, 大家见谅</p><p>又到了一年一度软件专业同学选择方向的时候了, 这时候的大家大概心里也对自己将来是考公, 考研, 还是就业 心里大概有了一个基本的方向, 下面是我对选方向上的一些经验, 分享给大家</p><p>首先我们先给大家扫扫盲</p><ul><li>每年学校给软工学生分配的方向和所处基地并不是强绑定的关系, 也就是说, 可能今年这个方向在某某基地, 但是明年是有概率换的</li><li>所有基地都会分考研班和就业班, 所以考研的同学不需要太过担心到基地后的学业压力, 基本每个基地的考研班在课程上都是很轻松的, 基本不会影响到你的备战</li><li>往年基本选定哪个方向就能去哪个方向, 但是去年我们这届情况特殊, 移动互联方向只有八十人左右, 而网安方向投递志愿的人太多, 所以会根据成绩进行排序, 排序靠后的同学最后会调剂到第二志愿的方向去</li><li>在选定方向后, 大三下就会根据不同方向有不同的课程以及课设安排, 之后大概在6, 7月份会对各方向的培训工作公开招标(但根据往年的情况看, 其实就是那几家), 一般7月份就会出招标结果, 7月中下旬或者8月上旬前往基地, 一直到在基地准备秋招或者考研考公到12月份初, 放假, 一般会在考四六级和考研前放, 今年国考的话, 需要请假回去考, 第二年在三月份左右上去, 准备春招, 复试还有毕业论文一直到6月份在基地完成论文答辩</li><li>如果大三下暑假找到了自己的实习, 需要向学校提交申请, 可以不去基地, 到了基地后, 或者大四下的找到工作后实习的话, 一般都可以不用呆在基地</li></ul><p>下面是我整理的每年各方向和相应方向第二年招标到的基地</p><table><thead><tr><th>年级</th><th>软件开发</th><th>移动互联</th><th>人工智能</th><th>大数据</th><th>网络安全</th></tr></thead><tbody><tr><td>2021</td><td>天津东软</td><td>四川华迪</td><td>北京百知(base天津)</td><td>昆山杰普</td><td>武汉天融信</td></tr><tr><td>2020</td><td>成都华迪</td><td>昆山杰普</td><td>北京百知(base天津)</td><td>天津东软</td><td>武汉天融信</td></tr><tr><td>2019</td><td>成都华迪</td><td>天津东软</td><td>北京百知(base天津)</td><td>昆山杰普</td><td>武汉天融信</td></tr><tr><td>2018</td><td>成都华迪</td><td>昆山杰普</td><td>北京百知(base天津)</td><td>天津东软</td><td></td></tr><tr><td>2017</td><td>成都华迪</td><td>昆山杰普</td><td>北京百知(base天津)</td><td>天津东软</td><td></td></tr><tr><td>2016</td><td>昆山杰普, 天津东软</td><td></td><td>北京百知(未知)</td><td>成都华迪</td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>需要注意两点</p><ul><li>北京百知实际位于天津武清, 其他基地位置基本就是前缀保持一致</li><li>网络安全方向是19级之后才出现的, 自出现后一直都在武汉天融信基地</li></ul><p>通常大家的选法都是  </p><ul><li>网络安全  人工智能  大数据  考研考公方向</li><li>软件开发  移动互联  就业方向</li></ul><p>比较主观, 只是说通常的选法, 最终选方向还是看个人情况和规划, 比方说你是校CTF队的想就业, 那选网安蛮合适, 如果说你以后准备在北京实习, 那么选招标相对固定的人工智能基地, 离北京近, 往返方便, 也挺好 </p><p>住宿条件的话, 今年 感觉 东软(单间)和天融信(有人打扫卫生换床单)是比较好的    杰普和百知相对一般, 华迪的话, 可能是这几个里面比较差</p><p>其实基地在你考研考公还是就业方面的帮助和影响并不算大, 更多还是看个人</p><p>关于今年秋招身边同学的就业情况, 因为比较主观, 就不在这里提及,可以私下问我</p><p>每年各方向敲定基地后, 都会提前开会, 告知基地位置, 住宿情况以及报道方式, 今年暑假我把每个方向的都做了笔记, 但是是微信聊天记录的形式, 搬到博客上加载起来太慢还麻烦, 直接加群看吧,  我邀请各方向的学长, 有问题可以在群里问, 学长有时间的话, 给你们答疑</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/image-20241216225902919.png" alt="image-20241216225902919"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【从零构建Spring|第十三节】  加载,解析资源并注册Bean对象</title>
      <link href="/posts/11413.html"/>
      <url>/posts/11413.html</url>
      
        <content type="html"><![CDATA[<h1 id="【从零构建Spring-第十三节】-加载-解析资源并注册Bean对象"><a href="#【从零构建Spring-第十三节】-加载-解析资源并注册Bean对象" class="headerlink" title="【从零构建Spring|第十三节】  加载,解析资源并注册Bean对象"></a>【从零构建Spring|第十三节】  加载,解析资源并注册Bean对象</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>在上一章节我们通过基于 Proxy.newProxyInstance 代理操作中处理方法匹配和方法拦截，对匹配的对象进行自定义的处理操作。并把这样的技术核心内容拆解到 Spring 中，用于实现 AOP 部分，通过拆分后基本可以明确各个类的职责，包括你的代理目标对象属性、拦截器属性、方法匹配属性，以及两种不同的代理操作 JDK 和 CGlib 的方式。</p><p>再有了一个 AOP 核心功能的实现后，我们可以通过单元测试的方式进行验证切面功能对方法进行拦截，但如果这是一个面向用户使用的功能，就不太可能让用户这么复杂且没有与 Spring 结合的方式单独使用 AOP，虽然可以满足需求，但使用上还是过去分散。</p><p>因此我们需要在本章节完成 AOP 核心功能与 Spring 框架的整合，最终能通过在 Spring 配置的方式完成切面的操作</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>将 AOP 融入 Spring 需要解决几个问题</p><ul><li>怎么通过 BeanPostProcessor 将动态代理融入 Bean 的生命周期中？</li><li>如何组装各项切点、拦截、前置以及适配对应的代理器？</li></ul><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/11.AOP%E6%89%A9%E5%B1%95%E5%88%B0Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-assets/202302141533758.png" alt="image-20230214153324289"></p><ul><li>为了可以让对象创建过程中，能把xml中配置的代理对象也就是切面的一些类对象实例化，就需要用到 BeanPostProcessor 提供的方法 <code>postProcessBeforeInitialization</code>、<code>postProcessAfterInitialization</code>，因为这个类的中的方法可以分别作用与 Bean 对象执行<strong>初始化前后修改 Bean 的对象的扩展信息</strong>。但这里需要集合于 BeanPostProcessor 实现新的接口和实现类，这样才能<strong>定向获取对应的类信息</strong>。</li><li>但因为创建的是代理对象不是之前流程里的普通对象，所以我们需要<strong>前置于其他对象的创建</strong>，所以在实际开发的过程中，需要在 AbstractAutowireCapableBeanFactory#createBean <strong>优先完成 Bean 对象的判断，是否需要代理，有则直接返回代理对象。</strong><em>在Spring的源码中会有 createBean 和 doCreateBean 的方法拆分</em></li><li>这里还包括要解决方法拦截器的具体功能，提供一些 BeforeAdvice、AfterAdvice 的实现，让用户可以更简化的使用切面功能。除此之外还包括需要包装切面表达式以及拦截方法的整合，以及提供不同类型的代理方式的代理工厂，来包装我们的切面服务。</li></ul><h3 id="Advice、Advisor、PointcutAdvisor"><a href="#Advice、Advisor、PointcutAdvisor" class="headerlink" title="Advice、Advisor、PointcutAdvisor"></a>Advice、Advisor、PointcutAdvisor</h3><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/11.AOP%E6%89%A9%E5%B1%95%E5%88%B0Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-assets/202302142204018.png" alt="image-20230214220424854"></p><ul><li>Advice 是 aop 提供的一个基类接口。本节用它定义 BeforeAdvice 在方法拦截前执行逻辑处理。也可以定义 AfterAdvice</li><li>Advisor 是 Advice 的访问者接口，只定义获取 Advice 方法。具体实现在 AspectJExpressionPointcutAdvisor，其也包装了切面、具体拦截方法、规则表达式</li><li>PointcutAdvisor 包装了 Advisor、Pointcut，它既能获取 advice，也可以获取 pointcut</li></ul><h3 id="代理工厂-ProxyFactory"><a href="#代理工厂-ProxyFactory" class="headerlink" title="代理工厂 ProxyFactory"></a>代理工厂 ProxyFactory</h3><p>抽象出代理工厂，使用 getProxy() 直接获取代理对象。代替了上一节中需要用户自己实例化具体的代理方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> createAopProxy().getProxy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，在 AdvisedSupport 新增 boolean：proxyTargetClass ，其为 true 代表使用 Cglib、否则选择使用 Jdk 方式实例化代理对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (advisedSupport.isProxyTargetClass()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cglib2AopProxy</span>(advisedSupport);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(advisedSupport);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="融入Bean生命周期的自动代理创建者"><a href="#融入Bean生命周期的自动代理创建者" class="headerlink" title="融入Bean生命周期的自动代理创建者"></a>融入Bean生命周期的自动代理创建者</h3><p>在 bean 实例化（初始化）之前，调用 postProcessorBeforeInstantiation 方法。该方法先执行 getBeansOfType 获取包装好的 Advisor :<code>AspectJExpressionPointcutAdvisor</code>。之后基本就是将上节测试的逻辑放在了该方法里。</p><p>值得注意的是，在上节中，我们使用 new 的方式创建出需要代理的类 UserService，再将其注入到 targetSource；但还记得 AOP 的定义吗，<strong>不通过 new 的方式创建出用户所需要的对象</strong>。精妙之处就在这里，此时需要代理类信息已经保存到 bean 里了，可以<strong>直接通过 <code>beanClass.getDeclaredConstructor().newInstance()</code> 这种反射的方式去创建实例完成注入</strong>。</p><p>详细代码：</p><ul><li>先判断当前 bean 是否为基础结构类：Advice、Pointcut、Advisor。通过 <code>isAssignableFrom(beanClass)</code> 进行判断，只有 <code>UserService</code> 这种类型的数据结构才能够被代理。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回过头来，之前提出的两个疑问我们是怎么解决？</p><h3 id="怎么通过-BeanPostProcessor-将动态代理融入-Bean-的生命周期中？"><a href="#怎么通过-BeanPostProcessor-将动态代理融入-Bean-的生命周期中？" class="headerlink" title="怎么通过 BeanPostProcessor 将动态代理融入 Bean 的生命周期中？"></a>怎么通过 BeanPostProcessor 将动态代理融入 Bean 的生命周期中？</h3><p>定义 BeanPostProcessor 的子接口 InstantiationAwareBeanPostProcessor，它定义了接口方法 <code>postProcessorBeforeInstantiation</code> 该方法在 Bean 进行初始化（实例化）之前就会调用，目的是将该 bean 的实例化从普通实例化转变为代理实例化，需要填充 AOP 逻辑。</p><h4 id="如何转变？"><a href="#如何转变？" class="headerlink" title="如何转变？"></a>如何转变？</h4><p>通过 getBeansOfType 获取 AspectJExpressionPointcutAdvisors 集合，而 AspectJExpressionPointcutAdvisor 是在 xml 中配置，在上下文加载时期被读取，我们知道，在 Spring IoC 中万物皆是 Bean 对象。</p><p>遍历每个 advisor，这时 ClassFilter 接口就排上用场了，它来检测当前 advisor 是否符合匹配规则。</p><p>匹配之后填充对应的 advisedSupport 属性。</p><p>最后调用 ProxyFactory 代理工厂的逻辑。选择是使用 Jdk 还是 Cglib 动态代理 bean。</p><p>+++</p><p>AOP的调用在 bean 对象执行<strong>其方法</strong>逻辑后。当没有调用 bean 对象逻辑或者 bean 对象没有对应逻辑时，自然也不会触发 AOP 切面方法</p><h3 id="如何组装各项切点、拦截、前置以及适配对应的代理器？"><a href="#如何组装各项切点、拦截、前置以及适配对应的代理器？" class="headerlink" title="如何组装各项切点、拦截、前置以及适配对应的代理器？"></a>如何组装各项切点、拦截、前置以及适配对应的代理器？</h3><p>通过接口继承接口的方法让逻辑更加通顺以及代码简洁。</p><p>在 AspectJExpressionPointcutAdvisor 里包装了 切面 Pointcut、具体拦截方法 advice、规则表达式 expression。</p><p>将上一节测试代码中的 UserServiceInterceptor 实现的逻辑转移到 MethodBeforeAdvice。它继承了 BeforeAdvice，在逻辑上为在方法调用前的通知。当然还有 AfterAdvice以及 MethodAfterAdvice，可以自己实现，它在逻辑上为在方法调用后的通知。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 渐进式实现Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七天重启人生计划</title>
      <link href="/posts/29849.html"/>
      <url>/posts/29849.html</url>
      
        <content type="html"><![CDATA[<h1 id="🌟七天重启人生计划🌟：从摆烂到高效，我的亲身实践🚀"><a href="#🌟七天重启人生计划🌟：从摆烂到高效，我的亲身实践🚀" class="headerlink" title="🌟七天重启人生计划🌟：从摆烂到高效，我的亲身实践🚀"></a>🌟七天重启人生计划🌟：从摆烂到高效，我的亲身实践🚀</h1><p>在人生的某个阶段或者某段时间，我们或许都会陷入一种<strong>“摆烂”</strong>状态——无目标、无动力，甚至开始怀疑自我。但你知道吗？<strong>只需七天，你就能重启人生</strong>，找回失去的激情与方向！🌈</p><h2 id="📆Day-1：记录与觉醒📝"><a href="#📆Day-1：记录与觉醒📝" class="headerlink" title="📆Day 1：记录与觉醒📝"></a>📆Day 1：记录与觉醒📝</h2><p>选择一个你觉得舒适的日子作为你的Day 1。这天，<strong>仔细记录你所做的一切</strong>，无论是刷手机的<strong>闲暇时光</strong>还是完成工作任务的<strong>高效瞬间</strong>。<strong>标记出那些消耗你时间和精力的“吸血鬼”</strong>，它们可能是无休止的社交媒体滚动、冗长无意义的会议或是拖延症。🎯</p><h2 id="🧠Day-2-4：目标设定与思维激荡💡"><a href="#🧠Day-2-4：目标设定与思维激荡💡" class="headerlink" title="🧠Day 2-4：目标设定与思维激荡💡"></a>🧠Day 2-4：目标设定与思维激荡💡</h2><p>接下来的三天，<strong>每晚睡前</strong>，让大脑<strong>沉浸在对未来一年目标的思考中</strong>。<strong>不要限制自己，任何可能性都是开放的</strong>。但到了<strong>第四天晚上</strong>，你需要<strong>对目标无比坚定</strong>，明确知道自己想要什么，无论是事业上的提升、健康状况的改善还是个人兴趣的培养。🌱</p><h2 id="🗓️Day-5：规划未来📅"><a href="#🗓️Day-5：规划未来📅" class="headerlink" title="🗓️Day 5：规划未来📅"></a>🗓️Day 5：规划未来📅</h2><p>今天，是时候<strong>制定详细的计划</strong>了。<strong>规划</strong>接下来<strong>一周、一个月乃至一年的具体行动</strong>。将<strong>大目标分解成小步骤</strong>，这样<strong>更容易执行</strong>。记得，每个项目都要有<strong>优先级</strong>，先做什么后做什么，一目了然。📈</p><h2 id="🔧Day-6：微调与优化🔧"><a href="#🔧Day-6：微调与优化🔧" class="headerlink" title="🔧Day 6：微调与优化🔧"></a>🔧Day 6：微调与优化🔧</h2><p><strong>回顾昨天的计划</strong>，看看是否有<strong>需要调整的地方</strong>。<strong>确保</strong>每一个步骤都是<strong>可行且实际</strong>的，<strong>避免好高骛远</strong>。这天，也是最后的机会来完善你的计划，确保它既挑战性又不失可行性。🛠️</p><h2 id="🚀Day-7：行动起来！"><a href="#🚀Day-7：行动起来！" class="headerlink" title="🚀Day 7：行动起来！"></a>🚀Day 7：行动起来！</h2><p>从今天开始，远离内耗，<strong>专注于执行</strong>。从小事做起，比如早起半小时、阅读一本书或是学习一项新技能。时刻与Day 1的自己<strong>作对比</strong>，<strong>反思自己的变化</strong>。💪</p><h2 id="🎯保持勇敢，感受内心💖"><a href="#🎯保持勇敢，感受内心💖" class="headerlink" title="🎯保持勇敢，感受内心💖"></a>🎯保持勇敢，感受内心💖</h2><p><strong>在这个过程中，保持勇气，不断感受内心的变化，培育你的野心。不要忘记，爱自己，给自己正面的反馈，这样才能持续前进。</strong>💌</p><h2 id="🏆结果与坚持🏆"><a href="#🏆结果与坚持🏆" class="headerlink" title="🏆结果与坚持🏆"></a>🏆结果与坚持🏆</h2><p>记住，<strong>成功的关键在于坚持</strong>。当你看到结果时，你会更加确信这个七天重启计划的有效性。无论是学业、工作还是个人成长，这个方法都能帮助你找到前进的方向。🎉</p><p>我就是用这种方法度过留学和工作的每个阶段的，效果真的非常棒！现在，轮到你了，开始你的<strong>七天重启之旅</strong>吧！🌟</p><hr><p>希望这篇博客能给正在寻找改变的你带来灵感和动力。如果你觉得有用，别忘了分享给更多需要的人哦！🤝</p>]]></content>
      
      
      <categories>
          
          <category> 重启人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重启人生 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【从零构建Spring|第十六节】  三级缓存解决循环依赖问题</title>
      <link href="/posts/11416.html"/>
      <url>/posts/11416.html</url>
      
        <content type="html"><![CDATA[<h1 id="【从零构建Spring-第十六节】-三级缓存解决循环依赖问题"><a href="#【从零构建Spring-第十六节】-三级缓存解决循环依赖问题" class="headerlink" title="【从零构建Spring|第十六节】  三级缓存解决循环依赖问题"></a>【从零构建Spring|第十六节】  三级缓存解决循环依赖问题</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目前我们的 Spring 可以完成一个基本功能。但是如果遇到 A、B 两个 Bean 对象相互依赖，就会报出 <code>java.lang.StackOverflowError</code> 错误。因为创建 A 时需要 B，而 B 的创建又依赖于 A 创建，死循环</p><p>循环依赖是 Spring 经典的场景。需要解决的主要是以下三种情况：</p><ul><li>自身依赖</li><li>循环依赖</li><li>多组依赖</li></ul><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/15.%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98-assets/202302221145600.png" alt="image-20230218114108130"></p><p>按照 Spring 框架的设计，用于解决循环依赖需要用到<strong>三个缓存 Map</strong>，这三个缓存分别存放了<strong>成品对象、半成品对象(未填充属性值)、代理对象</strong>，分阶段存放对象内容，来解决循环依赖问题。</p><ul><li>singletonObjects：成品对象</li><li>earlySingletonObjects：半成品对象</li><li>singletonFactories：工厂对象（代理对象）</li></ul><p>这里我们需要知道一个核心的原理，就是用于解决循环依赖就必须是三级缓存呢，二级行吗？一级可以不？其实都能解决，只不过 Spring 框架的实现要保证几个事情，如只有一级缓存处理流程没法拆分，复杂度也会增加，同时半成品对象可能会有空指针异常。而将半成品与成品对象分开，处理起来也更加优雅、简单、易扩展。另外 Spring 的两大特性中不仅有 IOC 还有 AOP，也就是基于字节码增强后的方法，该存放到哪，而三级缓存最主要，要解决的循环依赖就是对 AOP 的处理，但如果把 AOP 代理对象的创建提前，那么二级缓存也一样可以解决。但是就没法为 AOP 所创建的代理对象注入属性了</p><h3 id="半成品容易导致空指针现象"><a href="#半成品容易导致空指针现象" class="headerlink" title="半成品容易导致空指针现象"></a>半成品容易导致空指针现象</h3><p>半成品对象是指在对象的构造函数中，由于某些原因导致对象尚未完全初始化，即存在某些属性或者状态未被正确初始化的情况，这样的对象也被称作是“不完整的对象”。在使用这些对象的时候，由于其状态不完整，很容易引发 NullPointerException 等异常。</p><p>半成品对象引起空指针异常的原因通常有以下几个方面：</p><ol><li>对象的构造函数中发生了异常，导致对象没有被正确初始化。例如，构造函数中可能会调用其他方法或者访问其他属性，如果这些方法或属性返回了 null 值或者抛出了异常，就有可能导致对象的状态不完整。</li><li>多线程情况下，可能会出现并发访问半成品对象的情况。由于半成品对象尚未完全初始化，如果多个线程同时访问该对象，就有可能引发线程安全问题，例如出现竞态条件等情况。</li><li>对象中存在循环依赖的情况。如果两个或多个对象之间存在循环依赖关系，就有可能导致其中一个对象尚未完全初始化，从而出现半成品对象的情况。</li></ol><p>因此，在编写程序时，需要注意避免出现半成品对象的情况，通常的做法是在构造函数中完成所有属性的初始化，并且避免在构造函数中调用其他方法或者访问其他属性，同时也需要注意多线程访问和循环依赖的问题。</p><h3 id="三级缓存的具体流程如下"><a href="#三级缓存的具体流程如下" class="headerlink" title="三级缓存的具体流程如下"></a>三级缓存的具体流程如下</h3><p><strong>三级缓存架构图</strong>：</p><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/15.%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98-assets/202302221145691.png" alt="image-20230218185123867"></p><p>在 Spring 框架中，半成品对象容易引发空指针的问题，通常是由于对象之间的复杂依赖关系和循环依赖问题导致的。</p><p>为了解决这个问题，Spring 框架采用了 “三级缓存” 的机制，以确保对象能够正确地初始化和注入依赖。</p><p>在 Spring 中，对象的创建和管理是由 BeanFactory 和 ApplicationContext 完成的。当 Spring 容器创建一个 Bean 的实例时，会先将其创建成一个原型对象，然后检查该对象是否已经被创建过。如果没有被创建过，那么会将其添加到一级缓存（singletonObjects）中，即完全初始化完成的单例对象缓存中。如果该对象存在依赖关系，那么 Spring 会在创建过程中将其添加到二级缓存（earlySingletonObjects）中，即尚未完全初始化完成的单例对象缓存中，以避免循环依赖的问题。</p><p>当对象的所有依赖项都被注入后，Spring 会将对象从二级缓存中移除，并将其添加到三级缓存（singletonFactories）中，即创建单例对象的工厂实例缓存中。通过这个工厂实例，Spring 可以对对象进行一些扩展，例如使用 AOP 进行代理，以实现对对象的增强。</p><p>当下次需要获取该对象时，Spring 会从三级缓存中获取工厂实例，然后通过工厂实例创建一个新的对象。这个新的对象在创建的过程中，会使用已经存在的对象实例进行注入，确保对象的依赖关系得以正确处理。</p><p>通过这样的机制，Spring 可以保证对象的创建和初始化的正确性，从而避免了半成品对象容易引发空指针的问题。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 渐进式实现Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【从零构建Spring|第十四节】  自动扫描并注册Bean</title>
      <link href="/posts/11414.html"/>
      <url>/posts/11414.html</url>
      
        <content type="html"><![CDATA[<h1 id="【从零构建Spring-第十四节】-自动扫描并注册Bean"><a href="#【从零构建Spring-第十四节】-自动扫描并注册Bean" class="headerlink" title="【从零构建Spring|第十四节】  自动扫描并注册Bean"></a>【从零构建Spring|第十四节】  自动扫描并注册Bean</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一章节结束之后，我们其实已经完成了 IoC 和 AOP 的全部核心内容。但是现在还需要使用 Spring.xml 进行配置。思考思考我们平时最多是怎么用 Spring 完成信息配置的？一是注解，二是 property。</p><p>为了在核心逻辑上填充一些自动化的功能，所需要的知识有：</p><ul><li>包的扫描注册</li><li>注解配置使用</li><li>占位符属性的填充</li></ul><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>为了可以简化 Bean 对象的配置，达到整个 Bean 对象的注册都是自动扫描的。最基本的元素包括：</p><ul><li>扫描路径入口</li><li>XML 解析扫描信息</li><li>给需要扫描的 Bean 对象做注解标记</li><li>扫描 Class 对象摘取 Bean 注册的基本信息</li><li>组装 Bean 注册信息</li><li>注册 Bean 对象</li></ul><p>除此之外再顺带解决一个配置中占位符属性的知识点，比如可以通过 <code>$&#123;token&#125;</code> 给 Bean 对象注入进去属性信息，那么这个操作需要用到 BeanFactoryPostProcessor，因为它可以处理 <strong>在所有的 BeanDefinition 加载完成后，实例化 Bean 对象之前，提供修改 BeanDefinition 属性的机制</strong></p><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/12.%E8%87%AA%E5%8A%A8%E6%89%AB%E6%8F%8FBean%E5%AF%B9%E8%B1%A1%E6%B3%A8%E5%86%8C-assets/202302150946447.png" alt="image-20230215094554414"></p><p>结合 bean 的生命周期，包扫描只不过是<strong>扫描特定注解的类</strong>，提取类的相关信息组装成 BeanDefinition 注册到容器中。</p><p>在 XmlBeanDefinitionReader 中<strong>解析<code>&lt;context:component-scan /&gt;</code>标签</strong>，扫描类组装 BeanDefinition 然后注册到容器中的操作在 ClassPathBeanDefinitionScanner#doScan 中实现。</p><ul><li>自动扫描注册主要是扫描添加了自定义注解的类，在 xml 加载过程中提取类的信息，组装 BeanDefinition 注册到 Spring 容器中。</li><li>所以我们会用到 <code>&lt;context:component-scan /&gt;</code> 配置包路径并在 XmlBeanDefinitionReader 解析并做相应的处理。<em>这里的处理会包括对类的扫描、获取注解信息等</em></li><li>最后还包括了一部分关于 <code>BeanFactoryPostProcessor</code> 的使用，因为我们需要完成对占位符配置信息的加载，所以需要使用到 BeanFactoryPostProcessor 在所有的 BeanDefinition 加载完成后，实例化 Bean 对象之前，修改 BeanDefinition 的属性信息。<em>这一部分的实现也为后续处理关于占位符配置到注解上做准备</em></li></ul><h3 id="处理对象扫描装配"><a href="#处理对象扫描装配" class="headerlink" title="处理对象扫描装配"></a>处理对象扫描装配</h3><p>XML 解析类 XmlBeanDefinitionReader 对 ClassPathBeanDefinitionScanner#doScan 的使用</p><p>doScan 方法处理所有指定路径下添加注解的类，拆解出类的信息{ 名称 beanName，作用范围 scope }.在进行创建 BeanDefinition 用于 Bean 对象的注册操作。</p><p>详细代码：</p><ul><li>doScan 中，findCandidateComponents 负责将所有标注了 @Component 注解的类 通过 ClassUtil.scanPackageByAnnotation(basePackage, Component.class) 解析出来， Set&lt;Class&lt;?&gt;&gt; 维护 Class，Set 维护以及实例化好的 BeanDefinition(clazz)</li><li>对每个 BeanDefinition 而言，需要解析其 scope（可为 null）和 beanName。他们的解析都是通过获取注解内容的方式 getAnnotation(@interface.class)</li></ul><h3 id="PropertyPlaceholderConfigurer"><a href="#PropertyPlaceholderConfigurer" class="headerlink" title="PropertyPlaceholderConfigurer"></a>PropertyPlaceholderConfigurer</h3><p>目前看上去像一块单独的内容，后续会把这块的内容与自动加载 Bean 对象进行整合，也就是可以在注解上<strong>使用占位符配置一些在配置文件里的属性信息。</strong></p><p>他所做的步骤如下：</p><ol><li>读取属性文件资源，通过 load 方式将信息加载到 properties 类中</li><li>通过一些简单逻辑操作将占位符 “{@Value}” 替换成 “实际内容”</li></ol><p>详细代码：</p><h3 id="资源读取"><a href="#资源读取" class="headerlink" title="资源读取"></a>资源读取</h3><p>迭代读取 XML 配置信息的代码，使用 dom4j 方式解析 xml，不仅提高代码简洁性，也提升易读性</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.dom4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渐进式实现Spring </tag>
            
            <tag> Spr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【从零构建Spring|第十五节】  通过注解@Autowired注入属性信息</title>
      <link href="/posts/11415.html"/>
      <url>/posts/11415.html</url>
      
        <content type="html"><![CDATA[<h1 id="【从零构建Spring-第十五节】-通过注解-Autowired注入属性信息"><a href="#【从零构建Spring-第十五节】-通过注解-Autowired注入属性信息" class="headerlink" title="【从零构建Spring|第十五节】  通过注解@Autowired注入属性信息"></a>【从零构建Spring|第十五节】  通过注解@Autowired注入属性信息</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在目前 IOC、AOP 两大核心功能模块的支撑下，完全可以管理 Bean 对象的注册和获取，不过这样的使用方式总感觉像是刀耕火种有点难用。因此在上一章节我们解决需要手动配置 <code>Bean</code> 对象到 <code>spring.xml</code> 文件中，改为可以自动扫描带有注解 <code>@Component</code> 的对象完成自动装配和注册到 <code>Spring</code> 容器的操作。</p><p>那么在自动扫描包注册 Bean 对象之后，就需要把原来在配置文件中通过 <code>property name=&quot;token&quot;</code> 配置属性和Bean的操作，也改为可以自动注入。这就像我们使用 Spring 框架中 <code>@Autowired</code>、<code>@Value</code> 注解一样，完成我们对属性和对象的注入操作</p><p>本节需要添加 <code>@Autowired</code>、<code>@Value</code>、<code>@Qualifier</code> 等注解功能</p><ul><li>@Autowired 默认根据类型进行 Bean 注入，因此如果有多个类型相同的 Bean 候选者，则需要指定其中一个候选者，不然 Spring 抛出异常</li><li>@Qualifier 限定描述符除了能根据名字进行注入，更能通过更细粒度的控制如何选择候选者</li><li>@Resource 默认按照名称进行装配，名称可以通过 name 属性指定。如果没有指定 name 属性，当注解标注在字段上，默认取字段名进行名称查找；注解写在setter 方法上，默认取属性名进行装配，当找不到名称相符的 bean 才按照类型进行装配，但需要注意的是 name 属性一旦指定，就只会按照名称进行装配</li></ul><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>在完成 Bean 基础功能之后。后续陆续添加的内容都是基于 Bean 生命周期进行的。比如修改 Bean 定义信息的 BeanFactoryPostProcessor，处理 Bean 属性需要的 BeanPostProcessor，完成个性的属性操作则专门继承 BeanPostProcessor 提供新的接口，因为这样才能通过 instanceof 判断出具有标记性的接口。所以关于 Bean 等等的操作，以及监听 Aware、获取 BeanFactory，都需要在 Bean 的生命周期中完成。那么我们在设计属性和 Bean 对象的注入时候，也会用到 BeanPostProcessor 来完成在设置 Bean 属性之前，允许 BeanPostProcessor 修改属性值。</p><ul><li>要处理自动扫描注入，包括属性注入、对象注入，则需要在对象属性 <code>applyPropertyValues</code> 填充之前 ，把属性信息写入到 PropertyValues 的集合中去。这一步的操作相当于是解决了以前在 spring.xml 配置属性的过程。</li><li>而在属性的读取中，需要依赖于对 Bean 对象的类中属性的配置了注解的扫描，<code>field.getAnnotation(Value.class);</code> 依次拿出符合的属性并填充上相应的配置信息。<em>这里有一点 ，属性的配置信息需要依赖于 BeanFactoryPostProcessor 的实现类 PropertyPlaceholderConfigurer，把值写入到 AbstractBeanFactory的embeddedValueResolvers集合中，这样才能在属性填充中利用 beanFactory 获取相应的属性值</em></li><li>还有一个是关于 @Autowired 对于对象的注入，其实这一个和属性注入的唯一区别是对于对象的获取 <code>beanFactory.getBean(fieldType)</code>，其他就没有什么差一点了。</li><li>当所有的属性被设置到 PropertyValues 完成以后，接下来就到了创建对象的下一步，属性填充，而此时就会把我们一一获取到的配置和对象填充到属性上，也就实现了自动注入的功能。</li></ul><h2 id="小疑问"><a href="#小疑问" class="headerlink" title="小疑问"></a>小疑问</h2><p>Q:</p><p>Spring 框架中的 @Value 能将 properties k-v 结构转换成 map形式嘛</p><p>以下内容来自 Chatgpt</p><p>A:</p><p>Spring 框架中的 @Value 注解不支持直接将 properties 文件中的 k-v 结构转换成 Map 形式。</p><p>@Value 注解主要用于从配置文件或环境变量中读取配置值，然后将这些值注入到 Spring 管理的 Bean 中的属性中。它支持基本类型、字符串、数组和集合等类型的注入，但不支持直接将 properties 文件中的 k-v 结构转换成 Map 形式。</p><p>如果需要将 properties 文件中的 k-v 结构转换成 Map 形式，可以使用 Spring 的 PropertiesFactoryBean 类来实现。PropertiesFactoryBean 是一个工厂 Bean，它可以将 properties 文件中的内容转换成一个 Properties 对象，并且将该对象注入到其他 Bean 的属性中。通过在其他 Bean 中注入该 Properties 对象，我们就可以方便地访问其中的 k-v 结构，从而实现将 properties 文件中的 k-v 结构转换成 Map 形式的功能。</p><p>下面是一个使用 PropertiesFactoryBean 将 properties 文件中的 k-v 结构转换成 Map 形式的示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy code<span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:config.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PropertiesFactoryBean <span class="title function_">configProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">PropertiesFactoryBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertiesFactoryBean</span>();</span><br><span class="line">        bean.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;config.properties&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">MyBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">        bean.setConfigProperties(configProperties().getObject());</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们通过使用 @PropertySource 注解来指定 properties 文件的路径，然后通过在 AppConfig 类中定义一个 configProperties() 方法来创建 PropertiesFactoryBean 实例。最后，我们通过在 MyBean 类中注入 configProperties 对象来使用这些配置信息。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 渐进式实现Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【从零构建Spring|第十二节】  基于JDK, Cglib实现AOP切面</title>
      <link href="/posts/11412.html"/>
      <url>/posts/11412.html</url>
      
        <content type="html"><![CDATA[<h1 id="【从零构建Spring-第十二节】-基于JDK-Cglib实现AOP切面"><a href="#【从零构建Spring-第十二节】-基于JDK-Cglib实现AOP切面" class="headerlink" title="【从零构建Spring|第十二节】  基于JDK, Cglib实现AOP切面"></a>【从零构建Spring|第十二节】  基于JDK, Cglib实现AOP切面</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章节正式从 IoC 的实现，转向关于 AOP 内容的开发。</p><p>AOP(<code>Aspect Oriented Programming</code>) 内容开发，意为：面向切面编程，<strong>通过预处理的方式以及运行期间动态代理实现程序功能的统一维护</strong>。AOP 也是 OOP 的延续，在 Spring 框架中是一个非常非常重要的内容，<strong>使用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得各模块之间的业务逻辑耦合度降低</strong>。</p><blockquote><p>剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</p></blockquote><p>举一个不太恰当的例子：可以把<strong>切面理解为用刀切韭菜，一根一根切总是有点慢，那么用手(<code>代理</code>)把韭菜捏成一把，用菜刀或者斧头这样不同的拦截操作来处理。而程序中其实也是一样，只不过韭菜变成了方法，菜刀变成了拦截方法。</strong></p><p>实现 AOP 的技术，主要分为两大类：</p><ul><li>一是采用<strong>动态代理技术</strong>（典型代表为Spring AOP），利用截取消息的方式（典型代表为AspectJ-AOP），对该消息进行装饰，以取代原有对象行为的执行；</li><li>二是采用<strong>静态织入</strong>的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。</li></ul><p>关于代理，可以给一个接口的实现，但是不是通过 <code>new</code> 一个对象实例，而是通过代理的方式去替换掉这个实现类，使用代理类来去处理所需要的逻辑，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_proxy_class</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">IUserService</span> <span class="variable">userService</span> <span class="operator">=</span> (IUserService) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;IUserService.class&#125;, (proxy, method, args) -&gt; <span class="string">&quot;你被代理了！&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> userService.queryUserInfo();</span><br><span class="line">    System.out.println(<span class="string">&quot;测试结果：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类的实现基本如下，那么有了一个基本的思路后，接下来就需要考虑下怎么<strong>给方法做代理</strong>，而<strong>不是代理类</strong>。另外怎么<strong>去代理所有符合某些规则</strong>的所有类中方法呢。如果可以代理掉所有类的方法，就可以做一个方法拦截器，<strong>给所有被代理的方法添加上一些自定义处理，比如打印日志、记录耗时、监控异常等</strong>。</p><p>规则：其实也就是 execution 表达式，他的通常格式如下：<code>&quot;execution(* cn.bugstack.springframework.test.bean.IUserService.*(..))&quot;</code>，也就是寻找包下面的所有方法</p><p>也可以是注解，通过@AroundBefore、@AroudAfter 等等寻找合适的切点。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>想要将 AOP 切面编程思想融合到 Spring，我们需要思考两个问题：</p><ul><li>方法代理：如何给符合规则的方法做代理</li><li>拦截处理：做好代理方法的案例后，怎么把类的职责抽分出来？</li></ul><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/10.%E5%9F%BA%E4%BA%8EJDK%E3%80%81Cglib%E5%AE%9E%E7%8E%B0AOP%E5%88%87%E9%9D%A2-assets/202302142140033.png" alt="image-20230213195718812"></p><p>AOP 只需根据匹配规则处理需要被处理的方法，在拦截方法之后，执行方法的扩展操作</p><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/10.%E5%9F%BA%E4%BA%8EJDK%E3%80%81Cglib%E5%AE%9E%E7%8E%B0AOP%E5%88%87%E9%9D%A2-assets/202303022053751.png" alt="手写Spring-基于JDK和Cglib动态代理"></p><ul><li>整个类关系图就是 AOP 实现核心逻辑的地方</li><li>AspectJExpressionPointcut 的核心功能主要依赖于 aspectj 组件并处理 Pointcut、ClassFilter,、MethodMatcher 接口实现，专门用于处理类和方法的匹配过滤操作。</li><li>AopProxy 是代理的抽象对象，它的实现主要是基于 JDK 的代理和 Cglib 代理。在前面章节关于对象的实例化 CglibSubclassingInstantiationStrategy，我们也使用过 Cglib 提供的功能。</li></ul><h3 id="动态代理流程"><a href="#动态代理流程" class="headerlink" title="动态代理流程"></a>动态代理流程</h3><p>一个动态代理的流程代码如下：</p><ul><li>首先整个案例的目标是给一个 UserService 当成目标对象，对类中的所有方法进行拦截添加监控信息打印处理。</li><li>从案例中你可以看到有代理的实现 Proxy.newProxyInstance，有方法的匹配 MethodMatcher，有反射的调用 invoke(Object proxy, Method method, Object[] args)，也用用户自己拦截方法后的操作。这样一看其实和我们使用的 AOP 就非常类似了，只不过你在使用 AOP 的时候是框架已经提供更好的功能，这里是把所有的核心过程给你展示出来了。</li><li>从测试结果可以看到我们已经对 UserService#queryUserInfo 方法进行了拦截监控操作，其实后面我们实现的 AOP 就是现在体现出的结果，只不过我们需要把这部分测试的案例解耦为更具有扩展性的各个模块实现。</li></ul><p>按照这样的逻辑，我们需要将核心功能按照模块功能解耦</p><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/10.%E5%9F%BA%E4%BA%8EJDK%E3%80%81Cglib%E5%AE%9E%E7%8E%B0AOP%E5%88%87%E9%9D%A2-assets/202302132029473.png" alt="image-20230213202919056"></p><ul><li>代理对象：可以用 JDK 方式实现，也可以用 Cglib 实现</li><li>方法匹配器：方法匹配器操作其实已经是一个单独的实现类了，不过我们还需要把传入的目标对象、方法匹配、拦截方法，都进行统一的包装，方便外部调用时进行一个入参透传。</li><li>方法拦截器：按照代码给出的逻辑，只要在参数返回后执行相关扩展逻辑操作即可</li><li>反射调用：它目前已经是实现 <code>MethodInvocation</code> 接口的一个包装后的类，参数信息包括：调用的对象、调用的方法、调用的入参</li></ul><h2 id="工程"><a href="#工程" class="headerlink" title="工程"></a>工程</h2><h3 id="切点-Pointcut"><a href="#切点-Pointcut" class="headerlink" title="切点 Pointcut"></a>切点 Pointcut</h3><p>定义切点接口 Pointcut，即<code>org.springframework.aop.Pointcut</code>，Spring AOP 体系对切点的顶层抽象，贯穿整个 AOP 框架。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 切入点接口</span></span><br><span class="line"><span class="comment"> * 定义用于获取 ClassFilter、MethodMatcher 的两个类，这两个接口获取都是切点表达式提供的内容。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Pointcut</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此切入点的类筛选器。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ClassFilter <span class="title function_">getClassFilter</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此切入点的方法匹配器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MethodMatcher <span class="title function_">getMethodMatcher</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在该接口中<strong>主要负责对系统的相应的 Joinpoint 进行捕捉，对系统中所有的对象进行 Joinpoint 所定义的规则进行匹配</strong>。ClassFilter 与 MethodMatcher 分别用于在不同的级别上限定 Joinpoint 的匹配范围，满足不同粒度的匹配</li><li><strong>ClassFilter 限定在类级别上，MethodMatcher 限定在方法级别上</strong></li></ul><p>提示</p><p>Spring Aop 主要支持在方法级别上的匹配，所以对类级别的匹配支持相对简单一些</p><h3 id="方法匹配器-MethodMatcher"><a href="#方法匹配器-MethodMatcher" class="headerlink" title="方法匹配器 MethodMatcher"></a>方法匹配器 MethodMatcher</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法匹配器</span></span><br><span class="line"><span class="comment"> * 找到表达式范围内匹配下的目标类和方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodMatcher</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个称为静态匹配：在匹配条件不是太严格时使用，可以满足大部分场景的使用</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass)</span>;</span><br><span class="line"><span class="comment">// 这个称为动态匹配（运行时匹配）: 它是严格的匹配。在运行时动态的对参数的类型进行匹配</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass, Object... args)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个方法的分界线就是boolean isRuntime()方法，步骤如下</span></span><br><span class="line"><span class="comment">// 1、先调用静态匹配，若返回true。此时就会继续去检查isRuntime()的返回值</span></span><br><span class="line"><span class="comment">// 2、若isRuntime()还返回true，那就继续调用动态匹配</span></span><br><span class="line"><span class="comment">// (若静态匹配都匹配上，动态匹配那铁定更匹配不上得~~~~)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否需要执行动态匹配</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isRuntime</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当需要统计用户登录次数时，登录传入的参数就可以忽略，<strong>静态匹配</strong>足以</li><li>当需要在登录时对用户账号执行特殊操作（如赋权），就需要对参数进行检验，需要<strong>动态匹配</strong></li><li>当然在实现中没有那么复杂，我们只需要了解这些机制即可，目前只实现了静态匹配。</li></ul><h3 id="切入点表达式-AspectJExpressionPointcut"><a href="#切入点表达式-AspectJExpressionPointcut" class="headerlink" title="切入点表达式 AspectJExpressionPointcut"></a>切入点表达式 AspectJExpressionPointcut</h3><p>它与 <code>Expression</code> 表达式有关，这个切点表达式的解析，需要依赖于 AspectJ 的 jar 包进行解析，Spring 在 使用 @Aspect 注解时会大量使用到它</p><p>在 Spring 框架中，实现切点匹配的还有：基于正则的 <code>JdkRegexpMethodPointcut</code> 。用<code>AspectJExpressionPointcut</code>实现的切点比<code>JdkRegexpMethodPointcut</code>实现切点的好处就是，在设置切点的时候可以用切点语言来<strong>更加精确的</strong>表示拦截哪个方法。（可以精确到返回参数，参数类型，方法名,当然，也可以模糊匹配）</p><p>源码分析：</p><ul><li>Spring 支持的 AspectJ 的切点语言表达式一共有 10 中（加上后面的自己的 Bean 方式一共11种）, 详细介绍文章可看这篇：<a href="https://blog.csdn.net/f641385712/article/details/83543270">Spring AOP中@Pointcut切入点表达式最全面使用介绍 (opens new window)</a>，我们本章所实现的 <strong>execution</strong>，一般<strong>能在运行指定方法时拦截指定方法，用的最多</strong></li><li>在实现中，我们能发现 <code>AspectJExpressionPointCut</code> 既是<strong>方法匹配器，又是类筛选器，也是切点</strong>，同时这个类主要是的 Aspectj 包提供的表达式检验方法使用</li><li>实现匹配 matches 方法：类筛选和方法匹配</li></ul><h3 id="组装代理信息-AdvisedSupport"><a href="#组装代理信息-AdvisedSupport" class="headerlink" title="组装代理信息 AdvisedSupport"></a>组装代理信息 AdvisedSupport</h3><p>数据结构为 AdvisedSupport { targetSource 代理目标对象，MethodInterceptor 方法拦截器，MethodMatcher 方法匹配器}</p><h4 id="TargetSource-代理目标对象"><a href="#TargetSource-代理目标对象" class="headerlink" title="TargetSource 代理目标对象"></a>TargetSource 代理目标对象</h4><p>TargetSource 用于获取当前 MethodInvocation （方法调用）所需的 target （目标对象），target 通过反射方式被调用 <code>method.invoke(target, args)</code> ，proxy 代理的不是 target 而是 targetSource。</p><p>为什么 Spring Aop 代理不直接代理 target，而是通过代理 TargetSource 间接代理 target？</p><p>在通常情况下，一个 proxy 只能代理一个 target，每次方法调用的目标也是唯一固定的 target。</p><p>但如果让 proxy 代理 TargetSource，可以使得每次方法调用的 target 实例不同，这种机制使得方法的调用变得灵活，可以扩展很多高级功能，例如目标对象池（target pool），运行时目标对象热替换（hot swap）（当前并未实现这些扩展，非核心机制）</p><p>TargetSource 组件本身与 Spring IoC 无关，target 的生命周期不一定受 Spring 容器管理，以往的 XML 中 AOP 的配置，只是对受容器管理的 Bean 而言的，当然也<strong>可以手动创建一个 Target，同时使用 Spring AOP 而不使用 Spring IoC 容器</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TargetSource</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TargetSource</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此 &#123;<span class="doctag">@link</span> TargetSource&#125; 返回的目标类型。</span></span><br><span class="line"><span class="comment">     * 可以返回 null，尽管 TargetSource 的某些用法可能只适用于预定的目标类。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt;[] getTargetClass() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.target.getClass().getInterfaces();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回目标实例。在 AOP 框架调用 AOP 方法调用的“目标”之前立即调用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getTarget</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MethodInterceptor-方法拦截器"><a href="#MethodInterceptor-方法拦截器" class="headerlink" title="MethodInterceptor 方法拦截器"></a>MethodInterceptor 方法拦截器</h4><p>前言</p><p>Interceptor 拦截器中定义了通知的增强方式，也就是对 JoinPoint (连接点) 的拦截。<strong>一个通用的拦截器可以拦截所有的运行时事件</strong>，运行时连接点可以是一次方法调用、字段访问、异常产生。Interceptor 接口强调概念而非功能。</p><p>由 Interceptor 扩展出的<code>ConstructorInterceptor</code> 和 <code>MethodInterceptor</code> 两个子接口，才具体定义了拦截方式。他们一个用于拦截构造方法，一个拦截普通方法。但是 Spring AOP 对构造方法的拦截，原因是 Spring 框架本身通过 BeanPostProcessor 的定义已经将 Bean 生命周期的扩展实现的很充分了，完全可以在初始化前后拦截实现方法增强</p><p>MethodInterceptor 只定义了增强方式，实现交付给用户自定义具体的增强内容。当然 Spring 也提供了三种预定义的增强内容：前置通知 BeforeAdvice，后置通知 AfterAdvice 以及动态引介通知 DynamicIntroductionAdvice。前两者定义了增强内容的执行时机（方法调用前后执行），后者则是可以编辑目标类要实现的接口列表</p><p>最后，Spring 预定义的通知还是要通过对应的适配器，适配成 MethodInterceptor 接口类型的对象（如：MethodBeforeAdviceInterceptor 负责适配 MethodBeforeAdvice）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodInterceptor</span> <span class="keyword">extends</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    Object <span class="title function_">invoke</span><span class="params">(MethodInvocation var1)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义拦截方法, 该拦截器最终会被 JDK、Cglib 方式实现的 AopProxy 调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 户自定义的拦截方法需要实现 MethodInterceptor 接口的 invoke 方法，</span></span><br><span class="line"><span class="comment">     * 使用方式与 Spring AOP 非常相似，也是包装 invocation.proceed() 放行，并在 finally 中添加监控信息。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;监控 - Begin By AOP&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;方法名称：&quot;</span> + invocation.getMethod());</span><br><span class="line">            System.out.println(<span class="string">&quot;方法耗时：&quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;监控 - End\r&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="约定动态代理接口-AopProxy"><a href="#约定动态代理接口-AopProxy" class="headerlink" title="约定动态代理接口 AopProxy"></a>约定动态代理接口 AopProxy</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AopProxy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个标准接口，用于获取代理类。</span></span><br><span class="line"><span class="comment">     * 因为具体实现代理的方式可以有 JDK 方式，也可以是 Cglib 方式，所以定义接口会更加方便管理实现类。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object <span class="title function_">getProxy</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义一个标准接口，用于获取代理类。当具体实现由多种方式时，使用接口统一规范，能更方便管理实现类</li></ul><h4 id="JDK-实现动态代理"><a href="#JDK-实现动态代理" class="headerlink" title="JDK 实现动态代理"></a>JDK 实现动态代理</h4><p><em><strong>JDK动态代理是面向接口的代理模式，如果被代理目标没有接口那么Spring也无能为力</strong></em></p><p><em><strong>Spring通过java的反射机制生产被代理接口的新的匿名实现类，重写了其中AOP的增强方法。</strong></em></p><ul><li>需要实现接口 AopProxy、InvocationHandler，这样就可以把代理对象 getProxy 和反射调用方法 invoke 分开处理了</li><li>getProxy 方法是代理一个对象的操作，需要提供入参 ClassLoader、AdvisedSupport、和当前类 this，因为当前类提供 invoke</li></ul><h4 id="Cglib-实现动态代理"><a href="#Cglib-实现动态代理" class="headerlink" title="Cglib 实现动态代理"></a>Cglib 实现动态代理</h4><p><em><strong>CGLib是一个强大、高性能的Code生产类库，可以实现运行期动态扩展java类，Spring在运行期间通过 CGlib</strong></em></p><p><em><strong>继承要被动态代理的类，重写父类的方法，实现AOP面向切面编程</strong></em></p><ul><li>基于 Cglib 使用 Enhancer 代理的类可以在运行期间为接口使用底层 ASM 字节码增强技术处理对象的代理对象生成，因此被代理类不需要实现任何接口。</li></ul><h4 id="两者对比："><a href="#两者对比：" class="headerlink" title="两者对比："></a>两者对比：</h4><p>JDK 动态代理是面向接口，在创建代理实现类时比 CGLib 要快，创建代理速度快。</p><p>CGLib 动态代理是通过字节码底层继承要代理类来实现（如果被代理类被 final 关键字所修饰，那么抱歉会失败），在<strong>创建代理这一块没有 JDK 动态代理快</strong>，但是<strong>运行速度比 JDK 动态代理要快</strong>。</p><h4 id="使用注意："><a href="#使用注意：" class="headerlink" title="使用注意："></a>使用注意：</h4><p>如果要被代理的对象是个实现类，那么Spring会使用JDK动态代理来完成操作（Spirng默认采用JDK动态代理实现机制）</p><p>如果要被代理的对象不是个实现类那么，Spring会强制使用CGLib来实现动态代理。</p><h4 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h4><p>通过配置Spring的中<a href="aop:config">aop:config</a>标签来显示的指定使用动态代理机制 proxy-target-class&#x3D;true表示使用CGLib代理，如果为false就是默认使用JDK动态代理</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 切面详细配置.. --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>AOP 是如何完成动态代理的？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_dynamic</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 目标对象</span></span><br><span class="line">    <span class="type">IUserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    组装代理信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">AdvisedSupport</span> <span class="variable">advisedSupport</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AdvisedSupport</span>();</span><br><span class="line">    <span class="comment">// 填充目标对象。</span></span><br><span class="line">    advisedSupport.setTargetSource(<span class="keyword">new</span> <span class="title class_">TargetSource</span>(userService));</span><br><span class="line">    <span class="comment">// 填充用户自定义拦截器</span></span><br><span class="line">    advisedSupport.setMethodInterceptor(<span class="keyword">new</span> <span class="title class_">UserServiceInterceptor</span>());</span><br><span class="line">    advisedSupport.setMethodMatcher(<span class="keyword">new</span> <span class="title class_">AspectJExpressionPointCut</span>(<span class="string">&quot;execution(* com.bantanger.springframework.test.bean.IUserService.*(..))&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理对象(JdkDynamicAopProxy)</span></span><br><span class="line">    <span class="type">IUserService</span> <span class="variable">proxy_jdk</span> <span class="operator">=</span> (IUserService) <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(advisedSupport).getProxy();</span><br><span class="line">    <span class="comment">// 测试调用</span></span><br><span class="line">    System.out.println(<span class="string">&quot;测试结果:&quot;</span> + proxy_jdk.queryUserInfo());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理对象(Cglib2AopProxy)</span></span><br><span class="line">    <span class="type">IUserService</span> <span class="variable">proxy_cglib</span> <span class="operator">=</span> (IUserService) <span class="keyword">new</span> <span class="title class_">Cglib2AopProxy</span>(advisedSupport).getProxy();</span><br><span class="line">    <span class="comment">// 测试调用</span></span><br><span class="line">    System.out.println(<span class="string">&quot;测试结果:&quot;</span> + proxy_cglib.register(<span class="string">&quot;半糖&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>先创建出目标对象，将其填充到 advisedSupport 包装类中的 TargetSource。通过这种方式，反馈出 Spring AOP 中的核心：不通过 new 的方式创建一个对象实例，其实本质而言，是 Spring 底层 new 出所需要的 bean</li><li>往 advisedSupport 填充用户自定义拦截器以及方法匹配器所需匹配规则</li><li>之后调用动态代理的具体实例 JDK、Cglib，通过 getProxy 获取代理对象，本质是基于 Proxy.newProxyInstance。</li></ul><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/10.%E5%9F%BA%E4%BA%8EJDK%E3%80%81Cglib%E5%AE%9E%E7%8E%B0AOP%E5%88%87%E9%9D%A2-assets/202303021937806.png" alt="image-20230302193744276"></p><h2 id="全流程分析"><a href="#全流程分析" class="headerlink" title="全流程分析"></a>全流程分析</h2><p>创建需要代理的对象（目前是使用 new 的方式，之后会加载在 BeanFactory 里）</p><p>组装代理信息</p><ul><li>目标代理对象</li><li>用户自定义拦截器</li><li>方法匹配器（传入 AspectJExpressionPointCut 和表达式）</li></ul><p>通过 Jdk、Cglib 两种实例化方式创建代理对象。</p><p>JDK 方式：</p><ol><li>通过传入的组装代理信息 AdvisedSupport 创建 JDK 代理创建工厂</li><li>调用 getProxy ，内部使用的是 <code>Proxy.newProxyInstance</code> 方式指定 ClassLoader 对象和一组 interface 来创建动态代理对象，返回代理对象</li><li>通过代理对象调用方法，在调用前被 <code>invoke</code> 拦截（其实是通过反射机制获取动态代理类的构造参数）</li><li>方法匹配器判断当前方法是否需要代理，如果需要进入下一步</li><li>invoke 方法内部获取组装代理信息 AdvisedSupport 中的用户拦截器</li><li>传入数据结构 ReflectiveMethodInvocation ，提供入参对象 { 目标对象、方法、入参 }，调用用户拦截器增强方法</li></ol><p>Cglib 方式：</p><ol><li>通过传入的组装代理信息 AdvisedSupport 创建 Cglib 代理创建工厂</li><li>调用 getProxy ，内部使用的是 <code>enhancer.create</code> 方式创建代理对象，返回代理对象</li><li>通过代理对象调用方法，在调用前被 <code>DynamicAdvisedInterceptor#intercept</code> 拦截</li><li>方法匹配器判断当前方法是否需要代理，如果需要进入下一步</li><li>invoke 方法内部获取组装代理信息 AdvisedSupport 中的用户拦截器</li><li>传入数据结构 ReflectiveMethodInvocation ，提供入参对象 { 目标对象、方法、入参 }，调用用户拦截器增强方法</li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 渐进式实现Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【从零构建Spring|第十一节】  观察者模式实现容器事件及监听器</title>
      <link href="/posts/11411.html"/>
      <url>/posts/11411.html</url>
      
        <content type="html"><![CDATA[<h2 id="【从零构建Spring-第十一节】-观察者模式实现容器事件及监听器"><a href="#【从零构建Spring-第十一节】-观察者模式实现容器事件及监听器" class="headerlink" title="【从零构建Spring|第十一节】  观察者模式实现容器事件及监听器"></a>【从零构建Spring|第十一节】  观察者模式实现容器事件及监听器</h2><h2 id="Spring-为什么需要事件，可以用来干什么？"><a href="#Spring-为什么需要事件，可以用来干什么？" class="headerlink" title="Spring 为什么需要事件，可以用来干什么？"></a>Spring 为什么需要事件，可以用来干什么？</h2><p>用来解耦代码。高内聚，低耦合的设计思想</p><p>可以用于处理日志监控和各种事件发布订阅的客制化定义</p><p><img src="/%E5%97%AF.assets/202302111415017.png" alt="image-20230211141540391"></p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>在开发中，有很多利用到解耦的场景，例如<strong>在注册事件完成后异步发送事件推送消息，用户下单后异步发送MQ消息给与用户后续业务的跟进情况，用户付完款后就可以发送货物派送进度</strong>，都是依靠事件订阅和发布以及MQ消息这样的组件，来处理系统之间的调用解耦，最终也通过解耦的方式来提升整体系统架构的稳定性和负载能力</p><p>其实解耦思想就是观察者模式的一种体现。当<strong>对象间存在一对多关系</strong>时，则适合使用观察者模式，它定义了对象之间的一种一对多依赖关系。<strong>当一个对象的状态改变时，所有依赖他，与他有关的对象都会得到通知并且自动更新</strong>。</p><h3 id="观察者模式角色"><a href="#观察者模式角色" class="headerlink" title="观察者模式角色"></a>观察者模式角色</h3><p>Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</p><p>ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</p><p>Observer：抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</p><p>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</p><p><img src="/%E5%97%AF.assets/202302111339020.png" alt="image-20230211133858911"></p><p>这一节中和前几节结合起来，才更能明白 Spring 框架，在 Spring 框架中，我感觉是万物即 Bean 对象</p><p>就像本节的事件监听器，就是通过 xml 文件配置，被 ClassPathXmlApplicationContext 面向用户的应用上下文读取出来并通过 bean 对象加载。在上一节中 FactoryBean 实际上也是通过 xml 配置，读取出来实例化成 bean。只不过这个 bean 我们创建的更加简单，不需要配置引用类型。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/09.%E5%88%A9%E7%94%A8%E8%A7%82%E5%AF%9F%E8%80%85%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8-assets/202302282250411.png" alt="手写Spring-事件发布和监听机制"></p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>在观察者模式中，我们提到一个事件想要运作，需要 <strong>事件、事件广播器(事件监听器)、事件发布器</strong> 三大部分，事件广播器实际上是一个管理 事件监听器的容器，负责处理其添加、触发。在 AbstractApplicationContext 中，<code>initApplicationEventMulticaster</code>和<code>registerListeners</code>去实现事件监听器的注册添加，因为 Spring IoC 容器中万物皆 Bean，因此监听器是由单例模式注册的，之后将所有的监听器都交由广播器来统一管理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initApplicationEventMulticaster</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">        applicationEventMulticaster = <span class="keyword">new</span> <span class="title class_">SimpleApplicationEventMulticaster</span>(beanFactory);</span><br><span class="line">        <span class="comment">// 将监听器注册为单例 bean 对象,在 Spring 里，所有对象都使用 bean 管理</span></span><br><span class="line">        beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BASE_NAME, applicationEventMulticaster);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册事件监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerListeners</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 通过 getBeansOfType 方法获取道所有在 spring.xml 中加载到的事件配置 Bean 对象</span></span><br><span class="line">        Collection&lt;ApplicationListener&gt; applicationListeners = getBeansOfType(ApplicationListener.class).values();</span><br><span class="line">        <span class="keyword">for</span> (ApplicationListener listener : applicationListeners) &#123;</span><br><span class="line">            applicationEventMulticaster.addApplicationLister(listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>事件机制的行为如下：</p><p><img src="/%E5%97%AF.assets/202302131734368.png" alt="image-20230213173412299"></p><p>同时还有专门处理容器关闭和容器刷新的监听器 <code>ContextCloseEventListener</code>、<code>ContextRefreshEventListener</code></p><p>并且由于是事件机制，它也是异步的，当等到一个事件的发布，事件监听器才会被触发去执行相应逻辑，即调用<code>onApplicationEvent</code>方法完成相关逻辑</p><p><img src="/%E5%97%AF.assets/202302131745488.png" alt="image-20230213174555458"></p><p>具体情况如图，事件广播器接受到事件发布之后，调用内部广播方法，遍历通知所有被管理的监听器，监听器调用各自的执行方法。完成事件订阅与接收逻辑</p><h2 id="工程"><a href="#工程" class="headerlink" title="工程"></a>工程</h2><h3 id="约定接口（整个事件机制的基石）"><a href="#约定接口（整个事件机制的基石）" class="headerlink" title="约定接口（整个事件机制的基石）"></a>约定接口（整个事件机制的基石）</h3><h4 id="监听器接口"><a href="#监听器接口" class="headerlink" title="监听器接口"></a>监听器接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationListener</span>&lt;E <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听器在接受到发布消息后各自需要完成的逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event the event to respond to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(E event)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发布器接口"><a href="#发布器接口" class="headerlink" title="发布器接口"></a>发布器接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationEventPublisher</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知在此应用程序中注册的所有侦听器应用程序事件。</span></span><br><span class="line"><span class="comment">     * 事件可以是框架事件（如 RequestHandledEvent）或特定于应用程序的事件。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event 发布事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(ApplicationEvent event)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>只处理发布事件的逻辑</li></ul><h4 id="事件广播器"><a href="#事件广播器" class="headerlink" title="事件广播器"></a>事件广播器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事件广播器(管理所有事件监听器)</span></span><br><span class="line"><span class="comment"> * 消息 --&gt; 事件发布者推送 --&gt; 事件广播器接收 --&gt; 通知所有事件监听器接收</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BanTanger 半糖</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2023/2/11 15:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationEventMulticaster</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加事件监听器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addApplicationLister</span><span class="params">(ApplicationListener&lt;?&gt; listener)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除事件监听器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeApplicationListener</span><span class="params">(ApplicationListener&lt;?&gt; listener)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 广播事件</span></span><br><span class="line"><span class="comment">     * 最终推送时间消息也会经过这个接口方法来处理谁该接收事件。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(ApplicationEvent event)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义事件的实现"><a href="#自定义事件的实现" class="headerlink" title="自定义事件的实现"></a>自定义事件的实现</h3><h3 id="事件监听器（刷新容器、关闭容器、自定义事件监听）的实现逻辑"><a href="#事件监听器（刷新容器、关闭容器、自定义事件监听）的实现逻辑" class="headerlink" title="事件监听器（刷新容器、关闭容器、自定义事件监听）的实现逻辑"></a>事件监听器（刷新容器、关闭容器、自定义事件监听）的实现逻辑</h3><p>AbstractApplicationContext 中集成了发布事件以及添加事件监听器的逻辑，并且提供了接口，这就是我们事件的入口</p><p>如何获取这个入口</p><ol><li>像测试用例一样，直接用xml去获取ClassPathXmlApplicationContext</li><li>通过ApplicationContextAware</li></ol><p>ApplicationContextAware</p><p>在 AbstractApplicationContext#refresh，会为实现了 ApplicationContextAware 的类设置好对应的 ApplicationContext，那就可以通过这样获取到入口。</p><p>而这个操作的实现，是<strong>注入了一个实现了BeanPostProcessor的专门用于添加ApplicationContext的实例ApplicationContextAwareProcessor</strong></p><p>那么由此又可以引申出，对象创建，BeanFactoryPostProcessor，ApplicationContext，Bean的生命周期，毕竟这 些都是在Bean的生命周期里实现的。</p><p>通过这章又可以回想起Cglib方式创建的对象，那是源于当时最初没有对有参构造进行特殊设置，从而有cglib和普通的反射方法创建的不同策略。</p><p>spring的IOC所进行的就是对Bean进行管理，<strong>Bean就是一个个的实例化对象（Spring IoC 中万物即 Bean 对象</strong>。每个Bean从创建到销毁，中间他是有许许多多的过程，它就使用了 ApplicationContext 进而扩展，对每个环节进行控制和扩展方法。比如对象创建前后的操作，对象感知容器，复杂对象的创建可以用另一种 FactoryBean 的方法，对事件的控制等等</p><p>参考：</p><ul><li><a href="https://blog.csdn.net/qq_37758497/article/details/118863308">Spring Event 事件发布&#x2F;监听机制 详解并使用(opens new window)</a></li><li><a href="https://blog.csdn.net/qq_19239339/article/details/82454090">Spring事件监听模式应用场景和思路(opens new window)</a></li><li><a href="https://www.cnblogs.com/m78-seven/p/15417797.html">Spring事件使用场景(opens new window)</a></li><li><a href="https://zhuanlan.zhihu.com/p/145927110">深入浅出Spring&#x2F;SpringBoot 事件监听机制</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 渐进式实现Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【从零构建Spring|第十节】 Aware感知容器</title>
      <link href="/posts/11410.html"/>
      <url>/posts/11410.html</url>
      
        <content type="html"><![CDATA[<h1 id="【从零构建Spring-第十节】-Aware感知容器"><a href="#【从零构建Spring-第十节】-Aware感知容器" class="headerlink" title="【从零构建Spring|第十节】 Aware感知容器"></a>【从零构建Spring|第十节】 Aware感知容器</h1><h2 id="Spring-为什么需要事件，可以用来干什么？"><a href="#Spring-为什么需要事件，可以用来干什么？" class="headerlink" title="Spring 为什么需要事件，可以用来干什么？"></a>Spring 为什么需要事件，可以用来干什么？</h2><p>用来解耦代码。高内聚，低耦合的设计思想</p><p>可以用于处理日志监控和各种事件发布订阅的客制化定义</p><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/09.%E5%88%A9%E7%94%A8%E8%A7%82%E5%AF%9F%E8%80%85%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8-assets/202302111415017.png" alt="image-20230211141540391"></p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>在开发中，有很多利用到解耦的场景，例如<strong>在注册事件完成后异步发送事件推送消息，用户下单后异步发送MQ消息给与用户后续业务的跟进情况，用户付完款后就可以发送货物派送进度</strong>，都是依靠事件订阅和发布以及MQ消息这样的组件，来处理系统之间的调用解耦，最终也通过解耦的方式来提升整体系统架构的稳定性和负载能力</p><p>其实解耦思想就是观察者模式的一种体现。当<strong>对象间存在一对多关系</strong>时，则适合使用观察者模式，它定义了对象之间的一种一对多依赖关系。<strong>当一个对象的状态改变时，所有依赖他，与他有关的对象都会得到通知并且自动更新</strong>。</p><h3 id="观察者模式角色"><a href="#观察者模式角色" class="headerlink" title="观察者模式角色"></a>观察者模式角色</h3><p>Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</p><p>ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</p><p>Observer：抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</p><p>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</p><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/09.%E5%88%A9%E7%94%A8%E8%A7%82%E5%AF%9F%E8%80%85%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8-assets/202302111339020.png" alt="image-20230211133858911"></p><p>这一节中和前几节结合起来，才更能明白 Spring 框架，在 Spring 框架中，我感觉是万物即 Bean 对象</p><p>就像本节的事件监听器，就是通过 xml 文件配置，被 ClassPathXmlApplicationContext 面向用户的应用上下文读取出来并通过 bean 对象加载。在上一节中 FactoryBean 实际上也是通过 xml 配置，读取出来实例化成 bean。只不过这个 bean 我们创建的更加简单，不需要配置引用类型。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/09.%E5%88%A9%E7%94%A8%E8%A7%82%E5%AF%9F%E8%80%85%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8-assets/202302282250411.png" alt="手写Spring-事件发布和监听机制"></p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>在观察者模式中，我们提到一个事件想要运作，需要 <strong>事件、事件广播器(事件监听器)、事件发布器</strong> 三大部分，事件广播器实际上是一个管理 事件监听器的容器，负责处理其添加、触发。在 AbstractApplicationContext 中，<code>initApplicationEventMulticaster</code>和<code>registerListeners</code>去实现事件监听器的注册添加，因为 Spring IoC 容器中万物皆 Bean，因此监听器是由单例模式注册的，之后将所有的监听器都交由广播器来统一管理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initApplicationEventMulticaster</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">        applicationEventMulticaster = <span class="keyword">new</span> <span class="title class_">SimpleApplicationEventMulticaster</span>(beanFactory);</span><br><span class="line">        <span class="comment">// 将监听器注册为单例 bean 对象,在 Spring 里，所有对象都使用 bean 管理</span></span><br><span class="line">        beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BASE_NAME, applicationEventMulticaster);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册事件监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerListeners</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 通过 getBeansOfType 方法获取道所有在 spring.xml 中加载到的事件配置 Bean 对象</span></span><br><span class="line">        Collection&lt;ApplicationListener&gt; applicationListeners = getBeansOfType(ApplicationListener.class).values();</span><br><span class="line">        <span class="keyword">for</span> (ApplicationListener listener : applicationListeners) &#123;</span><br><span class="line">            applicationEventMulticaster.addApplicationLister(listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>事件机制的行为如下：</p><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/09.%E5%88%A9%E7%94%A8%E8%A7%82%E5%AF%9F%E8%80%85%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8-assets/202302131734368.png" alt="image-20230213173412299"></p><p>同时还有专门处理容器关闭和容器刷新的监听器 <code>ContextCloseEventListener</code>、<code>ContextRefreshEventListener</code></p><p>并且由于是事件机制，它也是异步的，当等到一个事件的发布，事件监听器才会被触发去执行相应逻辑，即调用<code>onApplicationEvent</code>方法完成相关逻辑</p><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/09.%E5%88%A9%E7%94%A8%E8%A7%82%E5%AF%9F%E8%80%85%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8-assets/202302131745488.png" alt="image-20230213174555458"></p><p>具体情况如图，事件广播器接受到事件发布之后，调用内部广播方法，遍历通知所有被管理的监听器，监听器调用各自的执行方法。完成事件订阅与接收逻辑</p><h2 id="工程"><a href="#工程" class="headerlink" title="工程"></a>工程</h2><h3 id="约定接口（整个事件机制的基石）"><a href="#约定接口（整个事件机制的基石）" class="headerlink" title="约定接口（整个事件机制的基石）"></a>约定接口（整个事件机制的基石）</h3><h4 id="监听器接口"><a href="#监听器接口" class="headerlink" title="监听器接口"></a>监听器接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationListener</span>&lt;E <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听器在接受到发布消息后各自需要完成的逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event the event to respond to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(E event)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发布器接口"><a href="#发布器接口" class="headerlink" title="发布器接口"></a>发布器接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationEventPublisher</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知在此应用程序中注册的所有侦听器应用程序事件。</span></span><br><span class="line"><span class="comment">     * 事件可以是框架事件（如 RequestHandledEvent）或特定于应用程序的事件。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event 发布事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(ApplicationEvent event)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>只处理发布事件的逻辑</li></ul><h4 id="事件广播器"><a href="#事件广播器" class="headerlink" title="事件广播器"></a>事件广播器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事件广播器(管理所有事件监听器)</span></span><br><span class="line"><span class="comment"> * 消息 --&gt; 事件发布者推送 --&gt; 事件广播器接收 --&gt; 通知所有事件监听器接收</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BanTanger 半糖</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2023/2/11 15:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationEventMulticaster</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加事件监听器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addApplicationLister</span><span class="params">(ApplicationListener&lt;?&gt; listener)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除事件监听器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeApplicationListener</span><span class="params">(ApplicationListener&lt;?&gt; listener)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 广播事件</span></span><br><span class="line"><span class="comment">     * 最终推送时间消息也会经过这个接口方法来处理谁该接收事件。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(ApplicationEvent event)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义事件的实现"><a href="#自定义事件的实现" class="headerlink" title="自定义事件的实现"></a>自定义事件的实现</h3><ul><li>数据结构为 Event{ id, message }</li></ul><h3 id="事件监听器（刷新容器、关闭容器、自定义事件监听）的实现逻辑"><a href="#事件监听器（刷新容器、关闭容器、自定义事件监听）的实现逻辑" class="headerlink" title="事件监听器（刷新容器、关闭容器、自定义事件监听）的实现逻辑"></a>事件监听器（刷新容器、关闭容器、自定义事件监听）的实现逻辑</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>AbstractApplicationContext 中集成了发布事件以及添加事件监听器的逻辑，并且提供了接口，这就是我们事件的入口</p><p>如何获取这个入口</p><ol><li>像测试用例一样，直接用xml去获取ClassPathXmlApplicationContext</li><li>通过ApplicationContextAware</li></ol><p>ApplicationContextAware</p><p>在 AbstractApplicationContext#refresh，会为实现了 ApplicationContextAware 的类设置好对应的 ApplicationContext，那就可以通过这样获取到入口。</p><p>而这个操作的实现，是<strong>注入了一个实现了BeanPostProcessor的专门用于添加ApplicationContext的实例ApplicationContextAwareProcessor</strong></p><p>那么由此又可以引申出，对象创建，BeanFactoryPostProcessor，ApplicationContext，Bean的生命周期，毕竟这 些都是在Bean的生命周期里实现的。</p><p>通过这章又可以回想起Cglib方式创建的对象，那是源于当时最初没有对有参构造进行特殊设置，从而有cglib和普通的反射方法创建的不同策略。</p><p>spring的IOC所进行的就是对Bean进行管理，<strong>Bean就是一个个的实例化对象（Spring IoC 中万物即 Bean 对象</strong>。每个Bean从创建到销毁，中间他是有许许多多的过程，它就使用了 ApplicationContext 进而扩展，对每个环节进行控制和扩展方法。比如对象创建前后的操作，对象感知容器，复杂对象的创建可以用另一种 FactoryBean 的方法，对事件的控制等等</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渐进式实现Spring </tag>
            
            <tag> SPring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【从零构建Spring|第九节】 对象作用域和FactoryBean</title>
      <link href="/posts/11409.html"/>
      <url>/posts/11409.html</url>
      
        <content type="html"><![CDATA[<h2 id="【从零构建Spring-第九节】-对象作用域和FactoryBean"><a href="#【从零构建Spring-第九节】-对象作用域和FactoryBean" class="headerlink" title="【从零构建Spring|第九节】 对象作用域和FactoryBean"></a>【从零构建Spring|第九节】 对象作用域和FactoryBean</h2><h2 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h2><blockquote><p>FactoryBean是一个工厂Bean，它使用到工厂方法模式，可以代理生成一个实例</p></blockquote><h3 id="为什么使用FactoryBean"><a href="#为什么使用FactoryBean" class="headerlink" title="为什么使用FactoryBean"></a>为什么使用FactoryBean</h3><p>在之前的设计中， Spring IoC 容器通过反射或字节码增强的方式实例化 Bean，但有些情况下，实例化较复杂，要往 xml 里 <code>&lt;bean&gt;</code> 填写大量的配置信息，且过程不能为用户支配。就像我们之前的实现，要注册 UserService，还要在 xml 配置内部的 UserDao，万一以后又多了一个 EventDao 了呢？当需要往 xml 配置里塞的东西越来越多，本来简单的操作，也会变成庞大，难以理解的屎山。</p><p>FactoryBean 很好的解决了这一点，它是一个对用户暴露的客制化 Bean 实例化的接口，用户可以通过实现该接口定制实例化Bean的逻辑。可以隐藏实例化一些复杂Bean的细节。给上层应用带来便利。说人话就是，将一个待实例化的 bean 内部所有自定义类型都丢到 FactoryBean 代理。</p><blockquote><p><strong>将对象交由Spring管理的方式：</strong></p></blockquote><ol><li>使用XML配置文件标签；</li><li>在自定义类上使用@Component注解（将自定义对象交由Spring管理）</li><li>使用FactoryBean灵活的创建出对象，然后使用XML或者@Component注解交由Spring管理。</li><li><strong>使用@Bean注解（灵活的创建对象，并放入Spring容器中）；</strong></li></ol><h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><ul><li>FactoryBean 一般用于创建较为复杂的 Bean，一般的bean使用XML配置即可，但若是一个Bean的创建过程中涉及到很多其他 Bean 和 复杂的逻辑，使用XML配置比较复杂的话，这时可以考虑使用FactoryBean。</li><li>定时任务可以由 FactoryBean 实现</li><li>Mapper 类都是接口，无法被实例化，Mybatis 是通过 FactoryBean 对象创建 Mapper 对象的代理对象，完成 Mapper 接口的注入</li></ul><h2 id="工程"><a href="#工程" class="headerlink" title="工程"></a>工程</h2><p>还是那句老话，类与类之间各司其职，防止代码耦合</p><p>在 AbstractBeanFactory 继承的 DefaultSingletonBeanRegister 类中间加一层 FactoryBeanRegisterSupport ，这个类在 Spring IoC 框架中主要是用于处理 Factory Bean 注册的支撑操作</p><h3 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h3><p>singleton、prototype，是本次在 BeanDefinition 类中新增加的两个属性信息，用于<strong>把从 spring.xml 中解析到的 Bean 对象作用范围填充到属性中</strong>。</p><h3 id="创建-FactoryBean-接口"><a href="#创建-FactoryBean-接口" class="headerlink" title="创建 FactoryBean 接口"></a>创建 FactoryBean 接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FactoryBean</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-FactoryBean-注册服务"><a href="#实现-FactoryBean-注册服务" class="headerlink" title="实现 FactoryBean 注册服务"></a>实现 FactoryBean 注册服务</h3><ul><li>从缓存中获取 FactoryBean，要是没有通过 Factory.getObject 获取并存入缓存中，如果是原型就直接从 Factory.getObject 获取</li></ul><h3 id="扩展-AbstractBeanFactory-创建对象的逻辑"><a href="#扩展-AbstractBeanFactory-创建对象的逻辑" class="headerlink" title="扩展 AbstractBeanFactory 创建对象的逻辑"></a>扩展 AbstractBeanFactory 创建对象的逻辑</h3><p>​在之前的设计中，没有考虑到 Bean 有可能为原型模式，每次获取完 Bean 后就将对象放入缓存中供下一次调取。AbstractBeanFactory 简单继承 DefaultSingletonBeanRegistry，经过这次的设计，我们在 AbstractBeanFactory 和 DefaultSingletonBeanRegistry 之间加入 FactoryBeanRegisterSupport 进行过渡。<strong>即扩展出创建 FactoryBean 对象的能力并区分 Bean 到底是单例还是原型</strong></p><ul><li><p>从缓存中获取 FactoryBean，要是没有通过 Factory.getObject 获取并存入缓存中，如果是原型就直接从 Factory.getObject 获取 ### 扩展 AbstractBeanFactory 创建对象的逻辑 在之前的设计中，没有考虑到 Bean 有可能为原型模式，每次获取完 Bean 后就将对象放入缓存中供下一次调取。AbstractBeanFactory 简单继承 DefaultSingletonBeanRegistry，经过这次的设计，我们在 AbstractBeanFactory 和 DefaultSingletonBeanRegistry 之间加入 FactoryBeanRegisterSupport 进行过渡。<strong>即扩展出创建 FactoryBean 对象的能力并区分 Bean 到底是单例还是原型</strong></p></li><li><p>从缓存中获取 FactoryBean，要是没有通过 Factory.getObject 获取并存入缓存中，如果是原型就直接从 Factory.getObject 获取 ### 扩展 AbstractBeanFactory 创建对象的逻辑 在之前的设计中，没有考虑到 Bean 有可能为原型模式，每次获取完 Bean 后就将对象放入缓存中供下一次调取。AbstractBeanFactory 简单继承 DefaultSingletonBeanRegistry，经过这次的设计，我们在 AbstractBeanFactory 和 DefaultSingletonBeanRegistry 之间加入 FactoryBeanRegisterSupport 进行过渡。<strong>即扩展出创建 FactoryBean 对象的能力并区分 Bean 到底是单例还是原型</strong></p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​FactoryBean 是用于获取Bean，但和 BeanFactory 不太一样，BeanFactory 获取的是静态的类，就比如我们写的 Service 的各个实现类，它的逻辑就是我拿到你的 Bean 定义，然后一步步构造后作为 Spring 的 Bean。 FactoryBean 不关心怎么构造出来这个 Bean，对于他来讲，只要你实现了我的 getObject() 方法，我就能拿到你这个 Bean，这样他就更灵活，可以给一些第三方来用。 现实中的例子，Mybatis 的 Dao，我们使用 Dao 时，只需要写一个 Dao 的接口可以，这就是 Mybatis 通过 FactoryBean 实现了一个MapperFactoryBean 可以获取到一个 BaseMapepr ，其中封装了可以从数据库获取数据的 CURD 等操作，这样我们写 DAO 只需要继承BaseMapper，MapperFactoryBean 会帮我们把 BaseMapper 所有实现的DAO都注入，并在其中封装好查询操作，我们使用时啥都不需要关心。 也就是说，FacotryBean 可以帮我们注入<strong>一类 Bean</strong>，这类 Bean 所需要的通用依赖或者信息我们可以通过 FactoryBean 实现类统一处理，并注入。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 渐进式实现Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【从零构建Spring|第八节】 Aware感知容器</title>
      <link href="/posts/11408.html"/>
      <url>/posts/11408.html</url>
      
        <content type="html"><![CDATA[<h1 id="【从零构建Spring-第八节】-Aware感知容器"><a href="#【从零构建Spring-第八节】-Aware感知容器" class="headerlink" title="【从零构建Spring|第八节】 Aware感知容器"></a>【从零构建Spring|第八节】 Aware感知容器</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为什么需要 Aware？</p><p>Aware 能将业务代码和框架功能解耦，本质上就是自定义 Bean 后置处理器，在框架类代码中可以用来<strong>暴露自己的内部成员</strong>。类似这样的设计在很多框架中都有体现，用于<strong>给外部做扩展</strong>。</p><p>Spring 依赖注入的最大特点就是所有Bean 对象 对于 Spring 容器的存在是无感知的。但是在实际项目中，我们还是要用到 Spring 容器内部所提供的资源（通过 Bean 调用 Spring 容器组件资源）</p><p>举个实际案例，以下内容是我询问 chatgpt 所得到的回答。</p><p>Q:</p><p>请举一个使用 bean 需要知道 Spring 容器的案例，以证明 Aware 接口的必要性</p><p>A:</p><p>一个典型的案例是使用 ApplicationContextAware 接口，该接口使得我们能够在 Bean 中直接获取 Spring 容器，从而实现更高级别的操作。</p><p>举个例子，假设我们需要在一个自定义的 Bean 中使用 Spring 容器中的某些资源（如Bean、Properties文件等），如果不使用Aware接口，我们通常需要手动创建一个BeanFactory或者ApplicationContext，并通过getBean()方法获取需要的资源，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Resource myResource;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMyResource</span><span class="params">(Resource myResource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myResource = myResource;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> myResource.getInputStream();</span><br><span class="line">        <span class="comment">// 处理 InputStream</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在配置文件中配置 MyBean</span></span><br><span class="line">&lt;bean id=<span class="string">&quot;myBean&quot;</span> class=<span class="string">&quot;com.example.MyBean&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;myResource&quot;</span> value=<span class="string">&quot;classpath:/myFile.txt&quot;</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在代码中手动获取 Spring 容器和 MyBean</span></span><br><span class="line"><span class="type">BeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;applicationContext.xml&quot;</span>));</span><br><span class="line"><span class="type">MyBean</span> <span class="variable">myBean</span> <span class="operator">=</span> (MyBean) beanFactory.getBean(<span class="string">&quot;myBean&quot;</span>);</span><br><span class="line">myBean.doSomething();</span><br></pre></td></tr></table></figure><p>但是，如果我们使用 ApplicationContextAware 接口，则可以在 Bean 中直接注入 Spring 容器，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Resource myResource;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMyResource</span><span class="params">(Resource myResource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myResource = myResource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> myResource.getInputStream();</span><br><span class="line">        <span class="comment">// 处理 InputStream</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 从 Spring 容器中获取其他 Bean</span></span><br><span class="line">        <span class="type">OtherBean</span> <span class="variable">otherBean</span> <span class="operator">=</span> applicationContext.getBean(OtherBean.class);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在配置文件中配置 MyBean</span></span><br><span class="line">&lt;bean id=<span class="string">&quot;myBean&quot;</span> class=<span class="string">&quot;com.example.MyBean&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;myResource&quot;</span> value=<span class="string">&quot;classpath:/myFile.txt&quot;</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在代码中只需要获取 MyBean</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">MyBean</span> <span class="variable">myBean</span> <span class="operator">=</span> (MyBean) applicationContext.getBean(<span class="string">&quot;myBean&quot;</span>);</span><br><span class="line">myBean.doSomething();</span><br></pre></td></tr></table></figure><p>由上述两个例子可以看出，使用 ApplicationContextAware 接口可以避免手动创建 BeanFactory 或 ApplicationContext 的繁琐操作，并且可以在 Bean 中直接获取 Spring 容器中的其他资源，从而简化了代码的编写和维护。因此，Aware 接口的存在是必要的。</p><p>其实 Spring Aware 是 Spring 设计为框架内部使用的，Aware 标记性注解的出现大大提供了 Spring 的扩展性，不过如果使用了 Bean 就会与 Spring 框架耦合，所以不建议用户单独使用</p><p>在本节中，我们通过 <strong>ApplicationContextAwareProcessor 这个 Spring 内置 Bean</strong> 来实现应用上下文的注入（注意在 Spring IoC 中万物皆是 Bean 对象）</p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>想获得 Spring 框架提供的 BeanFactory、ApplicationContext、BeanClassLoader等这些能力做一些扩展框架的使用时该怎么操作呢。所以我们本章节希望在 Spring 框架中提供一种能感知容器操作的接口，如果谁实现了这样的一个接口，就可以获取接口入参中的各类能力。</p><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/07.Aware%E6%84%9F%E7%9F%A5%E5%AE%B9%E5%99%A8-assets/202302102039265.png" alt="image-20230210203928746"></p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/07.Aware%E6%84%9F%E7%9F%A5%E5%AE%B9%E5%99%A8-assets/202302231404069.png" alt="手写Spring-Aware"></p><h2 id="工程"><a href="#工程" class="headerlink" title="工程"></a>工程</h2><h3 id="Aware-接口"><a href="#Aware-接口" class="headerlink" title="Aware 接口"></a>Aware 接口</h3><blockquote><p>我们都是从 Spring 容器中获取 Bean，反过来，通过 Bean 获取 Spring 组件（BeanFactory、ClassLoader、BeanName、ApplicationContext）就是 Aware 接口的功能</p></blockquote><p>它是空实现，属于一种感知标记性接口（有了标记的存在更方便类的操作和具体判断实现），具体的子类定义和定义实现能够感知容器中相关对象。通过这个桥梁，向具体实现类中提供容器服务</p><p>下面列举一些常见的 Aware 接口及其作用：</p><ol><li>ApplicationContextAware：实现该接口的 Bean 可以获取 Spring 容器的实例，从而可以在应用程序中直接使用容器中的 Bean。</li><li>BeanNameAware：实现该接口的 Bean 可以获取自身在容器中的 Bean 名称，从而可以在应用程序中获取 Bean 的名称。</li><li>BeanClassLoaderAware：实现该接口的 Bean 可以获取加载自身类的类加载器，从而可以在应用程序中获取类加载器的信息。</li><li>BeanFactoryAware：实现该接口的 Bean 可以获取 BeanFactory 的实例，从而可以在应用程序中直接使用 BeanFactory 中的 Bean。</li><li>EnvironmentAware：实现该接口的 Bean 可以获取应用程序的环境配置，从而可以在应用程序中直接使用环境变量的值。</li><li>MessageSourceAware：实现该接口的 Bean 可以获取消息源，从而可以在应用程序中直接使用消息资源。</li><li>ResourceLoaderAware：实现该接口的 Bean 可以获取 ResourceLoader 的实例，从而可以在应用程序中直接使用资源加载器。</li><li>ServletContextAware：实现该接口的 Bean 可以获取 ServletContext 的实例，从而可以在 Web 应用程序中直接使用 ServletContext。</li></ol><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/07.Aware%E6%84%9F%E7%9F%A5%E5%AE%B9%E5%99%A8-assets/202302231306952.webp" alt="img"></p><p>因为应用上下文不能直接获取，因为用户层没法去接触应用上下文。面向于用户的 ClassPathXmlApplicationContext 从功能角度而言不能添加感知接口，所以新建一个后置器去包装感知方法，通过抽象实现 AbstractApplicationContext 中进入 refresh 核心方法中添加后置处理器时AbstractApplicationContext 本身存入后置处理器中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3. Spring 添加 ApplicationContextAwareProcessor，让继承了 ApplicationContextAware 的 Bean 对象都能感知所属的 ApplicationContext</span></span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationContextAwareProcessor</span>(<span class="built_in">this</span>));</span><br></pre></td></tr></table></figure><p>1<br>2</p><p>简单的来说，就是通过添加后置处理器方法，感知的 ApplicationContext 应用上下文存入后置处理器中，其中如何感知呢？就是通过 ApplicationContextAware 接口，将当前应用上下文注入到上下文设置里。</p><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/07.Aware%E6%84%9F%E7%9F%A5%E5%AE%B9%E5%99%A8-assets/202302131918943.png" alt="image-20230213191825295"></p><h2 id="Spring-里的-Aware"><a href="#Spring-里的-Aware" class="headerlink" title="Spring 里的 Aware"></a>Spring 里的 Aware</h2><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/07.Aware%E6%84%9F%E7%9F%A5%E5%AE%B9%E5%99%A8-assets202306051036186.png" alt="image-20230605103632554"></p><p>想要自定义 Bean 拥有哪个 spring 组件，只要继承对应 XxxAware 接口即可，组件自动装配到自定义 Bean 里。</p><p>本质上利用回调机制将 ioc 容器传递给自定义 Bean</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渐进式实现Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【从零构建Spring|第七节】  注册虚拟机钩子, 实现Bean初始化及销毁</title>
      <link href="/posts/11407.html"/>
      <url>/posts/11407.html</url>
      
        <content type="html"><![CDATA[<h1 id="【从零构建Spring-第七节】-注册虚拟机钩子-实现Bean初始化及销毁"><a href="#【从零构建Spring-第七节】-注册虚拟机钩子-实现Bean初始化及销毁" class="headerlink" title="【从零构建Spring|第七节】  注册虚拟机钩子, 实现Bean初始化及销毁"></a>【从零构建Spring|第七节】  注册虚拟机钩子, 实现Bean初始化及销毁</h1><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>重点：客制化 Bean 初始化阶段，<strong>用于接口暴漏、数据库数据读取、配置文件加载</strong>，链接注册中心暴露 RPC 接口以及在 Web 关闭时执行链接断开，内存销毁</p><p>目的：把这些操作交给 Spring 容器自动化处理，即满足用户可以在 <strong>xml 中配置</strong>初始化和销毁的方法，也可以通过<strong>实现类</strong>的方式处理，比如我们在使用 Spring 时用到的 InitializingBean, DisposableBean 两个接口。 其实还可以有一种是<strong>注解</strong>的方式处理初始化操作，不过目前还没有实现到注解的逻辑，后续再完善此类功能。</p><p>设计：初始化、销毁的生命周期在 Bean 加载以及注册阶段，如图所示</p><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/06.%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B3%A8%E5%86%8C%E9%92%A9%E5%AD%90,Bean%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E9%94%80%E6%AF%81-assets/202302092146011.png" alt="image-20230209214627168"></p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/06.%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B3%A8%E5%86%8C%E9%92%A9%E5%AD%90,Bean%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E9%94%80%E6%AF%81-assets/202302221622407.png" alt="手写Spring-Bean初始化和销毁"></p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>销毁方法有两种甚至多种，目前有 <code>实现接口 DisposableBean、配置信息 destroy-method</code> 两种方式。销毁方法是交由 ApplicationContext 应用上下文在注册虚拟机钩子后，虚拟机关闭前执行的操作动作。在销毁执行时，不希望 Spring 还得关注要销毁哪些类型的方法。它的使用更希望有一个统一的接口执行销毁，所以这里新增了适配器模式做统一处理</p><p>详细代码：</p><p>适配器内部可保存需要销毁 bean 的信息，并且实现了 DisposableBean，本质上就是一个 bean，具体是怎么调用到这个适配器的，可以看看最后面的流程分析</p><h3 id="信息的读取"><a href="#信息的读取" class="headerlink" title="信息的读取"></a>信息的读取</h3><p>BeanDefinition 新增两个属性：initMethodName、destroyMethodName。目的是为了在 Spring.xml 配置的 Bean 对象中可配置<code>init-method=&quot;initMethod&quot; destroy-method=&quot;destroyDataMethod&quot;</code> 操作。用接口实现也是一样的，只不过一个是接口方法直接调用，一个是配置文件读取方法反射调用</p><p>bean属性定义新增初始化和销毁后，需要在 <code>XmlBeanDefinitionReader</code> 中，添加对新增属性的读取，并将其存入 BeanDefinition 中</p><h3 id="销毁方法"><a href="#销毁方法" class="headerlink" title="销毁方法"></a>销毁方法</h3><p>销毁核心方法 <code>destroySingletons</code> 接口方法定义在 ConfigurableBeanFactory，实现却不是该接口的子类 AbstractBeanFactory，而是 <code>AbstractBeanFactory</code> 的父类 <code>DefaultSingletonBeanRegistry</code>。 <strong>DefaultSingletonBeanRegistry与 ConfigurableBeanFactory 并无直接继承关系。</strong>这对于我们正常程序员来说是几乎没法想到的。思考一下我们写程序的时候，难道不是定义一个接口，通过子类去实现吗。</p><p>不过转念一想倒也对，<strong>DefaultSingletonBeanRegistry 是 SingletonBeanRegistry 子类实现</strong>。接口定义了获取单例对象，其子类就有必要对单例对象的生命周期负责（注册，销毁）</p><blockquote><p>关于接口的定义通常都是接口定义获取手段，而不管怎么生成，怎么销毁。这些的实现统统交给子类，要是看到没有实现，那就再继承一次</p></blockquote><p>DefaultSingletonBeanRegistry 是单例对象创建销毁的基本单位（默认调用器），因此不应将销毁方法放入 AbstractBeanFactory，会导致数据脏污，接口职责混乱。也算是认识到 Spring 架构设计的牛逼之处！</p><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/06.%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B3%A8%E5%86%8C%E9%92%A9%E5%AD%90,Bean%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E9%94%80%E6%AF%81-assets/202302221616232.png" alt="image-20230222161647437"></p><p>销毁方法的实现在没有直接继承关系的 DefaultSingletonBeanRegistry</p><p><strong>销毁初始化方法的数据</strong></p><p>初始化和销毁方法不同，因为初始化只需要在读取配置文件检测是否有初始化方法即可，其在实例化 Bean 之前，执行 BeanPostProcesser 之后所调用。而销毁方法，无论有没有，他都是在实例化 Bean 之后所<strong>注册（不是调用）</strong>，调用则是由 ApplicationContext 应用上下文所定义的虚拟机钩子 Hook 来调用。因此这里就不能用和初始化一样的逻辑了。因为 Hook 调用时是将所有需要销毁的 Bean 方法统一销毁。我们是不知道 Bean 对象类型的，因此这里就需要使用适配器模式定义一个统一的接口，Hook 调用这个统一的适配器接口就好了，具体的对接通过继承适配器接口即可。</p><p>再来回顾一下刚刚所说的，<strong>销毁方法是在虚拟机关闭时统一执行的</strong>,怎么知道哪些 bean 是需要销毁的呢？要是我的话就封装一个查找是否有销毁方法的方法来逐一寻找，但是 Spring 很聪明，在设计时，直接把初始化和销毁放在同一个阶段读取与调用（实际上调用的不是销毁方法，而是调用销毁方法的注册表）。我一开始还很纳闷为什么两个作用时期不同的方法要放在一起。实则不然，这样做的好处就是在 Bean 创建对象实例时，会把销毁方法都给保存到内存里，方便后续执行销毁动作时候的调用。</p><p>销毁方法的具体信息，会通过</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerDisposableBeanIfNecessary</span><span class="params">(String beanName, Object bean, BeanDefinition beanDefinition)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> DisposableBean || StrUtil.isNotEmpty(beanDefinition.getDestroyMethodName())) &#123;</span><br><span class="line">        registerDisposableBean(beanName, <span class="keyword">new</span> <span class="title class_">DisposableBeanAdapter</span>(bean, beanName, beanDefinition));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法注册到 DefaultSingletonBeanRegistry 中新增的 DisposableBean 待销毁集合 <code>Map&lt;String, DisposableBean&gt; disposableBeanMap</code></p><p>这个接口的方法，最终会被类 AbstractApplicationContext 的 close 方法通过 <code>getBeanFactory().destroySingletons()</code> 调用</p><p>在注册销毁方法的时候，会根据是接口类型和配置类型统一交给 DisposableBeanAdapter 销毁适配器类来做统一处理。<em>实现了某个接口的类可以被 instanceof 判断或者强转后调用接口方法</em></p><h4 id="钩子-Hook-销毁程序"><a href="#钩子-Hook-销毁程序" class="headerlink" title="钩子 Hook 销毁程序"></a>钩子 Hook 销毁程序</h4><blockquote><p>Java提供了一个程序退出处理机制：Runtime.getRuntime().addShutdownHook(new Thread()），首先通过Runtime.getRuntime()获得当前的程序对象（这是一个静态方法），然后通过Runtime中的void addShutdownHook(Thread hook)方法来<strong>向java的虚拟机（JVM）注册一个shutdown的钩子事件</strong>，这样程序一旦结束，就会运行线程hook。在实际业务中，我们只需要将程序结束之前需要做的一些工作放在线程hook来完成就可以了。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>::close)); </span><br></pre></td></tr></table></figure><p>用于捕捉程序退出时刻，在程序退出时处理必要的退出准备，如关闭网路、关闭文件</p><p>对于单线程程序而言，我们退出程序无非使用 <code>System.exit(0)</code>进行关闭</p><p>但对于多线程程序而言，很难把握程序退出的时机，但有些业务情况很需要捕捉程序退出的一刻对程序进行必要处理，就好像 Spring 框架中需要及时销毁已经实例化的 Bean，防止内存愈发庞大。因此可以使用钩子方法</p><p>这个方法在一些中间件和监控系统的设计也能用到，例如<strong>监测服务器宕机，执行备机启动操作</strong></p><p>参考：</p><ul><li><a href="https://blog.csdn.net/CodePlayMe/article/details/120234171">钩子方法(opens new window)</a></li></ul><p>Bean 对象内部继承<code>InitializingBean, DisposableBean</code>两个接口实现</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>本节实现了上一节上下文中没有完成的初始化，如图：</p><p>上文提到初始化的调用在 Bean 实例化、注入属性之后，即在应用上下文容器创建时期</p><ol><li><p>初始化 Bean，反射获取实际的初始化方法并调用，初始化数据加载到内存中</p></li><li><p>之后注册销毁方法，往需要销毁的集合里存入适配器，适配器里保存了 Bean 信息，待钩子方法使用 close 将其销毁</p></li></ol><p>销毁方法调用在程序关闭时，这个程序关闭时到底是什么时候呢？可通过打断点的方式找到执行钩子事件 close() 的时机</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渐进式实现Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【从零构建Spring|第六节】  应用上下文, 自动识别, 资源加载, 扩展机制的实现</title>
      <link href="/posts/11406.html"/>
      <url>/posts/11406.html</url>
      
        <content type="html"><![CDATA[<h1 id="【从零构建Spring-第六节】-应用上下文-自动识别-资源加载-扩展机制的实现"><a href="#【从零构建Spring-第六节】-应用上下文-自动识别-资源加载-扩展机制的实现" class="headerlink" title="【从零构建Spring|第六节】  应用上下文, 自动识别, 资源加载, 扩展机制的实现"></a>【从零构建Spring|第六节】  应用上下文, 自动识别, 资源加载, 扩展机制的实现</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>提示</p><p>说到spring容器，有的同学可能知道指的是BeanFactory，有的可能说是ApplicationContext，其实这二者都是容器类。</p><p>BeanFactory是底层基础类，位于spring-beans模块中，而ApplicationContext位于spring-context模块，是对BeanFactory的装饰，即包含一个BeanFactory实例。</p><p>ApplicationContext 本质上还是调用了 BeanFactory 内部的系列方法实现功能，并拓展了许多别的功能</p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>在手写 Spring 框架过程中，需要不断扩展新的功能，如一个 Bean 的定义和实例化过程前后，是否可以做到支持自定义扩展，能够对 Bean 对象执行一些修改、增强、记录操作？要做到能随时扩展新功能，本身架构就必须设计好，不能把代码写死、耦合</p><p>本章节有所改动的内容：</p><ul><li><p>合并获取 BeanFactory、读取配置、注册 Bean 等操作，合并到 Spring 框架上下文中。让面向 Spring 的组件 DefaultListableBeanFactory 尽量不暴露给用户</p></li><li><p>在 Bean 的定义和初始化过程中插入接口类，以便实现在 Bean 对象从注册到实例化的过程中执行用户的自定义操作</p></li><li><p>新增两个对 Bean 对象扩展的两个接口，其实也是 Spring 框架中非常具有重量级的两个接口：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BeanFactoryPostProcess</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BeanPostProcessor</span><br></pre></td></tr></table></figure><p>（本质上也是 Bean 的一种，通过</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getBeanOfType(Bean(...)Processor.class)</span><br></pre></td></tr></table></figure><p>获取</p><ul><li>BeanFactoryPostProcessor，是由 Spring 框架组建提供的容器扩展机制，允许在 Bean 对象注册后但未实例化之前，对 Bean 的定义信息 <code>BeanDefinition</code> 执行修改操作。</li><li>BeanPostProcessor，也是 Spring 提供的扩展机制，不过 BeanPostProcessor 是在 Bean 对象实例化<strong>之后</strong>修改 Bean 对象（但注册要在实例化前），也可以替换 Bean 对象。这部分与后面要实现的 AOP 有着密切的关系。</li></ul></li><li><p>同时如果只是添加这两个接口，不做任何包装，那么对于使用者来说还是非常麻烦的。我们希望于开发 Spring 的上下文操作类，把相应的 XML 加载 、注册、实例化以及新增的修改和扩展都融合进去，让 Spring 可以自动扫描到我们的新增服务，便于用户使用。</p></li></ul><h3 id="Spring-应用上下文和对Bean对象扩展机制的类关系"><a href="#Spring-应用上下文和对Bean对象扩展机制的类关系" class="headerlink" title="Spring 应用上下文和对Bean对象扩展机制的类关系"></a>Spring 应用上下文和对Bean对象扩展机制的类关系</h3><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/05.%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E3%80%81%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E3%80%81%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6-assets/202302082322115.png" alt="image-20230208232154424"></p><ul><li>在整个类图中主要体现出来的是关于 Spring 应用上下文以及对 Bean 对象扩展机制的实现。</li><li>以继承了 ListableBeanFactory 接口的 ApplicationContext 接口开始，扩展出一系列应用上下文的抽象实现类，并最终完成 <code>ClassPathXmlApplicationContext</code> 类的实现。而这个类就是最后交给用户使用的类。</li><li>同时在实现应用上下文的过程中，通过定义接口：<code>BeanFactoryPostProcessor</code>、<code>BeanPostProcessor</code> 两个接口，把关于对 Bean 的扩展机制串联进去了。</li></ul><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/05.%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E3%80%81%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E3%80%81%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6-assets/202302221357479.png" alt="手写Spring-ApplicationContext"></p><h2 id="工程"><a href="#工程" class="headerlink" title="工程"></a>工程</h2><h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><p>如果我们想在 Spring 容器中完成 bean 实例化、配置以及其他初始化方法前后要添加一些自己逻辑处理。我们需要定义一个或多个 BeanPostProcessor 接口实现类，然后注册到 Spring IoC 容器中。它本身也是属于一种 Bean，可以注册到 Spring IoC ，通过 BeanFactory 的 getBeanOfType() 获取 bean 后置处理器集合</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化、依赖注入完毕，在调用显示的初始化之前完成一些定制的初始化任务  </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化、依赖注入、初始化完毕时执行  </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由API可以看出:</p><ol><li>后置处理器的<code>postProcessorBeforeInitailization</code>方法是在 bean 实例化，依赖注入之后及自定义初始化方法(例如：配置文件中bean标签添加init-method属性指定Java类中初始化方法、<code>@PostConstruct</code>注解指定初始化方法，Java类实现<code>InitailztingBean</code>接口)之前调用</li><li>后置处理器的 postProcessorAfterInitailization 方法是在bean实例化、依赖注入及自定义初始化方法之后调用</li></ol><p>一个后置处理器的 xml 写法：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 定义一个bean --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;narCodeService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.service.impl.NarCodeServiceImpl&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanLifecycle&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.spring.BeanLifecycle&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Spring后置处理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;postProcessor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.spring.PostProcessor&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意</p><p>BeanFactory 和 ApplicationContext 两个容器对待bean的后置处理器稍微有些不同。</p><p>ApplicationContext 容器会<strong>自动检测 Spring 配置文件中那些 bean</strong> （因为那些 bean 所对应的Java类<strong>实现了 BeanPostProcessor 接口</strong>），并<strong>自动把它们注册为后置处理器</strong>。在创建 bean 过程中调用它们，所以部署一个后置处理器跟普通的bean没有什么太大区别。</p><p>BeanFactory容器注册bean后置处理器时必须通过代码显示的注册，在IoC容器继承体系中的ConfigurableBeanFactory接口中定义了注册方法</p><h4 id="ConfigurableBeanFactory-接口"><a href="#ConfigurableBeanFactory-接口" class="headerlink" title="ConfigurableBeanFactory 接口"></a>ConfigurableBeanFactory 接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * beanFactory 扩展子接口</span></span><br><span class="line"><span class="comment"> * 可获取 BeanPostProcessor 后处理器、BeanClassLoader 类加载器等的一个配置化接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BanTanger 半糖</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2023/2/7 21:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConfigurableBeanFactory</span> <span class="keyword">extends</span> <span class="title class_">SingletonBeanRegistry</span>, HierarchicalBeanFactory &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例作用域标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">SCOPE_SINGLETON</span> <span class="operator">=</span> <span class="string">&quot;singleton&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原型作用域标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">SCOPE_PROTOTYPE</span> <span class="operator">=</span> <span class="string">&quot;prototype&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加处理 bean 的后处理器</span></span><br><span class="line"><span class="comment">     * BeanFactory 容器注册 bean 后处理器必须通过代码显式注册，此为注册方法。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanPostProcessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addBeanPostProcessor</span><span class="params">(BeanPostProcessor beanPostProcessor)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Spring-调用多个-BeanPostProcessor"><a href="#Spring-调用多个-BeanPostProcessor" class="headerlink" title="Spring 调用多个 BeanPostProcessor"></a>Spring 调用多个 BeanPostProcessor</h4><p>我们可以在 Spring 配置文件中添加多个 BeanPostProcessor(后置处理器) 接口实现类，在默认情况下Spring 容器会根据后置处理器的定义顺序来依次调用。</p><p>Spring配置文件：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;narCodeService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.service.impl.NarCodeServiceImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;postProcessor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.spring.PostProcessor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;postProcessorB&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.spring.PostProcessorB&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>postProcessor、postProcessorB 两个 BeanPostProcessor 的实现类（以 ApplicationContext 容器举例），按照 xml 的书写顺序依次注册执行，先 postProcessor 后 postProcessorB</p><p>当然 Spring 也支持通过 order 指定后置处理器调用顺序（需要 Order 接口，当前并没有书写此逻辑），通过让BeanPostProcessor接口实现类实现Ordered接口getOrder方法，该方法返回一整数，默认值为 0，优先级最高，值越大优先级越低</p><h3 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h3><p>Spring 中 BeanFactoryPostProcessor 和 BeanPostProcessor 都是 Spring 初始化 bean 时对外暴露的扩展接口，两个接口名字听起来很像，但实际作用和使用场景却不同</p><p>Spring IoC 容器允许 BeanFactoryPostProcessor 在容器实例化之前读取 Bean 的定义（也称配置元数据），并可以修改它们。可定义多个 BeanFactoryPostProcessor ，通过设置 order 属性（需要 Order 接口，当前暂时没书写此逻辑）来确定各个BeanFactoryPostProcessor执行顺序。</p><p>注册一个 BeanFactoryPostProcessor 实例需要定义一个 Java 类来实现 BeanFactoryPostProcessor 接口，并重写该接口的 postProcessorBeanFactory 方法。通过 beanFactory 可以获取 bean 的定义信息，并可以修改 bean 的定义信息。这点是和 BeanPostProcessor 最大区别.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 允许自定义修改 BeanDefinition 属性信息</span></span><br><span class="line"><span class="comment"> * 提供修改 BeanDefinition 属性的机制，生命周期：在所有的 BeanDefinition 加载完成后，实例化 Bean 对象之前</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BanTanger 半糖</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2023/2/7 23:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在所有的 BeanDefinition 加载完成后，实例化 Bean 对象之前，提供修改 BeanDefinition 属性的机制</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心方法-refresh-实现"><a href="#核心方法-refresh-实现" class="headerlink" title="核心方法 refresh 实现"></a>核心方法 refresh 实现</h3><p><strong>AbstractApplicationContext</strong>，只实现核心功能 refresh()</p><ul><li>AbstractApplicationContext 继承 DefaultResourceLoader 是为了处理 <code>spring.xml</code> 配置资源的加载。</li><li>之后是在 refresh() 定义实现过程</li><li>另外把定义出来的抽象方法，refreshBeanFactory()、getBeanFactory() 由后面的继承此抽象类的其他抽象类实现。</li></ul><p>抽象类 <code>AbstractRefreshableApplicationContext</code> 实现 refresh() 定义的模板方法：</p><p>:warning:</p><p>这里的 beanFactory 算是一个非常精妙的操作了，注意到他的创建在 <code>AbstractRefreshableApplicationContext</code> 而不是 <code>AbstractApplicationContext</code> 了吗？</p><p>按照我们一般人写逻辑，直接把工厂的创建放在和调用一个位置了。因为理解起来直观呀！但是代码整体不美观，且功能耦合。</p><p>Spring 将工厂的创建放在另一个抽象类中，且创建的是最基层的 beanFactroy —— DefaultListableBeanFactory。它拥有注册和获取 Bean 两个最基本的方法，也是 Bean 工厂最本质的功能。在这个抽象类里，读取配置文件，注册 Bean，并将这个注册好的 Factroy 放入内存中供 refresh 调用。而在 refresh 里，又通过向上转型的方式，将 beanFactroy 升级成 ConfigurableBeanFactory 可配置工厂，让这个最基础的工厂具有获取添加后置处理器的功能。</p><p>我们可以从 Spring 框架学会一点，最基础最核心最本质的功能在最顶级接口定义，实现类却位于最底层，中间都由接口不断的继承。这样的好处是实现类可以通过先上转型的方式获取到更多更全的内容。一方面让各个接口各司其职，不让代码耦合写死混乱；另一方面可维护性、可扩展性高，只要书写好文档说明，代码迭代的就会非常轻松。例如面向 Spring 所开发的 BeanFactory 系列组件、以及面向用户所设计的 ConfigurableBeanFactory 可配置工厂。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_BeanFactoryPostProcessorAndBeanPostProcessor_useContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 初始化 BeanFactory</span></span><br><span class="line">    <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:springPostProcessor.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 获取 Bean 对象调用方法</span></span><br><span class="line">    <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> userService.queryUserInfo();</span><br><span class="line">    System.out.println(<span class="string">&quot;测试结果：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ApplicationContext-功能"><a href="#ApplicationContext-功能" class="headerlink" title="ApplicationContext 功能"></a>ApplicationContext 功能</h2><ol><li>ApplicationEventPublisher：Ioc 事件派发器</li><li>MessageSource：国际化解析器</li><li>BeanFactory：Bean 工厂 –&gt; 组合自动装配</li><li>资源解析</li></ol><p>是用户能看见的 Bean 工厂，但 ApplicationContext 只是接口，我们都是调用其子类的方法来完成需求</p><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><h3 id="应用上下文容器的执行细节"><a href="#应用上下文容器的执行细节" class="headerlink" title="应用上下文容器的执行细节"></a>应用上下文容器的执行细节</h3><ol><li>启动项目，Spring 加载 applicationContext 应用上下文容器，进入 refresh() 核心步骤</li><li>创建 BeanFactory，读取 XML 配置文件（集成在 ApplicationContext）<ol><li>通过 refresh() 中的 refreshBeanFactory() 将创建 Bean 工厂 (创建的是默认最基础工厂 DefaultListableBeanFactory 其具有 注册 bean 和 获取 bean 的功能) 和读取 xml 资源文件</li><li>指定资源路径供 Spring IoC 中的组件 XmlBeanDefinitionReader 读取信息将其加载至 BeanDefinition 。注册好的 beanFactory 放入内存里</li></ol></li><li>提升 beanFactory ，通过自动转换的方式，由 DefaultListableBeanFactory 升级为 ConfigurableListableBeanFactory ，让工厂多了可配置工厂接口定义的方法：预先实例化单例 bean、增添后置处理器 addBeanPostProcessor</li><li>在 bean 实例化之前，Spring 注册 PostProcessor 后置处理器<ol><li>invokeBeanFactoryPostProcessors 通过 getBeanOfType 获取用户自定义的所有 MyBeanFactoryPostProcessors 集合（因为 BeanFactoryPostProcessor 本质也是 bean 的一种）从而修改 beanDefinition 配置元数据</li><li>registerBeanPostProcessors 通过 getBeanOfType 获取用户自定义的所有 MyBeanPostProcessors 集合</li></ol></li><li>beanFactory.preInstantiateSingletons() 预处理实例化 XML 书写的所有 Bean</li></ol><p>应用上下文容器完成了数据的读取，创建，bean对象的实例化</p><h3 id="创建-Bean-的执行细节"><a href="#创建-Bean-的执行细节" class="headerlink" title="创建 Bean 的执行细节"></a>创建 Bean 的执行细节</h3><ol><li>bean 通过 Cgilb（字节码增强） 或者 JDK 自带的手段（反射手段）和 BeanDefinition 中所定义的配置元数据<strong>实例化</strong> Bean 对象</li><li>往实例化 Bean 对象填充属性，如果是引用，递归的获取引用的 Bean 实例</li><li>执行 BeanPostProcessor 后置处理器的逻辑，在初始化之前需要做操作 Before</li><li>初始化 Bean，目前未实现，为空逻辑</li><li>执行 BeanPostProcessor 后置处理器的逻辑，在初始化之后需要做操作 After</li><li>将注册好的 Bean 存入单例缓存</li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 渐进式实现Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring系列之 SpringBoot启动流程</title>
      <link href="/posts/63628.html"/>
      <url>/posts/63628.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring系列之-SpringBoot启动流程"><a href="#Spring系列之-SpringBoot启动流程" class="headerlink" title="Spring系列之 SpringBoot启动流程"></a>Spring系列之 SpringBoot启动流程</h1><p>我叫Spring，今天为大家介绍我体内最核心的运行原理之一——Spring Boot的启动原理，帮助大家在面试和走向架构岗位的路上做出一点点贡献。各位程序员朋友们想要启动我，这个过程本质上是由<code>@SpringBootApplication</code>注解驱动的，它实际上是<code>@ComponentScan</code>、<code>@EnableAutoConfiguration</code>和<code>@Configuration</code>这三个注解的组合。</p><p><code>@EnableAutoConfiguration</code>是最为核心的部分，有了它之后，在启动时会导入“自动配置<code>AutoConfigurationImportSelector</code>类，这个类会将所有符合条件的<code>@Configuration</code>配置加载进容器。也就是说，这个类被标记为配置类，会被加载到容器中。如果启动类中不需要增加额外的配置内容，也不需要指定扫描路径，那么可以仅使用<code>@EnableAutoConfiguration</code>替代<code>@SpringBootApplication</code>，同样可以完成启动。</p><p><code>run()</code>这个方法开始执行后，会经历如下四个阶段：“容器创建”、“填充容器”，所谓的“服务构建”，这里的“服务”就是指Spring Boot应用本身，这个阶段就是用一大堆零件将我组装出来。在我的构造方法里，首先要把传入的“资源加载器”和“主方法类”记录在内存中。然后，我会逐一判断对应的服务类是否存在，来确定Web服务的类型，默认是<code>SERVLET</code>，即基于Servlet的Web服务，如Tomcat；还有响应式非阻塞服务<code>REACTIVE</code>，如Spring WebFlux；如果没有选择任何服务，则使用<code>NONE</code>。确定了选择哪个Web服务之后，然后就要加载初始化类了。我会去读取所有<code>META-INF/spring.factories</code>文件中的“注册初始化器”、“上下文初始化器”和“监听器”这三类配置。在Spring Boot内部，并没有默认的“注册初始化器”配置，但是有7个“上下文初始化器”和8个“监听器”。这些配置信息会在后续的启动过程中使用到。当然，各位程序员朋友们也可以自定义这三个配置，只需要将其放到工程中的<code>sprin g.factories</code>文件中，我就会将它们一并加载进来。</p><p>接下来会通过调用栈（stack trace）判断出<code>main</code>方法所在的类，大概率就是启动类本身，后续过程会使用到。这样，我的Spring服务<code>SpringApplication</code>就构造完成了，然后就是调用它的<code>run()</code>方法进入“环境准备”阶段了。在这个阶段，<code>SpringApplication</code>会准备<code>ConfigurableEnvironment</code>，同时逐一调用刚刚加载的“启动注册初始化器”。不过正如前面提到的，Spring Boot内部并没有默认的<code>BootstrapRegistryInitializer</code>，所以默认情况下并不会执行什么特别的操作。接下来会将<code>java.awt.headless</code>这个设置改为<code>true</code>，表示即使缺少显示器、键盘等输入设备也可以正常启动。然后会启动体内的“运行监听器<code>SpringApplicationRunListeners</code>”，同时发布“启动”事件。这样，各位朋友们就可以通过监听这些事件，在启动流程中加入自定义逻辑。具体的监听器原理我会在后续视频中详细介绍。</p><p>接下来就要通过<code>prepareEnvironment()</code>方法“组装启动参数”了。根据不同的Web服务类型会构造不同的环境，默认是Servlet。构造之后会加载很多诸如“系统环境变量”、<code>systemProperties</code>等在内的四组配置信息。这样，后续使用到这些信息就无需重新加载了。启动时传入的环境参数<code>args</code>也会进行设置，例如启动时传入的诸如“开发&#x2F;生产”环境配置等都会在这一步进行加载。</p><p>接下来就会发布“环境准备完成”这个事件，刚加载进来的监听器会监听到这个事件，其中的部分“监听器”会进行相应处理。这包括<code>EnvironmentPostProcessor</code>和<code>ApplicationListener</code>，它们会去加载<code>spring.factories</code>配置文件中“环境配置后处理器”。这里要注意，监听器通过观察者模式设计，“环境准备完成”是逐个“串行”执行，并不是异步“并行”，需要等待所有监听器都处理完成之后，才会继续走后续的逻辑。</p><p>等环境绑定到我体内之后，剩下的就是考虑到刚创建的“可配置环境”在一系列过程中可能已有变化，进而做的补偿。这样，“环境准备”阶段就完成了。</p><p>我会将上一阶段准备好的各种养分进行组合，孵化我最最核心的“容器”器官，所谓“容器”——<code>ApplicationContext</code>，也可以称为配置上下文，当然叫做“容器”更好理解。创建过程很简单，默认的服务类型是<code>SERVLET</code>，所以创建的是注解配置的Servlet-Web服务容器。在这个过程中，会用到<code>DefaultListableBeanFactory</code>，用来解析<code>@Component</code>、<code>@Bean</code>等，并通过<code>ConfigurationClassPostProcessors</code>把它们都放入容器中。之后，通过<code>prepareContext()</code>方法对容器中的部分属性进行初始化，比如设置“Bean名称生成器”、“资源加载器”、“类型转换器”等。此外，<code>ApplicationInitializer</code>也会被加载，虽然默认没有，但可以自定义。在发布“容器准备完成”监听事件之后，会陆续为容器注册完成“Banner”Bean引用策略和“懒加载策略”等等。最后通过Bean定义加载器将“启动类”在内的资源放入“Bean定义池”<code>BeanDefinitionMap</code>中，以便后续根据Bean定义创建Bean对象。</p><p>我体内最核心的“容器”就创建完成啦。在这个过程中，我会创建自身提供的以及各位朋友们自定义的所有Bean对象，这个过程也被大家称为自动装配。这个过程大体分为12个小步骤，不仅包含了我之前介绍过的Bean生命周期管理，还会构造和启动一个Web服务器。这12个步骤我会在下一个视频中为各位朋友们详细介绍。</p><p>在“环境准备完成”、“容器准备完成”和“资源加载完成”之后，会回调朋友们自定义实现的<code>Runner</code>接口，至此，启动过程全部完成。</p><p>如果喜欢这期视频的话，请一定记得长按点赞按钮。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【从零构建Spring|第五节】  加载,解析资源并注册Bean对象</title>
      <link href="/posts/11405.html"/>
      <url>/posts/11405.html</url>
      
        <content type="html"><![CDATA[<h1 id="【从零构建Spring-第五节】-加载-解析资源并注册Bean对象"><a href="#【从零构建Spring-第五节】-加载-解析资源并注册Bean对象" class="headerlink" title="【从零构建Spring|第五节】  加载,解析资源并注册Bean对象"></a>【从零构建Spring|第五节】  加载,解析资源并注册Bean对象</h1><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>上一节我们实现了往 Bean 对象注入属性，但所有的操作都需要用户手动填写，这显然是不合适的，因此这一节我们来优化</p><p>本章节主要有以下改动：</p><ul><li>资源加载接口的定义和实现</li><li>解析 XML 处理 Bean 注册</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>通过单元测试进行手动操作 Bean 对象的定义、注册和属性填充，以及最终获取对象调用方法。但这里会有一个问题，就是如果实际使用这个 Spring 框架，是不太可能让用户通过手动方式创建的，而是最好能通过配置文件的方式简化创建过程。需要完成如下操作：</p><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/04.%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%99%A8xml%E8%A7%A3%E6%9E%90%E5%92%8C%E6%B3%A8%E5%86%8CBean%E5%AF%B9%E8%B1%A1-assets/202302071306597.png" alt="image-20230207130632924"></p><ul><li>如图中我们需要把步骤：2、3、4整合到Spring框架中，通过 Spring 配置文件的方式将 Bean 对象实例化。</li><li>接下来我们就需要在现有的 Spring 框架中，添加能解决 Spring 配置的读取、解析、注册Bean的操作。</li></ul><p>XmlReader 的作用，就是为 Spring 自动配置 Bean 对象的注册、属性设置、Bean 对象实例化。整个过程用户无感，最终用户所需要做的操作就是调用所需的 Bean 对象就行！</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>依照本章节的需求背景，我们需要在现有的 Spring 框架雏形中添加一个资源解析器，也就是能读取classpath、本地文件和云文件的配置内容。这些配置内容就是像使用 Spring 时配置的 Spring.xml 一样，里面会包括 Bean 对象的描述和属性信息。在读取配置文件信息后，接下来就是对配置文件中的 Bean 描述信息解析后进行注册操作，把 Bean 对象注册到 Spring 容器中。整体设计结构如下图：</p><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/04.%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%99%A8xml%E8%A7%A3%E6%9E%90%E5%92%8C%E6%B3%A8%E5%86%8CBean%E5%AF%B9%E8%B1%A1-assets/202302071319788.png" alt="image-20230207131936379"></p><ul><li>资源加载器属于相对独立的一部分，它位于 Spring 框架核心包下的 IO 实现内容，主要用于处理 Class、本地、云环境的文件信息</li><li>当资源可以加载后，接下来就是解析和注册 Bean 到 Spring 的所有操作，这一部分的实现需要和 DefaultListableBeanFactory 核心类结合起来，因为所有的解析后的注册动作，都会把 Bean 定义信息放到这个类里</li><li>实现需要实现接口的层次关系，包括需要定义出 Bean 定义的<strong>读取接口 BeanDeinitionReader</strong> 以及做好对应的实现类，在实现类中完成对 Bean 对象的解析和注册</li></ul><h3 id="Spring-Bean-容器资源加载和使用类关系"><a href="#Spring-Bean-容器资源加载和使用类关系" class="headerlink" title="Spring Bean 容器资源加载和使用类关系"></a>Spring Bean 容器资源加载和使用类关系</h3><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/04.%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%99%A8xml%E8%A7%A3%E6%9E%90%E5%92%8C%E6%B3%A8%E5%86%8CBean%E5%AF%B9%E8%B1%A1-assets/202302212130385.png" alt="手写Spring-资源加载和读取"></p><ul><li>本章节为了能把 Bean 的定义、注册和初始化交给 Spring.xml 配置化处理，那么就需要实现两大块内容，分别是：<strong>资源加载器、xml资源处理类</strong>，实现过程主要以对接口 <code>Resource</code>、<code>ResourceLoader</code> 的实现，而另外 <code>BeanDefinitionReader</code> 接口则是对资源的具体使用，将配置信息注册到 Spring 容器中去。</li><li>在 Resource 的资源加载器的实现中包括了 <strong>ClassPath、系统文件、云配置文件</strong>，这三部分与 Spring 源码中的设计和实现保持一致，最终在 DefaultResourceLoader 中做具体的调用。</li><li>接口：BeanDefinitionReader、抽象类：AbstractBeanDefinitionReader、实现类：XmlBeanDefinitionReader，这三部分内容主要是合理清晰的处理了资源读取后的注册 Bean 容器操作。<em>接口管定义，抽象类处理非接口功能外的注册Bean组件填充，最终实现类即可只关心具体的业务实现</em></li></ul><p>另外本章节还参考 Spring 源码，做了相应接口的集成和实现的关系，虽然这些接口目前还并没有太大的作用，但随着框架的逐步完善，它们也会发挥作用。</p><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/04.%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%99%A8xml%E8%A7%A3%E6%9E%90%E5%92%8C%E6%B3%A8%E5%86%8CBean%E5%AF%B9%E8%B1%A1-assets/202302072208646.png" alt="image-20230207220856393"></p><ul><li>BeanFactory，已经存在的 Bean 工厂接口，用于获取 Bean 对象，这次<strong>新增加了按照类型获取 Bean 的方法</strong>：<code>&lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType)</code></li><li>ListableBeanFactory，是一个扩展 Bean 工厂接口的接口，新增加了 <code>getBeansOfType</code>、<code>getBeanDefinitionNames()</code> 方法，在 Spring 源码中还有其他扩展方法。</li><li>HierarchicalBeanFactory，在 Spring 源码中它提供了可以获取父类 BeanFactory 方法，属于是一种扩展工厂的层次子接口。<em>Sub-interface implemented by bean factories that can be part of a hierarchy.</em></li><li>AutowireCapableBeanFactory，是一个自动化处理Bean工厂配置的接口，目前案例工程中还没有做相应的实现，后续逐步完善。</li><li>ConfigurableBeanFactory，可获取 BeanPostProcessor 后置处理器、BeanClassLoader 类加载器等的一个配置化接口</li><li>ConfigurableListableBeanFactory，提供分析和修改Bean以及预先实例化的操作接口，不过目前只有一个 getBeanDefinition 方法。</li></ul><h2 id="工程"><a href="#工程" class="headerlink" title="工程"></a>工程</h2><h3 id="资源加载接口的定义与实现"><a href="#资源加载接口的定义与实现" class="headerlink" title="资源加载接口的定义与实现"></a>资源加载接口的定义与实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line"></span><br><span class="line">    InputStream <span class="title function_">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 Spring 框架下创建 core.io 核心包，在这个包中主要用于处理资源加载流。</li><li>定义 Resource 接口，提供获取 InputStream 流的方法，接下来再分别实现三种不同的流文件操作：classPath、FileSystem、URL</li></ul><p>ClassPath:</p><p>FileSystem</p><p>URL</p><h3 id="包装资源加载器"><a href="#包装资源加载器" class="headerlink" title="包装资源加载器"></a>包装资源加载器</h3><p>按照资源加载的不同方式，资源加载器可以把这些方式集中到统一的类服务下进行处理，外部用户只需要传递资源地址即可，简化使用。</p><p>定义统一接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResourceLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用路径前缀强制指定从 Spring 容器中获取 Resource 实现类</span></span><br><span class="line">    <span class="comment">// 当前的前缀是指定使用 ClassPathResource</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">CLASSPATH_URL_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;classpath:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 外部调度资源加载器统一接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> location 外部资源地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Resource 接口实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Resource <span class="title function_">getResource</span><span class="params">(String location)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义获取资源接口，里面传递 location 地址即可。</li></ul><p>默认资源加载器实现类：（按照 Spring 内定顺序指定不同的 Resource 加载资源）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultResourceLoader</span> <span class="keyword">implements</span> <span class="title class_">ResourceLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Resource <span class="title function_">getResource</span><span class="params">(String location)</span> &#123;</span><br><span class="line">        Assert.notNull(location, <span class="string">&quot;Location must not be null -- 资源路径不能为空&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;</span><br><span class="line">            <span class="comment">// ClassPath 方式加载资源: 获取 location: 后的内容，并加载资源</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(location.substring(CLASSPATH_URL_PREFIX.length()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// URL 方式加载资源</span></span><br><span class="line">                <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(location);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UrlResource</span>(url);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">                <span class="comment">// File 加载资源</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FileSystemResource</span>(location);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>默认资源加载器，用于用户、Spring IoC 传参只有注册器，没有加载器时的默认添加，具体逻辑在 <code>AbstractBeanDefinitionReader</code></li></ul><h4 id="这里需要说明一下-Spring-的-Resource-策略"><a href="#这里需要说明一下-Spring-的-Resource-策略" class="headerlink" title="这里需要说明一下 Spring 的 Resource 策略"></a>这里需要说明一下 Spring 的 Resource 策略</h4><p>背景知识: ApplicationContext的创建方式</p><p>学过原生Spring的同学都知道，当我们想开发一个Spring项目，也就是创建ApplicationContext容器、让Spring启动生效时，我们：</p><ol><li>首先会写一个xml文件，其中定义若干个元素；</li><li>然后在java代码中用如下的几种写法，去加载其中的bean元素，生成对应的实例并注入ApplicationContext容器内：<ol><li>new ClassPathXmlApplicationContext(“xxx.xml”)</li><li>new FileSystemXmlApplicationContext(“xxx.xml”)</li><li>WebApplicationContextUtils.getWebApplicationContext(servletContext)</li></ol></li><li>在SpringMVC、SpringBoot中，程序员没有直接这样创建applicationContext对象，是因为框架已经使用这些方法封装好了创建方式，在启动时会自动加载。但内部也都存在对应的ApplicationContext容器，会有类似的调用或创建语法。</li></ol><p>获取指定的Resource实现类</p><p>Spring 通过使用<strong>路径前缀</strong>的方式来<strong>强制指定从 Spring 容器获取 Resource 实现类</strong>，在接口 ResourceLoader 有所体现</p><p>例如前缀**”classpath:”<strong>是指定使用ClassPathResource；前缀</strong>“file:”**则指定使用UrlResource访问本地系统资源等</p><h3 id="Bean-定义读取接口"><a href="#Bean-定义读取接口" class="headerlink" title="Bean 定义读取接口"></a>Bean 定义读取接口</h3><p>定义 BeanDefinitionReader ,其作用是读取 Spring 配置文件中的内容，将其转换为 IoC 容器内部的数据结构：BeanDefinition。</p><p>BeanDefinitionReader</p><p>我们之前实现的 BeanDefinitionRegistry 接口一次只能注册一个 BeanDefinition，而且只能通过自己构造 BeanDefinition 数据结构才能注册</p><p>本次我们升级，使用 BeanDefinitionReader 集成解决问题，它可以使用一个 BeanDefinitionRegistry 构造，然后通过 <code>loadBeanDefinitions()</code> 等方法读取 Resources，把 Resources 通过流的方式转化成多个 BeanDefinition 并注册到 BeanDefinitionRegistry 中。其中转化成流的好处不用多说，二进制节省内存以及加快传输效率</p><p>具体代码如下：</p><ul><li>这是一个 <em>Simple interface for bean definition readers.</em> 其实里面无非定义了几个方法，包括：getRegistry()、getResourceLoader()，以及三个加载Bean定义的方法：分别为单个资源加载、多个资源加载、指定资源路径加载。流程为 先指定资源路径加载，然后调用具体的资源加载</li><li>这里需要注意 getRegistry()、getResourceLoader()，都是用于提供给后面三个方法的工具，加载和注册，这两个方法的实现会包装到抽象类中，以免<strong>污染具体的接口实现方法</strong>。</li></ul><h3 id="Bean-定义抽象类实现"><a href="#Bean-定义抽象类实现" class="headerlink" title="Bean 定义抽象类实现"></a>Bean 定义抽象类实现</h3><p>该类是实现了 BeanDefinitionReader 接口的抽象类，提供常见属性：注册 bean 信息的工厂、资源加载器。具体定义如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractBeanDefinitionReader</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionReader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册 Bean 定义的 Bean 工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BeanDefinitionRegistry registry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源加载器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(registry, <span class="keyword">new</span> <span class="title class_">DefaultResourceLoader</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry, ResourceLoader resourceLoader)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.registry = registry;</span><br><span class="line">        <span class="built_in">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BeanDefinitionRegistry <span class="title function_">getRegister</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> registry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ResourceLoader <span class="title function_">getResourceLoader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>抽象类把 BeanDefinitionReader 接口的前两个方法全部实现完了，并提供了构造函数，让外部的调用使用方，把Bean定义注入类，传递进来。</li><li>这样在接口 BeanDefinitionReader 的具体实现类中，就可以把解析后的 XML 文件中的 Bean 信息，注册到 Spring 容器去了。<em>以前我们是通过单元测试使用，调用 BeanDefinitionRegistry 完成 Bean的注册，现在可以放到 XMl 中操作了</em></li></ul><h3 id="解析-XML-处理-Bean-注册"><a href="#解析-XML-处理-Bean-注册" class="headerlink" title="解析 XML 处理 Bean 注册"></a>解析 XML 处理 Bean 注册</h3><p>宏观层面上，配置 xml 配置文件后执行 BeanDefinitionReader 会先调用 XmlBeanDefinitionReader。底层是通过 <code>loadBeanDefinitions()</code> 系列方法将配置加载成流对象，其可以节省内存以及提高对象传输效率。之后通过 <code>doLoadBeanDefinitions()</code> 读取 XML 配置信息，拆分成 <code>&lt;bean&gt;、&lt;property&gt;、&lt;raf&gt;、&lt;id&gt;、&lt;value&gt;</code> 等标签读取其内容。</p><p>具体代码：</p><p>XmlBeanDefinitionReader 类最核心的内容就是对 XML 文件的解析，把我们本来在代码中的操作放到了通过解析 XML 自动注册的方式。</p><ul><li>loadBeanDefinitions 方法，处理资源加载，这里新增加了一个内部方法：<code>doLoadBeanDefinitions</code>，它主要负责解析 xml</li><li>在 doLoadBeanDefinitions 方法中，主要是对xml的读取 <code>XmlUtil.readXML(inputStream)</code> 和元素 Element 解析。在解析的过程中通过循环操作，以此获取 Bean 配置以及配置中的 id、name、class、value、ref 信息。</li><li>最终把读取出来的配置信息，创建成 BeanDefinition 以及 PropertyValue，最终把完整的 Bean 定义内容注册到 Bean 容器：<code>getRegistry().registerBeanDefinition(beanName, beanDefinition)</code></li></ul><p>一个 XML 文件的大致信息如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.bantanger.springframework.test.bean.UserDao&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.bantanger.springframework.test.bean.UserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;uId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10001&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过这些操作将所有标签的值读取下来：<code>getAttribute()</code> 获取方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析标签：bean 并获取其 id、name、className</span></span><br><span class="line"><span class="type">Element</span> <span class="variable">bean</span> <span class="operator">=</span> (Element) childNodes.item(i);</span><br><span class="line"><span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> bean.getAttribute(<span class="string">&quot;id&quot;</span>); <span class="comment">// userDao、userService</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> bean.getAttribute(<span class="string">&quot;name&quot;</span>); <span class="comment">// null、null</span></span><br><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> bean.getAttribute(<span class="string">&quot;class&quot;</span>); <span class="comment">// com.bantanger.springframework.test.bean.UserDao、com.bantanger.springframework.test.bean.UserService</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析标签: property 并获取其 name、value、ref</span></span><br><span class="line"><span class="type">Element</span> <span class="variable">property</span> <span class="operator">=</span> (Element) bean.getChildNodes().item(j);</span><br><span class="line"><span class="type">String</span> <span class="variable">attrName</span> <span class="operator">=</span> property.getAttribute(<span class="string">&quot;name&quot;</span>); <span class="comment">// uId、userDao</span></span><br><span class="line"><span class="type">String</span> <span class="variable">attrValue</span> <span class="operator">=</span> property.getAttribute(<span class="string">&quot;value&quot;</span>); <span class="comment">// 10001</span></span><br><span class="line"><span class="type">String</span> <span class="variable">attrRef</span> <span class="operator">=</span> property.getAttribute(<span class="string">&quot;ref&quot;</span>); <span class="comment">// userDao</span></span><br></pre></td></tr></table></figure><p>读取下来的 className 通过反射机制：<code>forName()</code> 获取具体类信息 <code>clazz</code>，这是 注册 bean 信息的关键，<code>BeanDefinition(clazz)</code></p><p>XML中可以通过id、name两种方式指定 beanName 但 Spring 规定优先级：id &gt; name。所以默认以 id 作为 beanName，只有 id 不存在、才使用 name 指定</p><p><code>&lt;property&gt;</code>标签的值读取之后，作为属性信息注入到 bean 定义中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创造属性信息并注入到 bean 定义</span></span><br><span class="line"><span class="type">PropertyValue</span> <span class="variable">propertyValue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyValue</span>(attrName, value);</span><br><span class="line">beanDefinition.getPropertyValues().addPropertyValue(propertyValue);</span><br></pre></td></tr></table></figure><p>最后注册 BeanDefinition</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getRegister().registerBeanDefinition(beanName, beanDefinition);</span><br></pre></td></tr></table></figure><p>可以看到，我们将配置信息 <strong>从</strong> 在单元测试类手写 <strong>到</strong> 使用 XML 文件配置通过 Spring 自动读取。更能体现 Spring 中 DI 依赖注入思想。并且使用 getRegister() 而不是 register，防止污染具体的实现接口。整个设计十分优雅</p><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_xml</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.初始化 BeanFactory</span></span><br><span class="line">    <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 读取配置文件&amp;注册Bean</span></span><br><span class="line">    <span class="type">XmlBeanDefinitionReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(beanFactory);</span><br><span class="line">    reader.loadBeanDefinitions(<span class="string">&quot;classpath:spring.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取Bean对象调用方法</span></span><br><span class="line">    <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> beanFactory.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> userService.queryUserInfo();</span><br><span class="line">    System.out.println(<span class="string">&quot;测试结果：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回顾整篇文章，可以略探 Spring 框架的精髓，以配置文件为入口解析和注册 Bean 信息，最终再通过 Bean 工厂获取 Bean 以及做出相应调用操作</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 渐进式实现Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring系列之 探索AOP</title>
      <link href="/posts/5.html"/>
      <url>/posts/5.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring系列之-探索AOP"><a href="#Spring系列之-探索AOP" class="headerlink" title="Spring系列之 探索AOP"></a>Spring系列之 探索AOP</h1><p>大家好，我叫Spring，是众多程序员朋友们手中把玩的宠儿。AOP，作为我体内最重要的特性之一，自从我诞生以来，已经陪伴我度过了二十多年。为了让各位程序员朋友们尽可能地减少代码量，将“懒惰”这一美德发挥到极致，我早在诞生之前，就开始了广泛的探索和学习，以求能在现有方法、属性和代码块的基础上，批量地为它们添加额外的功能。对于那些追求代码简洁的朋友们来说，AOP就像如鸟入林，如鱼得水，如虎添翼。因此，我汲取了它的精髓，进化出了属于自己的AOP机制。虽然没有AspectJ那么全面，但它完美适应了我的内部环境。这绝不是抄袭，而是借鉴和创新！</p><p>最直接的应用当然是减少重复代码。比如，去理发店剪头发，过程不仅仅是剪发那么简单，还包括排队、洗头、剪发后再次洗头、吹头、结账等环节。如果我们用代码来模拟这一场景，会发现为每个理发师（Tony、Kevin等）都编写相同的排队、洗头、吹头、结账代码是多么的冗余。聪明的我们当然不会让这种事情发生，将这些通用流程抽取成公共方法调用是个不错的解决办法。但，这真的是最“懒”的做法吗？当然不是。既然这些重复的方法每次都得调用，那么在每次调用方法前，通过“切面”的方式来自动化这些流程，可以进一步减少大量的调用代码。这种方式就是我们所说的AOP思想，虽然我体内的AOP可能不像AspectJ那样强大，但它是最适合我的。那么，我是如何实现AOP的呢？</p><p>答案是代理模式。就像理发店里的助理一样，虽然顾客面对的是助理，但实际上是助理在代理发师完成一系列的服务。助理先带我们排队，给我们洗头，之后由真正的理发师剪发，最后助理再来为我们洗头、吹头，并收取费用。理发师们只提供剪发服务，而助理则是代理，能够代表理发师，同时在剪发前后添加额外的操作。这里的“顾客”相当于调用者，“正主理发师”是我们关注的对象，而“助理”则是代理。只有“剪发”行为本身不需要额外的增强，像“修刘海”这样的特定行为可能就不需要额外的流程了。</p><p>基于上述概念，代理模式具体实现上有两种主要类型：静态代理和动态代理。静态代理在代码运行前通过修改class文件完成，理论上可以提供无限的功能扩展，但复杂度较高，且无需在运行时做额外的事情，运行效率通常远超动态代理。实现方式有三种：一是在代码编译阶段，使用AspectJ编译器生成新的代理类，随后将新类加载到虚拟机中；二是在代码编译后，利用字节码技术重构class和jar文件，这在代理第三方jar包时尤为常见；三是IVM加载类时植入代理。</p><p>动态代理则是在代码运行时动态创建代理，功能受限并伴随一定的运行时性能开销，但使用起来更为便捷。通常有两种实现：一是使用CGLIB工具，通过字节码技术在运行时生成目标类的代理类；二是使用JDK Proxy，通过实现目标类接口来构造一个能够冒充目标类的代理类。需要注意的是，JDK Proxy有一个限制，即目标类必须实现至少一个接口。在原始的Spring框架中，如果目标类实现了任意接口，会使用JDK Proxy；否则，会采用CGLIB。然而，在Spring Boot中，无论目标类的情况如何，都会默认使用CGLIB进行代理，这样就规避了JDK Proxy的使用限制。</p><p>此外，我体内的AOP在使用过程中，确实会参考AspectJ框架的一些注解，但其功能和具体实现与AspectJ没有任何直接关系。最后，让我们看看哪些场景会使用AOP。无论是服务端还是移动端（如Android应用），我的AOP特性通常被用于实现性能统计、事务管理、缓存操作、统一异常处理、日志记录、权限控制、资源同步等辅助功能。在不需要引入AspectJ的情况下，AOP就能胜任这些工作。而在Android应用中，由于通常不使用Spring框架，因此对于增强需求，AspectJ成为了首选。</p><p>今天关于AOP的基础内容就介绍到这里。如果你喜欢这期视频，请记得长按点赞按钮，给我一个三连鼓励！</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【从零构建Spring|第四节】  Bean的属性注入</title>
      <link href="/posts/11404.html"/>
      <url>/posts/11404.html</url>
      
        <content type="html"><![CDATA[<h1 id="【从零构建Spring-第四节】-Bean的属性注入"><a href="#【从零构建Spring-第四节】-Bean的属性注入" class="headerlink" title="【从零构建Spring|第四节】  Bean的属性注入"></a>【从零构建Spring|第四节】  Bean的属性注入</h1><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>前几节内容，我们初步实现了一个容器、定义 Bean、注册 Bean 、实例化，按照是否包含构造函数实现不同的实例化策略。</p><p>本章节有以下变动：</p><ul><li>查询类中是否有属性，如果类中包含属性，在实例化时注入属性信息。对于属性的填充不只是 int、Long、String，还包括还没有实例化的对象属性，都需要在 Bean 创建时进行填充操作。<em>不过这里我们暂时不会考虑 Bean 的循环依赖，否则会把整个功能实现撑大，这样新人学习时就把握不住了，待后续陆续先把核心功能实现后，再逐步完善</em></li></ul><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p>鉴于属性填充是在 Bean 使用 <code>newInstance</code> 或者 <code>Cglib</code> 创建后，开始补全属性信息，那么就可以在类 <code>AbstractAutowireCapableBeanFactory</code> 的 createBean 方法中添加补全属性方法。</p><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/03.Bean%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5%E4%BB%A5%E5%8F%8A%E4%BE%9D%E8%B5%96Bean-assets/202302071100142.png" alt="image-20230207110026550"></p><ul><li>属性填充要在类实例化创建之后，也就是需要在 <code>AbstractAutowireCapableBeanFactory</code> 的 createBean 方法中添加 <code>applyPropertyValues</code> 操作。</li><li>由于我们需要在创建Bean时候填充属性操作，那么就需要在 bean 定义 BeanDefinition 类中，添加 PropertyValues 信息。</li><li>另外是填充属性信息还包括了 Bean 的对象类型，也就是需要再定义一个 BeanReference，里面其实就是一个简单的 Bean 名称，在具体的实例化操作时进行递归创建和填充，与 Spring 源码实现一样。<em>Spring 源码中 BeanReference 是一个接口</em></li></ul><h3 id="Spring-Bean-容器类关系"><a href="#Spring-Bean-容器类关系" class="headerlink" title="Spring Bean 容器类关系"></a>Spring Bean 容器类关系</h3><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/03.Bean%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5%E4%BB%A5%E5%8F%8A%E4%BE%9D%E8%B5%96Bean-assets/202302221150430.png" alt="手写Spring-属性注入"></p><ul><li>本章节中需要新增加3个类，<code>BeanReference</code>(类引用)、<code>PropertyValue</code>(属性值)、<code>PropertyValues</code>(属性集合)，分别用于类和其他类型属性填充操作。</li><li>另外改动的类主要是 <code>AbstractAutowireCapableBeanFactory</code>，在 createBean 中补全属性填充部分。</li></ul><h3 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h3><p>在实例化时注入属性信息。对于属性的填充不只是 int、Long、String，还包括还没有实例化的对象属性，既然类型不能确定。那么干脆用一个 PropertyValue 统一就好了，强制将 Bean 的属性都统一使用 PropertyValue 替代。其有两个属性：name、value，其中 value 存储非基本类型时，使用 BeanRefence 引用（beanName）来替代。</p><p>实例化 Bean 时，先会查看 PropertyValue 是否有自定义类型，如果有先实例化该类型，后即可通过 beanName 从 Spring IoC 容器中获取 Bean，最后才继续实例化当前 Bean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertyValue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PropertyValue</span><span class="params">(String name, Object value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...get/set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertyValues</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;PropertyValue&gt; propertyValueList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addPropertyValue</span><span class="params">(PropertyValue pv)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.propertyValueList.add(pv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PropertyValue[] getPropertyValues() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.propertyValueList.toArray(<span class="keyword">new</span> <span class="title class_">PropertyValue</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PropertyValue <span class="title function_">getPropertyValue</span><span class="params">(String propertyName)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (PropertyValue pv : <span class="built_in">this</span>.propertyValueList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pv.getName().equals(propertyName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> pv;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这两个类的作用就是创建出一个用于传递类中属性信息的类，因为属性可能会有很多，所以还需要定义一个集合包装下。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanReference</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String beanName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BeanReference</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.beanName = beanName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBeanName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> beanName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bean定义补全"><a href="#Bean定义补全" class="headerlink" title="Bean定义补全"></a>Bean定义补全</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanDefinition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class beanClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PropertyValues propertyValues;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BeanDefinition</span><span class="params">(Class beanClass)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.beanClass = beanClass;</span><br><span class="line">        <span class="built_in">this</span>.propertyValues = <span class="keyword">new</span> <span class="title class_">PropertyValues</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BeanDefinition</span><span class="params">(Class beanClass, PropertyValues propertyValues)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.beanClass = beanClass;</span><br><span class="line">        <span class="built_in">this</span>.propertyValues = propertyValues != <span class="literal">null</span> ? propertyValues : <span class="keyword">new</span> <span class="title class_">PropertyValues</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...get/set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 Bean 注册的过程中是需要传递 Bean 的信息，在几个前面章节的测试中都有所体现 <code>new BeanDefinition(UserService.class, propertyValues);</code></li><li>所以为了把属性一定交给 Bean 定义，所以这里填充了 PropertyValues 属性，同时把两个构造函数做了一些简单的优化，避免后面 for 循环时还得判断属性填充是否为空。</li></ul><h3 id="Bean-属性填充"><a href="#Bean-属性填充" class="headerlink" title="Bean 属性填充"></a>Bean 属性填充</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractBeanFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">InstantiationStrategy</span> <span class="variable">instantiationStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CglibSubclassingInstantiationStrategy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, BeanDefinition beanDefinition, Object[] args)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bean = createBeanInstance(beanDefinition, beanName, args);</span><br><span class="line">            <span class="comment">// 给 Bean 填充属性</span></span><br><span class="line">            applyPropertyValues(beanName, bean, beanDefinition);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeansException</span>(<span class="string">&quot;Instantiation of bean failed&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addSingleton(beanName, bean);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">createBeanInstance</span><span class="params">(BeanDefinition beanDefinition, String beanName, Object[] args)</span> &#123;</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructorToUse</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        Class&lt;?&gt; beanClass = beanDefinition.getBeanClass();</span><br><span class="line">        Constructor&lt;?&gt;[] declaredConstructors = beanClass.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor ctor : declaredConstructors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != args &amp;&amp; ctor.getParameterTypes().length == args.length) &#123;</span><br><span class="line">                constructorToUse = ctor;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getInstantiationStrategy().instantiate(beanDefinition, beanName, constructorToUse, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bean 属性填充</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">applyPropertyValues</span><span class="params">(String beanName, Object bean, BeanDefinition beanDefinition)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">PropertyValues</span> <span class="variable">propertyValues</span> <span class="operator">=</span> beanDefinition.getPropertyValues();</span><br><span class="line">            <span class="keyword">for</span> (PropertyValue propertyValue : propertyValues.getPropertyValues()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> propertyValue.getName();</span><br><span class="line">                <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> propertyValue.getValue();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (value <span class="keyword">instanceof</span> BeanReference) &#123;</span><br><span class="line">                    <span class="comment">// A 依赖 B，获取 B 的实例化</span></span><br><span class="line">                    <span class="type">BeanReference</span> <span class="variable">beanReference</span> <span class="operator">=</span> (BeanReference) value;</span><br><span class="line">                    value = getBean(beanReference.getBeanName());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 属性填充</span></span><br><span class="line">                BeanUtil.setFieldValue(bean, name, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeansException</span>(<span class="string">&quot;Error setting property values：&quot;</span> + beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> InstantiationStrategy <span class="title function_">getInstantiationStrategy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instantiationStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setInstantiationStrategy</span><span class="params">(InstantiationStrategy instantiationStrategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.instantiationStrategy = instantiationStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个类的内容稍微有点长，主要包括三个方法：createBean、createBeanInstance、applyPropertyValues，这里我们主要关注 createBean 的方法中调用的 applyPropertyValues 方法。</li><li>在 applyPropertyValues 中，通过获取 <code>beanDefinition.getPropertyValues()</code> 循环进行属性填充操作，如果遇到的是 BeanReference，那么就需要递归获取 Bean 实例，调用 getBean 方法。</li><li>当把依赖的 Bean 对象创建完成后，会递归回现在属性填充中。这里需要注意我们并没有去处理循环依赖的问题，这部分内容较大，后续补充。<em>BeanUtil.setFieldValue(bean, name, value) 是 hutool-all 工具类中的方法，你也可以自己实现</em></li></ul><p>Bean 生命周期：Bean 实例化 –&gt; 属性注入</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a><strong>测试</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        hashMap.put(<span class="string">&quot;10001&quot;</span>, <span class="string">&quot;半糖&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;10002&quot;</span>, <span class="string">&quot;小鲨鱼&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;10003&quot;</span>, <span class="string">&quot;bantanger&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">queryUserName</span><span class="params">(String uId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hashMap.get(uId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String uId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryUserInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询用户信息：&quot;</span> + userDao.queryUserName(uId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...get/set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Dao、Service，是我们平常开发经常使用的场景。在 UserService 中注入 UserDao，这样就能体现出Bean属性的依赖了。</li></ul><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_BeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.初始化 BeanFactory</span></span><br><span class="line">    <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. UserDao 注册</span></span><br><span class="line">    beanFactory.registerBeanDefinition(<span class="string">&quot;userDao&quot;</span>, <span class="keyword">new</span> <span class="title class_">BeanDefinition</span>(UserDao.class));   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. UserService 设置属性[uId、userDao]</span></span><br><span class="line">    <span class="type">PropertyValues</span> <span class="variable">propertyValues</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyValues</span>();</span><br><span class="line">    propertyValues.addPropertyValue(<span class="keyword">new</span> <span class="title class_">PropertyValue</span>(<span class="string">&quot;uId&quot;</span>, <span class="string">&quot;10001&quot;</span>));</span><br><span class="line">    propertyValues.addPropertyValue(<span class="keyword">new</span> <span class="title class_">PropertyValue</span>(<span class="string">&quot;userDao&quot;</span>,<span class="keyword">new</span> <span class="title class_">BeanReference</span>(<span class="string">&quot;userDao&quot;</span>)));  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. UserService 注入bean</span></span><br><span class="line">    <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinition</span>(UserService.class, propertyValues);</span><br><span class="line">    beanFactory.registerBeanDefinition(<span class="string">&quot;userService&quot;</span>, beanDefinition);    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. UserService 获取bean</span></span><br><span class="line">    <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) beanFactory.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">    userService.queryUserInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>与直接获取 Bean 对象不同，这次我们还需要先把 userDao 注入到 Bean 容器中。<code>beanFactory.registerBeanDefinition(&quot;userDao&quot;, new BeanDefinition(UserDao.class));</code></li><li>接下来就是属性填充的操作了，一种是普通属性 <code>new PropertyValue(&quot;uId&quot;, &quot;10001&quot;)</code>，另外一种是对象属性 <code>new PropertyValue(&quot;userDao&quot;,new BeanReference(&quot;userDao&quot;))</code></li><li>接下来的操作就简单了，只不过是正常获取 userService 对象，调用方法即可。</li></ul><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">查询用户信息：半糖</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>从测试结果看我们的属性填充已经起作用了，因为只有属性填充后，才能调用到Dao方法，如：<code>userDao.queryUserName(uId)</code></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li>在本章节中我们把 AbstractAutowireCapableBeanFactory 类中的创建对象功能又做了扩充，依赖于是否有构造函数的实例化策略完成后，开始补充 Bean 属性信息。当遇到 Bean 属性为 Bean 对象时，需要<strong>递归处理</strong>。最后在属性填充时需要用到反射操作，也可以使用一些工具类处理。</li><li>本章也体现一种统一思想，Java 里面的 Object 类就是统一的类，所有的类的父对象都是 Object，在我们常用的 Mybatis 里面也有统一的IService 类，这个类是所有 Service 类的统一类。而这一步我们实现的类里面 PropertyValue 也算是一种统一，既是把所有 Bean 对象里面的成员对象统一包装成 PropertyValue，就不用管他原先到底是什么类型的对象了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 渐进式实现Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring系列之 AOP原理篇</title>
      <link href="/posts/5.html"/>
      <url>/posts/5.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring系列之-AOP原理篇"><a href="#Spring系列之-AOP原理篇" class="headerlink" title="Spring系列之 AOP原理篇"></a>Spring系列之 AOP原理篇</h1><p>大家好，我叫Spring，是众多程序员朋友手心的宝贝，AOP作为我体内的重要组成部分，尽管其重要性无可替代，但使用起来却相当直观和简便。我们只需创建一个类，并将其标记为切面(@Aspect)，即可激活AOP的功能。在切面类中定义增强方法，使用如@After、@AfterReturning、@Around等注解来指示增强逻辑在目标方法执行的不同阶段介入。例如，@After在方法执行后触发，@AfterReturning在方法正常返回后执行，而@Around则可以完全包围目标方法。</p><p>让我们举个例子，假如我们想在某个方法执行后记录日志，只需简单地添加@After注解即可。如果想要在方法抛出异常后执行特定逻辑，则可以使用@AfterThrowing。通过这些注解，我们可以精准地针对特定类的特定方法实施增强。一旦完成了这些基本设置，AOP就可以在我的环境中发挥作用了。当原有的bean方法被调用时，相应的增强逻辑就会自动执行。</p><p>那么，AOP在我体内是如何运行的呢？当我启动时，会创建IOC容器，并对容器中的bean进行三个关键步骤：构造、属性注入、初始化。AOP的实现可以视为IOC容器的一个附加功能，特别是在处理AOP后置处理器方面。bean的完整生命周期和AOP的集成在系列教程的第一集中有详细介绍。</p><p>在bean初始化完成后，我会检查是否需要对该bean应用AOP。如果配置的切面条件符合，我将为符合条件的bean创建代理对象，以实现AOP。为了统一和简化代理对象的创建，我提供了一个代理工厂，它可以根据具体情况选择CGLIB或JDK Proxy作为代理策略。通常，我会将proxyTargetClass属性设置为true，以强制使用CGLIB，这也是Spring Boot的默认配置。然而，如果该属性设为false，且目标类实现了至少一个接口，系统将使用JDK Proxy；否则，仍会使用CGLIB。</p><p>确定了代理策略后，代理工厂将目标bean封装为其内部的一个成员变量。当我们调用bean的方法时，实际上是在执行代理对象的invoke方法。该方法首先解析execution表达式，找到与当前方法匹配的所有增强方法，并按顺序排列成调用链。接下来，代理对象会按照责任链模式依次执行这些增强方法，其间会插入并执行目标bean的真实方法。</p><p>以CGLIB AOP Proxy为例，它在getProxy方法中构建代理对象，并通过enhancer.create()生成代理实例。与JDK Proxy不同，CGLIB基于ASM（Java字节码生成库）生成新的.class文件，这意味着即使目标bean没有实现任何接口，也能为其创建代理对象。当调用bean方法时，会先执行代理对象的intercept方法，如同JDK Proxy一样，通过责任链模式执行所有增强逻辑。</p><p>以上就是AOP在Spring框架中底层原理的概述。如果你能耐心阅读至此，那必定是我的忠实粉丝了。各位大佬，别忘了长按点赞按钮，给我一个三连，你的支持是我前进的动力！</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【从零构建Spring|第三节】  JDK和Cglib动态代理实例化策略</title>
      <link href="/posts/11403.html"/>
      <url>/posts/11403.html</url>
      
        <content type="html"><![CDATA[<h1 id="【从零构建Spring-第三节】-JDK和Cglib动态代理实例化策略"><a href="#【从零构建Spring-第三节】-JDK和Cglib动态代理实例化策略" class="headerlink" title="【从零构建Spring|第三节】  JDK和Cglib动态代理实例化策略"></a>【从零构建Spring|第三节】  JDK和Cglib动态代理实例化策略</h1><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>在上一节中，出现了一个小问题：没法实例化有参构造对象</p><p>本章节有以下变动：</p><ul><li>使用Cglib字节码方式、JDK内部方式进行有参对象的实例化</li><li>后续章节可采用策略模式优化策略的选择</li></ul><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/02.%E4%BF%AE%E5%A4%8D%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E6%8A%A5%E9%94%99bug-assets/202302212024143.png" alt="手写Spring-属性注入"></p><p>这里不小心把下一节的 UML 画了。。。</p><p>因为比较简单，就只展示 Cglib 字节码和 JDK 两种实例化对象的代码了</p><h3 id="Cglib方式："><a href="#Cglib方式：" class="headerlink" title="Cglib方式："></a>Cglib方式：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibSubclassingInstantiationStrategy</span> <span class="keyword">implements</span> <span class="title class_">InstantiationStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">instantiate</span><span class="params">(BeanDefinition beanDefinition, String beanName, Constructor ctor, Object[] args)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(beanDefinition.getBeanClass());</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">NoOp</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">super</span>.hashCode();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == ctor) &#123;</span><br><span class="line">            <span class="keyword">return</span> enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> ctor != <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> enhancer.create(ctor.getParameterTypes(), args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>核心方法为 Enhancer.create</li></ul><h3 id="JDK方式："><a href="#JDK方式：" class="headerlink" title="JDK方式："></a>JDK方式：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleInstantiationStrategy</span> <span class="keyword">implements</span> <span class="title class_">InstantiationStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">instantiate</span><span class="params">(BeanDefinition beanDefinition, String beanName, Constructor ctor, Object[] args)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> beanDefinition.getBeanClass();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (args != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 有参构造</span></span><br><span class="line">                <span class="keyword">return</span> clazz.getDeclaredConstructor(ctor.getParameterTypes()).newInstance(args);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 无参构造</span></span><br><span class="line">                <span class="keyword">return</span> clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeansException</span>(<span class="string">&quot;Failed to instantiate [&quot;</span> + clazz.getName() + <span class="string">&quot;]&quot;</span></span><br><span class="line">                    + <span class="string">&quot; -- [&quot;</span> + clazz.getName() + <span class="string">&quot;] 实例化失败&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>核心方法：getDeclaredConstructor(…)</li></ul><p>具体的调用在 AbstractAutowrieCapableBeanFactory</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_BeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 初始化 BeanFactory</span></span><br><span class="line">    <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanF</span></span><br><span class="line">        actory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 注册 Bean</span></span><br><span class="line">    <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinition</span>(UserService.class);</span><br><span class="line">    beanFactory.registerBeanDefinition(<span class="string">&quot;userService&quot;</span>, beanDefinition);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 无参 Bean</span></span><br><span class="line">    <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) beanFactory.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">    userService.queryUserInfo();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 有参 Bean 有 bug, bean 没法区分有参无参</span></span><br><span class="line">    <span class="type">UserService</span> <span class="variable">userService_args</span> <span class="operator">=</span> (UserService) beanFactory.getBean(<span class="string">&quot;userService&quot;</span>, <span class="string">&quot;半糖&quot;</span>);</span><br><span class="line">    userService_args.queryUserInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_dnsauth</p><p>202405010000001c5kq42954wu3x1udfifby92t5uw4pfdnl57d3lkwi0zz6p5ur</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 渐进式实现Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring系列之 Bean的生命周期</title>
      <link href="/posts/2.html"/>
      <url>/posts/2.html</url>
      
        <content type="html"><![CDATA[<h2 id="Spring系列之-Bean的生命周期"><a href="#Spring系列之-Bean的生命周期" class="headerlink" title="Spring系列之 Bean的生命周期"></a>Spring系列之 Bean的生命周期</h2><p>我叫<code>Spring</code>，今天为大家介绍<code>5.x</code>版本的我，体内最核心的运行原理之一——<code>IOC</code>（控制反转）中<code>Bean</code>的生命周期。后续将基于此一步一步拆解我的身体，为大家做更多的原理性介绍，帮大家在面试和走向架构岗位做一点点贡献。</p><p>首先程序员大哥们在我身体上编写的各种<code>Bean</code>, 是我的体内最为核心的东西。</p><p><code>Bean</code>在我体内，会经历三个大的阶段：<strong>生产、使用、销毁</strong>。其中，以生产阶段最为复杂。在程序员命令我启动的那一刻开始，我体内的生产线就开始准备生产一个个的<code>Bean</code>。<br>启动过程很复杂，下一个视频会为大家详细介绍。</p><p>在我启动之初，为了精准地了解程序员对于<code>Bean</code>的要求，我使用XML配置、注解扫描等各种方式，将程序员在我体内定义的<code>Bean</code>类一个个找到，即<code>BeanDefinitionMap</code>。</p><p>有了这些“<code>Bean</code>定义”集合之后，我就可以遍历这个集合，然后通过我体内的<code>createBean</code>方法，为程序员创建一个个<code>Bean</code>对象。</p><p>创建<code>Bean</code>大体分为“<strong>构造对象、填充属性、初始化实例、注册销毁</strong>”四个步骤：</p><p>首先，<strong>构造对象</strong>。我用反射机制从“<code>Bean</code>定义”中的<code>BeanClass</code>拿到这个类的构造方法。当然，我在拿取构造方法时，是有一些规则的。</p><p>如果这个<code>Bean</code>只有一个构造方法，那毫无疑问我只能拿它，无论这个构造方法有没有入参。当<code>Bean</code>中有多个构造方法时，我会先拿带有<code>@Autowired</code>注解的构造方法。当然，如果多个构造方法都加了<code>@Autowired</code>注解，那么我只能报错。如果构造方法都没有<code>@Autowired</code>注解，我就会优先拿无入参的方法。如果多个构造方法都是有入参的，我也无法判断具体拿哪一个，所以又要报错。我非常不建议程序员在任何Bean中添加多个构造方法，这样可读性低，理解和维护会很困难。<br>在我们选择了确定的构造方法之后，就要准备这个构造方法需要的参数了。我会在我的单例池中，根据参数的<code>Class</code>类进行查找。如果这个类在我的体内有多个实例，则会根据参数名再进行匹配。如果没有找到，我就会认为构造信息导致不完整，而直接报错。在参数准备好之后，通过反射就可以进行<code>Bean</code>的构造，也就是我们常说的实例化。当然，如果选择的是无参构造方法，则无需参数直接构造。</p><p>其次，<strong>填充属性</strong>。在<code>Bean</code>对象构造成功后，接下来就进行属性填充。通常就是<code>@Autowired</code>注解的这些变量，我会通过“<strong>三级缓存</strong>”机制进行填充，也就是我们所谓的依赖注入。三级缓存后续会详细介绍。</p><p>然后<strong>初始化实例</strong>，在属性填充后，紧接着就要通过<code>initializeBean</code>方法，对这个实例进行初始化了。初始化的第一步是初始化容器相关信息，通过<code>invokeAwareMethods</code>方法，为实现了各种<code>Aware</code>接口的<code>Bean</code>设置诸如<code>beanName</code>、<code>beanFactory</code>等容器信息。这里要注意的是，我体内的<code>Aware</code>接口代表“信息感知”接口，一旦实现了这些接口，就可以在<code>Bean</code>实例中感知并获取到对应的信息，真的非常方便。这个初始化方法，是程序员通过实现<code>InitializingBean</code>接口而实现的<code>afterPropertiesSet</code>方法，方法名很直接，表示“<code>Bean</code>填充属性后”执行。在<code>afterPropertiesSet</code>执行后，在执行初始化方法之前和之后，我通过<code>applyBeanPostProcessorsBeforeInitialization</code>和<code>applyBeanPostProcessorsAfterInitialization</code>，处理各种<code>Bean</code>的后置处理器。这些处理器包括我自身提供的负责<code>AOP</code>处理的<code>AspectJ</code>、<code>InitDestroyAnnotationBeanPostProcessor</code>等系统级处理器，以及程序员通过实现<code>BeanPostProcessor</code>接口的自定义处理器。当然，这些处理器有很多，可以通过实现<code>PriorityOrdered</code>接口来指定顺序，进行逐一处理。</p><p>最后，<strong>注册销毁</strong>。其实上面步骤完成时，<code>Bean</code>实例就已经可用了。为了让<code>Bean</code>优雅地销毁，我通过<code>registerDisposableBean</code>方法，这样在销毁时就可以执行<code>destroy</code>方法了。通过以上四小步，我们就将<code>Bean</code>创建好了。这样，“产生<code>Bean</code>”就全部完成啦。<br>接下来，最后，当我执行<code>close</code>关闭睡觉的时候，和“产生<code>Bean</code>”类似，在销毁之前要先执行“销毁前处理器”。这里就会执行<code>Bean</code>中的<code>@PreDestroy</code>注解的方法，销毁时会执行刚提到的<code>destroy</code>方法。在<code>destroy</code>执行之后，执行客自定义的代码。<code>Bean</code>的生产、使用到销毁这一套完整的生命周期就介绍完了。<br>如果你喜欢这期视频的话，请一定记得长按点赞按钮。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【从零构建Spring|第二节】  工厂, 模板方法模式优化Bean容器</title>
      <link href="/posts/11402.html"/>
      <url>/posts/11402.html</url>
      
        <content type="html"><![CDATA[<h1 id="【从零构建Spring-第二节】-工厂-模板方法模式优化Bean容器"><a href="#【从零构建Spring-第二节】-工厂-模板方法模式优化Bean容器" class="headerlink" title="【从零构建Spring|第二节】  工厂, 模板方法模式优化Bean容器"></a>【从零构建Spring|第二节】  工厂, 模板方法模式优化Bean容器</h1><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>在上一节中，只是简单创建了 BeanDefinition 和 BeanFactory</p><p>本章节有以下变动：</p><ul><li>使用单例模式注册 Bean 容器，从而实现对象第二次获取时可以从内存中获取对象</li><li>使用工厂模式将 Bean 的创建过程交给容器，而不是在调用时期传递一个实例化好的 Bean 对象</li><li>使用模板模式统一通用核心方法的调用逻辑和标准定义</li></ul><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>完善 Spring Bean：注册 Register 和获取 Get</p><p>架构图</p><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/01.%E4%BD%BF%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96Bean%E5%AE%B9%E5%99%A8-assets/202302061901732.png" alt="image-20230206190106725"></p><h3 id="注册-Register"><a href="#注册-Register" class="headerlink" title="注册 Register"></a>注册 Register</h3><p>提示</p><p>非常重要的一点是 Bean 注册时只注册一个类信息，而不会直接将实例化信息注册到 Spring 容器中，所以我们修改 BeanDefinition 中的属性 bean，将类型从 Object 转换为 Class。</p><p>负责 bean 对象第一次注册，之后存储到 单例对象缓存中，Get 直接从内存中获取</p><h3 id="获取-Get"><a href="#获取-Get" class="headerlink" title="获取 Get"></a>获取 Get</h3><p>提示</p><p>获取 Bean 对象时就需要处理 Bean 的对象实例化操作以及判断当前单例对象是否在容器里缓存起来。</p><ol><li>定义 BeanFactory 也就是 Bean 工厂接口，提供 Bean 获取方法 getBean(String name)</li><li>这个接口由抽象类 AbstractBeanFacotry 实现，其中使用模板模式实现通用核心方法的统一调度，让后续的实现不需要关心调用逻辑，只需关心具体的实现</li><li>继承抽象类 AbstractBeanFactory 后的 AbstractAutowireCapableBeanFactory 实现 Bean 的实例化</li><li>定义 SingletonBeanRegistry 单例接口，用 DefaultSingletonBeanRegistry 对接口实现后，会被抽象类 AbstractBeanFactory 继承。</li></ol><h2 id="工程"><a href="#工程" class="headerlink" title="工程"></a>工程</h2><h3 id="Spring-Bean-容器类关系"><a href="#Spring-Bean-容器类关系" class="headerlink" title="Spring Bean 容器类关系"></a>Spring Bean 容器类关系</h3><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/01.%E4%BD%BF%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96Bean%E5%AE%B9%E5%99%A8-assets/202302211645241.png" alt="image-20230221164540596"></p><ul><li>BeanFactory 接口工厂通过 AbstractBeanFactory 抽象类实现接口的 getBean 方法</li><li>AbstractBeanFactory 又继承了实现了 SingletonBeanRegistry 的 DefaultSingletonBeanRegister 类，从而让其具有单例 Bean 的注册功能</li><li>AbstractBeanFactory 定义两个抽象方法：<ul><li>getBeanDefinition(String beanName)，其由 DefaultListableBeanFacotry 实现</li><li>createBean(String beanName, BeanDefinition beanDefinition)，其由 AbstractAutowireCapableBeanFactory 实现</li></ul></li><li>DefaultListableBeanFactory 继承抽象类 AbstractAutowireCapableBeanFactory 也就可以调用抽象类中的 createBean 方法了</li></ul><h3 id="BeanDefinition-定义"><a href="#BeanDefinition-定义" class="headerlink" title="BeanDefinition 定义"></a>BeanDefinition 定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanDefinition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class beanClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BeanDefinition</span><span class="params">(Class beanClass)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.beanClass = beanClass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...get/set</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 Bean 定义类中已经把上一章节中的 Object bean 替换为 Class，这样就可以把 Bean 的实例化操作放到容器中处理了。本质上是通过类的反射实例化 Bean 对象</li></ul><h3 id="单例注册接口定义和实现"><a href="#单例注册接口定义和实现" class="headerlink" title="单例注册接口定义和实现"></a>单例注册接口定义和实现</h3><p>Spring中bean的默认作用域就是singleton。</p><p>以下内容看不明白可暂时跳过</p><p>除了 singleton（单例作用域），Spring bean还有下面几种作用域：</p><ul><li>prototype（原型作用域） : 每次请求都会创建一个新的 bean 实例。</li><li>request: 每一次HTTP请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li><li>session: 每一次HTTP请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li></ul><p>Spring实现单例的方式：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xml格式：&lt;bean <span class="built_in">id</span>=<span class="string">&quot;userService&quot;</span> class=<span class="string">&quot;top.snailclimb.UserService&quot;</span> scope=<span class="string">&quot;singleton&quot;</span>/&gt;</span><br><span class="line">注解：@Scope(value = <span class="string">&quot;singleton&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="定义-BeanFactory-工厂"><a href="#定义-BeanFactory-工厂" class="headerlink" title="定义 BeanFactory 工厂"></a>定义 BeanFactory 工厂</h3><p>这里使用工厂模式，目的是<strong>延迟注入</strong>，也就是使用到某个 bean 时才会注入这个 bean 对象的相关信息。配合上<strong>单例模式缓存</strong>已经注册的 bean 信息，<strong>相较于 ApplicationContext 占用的内存更少，启动速度更快</strong>。</p><p>而 ApplicationContext ，在容器启动的时候，不管你用没用到，一次性创建所有 bean 。BeanFactory 仅提供了最基本的依赖注入支持，ApplicationContext 扩展了 BeanFactory ,除了有 BeanFactory 的功能还有额外更多功能，所以一般开发人员使用ApplicationContext 会更多。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 Bean 实例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象类定义模板方法-AbstractBeanFactory"><a href="#抽象类定义模板方法-AbstractBeanFactory" class="headerlink" title="抽象类定义模板方法(AbstractBeanFactory)"></a>抽象类定义模板方法(AbstractBeanFactory)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractBeanFactory</span> <span class="keyword">extends</span> <span class="title class_">DefaultSingletonBeanRegistry</span> <span class="keyword">implements</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> getSingleton(name);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 单例 bean 对象已经存在于缓存中，直接获取返回</span></span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取不到 bean，说明是第一次注册，通过 bean 的定义完成实例化操作</span></span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> getBeanDefinition(name);</span><br><span class="line">        <span class="keyword">return</span> createBean(name, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> BeanDefinition <span class="title function_">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>AbstractBeanFactory 首先继承了 DefaultSingletonBeanRegistry，也就具备了使用单例注册类方法。</li><li>接下来很重要的一点是关于接口 BeanFactory 的实现，在方法 getBean 的实现过程中可以看到，主要是对单例 Bean 对象的获取以及在获取不到时需要拿到 Bean 的定义做相应 Bean 实例化操作。那么 getBean 并没有自身的去实现这些方法，而是只定义了调用过程以及提供了抽象方法，由实现此抽象类的其他类做相应实现。</li><li>后续继承抽象类 AbstractBeanFactory 的类有两个，包括：AbstractAutowireCapableBeanFactory、DefaultListableBeanFactory，这两个类分别做了相应的实现处理</li></ul><h3 id="实例化Bean类-AbstractAutowireCapableBeanFactory"><a href="#实例化Bean类-AbstractAutowireCapableBeanFactory" class="headerlink" title="实例化Bean类(AbstractAutowireCapableBeanFactory)"></a>实例化Bean类(AbstractAutowireCapableBeanFactory)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractBeanFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        Object bean;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从 BeanDefinition 获取 Bean 的类信息，实例化完整的类，但只能实例无参构造对象</span></span><br><span class="line">            bean = beanDefinition.getBeanClass().newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeansException</span>(<span class="string">&quot;实例化容器失败 Instantiation of bean failed&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将注册好的实例 Bean 存入单例对象缓存中</span></span><br><span class="line">        addSingleton(beanName, bean);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 AbstractAutowireCapableBeanFactory 类中实现了 Bean 的实例化操作 <code>newInstance</code>，其实这块会埋下一个坑，有构造函数入参的对象怎么处理？<em>可以提前思考</em></li><li>在处理完 Bean 对象的实例化后，直接调用 <code>addSingleton</code> 方法存放到单例对象的缓存中去。</li></ul><h3 id="核心类实现-DefaultListableBeanFactory"><a href="#核心类实现-DefaultListableBeanFactory" class="headerlink" title="核心类实现(DefaultListableBeanFactory)"></a>核心类实现(DefaultListableBeanFactory)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultListableBeanFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractAutowireCapableBeanFactory</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> BeanDefinition <span class="title function_">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> beanDefinitionMap.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (beanDefinition == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeansException</span>(<span class="string">&quot;No bean named &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; is defined&quot;</span> + <span class="string">&quot; -- &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; 没有被定义&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanDefinition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> &#123;</span><br><span class="line">        beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>DefaultListableBeanFactory 在 Spring 源码中也是一个非常核心的类</strong>，它对 Spring IoC 提供了生产和获取 Bean 的方法，DefaultListableBeanFactory 继承了 AbstractAutowireCapableBeanFactory 类，也就具备了接口 BeanFactory 和 AbstractBeanFactory 等一连串的功能实现。<em>所以有时候你会看到一些类的强转，调用某些方法，也是因为你强转的类实现接口或继承了某些类。</em></li><li>除此之外这个类还实现了接口 BeanDefinitionRegistry 中的 registerBeanDefinition(String beanName, BeanDefinition beanDefinition) 方法，当然你还会看到一个 getBeanDefinition 的实现，这个方法我们文中提到过它是抽象类 AbstractBeanFactory 中定义的抽象方法。<em>现在注册Bean定义与获取Bean定义就可以同时使用了，是不感觉这个套路还蛮深的。接口定义了注册，抽象类定义了获取，都集中在 DefaultListableBeanFactory 中的 beanDefinitionMap 里</em></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_BeanFactory</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.初始化 BeanFactory</span></span><br><span class="line">    <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">    <span class="comment">// 2.注册 bean</span></span><br><span class="line">    <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinition</span>(UserService.class);</span><br><span class="line">    beanFactory.registerBeanDefinition(<span class="string">&quot;userService&quot;</span>, beanDefinition);</span><br><span class="line">    <span class="comment">// 3.第一次获取 bean</span></span><br><span class="line">    <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) beanFactory.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">    userService.queryUserInfo();</span><br><span class="line">    <span class="comment">// 4.第二次获取 bean from Singleton</span></span><br><span class="line">    <span class="type">UserService</span> <span class="variable">userService_singleton</span> <span class="operator">=</span> (UserService) beanFactory.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">    userService_singleton.queryUserInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在此次的单元测试中除了包括；Bean 工厂、注册 Bean、获取 Bean，三个步骤，还额外增加了一次对象的获取和调用。这里主要测试验证单例对象的是否正确的存放到了缓存中。</li><li>此外与上一章节测试过程中不同的是，我们把 UserService.class 传递给了 BeanDefinition 而不是像上一章节那样直接 new UserService() 操作。</li></ul><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">查询用户信息</span><br><span class="line">查询用户信息</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><ul><li>这里会有两次测试信息，一次是获取 Bean 时直接创建的对象，另外一次是从缓存中获取的实例化对象。</li><li>此外从调试的截图中也可以看到第二次获取单例对象，已经可以从内存中获取了，如图 3-3<img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/01.%E4%BD%BF%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96Bean%E5%AE%B9%E5%99%A8-assets/202302062147388.png" alt="图片"></li><li>到这本章节的功能实现和测试验证就完成了，关于测试过程中可以再去断点调试下各个阶段类的调用，熟悉调用关系。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 渐进式实现Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring系列之 IOC容器的创建</title>
      <link href="/posts/24494.html"/>
      <url>/posts/24494.html</url>
      
        <content type="html"><![CDATA[<h2 id="Spring系列之-IOC容器的创建"><a href="#Spring系列之-IOC容器的创建" class="headerlink" title="Spring系列之 IOC容器的创建"></a>Spring系列之 IOC容器的创建</h2><p>我叫Spring，是一个万千程序员朋友们每天都在手心把玩的小宝贝。上次为各位朋友们介绍了我是如何通过<code>SpringApplication.run(String[])</code>启动，今天为大家详细介绍第四个大阶段“填充容器”，也就是面试中最频繁问到的步骤“自动装配Bean”。</p><p>这一阶段共分为12个小步骤：</p><p><strong>第一步</strong>，我会通过<code>prepareRefresh</code>方法，在已有的“系统环境”基础上，准备Servlet相关的环境。其他的环境配置在第二个大阶段“环境准备”中就已经注册完成了，具体可以参考合集的第二集。这一步还包括对<code>ServletConfig.InitParams</code>进行赋值，然后通过<code>validateRequiredProperties</code>方法验证是否有必填的环境变量。最终，完成监听器和事件初始化之后，环境准备就完成了。</p><p><strong>第二步和第三步</strong>，由于Spring Boot选择了<code>ServletWebServerApplicationContext</code>作为容器，在之前的步骤已经构造好了<code>BeanFactory</code>，因此<code>obtainFreshBeanFactory</code>中不进行任何处理。不过值得注意的是，对于原生的Spring来说，每次执行<code>obtainFreshBeanFactory</code>时，都会重新加载“Bean定义”<code>BeanDefinition</code>。而在准备容器<code>prepareBeanFactory</code>过程中，主要准备“类加载器”<code>BeanClassLoader</code>、“表达式解析器”<code>BeanExpressionResolver</code>以及两个“Bean后置处理器”！同时会注册一些“特殊Bean”和“系统级Bean”，比如容器本身<code>BeanFactory</code>和<code>ApplicationContext</code>，将它们放入“特殊对象池”和“单例池”中。</p><p><strong>第四步</strong>，我会通过<code>postProcessBeanFactory</code>方法，对<code>BeanFactory</code>进行额外设置或修改，同时也注册与Servlet相关的一些特殊Bean。</p><p><strong>第五步</strong>，开始执行我非常核心的<code>invokeBeanFactoryPostProcessors</code>方法。首先，我会逐一执行在第三个大阶段“容器创建”中注册的<code>BeanFactoryPostProcessor</code>实例，其中最主要的就是用来加载所有“Bean定义”的“配置处理器”<code>ConfigurationClassPostProcessor</code>。通过它加载所有<code>@Configuration</code>配置类，并通过<code>CassPathBeanDefinitionScanner</code>中的<code>doScan</code>方法扫描每个类，将所有扫描出来的“Bean定义”都放到“Bean定义池”<code>BeanDefinitionMap</code>中。</p><p><strong>第六步</strong>，我要通过<code>registerBeanPostProcessors</code>方法，检索所有的“Bean后置处理器”，同时根据指定的<code>order</code>为它们进行排序，然后放入“后置处理器池”<code>beanPostProcessors</code>中。每一个“Bean后置处理器”都会在Bean初始化之前和之后分别执行对应的逻辑。</p><p><strong>第七步和第八步</strong>，涉及到两个关键的Bean注册：一个是用于Web服务器的Bean，另一个是用于自定义广播事件的Bean。我体内默认的服务器是Tomcat，接下来通过<code>getWebServer</code>方法构造一个Tomcat对象，同时通过<code>start</code>方法进行启动，这样我体内的Web服务器就开始运行了。</p><p><strong>第九步</strong>，通过<code>registerListeners</code>方法，在Bean中查找所有的“监听器Bean”，将它们注册到<code>ApplicationEventMulticaster</code>中。</p><p><strong>第十步</strong>，这一步就是通过<code>finishBeanFactoryInitialization</code>方法完成剩余的初始化工作。这个过程较为复杂，需要详细理解可以参考合集的第一集。</p><p><strong>第十一步</strong>，<code>Bean</code>生成之后会放入“单例池”<code>singletonObjects</code>中。</p><p><strong>第十二步</strong>，这最后一步我会通过<code>finishRefresh</code>方法完成容器的最终刷新，当然，在容器关闭时也会自动调用对应的<code>stop</code>方法。接着发布一个“容器刷新完成”的事件之后，整个12步的“填充容器”就完成了。</p><p>如果你喜欢这期视频的话，请一定记得长按点赞按钮，求各位朋友们一个三连鼓励，给我一些信心坚持制作下去。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis最佳实践</title>
      <link href="/posts/41949.html"/>
      <url>/posts/41949.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis最佳实践"><a href="#Redis最佳实践" class="headerlink" title="Redis最佳实践"></a><code>Redis最佳实践</code></h1><p>🎉 本文, 我们将深入探索 <code>Redis</code>，一个强大且实用的开源内存数据库 , 以<strong>键值对</strong>形式提供数据结构存储服务。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>💾始于缓存</p><p>​在常见的 Web 应用架构中，静态内容（如 <code>HTML</code>、<code>CSS</code>、<code>JS</code>、<code>图片</code>等）可通过 <code>CDN</code> 或 <code>nginx</code> 缓存；而对于数据库中的动态数据，为减轻后端数据库的压力，可利用 <code>Redis</code> 来<strong>缓存</strong>那些不常变更的部分。</p><p>🔒 <code>Redis </code>不止于缓存</p><p>​除作为缓存工具外，<code>Redis</code> 还能充当<strong>分布式锁</strong>的角色，确保在高并发场景下的<strong>数据一致性</strong>。此外，它还提供了丰富的高效<strong>数据结构与算法</strong>供开发者使用</p><p>📚 <code>Redis</code> <strong>数据结构</strong>一览</p><p>Redis 常用的数据结构包括但不限于：</p><ol><li><strong>String</strong>：基本的键值对存储。</li><li><strong>List</strong>：双向链表，支持两端插入、弹出元素。</li><li><strong>Set</strong>：无序集合，自动去重。</li><li><strong>Sorted Set</strong>：有序集合，每个成员带有分数属性，按分数排序。</li><li><strong>Hash</strong>：键值对集合，适用于存储对象型数据。</li></ol><p>💡 学习策略</p><p>面对可能略显枯燥的 <code>Redis</code> 命令，我们的学习策略是结合实际应用场景逐一解析，让理论知识与实践操作紧密结合，便于理解与记忆。</p><p>📢 注意事项：</p><p>​<em>尽管 <code>Redis</code> 支持<strong>消息队列</strong>和<strong>流处理</strong>功能，但我们并<strong>不推荐</strong>将其用于此类场景。针对消息队列的需求，建议选用专门的服务，如 <code>Kafka</code> 或 <code>RabbitMQ</code>，它们在性能、可靠性和功能上更胜一筹。</em></p><p>​<em>至于 <code>Redis</code> 的发布&#x2F;订阅及 <code>Stream </code>数据结构，虽可用但不够理想，学习时应聚焦 <code>Redis</code> 的核心数据结构及其实际应用。</em></p><p>🚀 <code>Redis</code>特性解析</p><ol><li><p><strong>高性能内存数据库</strong>：所有数据在内存中操作，赋予 <code>Redis</code> 极高的读写速度。闪电般的响应时间使其成为缓存首选。</p></li><li><p><strong>C 语言编写，高效架构</strong>：底层采用 C 语言编写，保证了代码执行效率。<strong>多路复用</strong>和<strong>非阻塞 I&#x2F;O 模型</strong>使得 <code>Redis </code>能够轻松应对<strong>高并发场景</strong>。</p></li><li><p><strong>数据持久化</strong>：<code>Redis</code> 支持将数据同步至磁盘，防止因意外情况导致内存数据丢失。持久化有两种方式：</p><ul><li><strong>快照（<code>RDB</code>）</strong>：定时将内存数据生成数据文件。</li><li><strong>日志（<code>AOF</code>）</strong>：记录每次写操作，重启时重新执行以恢复数据。这两种方式将在后续视频中详细解读。</li></ul></li><li><p><strong>高可用与分布式</strong>：<code>Redis</code> 提供了<strong>多种部署模式</strong>以实现<strong>高可用</strong>与<strong>分布式</strong>系统支持：</p><ul><li><strong>哨兵模式（<code>Sentinel</code>）</strong>：监控主从节点状态，自动故障转移。</li><li><strong>主从复制</strong>：数据在多个实例间同步，提高数据冗余与可用性。</li><li><strong>分布式集群</strong>：数据分片，负载均衡，实现大规模数据处理能力。</li></ul></li></ol><p>​总结起来，<code>Redis</code> 凭借其内存数据库特性、丰富的数据结构、高效的命令操作以及对高可用与分布式的支持，已成为现代应用程序开发中不可或缺的组件。通过深入学习与实践，你将能充分利用 <code>Redis</code> 的强大功能，提升项目性能与稳定性。</p><p>​一起踏上 <code>Redis</code> 的探索之旅吧！</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【从零构建Spring|第一节】  构建简单Bean容器</title>
      <link href="/posts/11401.html"/>
      <url>/posts/11401.html</url>
      
        <content type="html"><![CDATA[<h1 id="【从零构建Spring-第一节】-构建简单Bean容器"><a href="#【从零构建Spring-第一节】-构建简单Bean容器" class="headerlink" title="【从零构建Spring|第一节】  构建简单Bean容器"></a>【从零构建Spring|第一节】  构建简单Bean容器</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每每谈到 <code>Spring</code> 框架，大家总会涉及一些高大上的名词，比如 <code>IOC</code> 控制反转、<code>DI</code> 依赖注入、<code>AOP </code>面向切面等等，但却忘记了最基本的一点。 <strong><code>Spring</code> 的本质是一个 <code>Bean</code> 工厂（<code>beanFactory</code>）或者说 <code>Bean</code> 容器</strong></p><p>它按照我们的要求，生产我们需要的各种各样的<code>bean</code>，提供给我们使用。只是在生产<code>bean</code>的过程中，需要解决<code>bean</code>之间的依赖问题，才引入了依赖注入(<code>DI</code>)这种技术。也就是说<strong>依赖注入是<code>beanFactory</code>生产<code>bean</code>时为了解决<code>bean</code>之间的依赖的一种技术而已</strong>。</p><p>为什么需要<code>Spring</code>框架来给我们提供这个 <code>beanFactory</code> 的功能呢？原因是一般我们认为是，可以将原来硬编码的依赖，通过 <code>Spring </code>这个 <code>beanFactory</code> 这个工厂来注入依赖，也就是说原来只有依赖方和被依赖方，现在我们<strong>引入了第三方</strong>—— <code>Spring</code> 这个 <code>beanFactory</code>，由它来解决<code>bean</code>之间的依赖问题，达到了<strong>松耦合</strong>的效果；</p><p>这个只是原因之一，还有一个更加重要的原因：在没有 <code>Spring </code>这个 <code>beanFactory </code>之前，我们都是直接通过 <code>new</code> 来实例化各种对象，现在各种对象 <code>bean </code>的生产都是通过 <code>beanFactory</code> 来实例化的，这样的话， <code>Spring</code> 这个 <code>beanFactory </code>就可以在实例化 bean 的过程中，<strong>做一些小动作</strong>——在实例化<code>bean</code>的各个阶段进行一些额外的处理，也就是说 <strong><code>beanFactory</code> 会在 <code>bean</code> 的生命周期的各个阶段中对 <code>bean</code> 进行各种管理</strong>，并且<code>Spring </code>将<strong>这些阶段通过各种接口暴露</strong>给我们，让我们可以对 <code>bean</code> 进行各种处理，我们只要让 <code>bean</code> 实现对应的接口，那么<code> Spring</code> 就会在 <code>bean</code>的生命周期调用我们实现的接口来处理该 <code>bean</code>。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p><img src="https://cdn.statically.io/gh/BanTanger/image-hosting@master/00.%E5%88%9B%E5%BB%BA%E7%AE%80%E5%8D%95Bean%E5%AE%B9%E5%99%A8-assets/202302211553406.png" alt="image-20230221155314512"></p><p>简单定义 <code>BeanFactory</code>，<code>BeanDefinition</code>。</p><ul><li><code>BeanFactory</code>：是最基层、最顶级的 <code>BeanFactory</code>。提供 Bean 的生产和管理方法，当然目前来说他是不完善的，在第二节中，会将它设置成接口，仅提供方法，规范代码的简洁性</li><li><code>BeanDefinition</code>：是 Bean 定义元数据，当前的实现是直接将 Bean 对象整个类存入 <code>BeanDefinition</code>。后续章节会将他的职责抽象为存储 Bean 对象的名称、类型和属性。</li></ul><p>创建 Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_BeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 初始化 BeanFactory</span></span><br><span class="line">    <span class="type">BeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanFactory</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 注入 Bean</span></span><br><span class="line">    <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinition</span>(<span class="keyword">new</span> <span class="title class_">UserService</span>());</span><br><span class="line">    beanFactory.registerBeanDefinition(<span class="string">&quot;userService&quot;</span>, beanDefinition);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取 Bean</span></span><br><span class="line">    <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) beanFactory.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">    userService.queryUserInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个最最最简单的 <code>Spring IOC</code> 实现就是如此，<code>BeanFactory</code> 提供 Bean 的生产和管理，<code>BeanDefinition</code> 存储 Bean 对象。当然目前来说是很不完善的，甚至是错误的。他甚至没有涉及到 <code>Spring IOC</code> 的核心思想 —— <strong>控制反转</strong>、<strong>依赖注入</strong>，但这样一个小例子，正是 <code>Spring IOC</code> 的核心内容（不是思想），后续的章节皆为完善与扩展知识</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>为什么说 <code>Spring</code> 是非侵入式的？</p><p>因为对于任何一个不懂 <code>Spring</code> 底层的程序员来说，只要他能熟练使用<code>xml</code>或者 注解方式（<code>Spring</code>底层称之为 <code>resource</code>）标注<code> bean</code>，<code>Spring</code> 通过 <code>resourceLoader </code>把 <code>resource</code> 解析成各种层次的组件清单，再将其加载到<code> BeanDefinitionReader</code> 里</p><p>可以认为<code> xml</code>、注解 就是 <code>Spring</code> 制造 <code>bean</code> 对象的 <code>蓝图</code>，<code>Spring</code> 通过 <code>resourceLoader</code></p><p>读取我们对将要构造的<code>Bean</code>的需求, 并进行统一的创建与管理, 也就是说我们只需要引入<code>Spring</code>的依赖, 并将元数据配置到<code>xml</code>或注解中, 就可以无缝将<code>Spring</code>集成到现有的Java应用程序中, 不需要更改业务代码或者依赖于各种<code>API</code> 或者 接口</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 渐进式实现Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC扩展点</title>
      <link href="/posts/28778.html"/>
      <url>/posts/28778.html</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC扩展点"><a href="#SpringMVC扩展点" class="headerlink" title="SpringMVC扩展点"></a>SpringMVC扩展点</h1><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/87caa037d8584c559b014e7ca8e36a27.png" alt="SpringMVC执行流程"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/image-20240328171342686.png" alt="image-20240328171342686"></p><ol><li><strong>DispatchServlet</strong>:<ul><li>这是Spring MVC的核心控制器，负责处理所有的HTTP请求和响应。它根据请求的URL来决定调用哪个处理器（Controller中的方法），并最终返回响应给客户端。</li><li>它使用<code>HandlerMapping</code>来确定具体的请求应该由哪个处理器方法来处理。</li></ul></li><li><strong>HandlerMapping</strong>:<ul><li>这个接口定义了如何将HTTP请求映射到处理器方法。<code>RequestMappingHandlerMapping</code>是<code>HandlerMapping</code>的一个实现，它使用注解（如<code>@RequestMapping</code>）来映射URL到具体的处理器方法。</li></ul></li><li><strong>HandlerAdapter</strong>:<ul><li>这个接口定义了如何调用处理器方法。<code>RequestMappingHandlerAdapter</code>是<code>HandlerAdapter</code>的一个实现，它负责调用与<code>@RequestMapping</code>注解的URL匹配的处理器方法。</li></ul></li><li><strong>RequestMappingHandlerMapping</strong> 和 <strong>RequestMappingHandlerAdapter</strong>:<ul><li>这两个组件是Spring MVC中处理基于注解的映射的核心。<code>RequestMappingHandlerMapping</code>负责查找和匹配URL到相应的处理器方法，而<code>RequestMappingHandlerAdapter</code>负责实际调用这些方法。</li></ul></li><li><strong>MappingRegistry</strong>:<ul><li>这是一个注册表，用于存储URL模式和对应的处理器方法。它使得<code>RequestMappingHandlerMapping</code>能够快速查找匹配的处理器方法。</li></ul></li><li><strong>HandlerMethodArgumentResolver</strong> 和 <strong>HandlerMethodReturnValueHandler</strong>:<ul><li>这两个接口定义了如何处理进入和返回自处理器方法的数据。<code>HandlerMethodArgumentResolver</code>用于解析方法参数，例如将URL中的占位符（如<code>&#123;id&#125;</code>）转换为方法参数的值。</li><li><code>HandlerMethodReturnValueHandler</code>用于处理方法的返回值，将其转换为适合HTTP响应的形式。</li></ul></li><li><strong>PathVariableMethodArgumentResolver</strong> 和 <strong>RequestResponseBodyMethodProcessor</strong>:<ul><li>这些是具体的解析器和处理器，用于处理特定的数据类型。<code>PathVariableMethodArgumentResolver</code>用于解析URL路径变量，而<code>RequestResponseBodyMethodProcessor</code>用于处理请求体和响应体，例如将JSON或XML数据绑定到Java对象，或将Java对象序列化为JSON或XML。</li></ul></li><li><strong>MappingJackson2HttpMessageConverter</strong>:<ul><li>这是一个消息转换器，用于将HTTP请求和响应体与Java对象之间进行转换。它通常用于处理JSON数据，将JSON字符串转换为Java对象，或将Java对象转换为JSON字符串。</li></ul></li><li><strong>MultiValueMap&lt;String, T&gt;</strong>:<ul><li>这是一个泛型接口，用于表示HTTP请求中参数的映射，其中键是参数名，值是参数值的列表。这允许处理具有相同名称的多个参数的情况。</li></ul></li></ol><p>这些组件通过它们的接口和实现类相互协作，形成了Spring MVC的请求处理流程。当一个HTTP请求到达时，<code>DispatchServlet</code>会使用<code>HandlerMapping</code>来确定请求应该由哪个处理器方法处理，然后通过<code>HandlerAdapter</code>来调用这个方法。参数和返回值的处理由<code>HandlerMethodArgumentResolver</code>和<code>HandlerMethodReturnValueHandler</code>负责。最终，请求被正确地处理并返回给客户端。</p><p>一般需要扩展的地方包括：</p><ul><li><code>HandlerMethodArgumentResolver</code><br>可以定制自己的参数接收方式 和<code>@PathVariable</code>同级</li><li><code>HandlerMethodReturnValueHandler</code><br>定制返回方式，和@ResponseBody同级</li><li><code>MessageConverter</code><br>如果采用<code>@ResponseBody</code>，可以根据不同的<code>Class</code>和<code>MediaType</code>定制不同的<code>Converter</code></li></ul><h2 id="HandlerMethodArgumentResolver"><a href="#HandlerMethodArgumentResolver" class="headerlink" title="HandlerMethodArgumentResolver"></a>HandlerMethodArgumentResolver</h2><p><code>HandlerMethodArgumentResolver</code>接口是Spring MVC中用于解析和提供处理器方法参数的组件。如果你想自定义参数的接收方式，可以通过实现这个接口来创建自己的参数解析器。下面是一个简单的代码示例，展示了如何创建一个自定义的<code>HandlerMethodArgumentResolver</code>来解析请求头中的参数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.springframework.core.MethodParameter;</span><br><span class="line">import org.springframework.web.bind.support.WebDataBinderFactory;</span><br><span class="line">import org.springframework.web.context.request.NativeWebRequest;</span><br><span class="line">import org.springframework.web.method.support.ModelAndViewContainer;</span><br><span class="line">import org.springframework.web.bind.support.HandlerMethodArgumentResolver;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line">public class CustomHeaderArgumentResolver implements HandlerMethodArgumentResolver &#123;</span><br><span class="line"></span><br><span class="line">    private static final String CUSTOM_HEADER_NAME = &quot;X-Custom-Header&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean supportsParameter(MethodParameter parameter) &#123;</span><br><span class="line">        // 检查方法参数是否有CustomHeader注解</span><br><span class="line">        return parameter.getParameterAnnotation(CustomHeader.class) != null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,</span><br><span class="line">                                  NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception &#123;</span><br><span class="line">        HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line">        // 从请求头中获取自定义的参数值</span><br><span class="line">        String headerValue = request.getHeader(CUSTOM_HEADER_NAME);</span><br><span class="line">        // 根据参数类型进行转换，这里假设是String类型</span><br><span class="line">        return headerValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个名为<code>CustomHeaderArgumentResolver</code>的类，它实现了<code>HandlerMethodArgumentResolver</code>接口。我们定义了一个名为<code>CUSTOM_HEADER_NAME</code>的常量来指定我们要解析的请求头的名称。</p><p><code>supportsParameter</code>方法检查方法参数是否有<code>CustomHeader</code>注解。这是一个自定义注解，你可以创建它来标记需要从请求头中解析的参数。</p><p><code>resolveArgument</code>方法是实际解析参数的地方。我们从<code>NativeWebRequest</code>中获取<code>HttpServletRequest</code>对象，然后调用<code>getHeader</code>方法来获取请求头中的值。最后，我们将这个值返回给Spring MVC，它将把这个值作为参数传递给处理器方法。</p><p>为了使用这个自定义的参数解析器，你需要将其添加到Spring MVC的解析器列表中。这通常在Spring配置文件中完成，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) &#123;</span><br><span class="line">        argumentResolvers.add(new CustomHeaderArgumentResolver());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，当你在控制器方法中使用<code>@CustomHeader</code>注解标记的参数时，Spring MVC将会使用我们自定义的<code>CustomHeaderArgumentResolver</code>来解析这个参数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class MyController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/example&quot;)</span><br><span class="line">    public String exampleMethod(@CustomHeader String customHeaderValue) &#123;</span><br><span class="line">        // 使用从请求头中解析的参数</span><br><span class="line">        return &quot;Custom header value: &quot; + customHeaderValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个控制器方法中，<code>customHeaderValue</code>参数将通过我们自定义的<code>HandlerMethodArgumentResolver</code>来获取请求头中<code>X-Custom-Header</code>的值。</p><h2 id="HandlerMethodReturnValueHandler"><a href="#HandlerMethodReturnValueHandler" class="headerlink" title="HandlerMethodReturnValueHandler"></a>HandlerMethodReturnValueHandler</h2><p><code>HandlerMethodReturnValueHandler</code>接口允许开发者自定义Spring MVC处理器方法的返回值处理逻辑。以下是一个简单的代码示例，展示了如何实现这个接口来自定义返回值的处理：</p><p>首先，我们创建一个自定义的<code>HandlerMethodReturnValueHandler</code>实现类，用于处理返回值为<code>String</code>类型的方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.springframework.core.MethodParameter;</span><br><span class="line">import org.springframework.web.context.request.NativeWebRequest;</span><br><span class="line">import org.springframework.web.method.support.ModelAndViewContainer;</span><br><span class="line">import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter;</span><br><span class="line">import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;</span><br><span class="line"></span><br><span class="line">public class CustomStringReturnValueHandler implements ResponseBodyAdvice&lt;Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean supports(MethodParameter returnType, Class&lt;? extends ResponseBodyAdvice&lt;?&gt;&gt; converterType) &#123;</span><br><span class="line">        // 检查返回类型是否为String</span><br><span class="line">        return String.class.isAssignableFrom(returnType.getParameterType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType,</span><br><span class="line">                                  NativeWebRequest request, ModelAndViewContainer mavContainer) throws Exception &#123;</span><br><span class="line">        // 自定义返回值的处理逻辑，例如添加额外的信息</span><br><span class="line">        if (body instanceof String) &#123;</span><br><span class="line">            String responseBody = (String) body;</span><br><span class="line">            return &quot;Custom String: &quot; + responseBody;</span><br><span class="line">        &#125;</span><br><span class="line">        return body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个实现中，<code>supports</code>方法检查返回类型是否为<code>String</code>。如果是，那么这个<code>HandlerMethodReturnValueHandler</code>将被用于处理返回值。</p><p><code>beforeBodyWrite</code>方法是实际处理返回值的地方。在这个方法中，我们可以自定义返回值的处理逻辑。在这个例子中，我们检查返回的<code>body</code>是否为<code>String</code>类型，如果是，我们添加了一些自定义的前缀文本。</p><p>接下来，我们需要将这个自定义的<code>HandlerMethodReturnValueHandler</code>注册到Spring MVC中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.method.support.HandlerMethodReturnValueHandler;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addReturnValueHandlers(List&lt;HandlerMethodReturnValueHandler&gt; handlers) &#123;</span><br><span class="line">        handlers.add(new CustomStringReturnValueHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>WebConfig</code>配置类中，我们通过实现<code>WebMvcConfigurer</code>接口并重写<code>addReturnValueHandlers</code>方法，将我们的<code>CustomStringReturnValueHandler</code>添加到Spring MVC的返回值处理器列表中。</p><p>现在，当控制器方法返回一个<code>String</code>类型的值时，我们的自定义<code>HandlerMethodReturnValueHandler</code>将会被调用来处理这个返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class MyController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/example&quot;)</span><br><span class="line">    public String exampleMethod() &#123;</span><br><span class="line">        // 控制器方法返回一个字符串</span><br><span class="line">        return &quot;Hello, World!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>exampleMethod</code>方法返回的字符串”Hello, World!”将会被<code>CustomStringReturnValueHandler</code>处理，最终响应给客户端的内容将是”Custom String: Hello, World!”。这样，我们就成功地自定义了返回值的处理逻辑。</p><h2 id="MessageConverter"><a href="#MessageConverter" class="headerlink" title="MessageConverter"></a>MessageConverter</h2><p><code>MessageConverter</code>接口是Spring MVC中用于在请求和响应之间转换数据格式的组件。以下是一个简单的代码示例，展示了如何实现<code>MessageConverter</code>接口来创建一个自定义的消息转换器，它将自定义的<code>MyObject</code>类实例转换为JSON字符串，并从JSON字符串中反序列化出<code>MyObject</code>实例。</p><p>首先，我们定义一个简单的<code>MyObject</code>类，它将被序列化和反序列化：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyObject &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    // 构造函数、getter和setter省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们创建一个自定义的<code>MessageConverter</code>实现类：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.springframework.http.MediaType;</span><br><span class="line">import org.springframework.http.converter.GenericHttpMessageConverter;</span><br><span class="line">import org.springframework.http.converter.HttpMessageNotReadableException;</span><br><span class="line">import org.springframework.http.converter.HttpMessageNotWritableException;</span><br><span class="line">import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;</span><br><span class="line">import org.springframework.web.context.request.RequestContext;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line">public class CustomMyObjectConverter extends MappingJackson2HttpMessageConverter &#123;</span><br><span class="line"></span><br><span class="line">    // 定义支持的媒体类型</span><br><span class="line">    public static final MediaType MY_OBJECT_MEDIA_TYPE = new MediaType(&quot;application&quot;, &quot;x-my-object&quot;);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean supports(Class&lt;?&gt; clazz, MediaType mediaType) &#123;</span><br><span class="line">        // 检查类类型和媒体类型</span><br><span class="line">        return MyObject.class.isAssignableFrom(clazz) &amp;&amp; MY_OBJECT_MEDIA_TYPE.isCompatibleWith(mediaType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean supportsInternal(MediaType mediaType) &#123;</span><br><span class="line">        // 检查媒体类型是否与自定义类型匹配</span><br><span class="line">        return MY_OBJECT_MEDIA_TYPE.isCompatibleWith(mediaType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object readInternal(Class&lt;?&gt; clazz, HttpInputMessage inputMessage)</span><br><span class="line">            throws IOException, HttpMessageNotReadableException &#123;</span><br><span class="line">        // 调用父类方法进行JSON读取和反序列化</span><br><span class="line">        return super.readInternal(clazz, inputMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void writeInternal(Object object, MediaType contentType, HttpOutputMessage outputMessage)</span><br><span class="line">            throws IOException, HttpMessageNotWritableException &#123;</span><br><span class="line">        // 调用父类方法进行序列化和JSON写入</span><br><span class="line">        super.writeInternal(object, contentType, outputMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;MediaType&gt; getSupportedMediaTypes() &#123;</span><br><span class="line">        // 返回支持的媒体类型列表</span><br><span class="line">        return Collections.singletonList(MY_OBJECT_MEDIA_TYPE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个实现中，我们继承了<code>MappingJackson2HttpMessageConverter</code>，它是一个基于Jackson库的JSON消息转换器。我们重写了<code>supports</code>方法来指定我们的转换器只处理<code>MyObject</code>类型的类，并且只支持我们自定义的<code>MY_OBJECT_MEDIA_TYPE</code>媒体类型。</p><p>我们还重写了<code>readInternal</code>和<code>writeInternal</code>方法，虽然在这个例子中我们只是调用了父类的方法，但这些方法是你可以自定义序列化和反序列化逻辑的地方。</p><p>最后，我们重写了<code>getSupportedMediaTypes</code>方法来返回我们的转换器支持的媒体类型列表。</p><p>为了注册我们的自定义<code>MessageConverter</code>，我们需要在Spring配置中添加它：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.http.converter.HttpMessageConverter;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123;</span><br><span class="line">        configurer.favorPathExtension(false)</span><br><span class="line">                .ignoreAcceptHeader(true)</span><br><span class="line">                .defaultContentType(MediaType.TEXT_HTML)</span><br><span class="line">                .mediaType(&quot;myobject&quot;, new CustomMyObjectConverter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;</span><br><span class="line">        converters.add(new CustomMyObjectConverter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个配置类中，我们通过实现<code>WebMvcConfigurer</code>接口并重写<code>configureContentNegotiation</code>和<code>extendMessageConverters</code>方法，将我们的<code>CustomMyObjectConverter</code>添加到Spring MVC的消息转换器列表中，并配置了内容协商。</p><p>现在，当控制器方法返回一个<code>MyObject</code>类型的值，并且请求的<code>Accept</code>头或URL路径扩展名指定了<code>application/x-my-object</code>类型时，Spring MVC将使用我们的自定义<code>MessageConverter</code>来处理这个返回值。同样，当客户端发送<code>application/x-my-object</code>类型的请求体时，我们的转换器也会被用来解析请求体中的<code>MyObject</code>实例。</p><p><a href="https://www.cnblogs.com/lexiaoyao1995/p/13849148.html">springMVC 扩展点 - 刃牙 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/zxd1435513775/article/details/103000992">SpringMVC中HandlerMapping和HandlerAdapter详解（适配器模式）_handlermapping和handler adatper-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StopWatch 使用教程</title>
      <link href="/posts/57352.html"/>
      <url>/posts/57352.html</url>
      
        <content type="html"><![CDATA[<h1 id="🚀StopWatch-使用教程"><a href="#🚀StopWatch-使用教程" class="headerlink" title="🚀StopWatch 使用教程"></a>🚀<code>StopWatch </code>使用教程</h1><h2 id="🤔-什么是StopWatch？"><a href="#🤔-什么是StopWatch？" class="headerlink" title="🤔 什么是StopWatch？"></a>🤔 什么是<code>StopWatch</code>？</h2><p>Hey 大家好，我是 Shio👋。今天我们来学习一个Spring框架中的工具类<code>StopWatch</code>，<code>StopWatch</code>是一个简单的<strong>停止看门狗计时器</strong>，它可以帮助开发者<strong>测量代码的执行时间</strong>。这对于<strong>性能调优</strong>和<strong>监控应用性能</strong>非常有用。想象一下，你有一个复杂的业务逻辑，你想知道<strong>每一步操作需要多长时间来执行</strong>，<code>StopWatch</code>就是你的<strong>瑞士军刀</strong>。</p><p>首先我们要了解为什么我们会使用<code>StopWatch</code>? 我总结为两点:</p><ul><li>方便易用的<code>API</code></li><li>纳秒级别的准确性</li></ul><p>当然除了<code>API</code>, 我还想讲一讲<code>StopWatch</code>准确性实现所用到的 <code> System.nanoTime()</code>方法,  以及为什么不用<code>System.currentTimeMillis()</code></p><h2 id="📏StopWatch准确性如何保障"><a href="#📏StopWatch准确性如何保障" class="headerlink" title="📏StopWatch准确性如何保障?"></a>📏<code>StopWatch</code>准确性如何保障?</h2><p><code>StopWatch</code> 类在<code>Spring</code>框架中用于<strong>精确测量时间间隔</strong>，它之所以能够提供高精度的时间测量，很大程度上<strong>归功于</strong>其内部使用的 <strong><code>System.nanoTime()</code></strong> 方法。下面我们来详细探讨 <code>System.nanoTime()</code> 以及 <code>StopWatch</code> 为何因此而更准确。</p><h3 id="System-nanoTime-的作用"><a href="#System-nanoTime-的作用" class="headerlink" title="System.nanoTime() 的作用"></a><code>System.nanoTime()</code> 的作用</h3><p><code>System.nanoTime()</code> 是 Java 中用于获取当前时间的纳秒值的方法。它提供了对<strong>最高精度的系统时钟</strong>的访问，通常由操作系统的实时时钟或高精度时钟提供。这个方法的返回值是<strong>自<code> JVM</code> 启动以来的纳秒数</strong>，不考虑闰秒。</p><ol><li><strong>纳秒级精度</strong>：<code>System.nanoTime()</code> 提供的是纳秒级别的时间，这意味着<code>StopWatch</code>能够测量到非常短的时间间隔，这对于性能分析来说是非常有用的。</li><li><strong>系统时钟直接读取</strong>：<code>System.nanoTime()</code> 直接读取系统时钟，这减少了由于时间同步或时间转换导致的误差。</li><li><strong>不受用户模式延迟影响</strong>：由于它使用的是系统时钟，因此不会受到用户模式下可能发生的延迟的影响，比如线程调度延迟。</li><li><strong>单线程环境下的准确性</strong>：在单线程环境中，<code>System.nanoTime()</code> 可以非常精确地测量两个事件之间的时间间隔。</li><li><strong>减少累积误差</strong>：<code>StopWatch </code>通过在任务开始和结束时记录时间戳，然后计算差值来测量每个任务的执行时间，这种方法减少了时间测量的累积误差。</li></ol><h3 id="与System-currentTimeMillis-进行比较"><a href="#与System-currentTimeMillis-进行比较" class="headerlink" title="与System.currentTimeMillis()进行比较"></a>与<code>System.currentTimeMillis()</code>进行比较</h3><p><code>System.currentTimeMillis()</code> 和 <code>System.nanoTime()</code> 都是 Java 中用于获取时间的方法，但它们之间存在一些关键的区别，这些区别决定了它们在<strong>不同场景下的适用性</strong>。</p><h4 id="System-currentTimeMillis"><a href="#System-currentTimeMillis" class="headerlink" title="System.currentTimeMillis()"></a><code>System.currentTimeMillis()</code></h4><ul><li><strong>返回值</strong>：返回的是自 1970 年 1 月 1 日 00:00:00 UTC 以来的毫秒数，也称为 Unix 时间或 Epoch 时间。</li><li><strong>精度</strong>：以毫秒为单位，这意味着最小时间间隔为 1 毫秒。</li><li><strong>用途</strong>：通常用于记录一个具体时间点，或者在不需要高精度时间差测量的场景中。</li><li><strong>线程安全</strong>：由于每次调用获取的是单个时间戳，因此是线程安全的。</li><li><strong>系统时钟依赖</strong>：依赖于系统时钟，可能会受到系统时间调整的影响。</li></ul><h4 id="System-nanoTime"><a href="#System-nanoTime" class="headerlink" title="System.nanoTime()"></a><code>System.nanoTime()</code></h4><ul><li><strong>返回值</strong>：返回的是自<code> JVM</code> 启动以来的纳秒数，不依赖于日期和时间。</li><li><strong>精度</strong>：以纳秒为单位，最小时间间隔为 1 纳秒，这使得它非常适合于高精度的时间间隔测量。</li><li><strong>用途</strong>：主要用于测量短时间的持续时间，比如性能测试和基准测试。</li><li><strong>线程安全</strong>：同样是线程安全的，因为它每次调用也是获取单个时间戳。</li><li><strong>系统时钟依赖</strong>：依赖于系统提供的高精度时钟，通常不受系统时间调整的影响。</li></ul><h4 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h4><ol><li><strong>时间起点</strong>：<code>System.currentTimeMillis()</code> 以 Unix 时间（1970 年 1 月 1 日 00:00:00 UTC）为起点，而 <code>System.nanoTime()</code> 以 <code>JVM </code>启动时间为起点。</li><li><strong>时间单位</strong>：<code>System.currentTimeMillis()</code> 以毫秒为单位，而 <code>System.nanoTime()</code> 以纳秒为单位。</li><li><strong>精度</strong>：<code>System.nanoTime()</code> 的精度远高于 <code>System.currentTimeMillis()</code>，适合于需要精确测量时间间隔的场景。</li><li><strong>适用场景</strong>：<code>System.currentTimeMillis()</code> 适合获取具体时间点的记录，而 <code>System.nanoTime()</code> 更适合测量两个事件之间的时间间隔。</li><li><strong>系统调整影响</strong>：系统时间的调整可能会影响 <code>System.currentTimeMillis()</code> 的返回值，而 <code>System.nanoTime()</code> 则不受这种调整的影响。</li></ol><h4 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h4><ul><li>当需要记录具体日期和时间点时，使用 <code>System.currentTimeMillis()</code>。</li><li>当需要测量代码块或方法执行的性能时，使用 <code>System.nanoTime()</code>。</li><li>在多线程环境中，两者都可以用来获取时间戳，但 <code>System.nanoTime()</code> 更适合于测量短时的持续时间。</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><code>StopWatch</code> 之所以能够提供高精度的时间测量，主要得益于其内部使用的 <code>System.nanoTime()</code> 方法。该方法提供了对系统时钟的直接访问，从而允许<code> StopWatch</code> 以纳秒级别的精度测量时间间隔。然而，开发者在使用时应考虑到多线程环境和系统负载等因素可能带来的影响，并合理地应用 <code>StopWatch</code> 以优化性能分析。</p><h2 id="🛠️-如何使用StopWatch？"><a href="#🛠️-如何使用StopWatch？" class="headerlink" title="🛠️ 如何使用StopWatch？"></a>🛠️ 如何使用<code>StopWatch</code>？</h2><h3 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a>1. 添加依赖</h3><p>首先，确保你的项目中已经包含了Spring的上下文模块。在Maven的pom.xml文件中添加以下依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-初始化StopWatch"><a href="#2-初始化StopWatch" class="headerlink" title="2. 初始化StopWatch"></a>2. 初始化<code>StopWatch</code></h3><p>在你的Spring配置文件或者Java配置类中，你可以注入<code>StopWatch</code>，并开始使用它：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.StopWatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PerformanceTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPerformance</span><span class="params">()</span> &#123;</span><br><span class="line">        stopWatch.start(<span class="string">&quot;TaskName&quot;</span>); <span class="comment">// 开始计时，并给任务命名</span></span><br><span class="line">        <span class="comment">// 执行你的代码</span></span><br><span class="line">        stopWatch.stop(); <span class="comment">// 停止计时</span></span><br><span class="line">        stopWatch.start(<span class="string">&quot;AnotherTask&quot;</span>); <span class="comment">// 开始另一个任务的计时</span></span><br><span class="line">        <span class="comment">// 执行另一个代码块</span></span><br><span class="line">        stopWatch.stop(); <span class="comment">// 停止另一个任务的计时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-获取和打印结果"><a href="#3-获取和打印结果" class="headerlink" title="3. 获取和打印结果"></a>3. 获取和打印结果</h3><p><code>StopWatch</code>提供了多种方法来获取计时结果。你可以获取总的运行时间，也可以获取每个任务的运行时间：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printResults</span><span class="params">()</span> &#123;</span><br><span class="line">    stopWatch.start(<span class="string">&quot;TotalTasks&quot;</span>);</span><br><span class="line">    performanceTask(); <span class="comment">// 假设这是你的业务方法</span></span><br><span class="line">    stopWatch.stop();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Total time taken: &quot;</span> + stopWatch.getTotalTimeMillis() + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stopWatch.getTaskCount(); i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Task &quot;</span> + i + <span class="string">&quot; took: &quot;</span> + stopWatch.getTaskInfo(i).getDuration() + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="🌟源码解析"><a href="#🌟源码解析" class="headerlink" title="🌟源码解析"></a>🌟源码解析</h2><h3 id="类变量和构造方法"><a href="#类变量和构造方法" class="headerlink" title="类变量和构造方法"></a>类变量和构造方法</h3><p><code>StopWatch</code>类有一些类变量和一个构造方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopWatch</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> keepTaskList;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;TaskInfo&gt; taskList;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> startTimeNanos;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> String currentTaskName;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> TaskInfo lastTaskInfo;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> taskCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> totalTimeNanos;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>id</code>: 一个字符串，用于标识这个<code>StopWatch</code>实例。</li><li><code>keepTaskList</code>: 一个布尔值，指示是否保留任务列表。</li><li><code>taskList</code>: 一个任务信息列表，用于存储每个任务的详细信息。</li><li><code>startTimeNanos</code>: 当前任务的开始时间（纳秒）。</li><li><code>currentTaskName</code>: 当前正在执行的任务名称。</li><li><code>lastTaskInfo</code>: 上一个任务的信息。</li><li><code>taskCount</code>: 任务计数器。</li><li><code>totalTimeNanos</code>: 所有任务的总时间（纳秒）。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">StopWatch</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">StopWatch</span><span class="params">(String id)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.keepTaskList = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">this</span>.taskList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>构造方法</strong>允许你为<code>StopWatch</code>实例指定一个ID，如果不指定，则<strong>默认为空字符串</strong>。</p><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><h4 id="start"><a href="#start" class="headerlink" title="start()"></a><code>start()</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException &#123;</span><br><span class="line">        <span class="built_in">this</span>.start(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(String taskName)</span> <span class="keyword">throws</span> IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.currentTaskName != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Can&#x27;t start StopWatch: it&#x27;s already running&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.currentTaskName = taskName;</span><br><span class="line">        <span class="built_in">this</span>.startTimeNanos = System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>start()</code> 方法用于开始一个新的计时任务。它接受一个任务名称作为参数，并记录当前时间（以纳秒为单位）作为开始时间。如果尝试在另一个任务正在进行时开始新任务，将抛出<code>IllegalStateException</code>。</p><h4 id="stop"><a href="#stop" class="headerlink" title="stop()"></a><code>stop()</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.currentTaskName == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Can&#x27;t stop StopWatch: it&#x27;s not running&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lastTime</span> <span class="operator">=</span> System.nanoTime() - <span class="built_in">this</span>.startTimeNanos;</span><br><span class="line">            <span class="built_in">this</span>.totalTimeNanos += lastTime;</span><br><span class="line">            <span class="built_in">this</span>.lastTaskInfo = <span class="keyword">new</span> <span class="title class_">TaskInfo</span>(<span class="built_in">this</span>.currentTaskName, lastTime);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.keepTaskList) &#123;</span><br><span class="line">                <span class="built_in">this</span>.taskList.add(<span class="built_in">this</span>.lastTaskInfo);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++<span class="built_in">this</span>.taskCount;</span><br><span class="line">            <span class="built_in">this</span>.currentTaskName = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>stop()</code> 方法用于结束当前计时任务。它计算当前时间与开始时间的差值，并将这个时间累加到总时间中。如果尝试停止一个未开始的任务，将抛出<code>IllegalStateException</code>。</p><h4 id="isRunning"><a href="#isRunning" class="headerlink" title="isRunning()"></a><code>isRunning()</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRunning</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.currentTaskName != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回一个布尔值，指示是否有任务正在进行。</p><h4 id="getLastTaskTimeNanos-getLastTaskTimeMillis"><a href="#getLastTaskTimeNanos-getLastTaskTimeMillis" class="headerlink" title="getLastTaskTimeNanos() / getLastTaskTimeMillis()"></a><code>getLastTaskTimeNanos() / getLastTaskTimeMillis()</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getLastTaskTimeNanos</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.lastTaskInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No tasks run: can&#x27;t get last task interval&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.lastTaskInfo.getTimeNanos();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getLastTaskTimeMillis</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.lastTaskInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No tasks run: can&#x27;t get last task interval&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.lastTaskInfo.getTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些方法返回<strong>最后一个任务的执行时间</strong>，可以是<strong>纳秒</strong>或<strong>毫秒</strong>。</p><h4 id="getTotalTimeNanos-getTotalTimeMillis-getTotalTimeSeconds"><a href="#getTotalTimeNanos-getTotalTimeMillis-getTotalTimeSeconds" class="headerlink" title="getTotalTimeNanos() / getTotalTimeMillis() / getTotalTimeSeconds()"></a><code>getTotalTimeNanos() / getTotalTimeMillis() / getTotalTimeSeconds()</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTotalTimeNanos</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.totalTimeNanos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTotalTimeMillis</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nanosToMillis(<span class="built_in">this</span>.totalTimeNanos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getTotalTimeSeconds</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nanosToSeconds(<span class="built_in">this</span>.totalTimeNanos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些方法返回所有任务的总执行时间，可以是纳秒、毫秒或秒。</p><h4 id="getTaskInfo"><a href="#getTaskInfo" class="headerlink" title="getTaskInfo()"></a><code>getTaskInfo()</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TaskInfo[] getTaskInfo() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.keepTaskList) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;Task info is not being kept!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (TaskInfo[])<span class="built_in">this</span>.taskList.toArray(<span class="keyword">new</span> <span class="title class_">TaskInfo</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>keepTaskList</code>为<code>true</code>，此方法返回一个包含所有任务信息的数组。</p><h4 id="shortSummary-prettyPrint-toString"><a href="#shortSummary-prettyPrint-toString" class="headerlink" title="shortSummary() / prettyPrint() / toString()"></a><code>shortSummary() / prettyPrint() / toString()</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">shortSummary</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;StopWatch &#x27;&quot;</span> + <span class="built_in">this</span>.getId() + <span class="string">&quot;&#x27;: running time = &quot;</span> + <span class="built_in">this</span>.getTotalTimeNanos() + <span class="string">&quot; ns&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">prettyPrint</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="built_in">this</span>.shortSummary());</span><br><span class="line">    sb.append(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.keepTaskList) &#123;</span><br><span class="line">        sb.append(<span class="string">&quot;No task info kept&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sb.append(<span class="string">&quot;---------------------------------------------\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;ns         %     Task name\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;---------------------------------------------\n&quot;</span>);</span><br><span class="line">        <span class="type">NumberFormat</span> <span class="variable">nf</span> <span class="operator">=</span> NumberFormat.getNumberInstance();</span><br><span class="line">        nf.setMinimumIntegerDigits(<span class="number">9</span>);</span><br><span class="line">        nf.setGroupingUsed(<span class="literal">false</span>);</span><br><span class="line">        <span class="type">NumberFormat</span> <span class="variable">pf</span> <span class="operator">=</span> NumberFormat.getPercentInstance();</span><br><span class="line">        pf.setMinimumIntegerDigits(<span class="number">3</span>);</span><br><span class="line">        pf.setGroupingUsed(<span class="literal">false</span>);</span><br><span class="line">        TaskInfo[] var4 = <span class="built_in">this</span>.getTaskInfo();</span><br><span class="line">        <span class="type">int</span> <span class="variable">var5</span> <span class="operator">=</span> var4.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="number">0</span>; var6 &lt; var5; ++var6) &#123;</span><br><span class="line">            <span class="type">TaskInfo</span> <span class="variable">task</span> <span class="operator">=</span> var4[var6];</span><br><span class="line">            sb.append(nf.format(task.getTimeNanos())).append(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            sb.append(pf.format((<span class="type">double</span>)task.getTimeNanos() / (<span class="type">double</span>)<span class="built_in">this</span>.getTotalTimeNanos())).append(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            sb.append(task.getTaskName()).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="built_in">this</span>.shortSummary());</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.keepTaskList) &#123;</span><br><span class="line">        TaskInfo[] var2 = <span class="built_in">this</span>.getTaskInfo();</span><br><span class="line">        <span class="type">int</span> <span class="variable">var3</span> <span class="operator">=</span> var2.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="number">0</span>; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">            <span class="type">TaskInfo</span> <span class="variable">task</span> <span class="operator">=</span> var2[var4];</span><br><span class="line">            sb.append(<span class="string">&quot;; [&quot;</span>).append(task.getTaskName()).append(<span class="string">&quot;] took &quot;</span>).append(task.getTimeNanos()).append(<span class="string">&quot; ns&quot;</span>);</span><br><span class="line">            <span class="type">long</span> <span class="variable">percent</span> <span class="operator">=</span> Math.round(<span class="number">100.0</span> * (<span class="type">double</span>)task.getTimeNanos() / (<span class="type">double</span>)<span class="built_in">this</span>.getTotalTimeNanos());</span><br><span class="line">            sb.append(<span class="string">&quot; = &quot;</span>).append(percent).append(<span class="string">&quot;%&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sb.append(<span class="string">&quot;; no task info kept&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些方法提供了不同格式的<code>StopWatch</code>状态的字符串表示，包括简短的摘要、详细的打印信息和字符串表示。</p><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><h4 id="nanosToMillis-nanosToSeconds"><a href="#nanosToMillis-nanosToSeconds" class="headerlink" title="nanosToMillis() / nanosToSeconds()"></a><code>nanosToMillis() / nanosToSeconds()</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">nanosToMillis</span><span class="params">(<span class="type">long</span> duration)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> TimeUnit.NANOSECONDS.toMillis(duration);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">nanosToSeconds</span><span class="params">(<span class="type">long</span> duration)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)duration / <span class="number">1.0E9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些是私有静态方法，用于将纳秒转换为毫秒或秒。</p><h3 id="内部类-TaskInfo"><a href="#内部类-TaskInfo" class="headerlink" title="内部类 TaskInfo"></a>内部类 <code>TaskInfo</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TaskInfo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String taskName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> timeNanos;</span><br><span class="line"></span><br><span class="line">    TaskInfo(String taskName, <span class="type">long</span> timeNanos) &#123;</span><br><span class="line">        <span class="built_in">this</span>.taskName = taskName;</span><br><span class="line">        <span class="built_in">this</span>.timeNanos = timeNanos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTaskName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.taskName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTimeNanos</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.timeNanos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTimeMillis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StopWatch.nanosToMillis(<span class="built_in">this</span>.timeNanos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getTimeSeconds</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StopWatch.nanosToSeconds(<span class="built_in">this</span>.timeNanos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TaskInfo</code>是<code>StopWatch</code>的内部类，用于存储单个任务的名称和执行时间（纳秒）。它提供了获取任务名称、时间（纳秒、毫秒或秒）的方法。</p><h3 id="使用StopWatch的最佳实践"><a href="#使用StopWatch的最佳实践" class="headerlink" title="使用StopWatch的最佳实践"></a>使用<code>StopWatch</code>的最佳实践</h3><ul><li>使用<code>start()</code>和<code>stop()</code>成对出现，以确保时间的准确性。</li><li>通过<code>setKeepTaskList()</code>方法可以控制是否保留任务列表，这有助于节省内存，尤其是在测量大量任务时。</li><li>使用<code>prettyPrint()</code>方法可以方便地查看所有任务的执行时间及其占比。</li></ul><h2 id="🚧-注意事项"><a href="#🚧-注意事项" class="headerlink" title="🚧 注意事项"></a>🚧 注意事项</h2><ul><li>不要在代码的每个角落都使用<code>StopWatch</code>，这可能会导致性能开销。</li><li>使用<code>StopWatch</code>的最佳实践是在开发和测试阶段进行性能分析，而不是在生产环境中频繁使用。</li><li>对于性能测试，虽然<code>StopWatch</code>可以进行单一有效的测试, 但是还是建议使用如 <code>JMH (Java Microbenchmarking Harness)</code>、<code>JMeter</code>、<code>Gatling</code> 等更加专业高效, 具有丰富测试场景的性能测试框架</li></ul><h2 id="🎉-结语"><a href="#🎉-结语" class="headerlink" title="🎉 结语"></a>🎉 结语</h2><p><code>StopWatch</code>是一个简单但强大的工具，可以帮助你监控和优化Spring应用的性能。记住，性能调优是一个持续的过程，不断地使用<code>StopWatch</code>来分析你的代码，你会发现性能提升的空间，让你的应用更加高效💨。</p><hr><p>希望这篇教程能帮助你在Spring应用中有效地使用<code>StopWatch</code>工具类。如果你有任何问题或者想要了解更多关于<code>Spring</code>框架的内容，随时欢迎提问！💬</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL系列之 MySQL的系统架构</title>
      <link href="/posts/17451.html"/>
      <url>/posts/17451.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL系列之-MySQL的系统架构"><a href="#MySQL系列之-MySQL的系统架构" class="headerlink" title="MySQL系列之 MySQL的系统架构"></a>MySQL系列之 MySQL的系统架构</h1><p>大家好，我是MySQL，虽然在关系型数据库的排行榜上，我常被称作“万年老二”，Oracle总是站在我的前面，但我深信，总有那么一天，我会全面超越，成为行业的领头羊。我的使命，就是默默地服务于每一位程序员，管理他们那些复杂多变的数据。为了更好地与程序员沟通，我进化出了“连接模块”，它就像是我的门卫，负责接待所有想要访问我的客户端。</p><p>程序员们通过使用“客户端连接驱动”，如JDBC或ODBC，来敲响我的大门，与我建立连接。一旦连接成功，我将开放我的数据宝藏，允许他们执行各种操作。然而，频繁的连接与断开，对于我这样精巧的系统而言，曾是一大负担。因此，我发展出了“连接池”这一机制，它像一座桥梁，能够保持连接的持久性，避免不必要的创建和销毁，从而提高资源的利用率。</p><p>连接池不仅是我与外部世界的门户，它还具备自我保护的能力，设置了一系列参数，如<code>max_connections</code>用于限制同时建立的连接数，<code>max_allowed_packet</code>则控制着数据包的最大尺寸。程序员通过合理配置这些参数，可以确保我运行得更为高效。</p><p>解决了连接的烦恼后，我的主要任务便是协助程序员执行我们之间的秘密语言——SQL（Structured Query Language）。SQL语言能够精确地描述对我的表、数据、索引和视图的操作。我通过“SQL接口”和“SQL解析器”向他们展现我的服务范围，同时对SQL语句进行翻译和验证。若发现SQL语句有误或无法执行，我将通过“SQL接口”返回错误信息。</p><p>经过“SQL解析器”的初步审查后，SQL语句将进入优化阶段。这并非质疑程序员的SQL技巧，而是因为我了解自己的内部结构、数据分布和索引状态，可以为SQL语句选择最佳执行路径，以达到最高的执行效率。“SQL解析器”是一个复杂而精细的器官，它的运作细节将在后续的讲解中深入探讨。</p><p>在我优化完SQL命令后，接下来的任务是执行它们。这时，我的“存储引擎”——相当于我的大脑，将发挥关键作用。不同于人类的大脑，我的“大脑”可以根据不同的应用场景做出选择，有的引擎擅长高速读取，有的注重数据一致性，有的功能全面，还有的体积轻巧。在与程序员的长期合作中，我逐渐对名为“InnoDB”的存储引擎产生了强烈的偏好，因为它在可靠性与性能方面表现卓越，在众多引擎中脱颖而出，赢得了广大程序员的认可。从第5.7版本开始，我将“InnoDB”设为默认的存储引擎，以提供更优质的服务。</p><p>除此之外，我还拥有许多其他“器官”，包括缓存、恢复机制、安全保障、集群功能等，它们共同构成了我强大的生态系统。在未来的讲解中，我将一一揭开它们的神秘面纱。</p><p>今天的分享就到这里。如果你喜欢这期内容，别忘了给我点赞和关注，你的支持将激励我更快地分享更多关于我的故事。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 枚举类型的选择</title>
      <link href="/posts/6841.html"/>
      <url>/posts/6841.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL中的枚举字段-该用什么类型定义呢"><a href="#MySQL中的枚举字段-该用什么类型定义呢" class="headerlink" title="MySQL中的枚举字段, 该用什么类型定义呢?"></a>MySQL中的枚举字段, 该用什么类型定义呢?</h1><h2 id="问题简述"><a href="#问题简述" class="headerlink" title="问题简述"></a>问题简述</h2><p>在项目数据库表设计阶段, 我们常常会用到枚举字段</p><p>例如 性别, 状态等数量有限在业务有特殊含义的字段</p><p>在建表时常用的字段有如下三种:</p><ul><li><code>tinyint</code></li><li><code>varchar</code></li><li><code>enum</code></li></ul><p><em>当然也有创建<code>Reference table</code>利用外键来管理枚举类型, 本节暂不讨论</em></p><p>其中 <code>tinyint</code>用的最多, <code>varchar</code>其次</p><p><code>enum</code>由于一些比较严重的缺陷所以用的最少</p><p>下面我们将简述三种类型各自的特点以及应用场景</p><h2 id="类型特点分析"><a href="#类型特点分析" class="headerlink" title="类型特点分析"></a>类型特点分析</h2><h3 id="TINYINT"><a href="#TINYINT" class="headerlink" title="TINYINT"></a>TINYINT</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li><strong>容量小</strong>：<code>tinyint</code> 只占用 1 字节的存储空间，可以存储范围为 -128 到 127 的整数值。因此，在数量有限的枚举字段中，使用 <code>tinyint</code> 可以有效地节省存储空间。</li><li><strong>整数表示</strong>：<code>tinyint</code> 存储的是整数值，而不是直接存储含义明确的字符或字符串。这样可以在查询和索引时更高效地处理，因为比较整数值的速度通常比比较字符或字符串值的速度更快</li></ol><p><strong>优点：</strong></p><ol><li><strong>节省存储空间</strong>：相比于字符串类型的枚举，使用 <code>tinyint</code> 类型可以节省存储空间，特别是在包含大量枚举字段的表中，可以显著减少数据占用。</li><li><strong>查询和索引性能较好</strong>：由于 <code>tinyint</code> 存储的是整数值，所以在查询和索引操作时相对高效，特别是在大量数据情境下，可以提高查询性能。</li><li><strong>易于扩展和维护</strong>：如果需要添加新的枚举值，只需要在 <code>tinyint</code> 数据类型的范围内增加合适的值即可，无需对表结构进行更改。</li></ol><p><strong>缺点：</strong></p><ol><li><strong>不直观</strong>：<code>tinyint</code> 类型存储的是整数值，而不是直接存储有意义的字符或字符串，所以在直接展示给终端用户或报表时，可能需要进行额外的处理来转换为易于理解的含义。</li><li><strong>不支持自助描述</strong>：相比于字符串类型的枚举，<code>tinyint</code> 类型无法自己描述枚举值的含义，需要在应用层或文档中加以说明。</li></ol><p><strong>应用场景：</strong></p><ol><li><strong>状态字段</strong>：当业务需求包含有限且离散的状态集合时，如订单状态、用户状态等，可以使用 <code>tinyint</code> 类型作为状态枚举字段。</li><li><strong>类型字段</strong>：当业务需要分类不同类型的实体对象时，比如商品类型、车辆类型等，可以使用 <code>tinyint</code> 类型作为类型枚举字段。</li><li><strong>标志字段</strong>：当需要表示开关状态或异或逻辑的选项时，如布尔值字段 (0&#x2F;1) 或开启&#x2F;关闭等，可以使用 <code>tinyint</code> 类型作为标志枚举字段。</li></ol><p>综上所述，将 <code>tinyint</code> 作为枚举类型在节省存储空间、提高查询性能方面具有优势，适用于数量有限、离散且不需要复杂描述的枚举值情况。但需要注意，在展示给用户时可能需要进行转换和解释，以保证易于理解和使用。</p><h3 id="VARCHAR"><a href="#VARCHAR" class="headerlink" title="VARCHAR"></a>VARCHAR</h3><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol><li><strong>灵活性</strong>：<code>VARCHAR</code> 类型可以存储可变长度的字符数据，因此可以灵活地存储不同长度的枚举值，适用于枚举值长度不固定的情况。</li><li><strong>直观性</strong>：<code>VARCHAR</code> 类型直接存储有意义的字符或字符串枚举值，便于直接展示给用户或在报表中使用。</li></ol><p><strong>优点：</strong></p><ol><li><strong>易读易懂</strong>：直接存储有意义的字符或字符串枚举值，便于人类直接理解，无需进行额外转换。</li><li><strong>支持自助描述</strong>：在数据库层面就包含了枚举值的描述，无需特殊处理，减少了在应用层对枚举值进行解释的成本。</li></ol><p><strong>缺点：</strong></p><ol><li><strong>存储消耗</strong>：相比较于使用整数类型的枚举，使用 <code>VARCHAR</code> 类型会消耗更多的存储空间，特别在包含大量枚举字段的表中，可能对存储资源造成压力。</li></ol><p><strong>应用场景：</strong></p><ol><li><strong>描述性字段</strong>：适用于需要直接存储描述性枚举值的场景，如文本分类、产品类型等。</li><li><strong>数据稀疏场景</strong>：当枚举值数量较多、但实际使用频率不高时，使用 <code>VARCHAR</code> 类型可以避免预分配大量整数值，节省存储空间。</li></ol><p>总的来说，将 <code>VARCHAR</code> 类型用作枚举类型适用于需要直接存储有意义的描述性枚举值，同时要考虑存储消耗的问题。通常适用于枚举值数量有限、较为离散且需要直接展示给用户的情况。</p><p>TINYINT 和 VARCHAR 性能比较: </p><p><a href="https://www.cnblogs.com/narcissu5/p/17013330.html">Mysql使用varchar或者tinyint表示枚举性能差异 - Narcissu5 - 博客园 (cnblogs.com)</a></p><h3 id="ENUM"><a href="#ENUM" class="headerlink" title="ENUM"></a>ENUM</h3><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a><strong>特点</strong></h4><ol><li><strong>有限取值</strong>：ENUM 类型允许您为列指定一组可能的值。这意味着您可以限制该列的值只能是 ENUM 列表中定义的值的其中之一。</li><li><strong>内部存储</strong>：在数据库内部，ENUM 类型的数据存储为整数，并且会分别对应枚举列表中定义的值，这样可以有效地节省存储空间。</li></ol><p><strong>优点：</strong></p><ol><li><strong>数据完整性</strong>：使用 ENUM 类型可以确保存储在列中的值只会是事先定义好的枚举列表中的其中一个值，确保了数据的完整性和一致性。</li><li><strong>节省存储空间</strong>：由于 ENUM 类型内部以整数形式存储枚举值，可以节省存储空间，特别在包含大量枚举字段的表中，能够有效减少存储空间的占用。</li><li><strong>直观性</strong>：相比于整数类型的枚举，ENUM 类型直接在数据库中存储有意义的描述性枚举值，便于直接展示和理解。</li></ol><p><strong>缺点：</strong></p><ol><li><strong>扩展困难</strong>：如果需要添加新的枚举值，修改 ENUM 类型需要对表结构进行更改，这可能涉及到对数据库结构的修改和数据的迁移，相比于整数类型的枚举，扩展性较差。</li><li><strong>跨数据库兼容性</strong>：ENUM 类型在不同数据库系统之间的兼容性可能有所不同，因此在不同数据库系统之间迁移时需要格外留意。</li></ol><p>其中在MySQL中更是不建议, 除上述几点外, 还有如下几个MySql自身实现的原因:</p><p>​MySQL, ENUM使用数字索引(1，2，3，…)来表示字符串值(注意：下标并不是从 0 开始，而 0 则具有其它的意义（空）),   <strong>如果使用数字作为ENUM枚举常量，这种双重性很容易导致混乱</strong>，例如ENUM(‘1’，’2’，’3’), 尽量避免这么做。</p><p>​ MySQL中非严格模式下,  ENUM 列中插入无效的值，是允许的，但插入的是一个特殊的空字符串，而该空字符串的索引是 0。所以正常的enum索引从1开始，0就是留给这个空字符串的。</p><p>​</p><p>应用场景：</p><ol><li><strong>固定取值</strong>：ENUM 类型适用于具有<strong>固定</strong>的、不经常改变的取值范围的字段，如性别、婚姻状况等。</li><li><strong>状态字段</strong>：适用于表示<strong>固定</strong>状态的字段，如订单状态、用户状态等。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上, 关于MySql中枚举值, 建表时类型选择我们给出以下建议:</p><ol><li><strong>避免使用ENUM类型存储数字</strong>：在 MySQL 中，尽量避免使用 ENUM 类型存储数字类型的枚举值，特别是在与弱类型语言搭配使用时，可能会引起问题。如果需要存储数字类型的枚举值，建议考虑使用整数类型，如 <code>tinyint</code>，以提高稳定性和易读性。</li><li><strong>考虑枚举成员的稳定性和维护性</strong>：在选择枚举类型时，需要慎重思考枚举成员是否稳定以及变更的可能性。如果枚举成员会经常变动，应该避免使用 ENUM 类型，以免频繁的数据库结构变更带来麻烦。</li><li><strong>对于固定的字符串枚举成员</strong>：如果枚举成员是固定的字符串，可以考虑使用 <code>char</code> 类型，特别是当长度固定时，<code>char</code> 类型能有效节省存储空间。</li><li><strong>长度可变的字符串枚举成员</strong>：如果枚举成员长度不固定，可以考虑使用 <code>varchar</code> 类型。这种类型能够灵活存储不同长度的枚举值，适用于长度不固定且无需索引的场景。</li><li><strong>数值型的枚举成员</strong>：对于数值型的枚举成员，建议使用 <code>tinyint</code> 类型，占用较小的存储空间且具备较高的稳定性。</li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 语句执行顺序</title>
      <link href="/posts/6842.html"/>
      <url>/posts/6842.html</url>
      
        <content type="html"><![CDATA[<h1 id="MYSQL语句执行顺序"><a href="#MYSQL语句执行顺序" class="headerlink" title="MYSQL语句执行顺序"></a>MYSQL语句执行顺序</h1><p>&#x2F;&#x2F; 先复制一篇, 明天来改</p><h2 id="一、sql执行顺序"><a href="#一、sql执行顺序" class="headerlink" title="一、sql执行顺序"></a>一、sql执行顺序</h2><ol><li>from</li><li>join （内连接inner join &#x3D; join，左外连接left outer join &#x3D; left join 右外连接 right outer join &#x3D; right join ）</li><li>on</li><li>where</li><li>group by(开始使用select中的别名，后面的语句中都可以使用)</li><li>avg,sum….</li><li>having</li><li>select</li><li>distinct</li><li>order by</li><li>limit</li></ol><p>从这个顺序中我们不难发现，所有的 查询语句都是从from开始执行的，在执行过程中，每个步骤都会为下一个步骤生成一个虚拟表，这个虚拟表将作为下一个执行步骤的输入。</p><p><strong>第一步：</strong>首先对from子句中的前两个表执行一个笛卡尔乘积，此时生成虚拟表 vt1（选择相对小的表做基础表）。<br><strong>第二步：</strong>接下来便是应用on筛选器，on 中的逻辑表达式将应用到 vt1 中的各个行，筛选出满足on逻辑表达式的行，生成虚拟表 vt2 。<br><strong>第三步：</strong>如果是outer join 那么这一步就将添加外部行，left outer jion 就把左表在第二步中过滤的添加进来，如果是right outer join 那么就将右表在第二步中过滤掉的行添加进来，这样生成虚拟表 vt3 。</p><p><strong>第四步：</strong>如果 from 子句中的表数目多余两个表，那么就将vt3和第三个表连接从而计算笛卡尔乘积，生成虚拟表，该过程就是一个重复1-3的步骤，最终得到一个新的虚拟表 vt3。</p><p><strong>第五步：</strong>应用where筛选器，对上一步生产的虚拟表引用where筛选器，生成虚拟表vt4，在这有个比较重要的细节不得不说一下，对于包含outer join子句的查询，就有一个让人感到困惑的问题，到底在on筛选器还是用where筛选器指定逻辑表达式呢？on和where的最大区别在于，如果在on应用逻辑表达式那么在第三步outer join中还可以把移除的行再次添加回来，而where的移除的最终的。举个简单的例子，有一个学生表（班级,姓名）和一个成绩表(姓名,成绩)，我现在需要返回一个x班级的全体同学的成绩，但是这个班级有几个学生缺考，也就是说在成绩表中没有记录。为了得到我们预期的结果我们就需要在on子句指定学生和成绩表的关系（学生.姓名&#x3D;成绩.姓名）那么我们是否发现在执行第二步的时候，对于没有参加考试的学生记录就不会出现在vt2中，因为他们被on的逻辑表达式过滤掉了,但是我们用left outer join就可以把左表（学生）中没有参加考试的学生找回来，因为我们想返回的是x班级的所有学生，如果在on中应用学生.班级&#x3D;’x’的话，left outer join会把x班级的所有学生记录找回，所以只能在where筛选器中应用学生.班级&#x3D;’x’ 因为它的过滤是最终的。</p><p><strong>第六步：</strong>group by 子句将中的唯一的值组合成为一组，得到虚拟表vt5。如果应用了group by，那么后面的所有步骤都只能得到的vt5的列或者是聚合函数（count、sum、avg等）。原因在于最终的结果集中只为每个组包含一行。这一点请牢记。</p><p><strong>第七步：</strong>应用cube或者rollup选项，为vt5生成超组，生成vt6.<br><strong>第八步：</strong>应用having筛选器，生成vt7。having筛选器是第一个也是为唯一一个应用到已分组数据的筛选器。<br><strong>第九步：</strong>处理select子句。将vt7中的在select中出现的列筛选出来。生成vt8.</p><p><strong>第十步：</strong>应用distinct子句，vt8中移除相同的行，生成vt9。事实上如果应用了group by子句那么distinct是多余的，原因同样在于，分组的时候是将列中唯一的值分成一组，同时只为每一组返回一行记录，那么所以的记录都将是不相同的。</p><p><strong>第十一步：</strong>应用order by子句。按照order_by_condition排序vt9，此时返回的一个游标，而不是虚拟表。sql是基于集合的理论的，集合不会预先对他的行排序，它只是成员的逻辑集合，成员的顺序是无关紧要的。对表进行排序的查询可以返回一个对象，这个对象包含特定的物理顺序的逻辑组织。这个对象就叫游标。正因为返回值是游标，那么使用order by 子句查询不能应用于表表达式。排序是很需要成本的，除非你必须要排序，否则最好不要指定order by，最后，在这一步中是第一个也是唯一一个可以使用select列表中别名的步骤。</p><p><strong>第十二步：</strong>应用top选项。此时才返回结果给请求者即用户。</p><h2 id="二、mysql的执行顺序"><a href="#二、mysql的执行顺序" class="headerlink" title="二、mysql的执行顺序"></a>二、mysql的执行顺序</h2><h2 id="1、SELECT语句定义"><a href="#1、SELECT语句定义" class="headerlink" title="1、SELECT语句定义"></a>1、SELECT语句定义</h2><p>一个完成的SELECT语句包含可选的几个子句。SELECT语句的定义如下：<br>SQL代码</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;SELECT clause&gt; [&lt;FROM clause&gt;] [&lt;WHERE clause&gt;] [&lt;GROUP BY clause&gt;] [&lt;HAVING clause&gt;] [&lt;ORDER BY clause&gt;] [&lt;LIMIT clause&gt;]</span><br></pre></td></tr></table></figure><p>SELECT子句是必选的，其它子句如WHERE子句、GROUP BY子句等是可选的。<br>一个SELECT语句中，子句的顺序是固定的。例如GROUP BY子句不会位于WHERE子句的前面。</p><h3 id="2、SELECT语句执行顺序"><a href="#2、SELECT语句执行顺序" class="headerlink" title="2、SELECT语句执行顺序"></a>2、SELECT语句执行顺序</h3><p>SELECT语句中子句的执行顺序与SELECT语句中子句的输入顺序是不一样的，所以并不是从SELECT子句开始执行的，而是按照下面的顺序执行：</p><blockquote><p>开始-&gt;FROM子句-&gt;WHERE子句-&gt;GROUP BY子句-&gt;HAVING子句-&gt;ORDER BY子句-&gt;SELECT子句-&gt;LIMIT子句-&gt;最终结果</p></blockquote><p>每个子句执行后都会产生一个中间结果，供接下来的子句使用，如果不存在某个子句，就跳过<br>对比了一下，mysql和sql执行顺序基本是一样的, 标准顺序的 SQL 语句为:</p><p><img src="/SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.assets/v2-20fb436ec6e92712503c756b98b6f3f1_720w.webp" alt="img"></p><p>在上面的示例中 SQL 语句的执行顺序如下:</p><p>　　 (1). 首先执行 FROM 子句, 从 tb_Grade 表组装数据源的数据</p><p>　　 (2). 执行 WHERE 子句, 筛选 tb_Grade 表中所有数据不为 NULL 的数据</p><p>　　 (3). 执行 GROUP BY 子句, 把 tb_Grade 表按 “学生姓名” 列进行分组(注：这一步开始才可以使用select中的别名，他返回的是一个游标，而不是一个表，所以在where中不可以使用select中的别名，而having却可以使用，感谢网友 <strong>zyt1369</strong> 提出这个问题)<br>　　 (4). 计算 max() 聚集函数, 按 “总成绩” 求出总成绩中最大的一些数值</p><p>　　 (5). 执行 HAVING 子句, 筛选课程的总成绩大于 600 分的.</p><p>　　 (7). 执行 ORDER BY 子句, 把最后的结果按 “Max 成绩” 进行排序</p><p><a href="https://zhuanlan.zhihu.com/p/58639733">GROUP BY都不会！ROLLUP，CUBE，GROUPPING详解 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/68467070">SQL汇总统计： 在SQL中使用CUBE和ROLLUP实现数据多维汇总 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列 之 深入理解类加载机制</title>
      <link href="/posts/28357.html"/>
      <url>/posts/28357.html</url>
      
        <content type="html"><![CDATA[<h1 id="🌟-JVM系列-之-深入理解类加载机制"><a href="#🌟-JVM系列-之-深入理解类加载机制" class="headerlink" title="🌟 JVM系列 之 深入理解类加载机制"></a>🌟 JVM系列 之 深入理解类加载机制</h1><h2 id="👥-背景故事"><a href="#👥-背景故事" class="headerlink" title="👥 背景故事"></a>👥 背景故事</h2><p>在一次友人间的聚餐讨论中，我们提及了不同编程语言的优势与学习深度。对于一位以PHP为背景的朋友，有人建议其转向Java生态，因为Java具有成熟的生态系统和广泛的应用场景。朋友表示自己也会Java, 掌握Java的语法 …..</p><h2 id="💡-学习层次剖析"><a href="#💡-学习层次剖析" class="headerlink" title="💡 学习层次剖析"></a>💡 学习层次剖析</h2><p>学习编程语言可分为三个递进层次：</p><ol><li>📚 基础语法核心类库的熟悉使用</li><li>🌐 优势劣势分析与生态系统了解</li><li>🔧 底层运行机制探究与应用优化</li></ol><h2 id="💻-Java核心-JVM"><a href="#💻-Java核心-JVM" class="headerlink" title="💻 Java核心 -JVM"></a>💻 Java核心 -JVM</h2><p>Java的核心魅力在于Java虚拟机（<code>JVM</code>），它是跨平台执行Java字节码的关键。诸如<code>Kotlin</code>, <code> Groovy</code>、<code>Scala</code>等其他基于<code>JVM</code>的语言，通过深入理解<code>JVM</code>可以更高效地掌握。</p><h2 id="📖-类加载机制详解"><a href="#📖-类加载机制详解" class="headerlink" title="📖 类加载机制详解"></a>📖 类加载机制详解</h2><ul><li><strong>编译与执行</strong>：Java源代码经过<code>javap</code>编译转换成.class字节码文件，由<code>JVM</code>加载并解析执行，同时即时编译器（<code>JIT</code>）会将热点代码转化为高效的二进制代码, 通过解释器和即时编译器想结合预热后的代码可以达到很快的执行效率</li></ul><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401061705931.png" alt="image-20240106170521969"></p><ul><li><p><strong>类加载流程</strong></p><ul><li><p><strong>加载阶段</strong>：加载阶段的任务是读取字节码资源以静态结构的形式存储在方法区，同时在堆中生成<code>java.lang.Class</code>对象。</p></li><li><p><strong>验证阶段</strong>：验证阶段用于验证字节码的合法性, 确保程序安全性和完整性(分布在多个步骤中)</p></li><li><p><strong>准备阶段</strong>：准备阶段为类的静态变量分配内存并设置默认初始值。这为静态变量的初始化提供了基础。</p></li><li><p><strong>解析阶段</strong>：解析阶段将符号引用解析为直接引用(可以发生在初始化阶段的前后)</p></li><li><p><strong>初始化阶段</strong>：在初始化阶段，会执行类中定义的静态代码块和静态变量的赋值操作。这是程序准备运行的重要阶段。</p></li></ul></li></ul><h3 id="📥-加载"><a href="#📥-加载" class="headerlink" title="📥 加载"></a>📥 <strong>加载</strong></h3><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401042339913.png" alt="image-20240104233940085"></p><p>加载阶段是类加载的第一个阶段,这个阶段的任务是  </p><p><strong>读取<code>Class</code>资源</strong>, 以<strong>静态数据结构</strong>的形式存储(<code>instanceKlass</code>)在<strong>方法区</strong>，同时在<strong>堆</strong>中生成**<code>java.lang.Class</code>对象**供程序调用, 通过引用彼此关联.</p><blockquote><p>静态字段数据</p><p>1.7 之前静态字段信息存在方法区中</p><p>1.8 之后静态字段信息存在堆区java.lang.Class&#96;对象  中</p></blockquote><p>此处**<code>Class文件</code>**不只是本地文件, 泛指各种二进制流, 不限于 网络, 数据库,以及即时生成的Class文件(例如动态代理)</p><p>❓问题: 为什么要分别在堆和方法去中存两份Class信息呢?</p><ul><li><code>instanceKlass</code> 由C++实现, 无法直接给使用ava程序调用获取信息</li><li><code>instanceKlass</code>存储的信息比<code>java.lang.Class</code>对象更全面(如虚方法表),  <code>java.lang.Class</code></li></ul><p>只提供Java程序可能需要的类信息, 这样的设计符合开闭原则</p><h3 id="link-连接"><a href="#link-连接" class="headerlink" title=":link: 连接"></a>:link: 连接</h3><h4 id="🔍-验证"><a href="#🔍-验证" class="headerlink" title="🔍 验证"></a>🔍 <strong>验证</strong></h4><p>验证阶段是连接阶段的一部分。</p><p>验证阶段其实分布在各个阶段中</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401042313773.png" alt="image-20240104231254562"></p><p>其中, 在加载期间就会进行 **Class文件格式验证 **(<em>例如 cafebabe, 主次版本号等</em>)</p><p>此时 虽然方法区已经存在类的静态结构, 堆中存在类的Class对象但是并不代表<code>JVM</code>完全认可这个类</p><p>程序如果想要使用这个类, 就必须进行连接, 而<strong>连接的第一步</strong>就是对类进行验证, 包括</p><ul><li>元数据验证(<em>例如 类必须有父类(super不能为空)</em>)</li><li>字节码验证 (<em>例如 语义校验 (程序跳转位置是否正确)</em>)</li></ul><p>简单概括来说就是对<strong>class静态结构</strong>进行<strong>语法和语义</strong>上的分析保证其不会产生危害虚拟机的</p><p>如果两个验证结束, 那么虚拟机会<strong>姑且</strong>认为该类是安全的, 但是这并不意味着验证的结束, 在解析阶段, 还会进行<strong>符号引用的验证</strong></p><p>所以说验证其实可以分很多个步骤, 分别在不同的阶段执行, 验证阶段是不断迭代的, <strong>随着<code>JDK</code>的迭代</strong>, <strong>以后</strong>虚拟机开发人员还会再虚拟机中引入<strong>更多更完善的验证策略</strong></p><h4 id="⚙️-准备"><a href="#⚙️-准备" class="headerlink" title="⚙️ 准备"></a>⚙️ <strong>准备</strong></h4><p>准备阶段是连接阶段的另一部分。</p><p>在准备阶段，<code>JVM</code>为类中的<strong>静态变量</strong>分配内存并设置默认初始值</p><table><thead><tr><th>数据类型</th><th>初始值</th></tr></thead><tbody><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>short</td><td>0</td></tr><tr><td>char</td><td>‘&#x2F;u0000’</td></tr><tr><td>byte</td><td>0</td></tr><tr><td>boolean</td><td>false</td></tr><tr><td>float</td><td>0.0</td></tr><tr><td>double</td><td>0.0</td></tr><tr><td>引用数据类型</td><td>null</td></tr></tbody></table><p>如果静态变量被<code>final</code>修饰, 会赋值代码中的初值(<em>别忘了, final修饰的静态变量如果不初始化赋值会直接报错的</em>)</p><p>❓问题 :  为什么需要赋初始值呢?</p><p>假如这片内存区域之前使用过, 那么如果后续没有堆该静态变量进行主动的赋值, 这个静态变量的值就会是随机的</p><p>这里<strong>只包括静态变量</strong>，不包括成员变量。</p><h4 id="👉-解析"><a href="#👉-解析" class="headerlink" title="👉 解析"></a>👉 <strong>解析</strong></h4><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401050012740.png" alt="image-20240104235310370"></p><p>解析阶段是连接阶段的最后也是最重要的一步。</p><p>首先要明确在Java中 <strong>符号引用</strong>和<strong>直接引用</strong>这两个相关的概念。</p><p>符号引用是在<strong>编译期间</strong>使用的一种符号表示方式，它用来表示<strong>需要引用的类、方法、字段等实体</strong>。符号引用并<strong>不包含具体的内存地址</strong>，而是使用一个字符串或其他<strong>标识</strong>来表示。</p><p>直接引用是在<strong>运行期间</strong>使用的一种引用方式，它包含<strong>实际的内存地址或偏移量</strong>，可以<strong>直接访问</strong>对应的类、方法、字段等实体。</p><p>在<strong>编译阶段</strong>，如果一个类A引用了另一个类B，由于B可能还未被编译或加载，所以A无法知道B的实际地址。因此，在A的class文件中会使用一个字符串S来代表B的地址，S就被称为符号引用。</p><p>在运行时，如果A被加载并进行解析阶段，发现B还未被加载，则会触发B的加载过程，将B加载到虚拟机中。此时，A中B的符号引用将被替换成B的实际地址，即直接引用。这样，A就能够真正地调用B了。</p><p>值得注意的是，对于多态的情况，Java通过后期绑定来实现。如果A调用的B是一个具体的实现类，这被称为<strong>静态解析</strong>，因为解析的目标类很明确。</p><p>但如果B是一个<strong>抽象类或接口</strong>，它可能有<strong>多个具体的实现类</strong>。此时，B的具体实现并不明确，无法确定使用哪个具体类的直接引用进行替换。在<strong>运行过程</strong>中，当发生了调用时，虚拟机调用栈中将会得到具体的类型信息，此时可以进行解析，使用明确的直接引用来替换符号引用, 这就是<strong>动态解析</strong>。</p><p>因此，解析阶段有时会发生在初始化阶段之后，这是为了支持动态解析的需要</p><h3 id="🚀-初始化"><a href="#🚀-初始化" class="headerlink" title="🚀 初始化"></a>🚀 <strong>初始化</strong></h3><p>初始化阶段是类加载的最后一个阶段。在这个阶段中，会执行类中定义的<strong>静态代码块和成员变量的赋值操作</strong>(<em>执行<code>clinit</code>字节码指令, 执行顺序和Java中代码顺序是一致的</em>)，即执行<strong>主动资源初始化动作</strong>。</p><p>需要注意的是，调用<strong>构造方法不在这个阶段</strong>, 这是<strong>类阶段</strong>的初始化, 只有显式调用new指令才会调用构造函数进行对象实例化，这是对象层面的初始化。</p><h4 id="🌐-扩展"><a href="#🌐-扩展" class="headerlink" title="🌐 扩展"></a>🌐 <strong>扩展</strong></h4><p>以下几种方式会导致类的初始化 (-XX: +TraceClassLoading 参数可以打印出加载并初始化的类): </p><ul><li>访问一个类的静态变量  或者静态方法(注意如果变量是final修饰的并且等号右边是常量不会触发初始化)</li><li>调用Class.forName(String className)</li><li>new一个该类的对象时</li><li>执行Main方法的当前类</li></ul><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401061651484.png" alt="image-20240106165153965"></p><p>继承关系下类的初始化</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401061658307.png" alt="image-20240106165851734"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401061659688.png" alt="image-20240106165929709"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401061702384.png" alt="image-20240106170209007"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401061702459.png" alt="image-20240106170254698"></p><h2 id="✨-结论"><a href="#✨-结论" class="headerlink" title="✨ 结论"></a>✨ 结论</h2><p>深入理解Java类加载机制是提升Java技术栈的重要一环。从编写代码到在不同操作系统上运行起来，<code>JVM</code>在其中扮演了至关重要的角色。</p><p>每个阶段都有其独特目的和功能，而掌握这一过程不仅能应对面试考点，更能帮助我们在实际开发中解决复杂问题，充分利用Java的<strong>动态扩展性</strong>和<strong>性能优化特性</strong>。</p><p><em><strong>参考文献</strong>:</em></p><ul><li><em>[[寒食君JVM系列](<a href="https://space.bilibili.com/1578320">寒食君的个人空间-寒食君个人主页-哔哩哔哩视频 (bilibili.com)</a>)]</em></li><li><a href="https://www.bilibili.com/video/BV1r94y1b7eS?p=1&vd_source=a2cdc337163157715ec6605c77937a77">Java虚拟机</a></li><li><em>[<a href="https://link.zhihu.com/?target=http://www.ibm.com/developerworks/cn/java/j-lo-classloader/">深入探讨 Java 类加载器-成富</a>]</em></li><li><em>[深入理解Java虚拟机：JVM高级特性与最佳实践].周志明</em></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">The Java® Virtual Machine Specification (oracle.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列 之 深入探索Java 类加载器</title>
      <link href="/posts/58090.html"/>
      <url>/posts/58090.html</url>
      
        <content type="html"><![CDATA[<h1 id="🚀JVM系列-之-深入探索Java-类加载器"><a href="#🚀JVM系列-之-深入探索Java-类加载器" class="headerlink" title="🚀JVM系列 之 深入探索Java 类加载器"></a>🚀JVM系列 之 深入探索Java 类加载器</h1><p>Hey 大家好，我是 Shio👋。今天我们将深入探讨 Java 的类加载器，这是 Java 虚拟机（JVM）中一个重要的概念。在上一篇中，我们了解到 Java 类加载分为多个步骤，其中只有加载步骤中的读取二进制流与初始化部分是由上层开发者控制的, 剩下的步骤都由 JVM 掌控 。 这是为了符合面向对象中的开闭原则和封装思想。</p><h2 id="📦-类加载器的分类"><a href="#📦-类加载器的分类" class="headerlink" title="📦 类加载器的分类"></a>📦 类加载器的分类</h2><p>首先要声明的是，类加载器的分类属于 JVM 规范，是一种抽象的概念。各个 JVM 的实现方式可能不同。在JVM 规范中，类加载器分为<strong>启动类加载器</strong>和<strong>非启动类加载器</strong>。本节我们只讲最常见和主流 <strong>HotSpot</strong>: </p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401051414202.png" alt="image-20240105141428134"></p><ul><li><p><em><strong>启动类加载器</strong></em></p><ul><li><p><strong>Bootstrap Class Loader</strong>：</p><ul><li><p>采用 C 和 C++ 实现，嵌套在 JVM 内部，无法被程序引用。</p></li><li><p>主要加载 Java 的核心类库，如 JAVA_HOME &#x2F;lib 路径下的包(rt.jar tool.jar等)或由启动参数指定的核心类库。(<code>-Xbootclasspath/a: jar包目录/jar包名</code> 的类也会被其加载)</p></li><li><p>只加载包名在白名单中的文件，例如以 <code>java</code>、<code>javax</code> 开头的包。</p></li></ul></li></ul></li><li><p><em><strong>非启动类加载器</strong></em></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401061731570.png" alt="image-20240106173100183"></p><ul><li><strong>Extension Class Loader</strong>：<ul><li>由 <code>sun.misc.Launcher </code>内部类&#96;&#96;ExtensionClassLoader&#96; 实现。</li><li>默认加载 JAVA_HOME &#x2F;lib 路径下的包(<code>-Djava.et.dirs=jar包目录</code>进行扩展, 但会覆盖掉原始目录, 所以要附带原始目录)</li><li>用于加载 Java API 的拓展，对 Java 类库提供一些补充能力。</li></ul></li><li><strong>Application Class Loader</strong>：<ul><li>由<code> sun.misc.Launcher</code> 内部类 <code>AppClassLoader</code> 实现。</li><li>主要加载环境变量 <code>classpath</code> 或系统属性指定路径下的类库。</li><li>用于加载上层程序员编写的代码和第三方类库。</li></ul></li><li><strong>User Class Loader</strong>：<ul><li>用户自定义的类加载器，继承自 <code>java.lang.ClassLoader</code>。</li><li>允许用户获取任何来源的字节码进行加载。</li></ul></li></ul></li></ul><p>❓ 问题  能不能用Extension ClassLoader 来加载我自己写的代码 或者说是一些第三方类库?</p><p><a href="https://cloud.tencent.com/developer/ask/sof/102226389">StackOverFlow 国内镜像访问CLASSPATH vs java.ext.dirs-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p>直接上结论</p><p>你完全<strong>可以这么做</strong> 但是没有必要 这种操作呢 <strong>不符合规范</strong>工程项目中的分层和抽象 就像你完全可以把一个项目 所有的代码都写在一个文件中, 但是是<strong>不推荐</strong>这么做的 </p><h2 id="🌐-类加载器的命名空间"><a href="#🌐-类加载器的命名空间" class="headerlink" title="🌐 类加载器的命名空间"></a>🌐 类加载器的命名空间</h2><p>每个类加载器都有属于自己的<strong>命名空间</strong>，即使加载了相同限定名的类，JVM 也认为它们是<strong>不同的类</strong>。这有助于避免不同类加载器间的混乱，提高程序的开发和维护难度。</p><p>判断是否是同一个类的标准<br>在JVM中表示两个class对象是否为同一个类的两个必要条件：</p><ul><li><p>类的<strong>完整类名</strong>必须一致，包括包名。</p></li><li><p>加载这个类的<strong>ClassLoader</strong>（指ClassLoader实例对象）必须相同</p></li></ul><p>换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个对象也不是相等的。</p><p>示例(来源于&lt;&lt;深入理解Java虚拟机&gt;&gt;): </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">myLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassLoader</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> name.substring(name.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">                    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> getClass().getResourceAsStream(fileName);</span><br><span class="line">                    <span class="keyword">if</span> (is == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">super</span>.loadClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[is.available()];</span><br><span class="line">                    is.read(b);</span><br><span class="line">                    <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> myLoader.loadClass(<span class="string">&quot;com.study.Test&quot;</span>).newInstance();</span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">        System.out.println(obj <span class="keyword">instanceof</span> com.study.Test);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">class com.study.Test</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>注意: </p><p>​上述例子中,  只有当这个限定名类(com.study.Test)与这个Main类在<strong>同一个包下时</strong>(com.study)，返回的结果才会为<strong>false</strong>，因为 如果这个限定名类与Main类不在同一个包下时，<strong>InputStream is &#x3D; getClass().getResourceAsStream(filename)</strong>, 不同包下这个方法<strong>返回null</strong>，然后直接走的<strong>super方法</strong>，你需要去修改下filename才能找到文件位置，返回的结果才能为true, 而同包的话就可以直接找到</p><h2 id="🤝-双亲委派模型"><a href="#🤝-双亲委派模型" class="headerlink" title="🤝 双亲委派模型"></a>🤝 双亲委派模型</h2><blockquote><p>引言:  </p><p>​竟然Java中存在这么多类加载器,那么如何判断一个类到底由谁来加载呢? 有的同学可能会说根据目录划分, 那么如果我把类在每一个目录都复制一份, 那么由谁来加载呢, 解决这个问题就需要引入Java的双亲委模型了</p></blockquote><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401051651853.png" alt="image-20240105145552504"></p><p>为了保证类加载的<strong>安全性</strong>(<em>攻击方在提供的ar包中自己实现了一个 java.lang.String, 引入后如何确保核心类库的完整性质和安全性</em>)和<strong>避免重复加载</strong> (<em>避免同一个类被多次加载</em>)</p><p>JVM 引入了<strong>双亲委派模型</strong>，即类加载器在收到加载请求时不会立即加载，而是<strong>传递</strong>给<strong>父加载器</strong>。只有父加载器无法完成加载时，子加载器才会尝试加载。这样确保了每个类只会被<strong>加载一次</strong>，<strong>避免了混乱</strong>。</p><p><strong>向上查找</strong> : 保证类不重复加载</p><p><strong>向下加载</strong>:  以加载优先级进行加载(Bootstrap -&gt; Extension &gt; Application )</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401061826186.png" alt="image-20240106182648876"></p><p><em>Arthas验证</em></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401061848753.png" alt="image-20240106184840870"></p><p>双亲委派模型通过 <code>java.lang.ClassLoader</code> 的 <code>loadClass</code> 方法实现。该方法首先检查是否已加载，然后传递给父加载器，如果父加载器无法加载，则调用 <code>findClass</code> 方法加载。</p><h4 id="🔍源码解析"><a href="#🔍源码解析" class="headerlink" title="🔍源码解析"></a>🔍源码解析</h4><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401061914459.png" alt="image-20240106191457783"></p><p>接下来，我们通过源码来理解双亲委派模型的实现。</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401051651773.png" alt="image-20240105150139002"></p><p>在java.lang.ClassLoader中的<strong>loadClass方法</strong>中，</p><ul><li><p>首先检查类是否已经加载, </p></li><li><p>如果没有，则启动加载流程。<code>parent</code>变量代表当前ClassLoader的父加载器，这里通过<strong>组合而非继承</strong>实现父子关系。当**<code>parent</code>为null<strong>时，约定为</strong>Bootstrap Class Loader**。</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401061844325.png" alt="image-20240106184429274"></p></li><li><p>如果<code>parent</code>不为null，将加载请求传递给父加载器。只有父加载器无法完成加载时，子加载器才会尝试自己加载，这是双亲委派的关键。</p></li></ul><p><strong>findClass方法</strong>表示如何<strong>寻找指定限定名的class</strong>，需要各个类加载器<strong>自己实现</strong>。</p><blockquote><p>查找具有指定二进制名称的类。该方法应由遵循委托模式加载类的类加载器实现重载，并将在检查父类加载器是否有请求的类后由 loadClass 方法调用。</p></blockquote><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401051506271.png" alt="image-20240105150638331"></p><p>Extension Class Loader和Application Class Loader使用了相同的逻辑(父类URLClassLoader提供)，将类的限定名转化为文件路径，通过UCP（Unified Class Path）寻找文件资源</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401051519801.png" alt="image-20240105151929138"></p><p>找到资源之后, 然后调用<code>defineClass</code>进行类加载的后续流程。<code>defineClass</code>方法被<code>final</code>修饰，表示最终由java.lang.ClassLoader来进行后续操作。</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401051516945.png" alt="image-20240105151611984"></p><p>综上可以总结出双亲委派模型的核心代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (parent != null) &#123;</span><br><span class="line">c = parent.loadClass(name, false);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">c = findBootstrapClassOrNull(name);</span><br><span class="line">&#125;</span><br><span class="line">if (c == null) </span><br><span class="line">c = findClass(name);</span><br></pre></td></tr></table></figure><h4 id="❓-双亲委派模型的疑问"><a href="#❓-双亲委派模型的疑问" class="headerlink" title="❓ 双亲委派模型的疑问"></a>❓ 双亲委派模型的疑问</h4><p><strong>问题一</strong>：不同的类加载器，除了读取二进制流的动作和范围不一样，后续的加载逻辑是否也不一样？根据源码，我们了解到所有非Bootstrap Class Loader都继承自java.util.ClassLoader，都是由这个类的<code>defineClass</code>方法来进行后续处理。</p><p><strong>问题二</strong>：遇到限定名一样的类，这么多类加载器会不会产生混乱？根据源码，我们知道不同类加载器有不同的加载范围，越核心的类越由上层加载器加载。一旦某个类被加载，<strong>被动情况下不会</strong>再去加载相同限定名的类，<strong>有效避免混乱</strong>。</p><p><strong>问题三</strong>:  攻击方在提供的jar包中自己实现了一个 java.lang.String,  双亲委派机制如何保证如何确保核心类库的完整性质和安全性?   双亲委派机制通过<strong>向下加载</strong>机制保证了 java核心类库中的类, 永远都由先 Bootstrap ClassLoader加载, 攻击方的java.lang.String不会被加载</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取Application ClassLoader</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> Demo.class.getClassLoader();</span><br><span class="line">        System.out.println(cl);</span><br><span class="line">        <span class="comment">// 使用Application ClassLoader加载jdk核心类库的java.lang.String</span></span><br><span class="line">        Class&lt;?&gt; stringClazz = cl.lloadClass(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">        <span class="comment">// 由于双亲委派模型的存在, 最终java.lang.String将被委派给BootStrap ClassLoader加载</span></span><br><span class="line">        System.out.println(stringClazz.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401061841818.png" alt="image-20240106184131302"></p><p>当然, 即使你自定义类加载器去尝试的话, 以”java.”包名开头的类也会直接抛异常</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401061933343.png" alt="image-20240106193318357"></p><p>尽管双亲委派模型在大部分情况下是透明且可靠的，但并非具有强约束力的模型，存在设计缺陷, 在大多数情况下, 双亲委派模型是生效而且好用的。</p><p>但在一些情况下，双亲委派模型<strong>可以被主动破坏</strong>。例如，通过重写<code>loadClass</code>方法，我们可以破坏原有的双亲委派逻辑，导致限定名对应两种不同的情况。(就像上文中证明类加载器命名空间的那个例子, 重写了loadClass方法, 破坏了原有双亲委派模型, 出现了一个限定名对应两种不同Class的情况, 除非有特殊业务场景, <strong>一般不要主动破坏</strong>)</p><h2 id="🚨-双亲委派模型的破坏"><a href="#🚨-双亲委派模型的破坏" class="headerlink" title="🚨 双亲委派模型的破坏"></a>🚨 双亲委派模型的破坏</h2><h3 id="🩸-First-Blood"><a href="#🩸-First-Blood" class="headerlink" title="🩸 First Blood"></a>🩸 First Blood</h3><p>既然JVM推荐并希望开发者遵循双亲委派模型</p><p>为什么不将 <code>loadClass</code> 方法设定成 <code>final</code> 来限制重写?  这样上层开发者就不久必须强制遵循双亲委派逻辑了么?</p><p>事实上，Java.lang.ClassLoader在Java很早的版本就存在了, 而双亲委派模型是在JDK1.2才引入的</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401051534628.png" alt="image-20240105153413082"></p><p>也就说 , 在JDK1.2版本引入双亲委派模型的特性之前就<strong>已经存在着大量重写loadClass方法的代码</strong>了，而JVM无法拒绝<strong>支持这些旧代码</strong>，只能采取<strong>补救措施</strong>。因此，JDK1.2版本后引入了 <code>findClass</code> 方法来推荐用户重写，而不是直接重写 <code>loadClass</code> 方法，这样就依然能够符合双亲委派模型的逻辑。</p><p>这算是<strong>第一次对双亲委派模型的破坏</strong></p><h3 id="🩸-🩸-Double-Kill"><a href="#🩸-🩸-Double-Kill" class="headerlink" title="🩸 🩸 Double Kill"></a>🩸 🩸 Double Kill</h3><p>有了第一次, 自然会有第二次</p><p>以JDK操作数据库为例, JDK想要有操作数据库的功能, 而数据库有很多种, 而且会随着时间而增多, JDK不可能把所有数据库的代码一一实现, 那么比较合理的就是 JDK提供一组规范接口, 由不同的数据库厂商实现这组接口即可</p><p>那么问题就出现了, <strong>JDK自己定义的接口类</strong>的加载一定是使用到了<strong>上层类加载器</strong>(BootStrap ClassLoader), 但当你调用JDK接口时必然会触发第三方类库的动态加载, 而<strong>第三方厂商的实现类</strong>加载, 使用的是<strong>下层类加载器</strong>(Application ClassLoader) ,<del>这就不符合自下而而上的委派加载顺序了, 而是出现了<strong>上层类加载器放下身段去调用下层类加载器</strong>的情况 这就产生了<strong>对双亲委派模型的破坏</strong></del></p><blockquote><p>纠正 :</p><p>这种说法最早源于周志明老师的&lt;&lt;深入理解Java虚拟机&gt;&gt;, 实际上自己思考后, SPI机制 没有打破双亲委派机制, 通过currentThread获取ApplicationClassLoader 来加载类, 不仍然还是遵从 向上查找, 向下加载的机制? 所以最我的终观点是  没有打破, 当然下文, 源码解析仍然正确,别跳过塞</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401062342128.png" alt="image-20240106195642054"></p></blockquote><p>示例代码: </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/数据库名?serverTimezone=UTC&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;数据库账号名&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;数据库账号密码&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">            System.out.println(<span class="string">&quot;DriverManager 的ClassLoader为 : &quot;</span> + DriverManager.class.getClassLoader());</span><br><span class="line">            Enumeration&lt;Driver&gt; drivers = DriverManager.getDrivers();</span><br><span class="line">            <span class="keyword">while</span> (drivers.hasMoreElements()) &#123;</span><br><span class="line">                <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> drivers.nextElement();</span><br><span class="line">                System.out.print(driver + <span class="string">&quot; 的ClassLoader为 : &quot;</span>);</span><br><span class="line">                System.out.println(driver.getClass().getClassLoader());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(conn);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果:</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401051639227.png" alt="image-20240105163920912"></p><p><code>null</code> 即 BootStrap ClassLoader</p><p><code>sun.misc.Launcher$AppClassLoader@18b4aac2</code>  即 Application ClassLoader</p><p>以<code>DriverManager</code>类为例，其类加载器为<code>null</code>，即约定为<code>bootstrap class loader</code>，而<code>DriverManager</code>内部加载的两个<code>Driver</code>的类加载器均为<code>application class loader</code>，这表明<code>bootstrap class loader</code>委托了<code>application class loader</code>加载了来自第三方的类, <del>这就是<strong>SPI</strong>对双亲委派模型的破坏。</del></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401051618628.png" alt="image-20240105161803714"></p><p>进一步分析<code>DriverManager</code>的源码可以发现，其主动对第三方Driver类进行加载，扫描所有注册为<code>java.sql.Driver</code>开头的第三方类，然后使用<code>ServiceLoader</code>进行加载，而<code>ServiceLoader</code>内部使用了当前线程context中的类加载器，默认为<code>application class loader</code>，因此这些第三方类也能够被正常加载，<del>也从而破坏了双亲委派模型的约定。</del></p><p>这便是<del><strong>第二次对双亲委派模型的破坏</strong></del></p><h3 id="🩸-🩸-🩸-Triple-Kill"><a href="#🩸-🩸-🩸-Triple-Kill" class="headerlink" title="🩸 🩸 🩸 Triple Kill"></a>🩸 🩸 🩸 Triple Kill</h3><p>随着对模块化和热替换的追求，希望在着程序运行期间, 动态地对部分组件代码进行替换，可想而知这里又会涉及到很多的自由的类加载操作, 所以又将对双亲委派模型的践踏。(<em>存疑</em>)</p><p>综上, 尽管双亲委派模型在大部分情况下有效，但在某些场景下可被主动破坏。主要有三次破坏：</p><ol><li><strong>自定义类加载器</strong>：用户可以通过自定义类加载器重写 <code>loadClass</code> 方法，破坏默认的委派逻辑。</li><li><strong>Java SPI 机制</strong>：在服务提供者接口（SPI）中，JDK 会主动加载第三方实现，违反了双亲委派的加载顺序。</li><li><strong>模块化和热替换</strong>：随着对模块化和热替换的追求，程序可能会动态地对部分组件代码进行替换，导致对双亲委派模型的践踏。</li></ol><h2 id="📚-总结"><a href="#📚-总结" class="headerlink" title="📚 总结"></a>📚 总结</h2><p>尽管双亲委派模型被破坏了三次，它在大部分场景下仍然是一个有效、透明的设计。在发现缺陷时，JVM 设计者采取了一些补救措施。总体而言，双亲委派模型是一个不错的设计，如果有更好的设计思路，欢迎分享讨论。</p><p>希望通过本文的介绍，大家对 Java 类加载器有了更深入的理解。下一篇我们将继续探讨 Java 中的其他关键概念，敬请期待！如果有任何问题或建议，欢迎留言交流。感谢阅读！ 🚀</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h4 id="打破双亲委派机制的三种方式"><a href="#打破双亲委派机制的三种方式" class="headerlink" title="打破双亲委派机制的三种方式"></a>打破双亲委派机制的三种方式</h4><ul><li><strong>自定义ClassLoader并重写loadClass方法</strong>, 就可以将双亲委派机制代码去除(如Tomcat通过这种方式实现应用之间的隔离)</li><li><del>利用<strong>上下文类加载器</strong>加载类, 例如JDBC和JNDI</del>(没有打破)</li><li>历史上<strong>Osgi框架</strong>实现一套新的类加载机制, 允许同级之间委托类加载</li></ul><h4 id="Arthas-实现不停机热部署"><a href="#Arthas-实现不停机热部署" class="headerlink" title="Arthas 实现不停机热部署"></a>Arthas 实现不停机热部署</h4><blockquote><p>背景：<br>        小李的团队将代码上线之后，发现存在一个小bug,但是用户急着使用，如果重<br>新打包再发布需要一个多小时的时间，所以希望能使用arthas尽快的将这个问<br>题修复。</p></blockquote><p>我们已知 某个类代码逻辑缺陷的情况下, 在不停机的情况下, 对代码进行热更改热部署</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在出问题的服务器上部署一个Arthas , 并启动。</span><br><span class="line"></span><br><span class="line">// 反编译class文件，然后可以用编辑器进行修改</span><br><span class="line">jad-source-only  `类全限定名`  &gt;`目录/文件名.java` </span><br><span class="line">   </span><br><span class="line">// 获取原java文件使用的类加载器的hashcode</span><br><span class="line">sc -d `类全限定名`  </span><br><span class="line"> </span><br><span class="line">// 将修改后的.java文件使用原类加载器编译成class文件</span><br><span class="line">mc -c  类加载器的hashcode `目录/文件名.java` -d 输出目录</span><br><span class="line">    </span><br><span class="line">// 用retransform命令加载新的class文件</span><br><span class="line">retransform class.文件所在目录/xxx.class</span><br></pre></td></tr></table></figure><ul><li>注意事项:</li></ul><p>​程序重启后, 字节码文件就会恢复, 除非将class文件放入jar包中更新</p><p>​使用retransform不能添加方法或者字段, 也不能更新正在执行中的方法</p><h4 id="JDK9-之后的类加载器变化"><a href="#JDK9-之后的类加载器变化" class="headerlink" title="JDK9 之后的类加载器变化"></a>JDK9 之后的类加载器变化</h4><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401062027257.png" alt="image-20240106202658811"></p><p>JDK9 引入了模块化的概念, 加载类也从之前的按照目录加载, 转变为按照.jmod文件进行加载</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401062028040.png" alt="image-20240106202843626"></p><p>即使使用Java实现启动类加载器, 也仍然<strong>无法获取</strong>启动类加载器</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401062031363.png" alt="image-20240106203157866"></p><p>理论上使用了<strong>模块化</strong>的思想, 扩展就<strong>不需要使用ExtensionClassLoader了</strong>, 而为了兼容还是将其保留</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401062029221.png" alt="image-20240106202940432"></p><h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><p> <img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401062034485.png" alt="image-20240106203451263"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401062035727.png" alt="image-20240106203517200"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401062035517.png" alt="image-20240106203547091"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401062036215.png" alt="image-20240106203640068"></p><p><em><strong>参考文献</strong>:</em></p><ul><li><em>[[寒食君JVM系列](<a href="https://space.bilibili.com/1578320">寒食君的个人空间-寒食君个人主页-哔哩哔哩视频 (bilibili.com)</a>)]</em></li><li><a href="https://www.bilibili.com/video/BV1r94y1b7eS?p=1&vd_source=a2cdc337163157715ec6605c77937a77">Java虚拟机</a></li><li><em>[<a href="https://link.zhihu.com/?target=http://www.ibm.com/developerworks/cn/java/j-lo-classloader/">深入探讨 Java 类加载器-成富</a>]</em></li><li><em>[深入理解Java虚拟机：JVM高级特性与最佳实践].周志明</em></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">The Java® Virtual Machine Specification (oracle.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列 之 自底向上理解Java内存模型</title>
      <link href="/posts/24862.html"/>
      <url>/posts/24862.html</url>
      
        <content type="html"><![CDATA[<h1 id="🌱JVM系列-之-自底向上理解Java内存模型"><a href="#🌱JVM系列-之-自底向上理解Java内存模型" class="headerlink" title="🌱JVM系列 之 自底向上理解Java内存模型"></a>🌱JVM系列 之 自底向上理解Java内存模型</h1><p>Hey 大家好，我是 Shio👋。今天我们将深入探讨Java 内存模型</p><p>⚠️ 注意!!!!</p><p>🚧🚧🚧 本文并不完整, 还未彻底 完成🚧🚧🚧</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401052153173.png" alt="image-20240105215354498"></p><h2 id="💾内存模型发展"><a href="#💾内存模型发展" class="headerlink" title="💾内存模型发展"></a>💾内存模型发展</h2><p><strong>:rocket: 单处理器时代的纵向优化</strong></p><p>在单处理器计算机时代，程序员只需编写单线程程序，除了算法降低复杂度外,  只能依赖硬件和编译器进行<strong>纵向优化</strong>。</p><p>随着硬件发展速度趋于平缓，工程师们开始追求<strong>横向拓展</strong>，即在单台计算机中使用更多的处理器。</p><p><strong>👾 缓存的引入与多处理器时代的问题</strong></p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401052157605.png" alt="image-20240105215702513" style="zoom: 40%;" /><p>为弥补CPU处理速度与内存读写速度的差距，引入了缓存以提高效率。然而，在多处理器环境下，缓存带来了数据不一致的问题。</p><p><strong>🚧 缓存一致性协议的设计</strong></p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401052200730.png" alt="image-20240105215925754" style="zoom: 40%;" /><p>为此科学家们设计了<strong>缓存一致性协议</strong>，解决多个CPU缓存之间的同步问题这些协议, 保证了数据的一致性。</p><p>大致分为<strong>窥探型</strong>和基于<strong>目录型</strong>。</p><p>可想而知, 为了保证多个CPU缓存一致性和同步, 协议中一定涉及到<strong>等待</strong>和<strong>唤醒</strong>等同步步骤</p><p>对于CPU这种运算速率极快的组件来说, 任何等待都是对其性能极大的浪费 (CPU A 在读取 D时还需要等待 CPU B 将D写回到内存)</p><p><strong>🛠 优化与异步化</strong></p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401052330377.png" alt="image-20240105220954445" style="zoom:40%;" /><p>为减少性能问题，将CPU<strong>同步改为异步</strong>。(CPU A 在读取 D时, 注册一个读取D的消息, 然后CPUA就能去做自己的事情, 等CPUB写回数据D后 响应这个注册消息, CPU发现消息被响应后再去读D, 这样就能提高效率)</p><p>通过注册消息和响应的方式，提升了数据访问的效率。</p><p>然而，这可能带来<strong>指令重排序</strong>的问题，CPU仍需确保程序执行结果的正确性</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401061350635.png" alt="image-20240106135011906"></p><p>具体实现可以参考MESI缓存一致性协议这篇博客, 会对Store Buffer,   Store Forwarding, Invaild Queue, 读屏障, 写屏障等相关概念进行讲解</p><h2 id="🚀-Java线程模型"><a href="#🚀-Java线程模型" class="headerlink" title="🚀 Java线程模型"></a>🚀 Java线程模型</h2><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401052222794.png" alt="image-20240105222249634" style="zoom:60%;" /><p>随着高级语言的流行，工程师们开始设计<strong>编程语言级别</strong>的内存模型，以实现一致性的内存视图。</p><h3 id="🌐-Java线程模型"><a href="#🌐-Java线程模型" class="headerlink" title="🌐 Java线程模型"></a>🌐 Java线程模型</h3><p>在<strong>硬件内存模型</strong>之上，还存在着为编程语言设计的内存模型，比如<strong>Java内存模型</strong>,  它定义了多个线程之间的交互方式和行为。</p><p>Java内存模型<strong>屏蔽</strong>了各种硬件和操作系统的内存访问差异，提供了一个<strong>统一的内存视图</strong>给开发者使用, 实现了Java程序能够在各种硬件平台下都能按照预期方式运行 。</p><p>Java内存模型的抽象如下图所示：</p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401052226009.png" alt="image-20240105222620913" style="zoom: 50%;" /><p>如上图, 每个工作线程都拥有独占的本地内存, 本地内存中存储的是私有变量以及共享变量的副本, 并且使用一定机制来控制本地内存和贮存之间的读写数据时的同步问题</p><h3 id="🗄-本地内存的构成"><a href="#🗄-本地内存的构成" class="headerlink" title="🗄 本地内存的构成"></a>🗄 <strong>本地内存的构成</strong></h3><p>工作线程的本地内存可以抽象为<strong>线程栈（Thread Stack）</strong>和<strong>堆（Heap）</strong>。</p><p>在线程栈中，有两种类型的变量：原始类型的变量（如int、char）总是存储在线程栈上。而对象类型的变量，它的<strong>引用</strong>或者说指针是存储在线程栈上的，而具体的对象则存储在堆上。</p><p>而在堆中，保存了对象本身和由该对象引用的其他对象。</p><p>可以理解为，线程栈和堆都是对物理内存的一种<strong>抽象</strong>。这样的设计使开发者只需要关注自己编写的程序中涉及线程栈和堆的部分，而<strong>无需关心</strong>底层寄存器、CPU缓存, 内存的实现。</p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401052228330.png" alt="image-20240105222849465" style="zoom: 60%;" /><h3 id="🔗-JVM内存模型与硬件内存映射关系"><a href="#🔗-JVM内存模型与硬件内存映射关系" class="headerlink" title="🔗 JVM内存模型与硬件内存映射关系"></a>🔗 JVM内存模型与硬件内存映射关系</h3><p>可以猜测, <strong>线程栈(Thread Stack)<strong>大部分情况在读写内存, 对内存读写</strong>性能</strong>要求高, 所以是在<strong>寄存器和缓存</strong>来实现</p><p>而 <strong>堆(Heap)</strong> 需要<strong>存储</strong>大量的内存, 需要更大的容量, 那么他可能大部分都是使用<strong>主存</strong>来实现的</p><p>这种映射关系使得Java程序在不同的硬件平台上都能够按照<strong>一致的方式</strong>进行运行，从而提供了强大的<strong>可移植性</strong>和<strong>跨平台特性</strong>。</p><h3 id="📡-Java线程通信和指令"><a href="#📡-Java线程通信和指令" class="headerlink" title="📡 Java线程通信和指令"></a>📡 Java线程通信和指令</h3><p>Java内存模型通过一些机制来实现主存与工作内存之间的数据传输与同步。</p><p>这种数据传递是线程之间的通信方式，主存与工作内存之间通过<strong>八个指令</strong>来实现数据的读写与同步。这些指令可以根据其作用分为两类：储存相关指令和工作内存相关指令。</p><table><thead><tr><th>作用于内存</th><th>作用于工作内存</th></tr></thead><tbody><tr><td>lock : 锁定</td><td>load : 载入</td></tr><tr><td>unlock : 解锁</td><td>use : 使用</td></tr><tr><td>read : 读取</td><td>assign : 赋值</td></tr><tr><td>write : 写入</td><td>store : 存储</td></tr></tbody></table><p>主存相关指令用于主存和工作内存的数据传输，包括<code>lock</code>、<code>unlock</code>、<code>read</code>和<code>write</code>指令。工作内存相关指令用于工作内存上的数据读写和同步操作，包括&#96;&#96;load <code>、</code>use<code>、</code>assign<code>和</code>store&#96;指令。</p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401052327643.png" alt="image-20240105224852649" style="zoom: 50%;" /><p>了解这些指令的存在和作用，而无需详细记住每个指令的内容，有助于理解Java内存模型的设计原理。</p><h3 id="🔍-可见性与原子性问题"><a href="#🔍-可见性与原子性问题" class="headerlink" title="🔍 可见性与原子性问题"></a>🔍 可见性与原子性问题</h3><p>在多线程编程中，可能会遇到<strong>可见性</strong>和<strong>原子性</strong>问题。</p><p>可见性问题指的是，当一个线程将变量刷新到主内存后，其他线程如何获取变量的最新值。</p><p>原子性问题指的是，多个线程同时对变量进行操作，结果是否符合预期。</p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401052327022.png" alt="image-20240105225526017" style="zoom: 50%;" /><p>假设本地内存A和本地内存B都保存了变量X的副本，且值都为1。线程A将X修改为2并刷新到主存中，此时线程B想要读取变量X，默认情况下将从本地内存B中读取，而此时本地内存B中的X仍旧是1，所以线程B无法获取到最新的值, 这就是一个可见性问题。 </p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202401052327833.png" alt="image-20240105225724949" style="zoom:50%;" /><p>假如线程A和B都从主存中读取了变量X, 此时X是等于1的分别在各自的本地内存中自增了, 以X变为了2 然后再刷新回主存, 这里就有一个问题 实际上总共自增了2次 , X应该是变为3的 , 但是主存中的X却为2, 这就是一个原子性问题。</p><p>下文我们将会通过具体代码进行的讲解</p><h2 id="📚-并发三要素"><a href="#📚-并发三要素" class="headerlink" title="📚 并发三要素"></a>📚 并发三要素</h2><p>当多个线程在并发操作共享数据时呢 可能会引发各种各样的问题 这些问题呢被总结为三个要素</p><ul><li>可见性 </li><li>原则性 </li><li>有序性</li></ul><h3 id="👁-可见性问题"><a href="#👁-可见性问题" class="headerlink" title="👁 可见性问题"></a>👁 可见性问题</h3><p>可见性问题指的是当一个线程<strong>修改了共享变量的值</strong>时，其他线程需要<strong>立即</strong>知道该变化。</p><p>当一个线程在自己的工作内存中修改了某个变量，应该把该变量<strong>立即刷新</strong>到主内存，并使其他线程<strong>感知</strong>到这个<strong>修改</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>( () -&gt; &#123;</span><br><span class="line">           <span class="keyword">while</span> (a != <span class="number">2</span>) &#123;</span><br><span class="line">           &#125; </span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>( () -&gt; &#123;</span><br><span class="line">                a = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">// 在启动 t2 之前等待 1 秒</span></span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序将会死循环, 因为对于<code>t1</code>来说, <code>t2</code> 对变量a修改不可见</p><h3 id="🔄️有序性问题"><a href="#🔄️有序性问题" class="headerlink" title="🔄️有序性问题"></a>🔄️有序性问题</h3><p>线程B 需要读到被修改的变量D, 线程A应该修改, 但因为重排序导致线程没有及时修改变量D(指令重排序导致)</p><p>这句话可能有些拗口, 请看以下这个例子, 请问 代码执行到步骤4时, 变量i一定是1吗?</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            a = <span class="number">1</span>;<span class="comment">// 步骤1</span></span><br><span class="line">            flag = <span class="literal">true</span>;<span class="comment">// 步骤2</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;<span class="comment">// 步骤3</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a;<span class="comment">// 步骤4</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们上面提到硬件内存模型中存在<strong>指令重排序</strong>, 而在其上层的Java内存模型也存在指令重排序的现象(为提高效率使用<strong>异步通信</strong>导致的)</p><p>当这种指令重排在单线程环境下，因为处理器会保证结果的一致性，我们并不需要关心这个问题。</p><p>但在多线程环境下, 由于指令重排序, 可能会导致运行顺序如下</p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402150042753.png" alt="image-20240106121542500" style="zoom: 80%;" /><p>此时 a &#x3D; 0; </p><blockquote><p>如果在本线程内观察，所有操作都是天然有序的。如果在一个线程中观察另一个线程，所有操作都是无序的。前半句是指“线程内似表现为串行的语义”，后半句是指“指令重排”现象和“工作内存与主内存同步延迟”现象。                       </p><p>​《深入理解Java虚拟机》</p></blockquote><h3 id="⚛-原子性问题"><a href="#⚛-原子性问题" class="headerlink" title="⚛ 原子性问题"></a>⚛ 原子性问题</h3><p><strong>原子性问题</strong>指的是当多个线程对共享变量进行并发操作时，并发操作的结果是否与期望一致。</p><p>例如，多个线程同时对变量X进行自增操作，预期X的值应该递增两次，但实际上只递增了一次。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TOTAL</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// volatile 关键字解决可见性问题，但并没有解决原子性问题</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Main</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; main.addCount());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; main.addCount());</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread1.join();</span><br><span class="line">            thread2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addCount</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (start ++ &lt; TOTAL)&#123;</span><br><span class="line">            <span class="built_in">this</span>.count ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述结果将会在 1W ~ 2W之间, 原因是 在count++ 的操作并非原子性的</p><p>而是分为</p><ul><li><p>读取主内存值到本地内存</p></li><li><p>修改本地内存值</p></li><li><p>写回主内存</p></li></ul><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402150042786.png" alt="image-20240106134500287" style="zoom:80%;" /><p>这样两个线程总计+2的操作, 写入内存只+1</p><h2 id="🔒-volatile与synchronized关键字"><a href="#🔒-volatile与synchronized关键字" class="headerlink" title="🔒 volatile与synchronized关键字"></a>🔒 volatile与synchronized关键字</h2><blockquote><p><code>synchronized</code>关键字在需要原子性、可见性和有序性这三种特性的时候都可以作为其中一种解决方案，看起来是“万能”的。的确，大部分并发控制操作都能使用synchronized来完成。</p><p>​                                        《深入理解Java虚拟机》</p></blockquote><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>被<code>synchronized</code>修饰的代码块及方法，在同一时间，只能被单个线程访问。</p><p><code>synchronized</code>，是Java中用于解决并发情况下数据同步访问的一个很重要的关键字。当我们想要保证一个共享资源在同一时间只会被一个线程访问到时，我们可以在代码中使用<code>synchronized</code>关键字对类或者对象加锁。</p><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>保证原子性，提供了两个高级的字节码指令<code>monitorenter</code>和<code>monitorexit</code>。</p><p>通过<code>monitorenter</code>和<code>monitorexit</code>指令，可以保证被<code>synchronized</code>修饰的代码在<strong>同一时间只能被一个线程访问</strong>，在锁未释放之前，无法被其他线程访问到。因此，在Java中可以使用<code>synchronized</code>来保证方法和代码块内的操作是原子性的。</p><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>被<code>synchronized</code>修饰的代码，在开始执行时会加锁，执行完成后会进行解锁。而为了保证可见性，有一条规则是这样的：<strong>对一个变量解锁之前，必须先把此变量同步回主存中</strong>。这样解锁后，后续线程就可以访问到被修改后的值。</p><ul><li>【进入】synchronized 块的内存语义是把在 synchronized 块内使用的变量从线程的工作内存中清除，从主内存中读取</li><li>【退出】synchronized 块的内存语义事把在 synchronized 块内对共享变量的修改刷新到主内存中</li></ul><p>所以，synchronized关键字锁住的对象，其值是具有可见性的。</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>单线程程序的执行结果都不能被改变。编译器和处理器无论如何优化，都必须遵守<code>as-if-serial</code>语义。</p><p><code>as-if-serial语义</code>保证了单线程中，指令重排是有一定的限制的，而只要编译器和处理器都遵守了这个语义，那么就可以认为单线程程序是按照顺序执行的。当然，实际上还是有重排的，只不过我们无须关心这种重排的干扰。</p><p>由于<code>synchronized</code>修饰的代码，同一时间只能被同一线程访问。</p><p>那么也就是单线程执行的。所以，可以保证其有序性(原子性 + as-if-serial语义保证一定程度上的有序性)</p><p><strong>⚠️ BUT!!!</strong></p><p>经典的双重检查锁实现单例模式, 你有没有想过为什么已经使用synchronized包装了内部代码块, 既然 <code>synchronized</code> 可以保证可见性, 有序性, 原子性, 那么为什么还需要给单例对象添加<code>volatile</code>修饰呢?</p><p>感兴趣的同学可以去看这篇文章</p><p><a href="https://blog.csdn.net/zengfanwei1990/article/details/110245035">阿里面试：Java的synchronized 能防止指令重排序吗？_synchronized语句块后的代码会重排到其前吗-CSDN博客</a></p><p>这里直接上结论</p><p><code>synchnronized</code>的有序性保证, 只能是保证<code>synchnronized</code>整个代码块之间的有序性, 其代码块内部的有序性其实是无法保证的</p><p>如果在一个线程中观察另一个线程，另一个线程所有操作都是无序的。</p><p>而<code>volatile</code>关键字有序性是通过插入内存屏障来保证指令按照顺序执行。</p><p>不会存在后面的指令跑到前面的指令之前来执行。是保证编译器优化的时候不会让指令乱序。</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile一个强大的功能，那就是他可以禁止指令重排优化。通过禁止指令重排优化，就可以保证代码程序会严格按照代码的先后顺序执行。那么volatile又是如何禁止指令重排的呢？</p><p><strong>内存屏障（Memory Barrier）</strong>是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。下表描述了和volatile有关的指令重排禁止行为：</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402150042337.png" alt="volatile"></p><p>从上表我们可以看出：</p><blockquote><p>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</p><p>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</p><p>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</p></blockquote><h4 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h4><p>当一个变量被声明为 volatile 时：</p><ul><li>线程在【读取】共享变量时，会先清空本地内存变量值，再从主内存获取最新值</li><li>线程在【写入】共享变量时，不会把值缓存在寄存器或其他地方（就是刚刚说的所谓的「工作内存」），而是会把值刷新回主内存</li></ul><p>借此, 当多个线程访问同一个变量（共享变量）时，如果在这期间有某个线程修改了该共享变量的值，那么其他线程也能够立即看得到修改后的值。</p><h4 id="有序性-1"><a href="#有序性-1" class="headerlink" title="有序性"></a>有序性</h4><p>造成有序性问题的其中一个原因是处理器的<strong>指令重排序</strong>，</p><p>作为一个优化来讲，指令重排序是有其存在的必要性的，但是处理器并不知道什么时候应该禁止这种重排序优化来保证程序执行的正确性，于是将禁用的时机抛给了使用者。</p><p>针对两种不同的重排序，编译器的重排序和处理器的重排序，Java 内存模型 统一制定了重排序的管理规则，通过插入内存屏障来标识什么时候是禁止重排序优化的，而插入内存屏障时机，就是volatile修饰的变做读写操作的时候。</p><p>由于编译器和处理器都能执行指令重排优化，如果在指令之间插入一条内存屏障则会告诉编译器和cup不管在任何情况下，无论任何指令都不能和这条内存屏障进行指令重排，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。</p><h2 id="⚙️Happens-Before原则"><a href="#⚙️Happens-Before原则" class="headerlink" title="⚙️Happens-Before原则"></a>⚙️Happens-Before原则</h2><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402150042360.png" alt="image-20240106123204824"></p><p>我们重点理解前三个即可, 文末我会给出所有Happens-Before原则的定义</p><h3 id="🔄-volatile规则"><a href="#🔄-volatile规则" class="headerlink" title="🔄 volatile规则"></a>🔄 volatile规则</h3><p>对于一个volatile变量的写操作（修改）总是happens-before于随后对该变量的读操作。</p><p>这意味着，当一个线程修改了一个volatile变量的值后，其他线程将立即感知到这个修改。这一特性是通过刷新存储和禁止重排序来实现的。</p><h3 id="🤝-锁定规则"><a href="#🤝-锁定规则" class="headerlink" title="🤝 锁定规则"></a>🤝 锁定规则</h3><p>锁定规则是原则性的一种体现。它指出，对于一个锁的解锁操作总是happens-before于随后对该锁的加锁操作。</p><p>这意味着，在一个线程中，对于同一个锁的解锁操作将确保之后加锁的操作能够读取到最新的值。</p><h3 id="📃-程序顺序原则"><a href="#📃-程序顺序原则" class="headerlink" title="📃 程序顺序原则"></a>📃 程序顺序原则</h3><p>程序顺序原则是原则性的又一种体现。它指出，在一个线程内部，按照程序代码的书写顺序执行的操作满足happens-before关系。</p><p>尽管指令可能被硬件或编译器重排，但Java内存模型会确保程序执行结果的正确性。</p><p>这一原则是由于单个线程的执行是按照程序语义需要进行顺序执行的。</p><ol><li>程序顺序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。</li><li>锁规则 解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说， 如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。</li><li>volatile规则 volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单 的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当 该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能 够看到该变量的最新值。</li><li>线程启动规则 线程的start()方法先于它的每一个动作，即如果线程A在执行线程B的 start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量 的修改对线程B可见</li><li>传递性 A先于B ，B先于C 那么A必然先于C</li><li>线程终止规则 线程的所有操作先于线程的终结，Thread.join()方法的作用是等待当前 执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法 成功返回后，线程B对共享变量的修改将对线程A可见。</li><li>线程中断规则 对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中 断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。</li><li>对象终结规则 对象的构造函数执行，结束先于finalize()方法</li></ol><ul><li><a href="https://blog.csdn.net/zengfanwei1990/article/details/110245035">阿里面试：Java的synchronized 能防止指令重排序吗？_synchronized语句块后的代码会重排到其前吗-CSDN博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渐进式实现Spring日志</title>
      <link href="/posts/14978.html"/>
      <url>/posts/14978.html</url>
      
        <content type="html"><![CDATA[<h1 id="渐进式实现Spring日志"><a href="#渐进式实现Spring日志" class="headerlink" title="渐进式实现Spring日志"></a>渐进式实现Spring日志</h1><h2 id="1-开始实现一个简单的Spring-Bean容器"><a href="#1-开始实现一个简单的Spring-Bean容器" class="headerlink" title="1 开始实现一个简单的Spring Bean容器"></a>1 开始实现一个简单的Spring Bean容器</h2><h3 id="1-1-设计思路"><a href="#1-1-设计思路" class="headerlink" title="1.1 设计思路"></a>1.1 设计思路</h3><p>使用Map数据结构来存储所有的Bean对象。</p><h2 id="2-基于模板模式实现对象定义、注册和获取"><a href="#2-基于模板模式实现对象定义、注册和获取" class="headerlink" title="2. 基于模板模式实现对象定义、注册和获取"></a>2. 基于模板模式实现对象定义、注册和获取</h2><h3 id="2-1-设计思路"><a href="#2-1-设计思路" class="headerlink" title="2.1 设计思路"></a>2.1 设计思路</h3><p>使用模板模式，统一使用核心方法的调用逻辑和标准定义，进而可以很好地实现后续步骤而不用关心某一方法的调用逻辑。按照统一方式执行，<a href="https://so.csdn.net/so/search?q=%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF&spm=1001.2101.3001.7020">类的继承</a>者只需要关心具体方法如何实现即可。</p><p>基于模板方法模式实现对象定义, 注册, 获取</p><p><img src="/%E6%B8%90%E8%BF%9B%E5%BC%8F%E5%AE%9E%E7%8E%B0Spring%E6%97%A5%E5%BF%97.assets/image-20240203153836970.png" alt="image-20240203153836970"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SingletonBeanRegistry</span><br><span class="line">- 获取单例的注入和获取能力</span><br><span class="line"></span><br><span class="line">DefaultSingletonBeanRegistry</span><br><span class="line">- 内部维护singletonObjectsMap, 提供单例对象的管理能力</span><br><span class="line"></span><br><span class="line">BeanFactory</span><br><span class="line">- 获取Bean的能力</span><br><span class="line"></span><br><span class="line">AbstractBeanFactory</span><br><span class="line">- 提供getBean的模板方法实现</span><br><span class="line">- 获取单例, 获取成功直接返回(利用父类DefaultSingletonBeanRegistry)</span><br><span class="line">- 获取BeanDefinition 抽象方法交给子类实现</span><br><span class="line">- 创建Bean实例  抽象方法交给子类实现</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DefaultAutowireCapableBeanFactory</span><br><span class="line">- 实现创建Bean的能力</span><br><span class="line"></span><br><span class="line">BeanDefinition</span><br><span class="line">- 记录用户对Bean的需求</span><br><span class="line"></span><br><span class="line">BeanDefinitionRegistry</span><br><span class="line">- 注册BeanDefinition的能力</span><br><span class="line"></span><br><span class="line">DefaultListableBeanFactory</span><br><span class="line">- 类本身只通过维护beanDefinitionMap, 提供BeanDefinition的管理能力</span><br><span class="line">- 但是由于继承, 使其成为完整完成bean管理的容器</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-基于策略模式实现含构造函数的类实例化"><a href="#3-基于策略模式实现含构造函数的类实例化" class="headerlink" title="3 基于策略模式实现含构造函数的类实例化"></a>3 基于策略模式实现含构造函数的类实例化</h2><h3 id="3-1-设计思路"><a href="#3-1-设计思路" class="headerlink" title="3.1 设计思路"></a>3.1 设计思路</h3><p>不能简单的直接使用<code>newInstance</code>来进行类型实例化。要处理带参数的构造函数的情况。 创建类实例有多种技术手段，例如<code>JDK</code>本身的能力和<code>cglib</code>。可以通过策略模式来进行组织</p><p><img src="/%E6%B8%90%E8%BF%9B%E5%BC%8F%E5%AE%9E%E7%8E%B0Spring%E6%97%A5%E5%BF%97.assets/234319e7c577480581b237f6408894a2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InstantiationStrategy</span><br><span class="line">- 策略模式, 提供创建对象实例的能力</span><br><span class="line"></span><br><span class="line">CglibSubClassingInstantiationStrategy</span><br><span class="line">- 通过Cglib实现Bean的实例化能力</span><br><span class="line"></span><br><span class="line">SimpleInstantiationStragy</span><br><span class="line">- 通过JDK实现Bean的实例化能力</span><br></pre></td></tr></table></figure><h2 id="4-注入属性和依赖对象"><a href="#4-注入属性和依赖对象" class="headerlink" title="4 注入属性和依赖对象"></a>4 注入属性和依赖对象</h2><h3 id=""><a href="#" class="headerlink" title=""></a><img src="/%E6%B8%90%E8%BF%9B%E5%BC%8F%E5%AE%9E%E7%8E%B0Spring%E6%97%A5%E5%BF%97.assets/image-20240203191909913.png" alt="image-20240203191909913"></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PropertyValue</span><br><span class="line">- 封装Bean对象单个属性(基本属性)的属性名和值</span><br><span class="line"></span><br><span class="line">PropertyValues</span><br><span class="line">- 封装Bean对象全部属性的属性名(基本属性)和值的集合</span><br><span class="line"></span><br><span class="line">BeanReference</span><br><span class="line">- 封装Bean对象的引用属性</span><br><span class="line"></span><br><span class="line">BeanDefinition</span><br><span class="line">- 在Bean定义中添加PropertyValues属性</span><br><span class="line"></span><br><span class="line">AbstracAutowireCapableBeanFactory</span><br><span class="line">-  在createBean中新增applyPropertyValues方法, 根据BeanDefinition 为实例化后的Bean填充属性</span><br></pre></td></tr></table></figure><h2 id="5-将资源文件中定义的对象注册到容器中"><a href="#5-将资源文件中定义的对象注册到容器中" class="headerlink" title="5 将资源文件中定义的对象注册到容器中"></a>5 将资源文件中定义的对象注册到容器中</h2><h3 id="5-1-设计思路"><a href="#5-1-设计思路" class="headerlink" title="5.1 设计思路"></a>5.1 设计思路</h3><p>Resource和ResourceLoader实现对资源的加载。BeanDefinitionReader实现的是对资源的解析，将文件中定义的bean注入到容器中</p><p><img src="/%E6%B8%90%E8%BF%9B%E5%BC%8F%E5%AE%9E%E7%8E%B0Spring%E6%97%A5%E5%BF%97.assets/25babf7e4f5f411fa29998c362741c90.png" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>6 实现ApplicationContext<br>6.1 设计思路<br>将资源管理和Bean管理的功能进行整合，全部整合到ApplicationContext中。通过context的封装，可以提升整个系统的易用性。</p><p><img src="/%E6%B8%90%E8%BF%9B%E5%BC%8F%E5%AE%9E%E7%8E%B0Spring%E6%97%A5%E5%BF%97.assets/8ce068c911f447e9bb9c3cdc9edf8d14.png" alt="在这里插入图片描述"></p><p><img src="/%E6%B8%90%E8%BF%9B%E5%BC%8F%E5%AE%9E%E7%8E%B0Spring%E6%97%A5%E5%BF%97.assets/ed6c71dd63974c31858a1589f52a56bf.png" alt="在这里插入图片描述"></p><p><strong><code>ListableBeanFactory</code>是<code>beanFactory</code>接口的扩展接口，它可以枚举所有的bean实例，而不是客户端通过名称一个一个的查询得出所有的实例。要预加载所有的bean定义的<code>beanfactory</code>可以实现这个接口来。该 接口定义了访问容器中Bean基本信息的若干方法，如查看Bean的个数、获取某一类型Bean的配置名、查看容器中是否包括某一Bean等方法</strong></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列 之 详解JVM内存分区(线程不安全篇)</title>
      <link href="/posts/63197.html"/>
      <url>/posts/63197.html</url>
      
        <content type="html"><![CDATA[<h1 id="🌱JVM系列-之-详解JVM-内存分区-线程不安全篇"><a href="#🌱JVM系列-之-详解JVM-内存分区-线程不安全篇" class="headerlink" title="🌱JVM系列 之  详解JVM 内存分区(线程不安全篇)"></a>🌱JVM系列 之  详解JVM 内存分区(线程不安全篇)</h1><p>🚧🚧🚧 暂待施工🚧🚧🚧</p><ul><li>堆</li><li>方法区</li></ul><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p><p>Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列 之 详解JVM内存分区(线程安全篇)</title>
      <link href="/posts/63198.html"/>
      <url>/posts/63198.html</url>
      
        <content type="html"><![CDATA[<h1 id="🌱JVM系列-之-详解JVM内存分区-线程安全篇"><a href="#🌱JVM系列-之-详解JVM内存分区-线程安全篇" class="headerlink" title="🌱JVM系列 之 详解JVM内存分区(线程安全篇)"></a>🌱JVM系列 之 详解JVM内存分区(线程安全篇)</h1><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>👋 大家好，我是Shio！今天我们要深入探索Java虚拟机（JVM）如何通过内存区域划分和管理来支撑庞大的Java生态并简化开发流程。我们将聚焦于JVM的内存区域、线程间共享与隔离机制以及各个内存区域的具体功能。</p><h3 id="一、-JVM内存区域概述"><a href="#一、-JVM内存区域概述" class="headerlink" title="一、 JVM内存区域概述"></a>一、 JVM内存区域概述</h3><h4 id="1️⃣-内存区域与内存模型的区别"><a href="#1️⃣-内存区域与内存模型的区别" class="headerlink" title="1️⃣ 内存区域与内存模型的区别"></a>1️⃣ 内存区域与内存模型的区别</h4><p>首先区分两个概念：内存区域是JVM对物理内存的实际划分；而内存模型更关注数据的可见性和一致性问题。JVM内存区域主要包括五大块：<strong>程序计数器</strong>、<strong>虚拟机栈</strong>、<strong>本地方法栈</strong>、<strong>堆</strong>和<strong>方法区</strong>。</p><h4 id="2️⃣-线程共享与线程独占"><a href="#2️⃣-线程共享与线程独占" class="headerlink" title="2️⃣ 线程共享与线程独占"></a>2️⃣ 线程共享与线程独占</h4><ul><li>🔄 <strong>线程共享内存区域</strong>：堆和方法区存放所有线程都能访问的数据（如对象实例和类信息），在这些区域操作时要考虑线程安全。</li><li>👤 <strong>线程独占内存区域</strong>：程序计数器、虚拟机栈和本地方法栈为每个线程单独分配，用于保存当前<strong>执行路径</strong>和<strong>局部变量</strong>等信息，<strong>无需</strong>关心线程安全问题。</li></ul><p>​今天我们着重讲解线程安全的内存区域, 线程不安全的堆和方法区因为内容比较多, 我们放在下一节进行讲解</p><h3 id="二、-JVM内存区域详细解析"><a href="#二、-JVM内存区域详细解析" class="headerlink" title="二、 JVM内存区域详细解析"></a>二、 JVM内存区域详细解析</h3><h4 id="1️⃣-程序计数器"><a href="#1️⃣-程序计数器" class="headerlink" title="1️⃣ 程序计数器"></a>1️⃣ 程序计数器</h4><p>💻 </p><p>程序计数器（<strong>Program Counter Register</strong>）也叫<strong>PC</strong>寄存器，每个线程会通过程序计数器记录当前要执行的的字节码指令的地址。</p><p>程序计数器类似硬件层面的寄存器，在JVM中记录当前线程执行的字节码指令地址，供执行引擎读取执行。尽管不能直接监控其值，但通过反编译字节码可以观察其工作原理及循环逻辑表现。</p><p>在加载阶段，虚拟机将字节码文件中的指令读取到内存之后，会将原文件中的偏移量转换成内存地址。每一条字节码指令都会拥有一个内存地址</p><ul><li><p>程序计数器可以控制程序指令的进行，实现分支、跳转、异常等逻辑</p></li><li><p>在多线程执行情况下，<strong>Java</strong>虚拟机需要通过程序计数器记录<strong>CPU</strong>切换前解释执行到那一句指令并继续解释运行。</p></li></ul><blockquote><p>注意：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，所需的空间是固定的大小,开始即会分配足量的空间(本身只有)</p><p>它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p></blockquote><h4 id="2️⃣-虚拟机栈（Java方法栈）"><a href="#2️⃣-虚拟机栈（Java方法栈）" class="headerlink" title="2️⃣ 虚拟机栈（Java方法栈）"></a>2️⃣ 虚拟机栈（Java方法栈）</h4><p>  每个方法调用对应一个栈帧，其中包含四个重要部分：</p><ul><li>🔢 局部变量表：由固定数量和类型的slot组成，存储方法参数、局部变量等信息，编译期间即可计算所需空间大小。</li><li>📚 操作数栈：作为方法内变量和中间结果的临时存储区域，执行引擎按顺序读取栈顶操作数进行计算，并将结果压回栈顶。</li><li>🔗 动态连接：在多态场景下，方法调用依赖运行时常量池中的动态连接，支持运行时类型判断和方法调用。</li><li>🚪 返回地址：无论是正常完成还是异常结束，方法退出时需处理返回地址以继续后续指令执行。</li><li>异常表</li></ul><h4 id="3️⃣-本地方法栈"><a href="#3️⃣-本地方法栈" class="headerlink" title="3️⃣ 本地方法栈"></a>3️⃣ 本地方法栈</h4><p>🛠️ 本地方法栈服务于非Java语言编写的本地方法（如C&#x2F;C++），遵循线程独占原则，涉及操作系统接口或高效计算。</p><h3 id="三、线程隔离与共享结论"><a href="#三、线程隔离与共享结论" class="headerlink" title="三、线程隔离与共享结论"></a>三、线程隔离与共享结论</h3><p>回顾上述内容，我们可以得出结论：</p><p>🔒 <strong>线程隔离内存区域</strong>：由于程序计数器、虚拟机栈和本地方法栈与线程执行状态紧密相关，因此一定是线程独占的。<br>👥 <strong>线程共享内存区域</strong>：堆和方法区容纳所有线程可访问的数据，自然成为线程共享资源。</p><h3 id="结语与预告"><a href="#结语与预告" class="headerlink" title="结语与预告"></a>结语与预告</h3><p>🎉 在本篇博客中，我们深度剖析了JVM内存区域中的程序计数器、虚拟机栈和本地方法栈及其在Java方法执行过程中的作用。敬请期待下期内容，我们将详细介绍剩余的堆和方法区，进一步深化对JVM内存管理机制的理解。感谢阅读，希望您能持续关注我们的更新！👍</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列 之 垃圾回收梳理(终章)</title>
      <link href="/posts/40777.html"/>
      <url>/posts/40777.html</url>
      
        <content type="html"><![CDATA[<h1 id="♻️JVM系列-之-垃圾回收梳理-终章"><a href="#♻️JVM系列-之-垃圾回收梳理-终章" class="headerlink" title="♻️JVM系列 之 垃圾回收梳理(终章)"></a>♻️JVM系列 之 垃圾回收梳理(终章)</h1><p>🚧🚧🚧 暂待施工🚧🚧🚧</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/posts/40992.html"/>
      <url>/posts/40992.html</url>
      
        <content type="html"><![CDATA[<h1 id="Docker实用篇"><a href="#Docker实用篇" class="headerlink" title="Docker实用篇"></a>Docker实用篇</h1><h2 id="初识Docker"><a href="#初识Docker" class="headerlink" title="初识Docker"></a>初识Docker</h2><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222055733.png" alt="image-20231117203235114"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222103003.png" alt="image-20231117203248677"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222103648.png" alt="image-20231117203526799"></p><h3 id="Docker概念"><a href="#Docker概念" class="headerlink" title="Docker概念"></a>Docker概念</h3><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222103249.png" alt="image-20231117203617473"></p><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222110359.png" alt="image-20231117203845853"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1、yum 包更新到最新 </span><br><span class="line">yum update</span><br><span class="line"># 2、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 </span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"># 3、 设置yum源</span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"># 4、 安装docker，出现输入的界面都按 y </span><br><span class="line">yum install -y docker-ce</span><br><span class="line"># 5、 查看docker版本，验证是否验证成功</span><br><span class="line">docker -v</span><br></pre></td></tr></table></figure><p>当发生如下报错</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error: Failed to download metadata for repo &#x27;appstream&#x27;: Cannot prepare internal mirrorlist: No URLs in mirrorlist</span><br></pre></td></tr></table></figure><p>依次执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /etc/yum.repos.d/</span><br><span class="line">sed -i &#x27;s/mirrorlist/#mirrorlist/g&#x27; /etc/yum.repos.d/CentOS-*</span><br><span class="line">sed -i &#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27; /etc/yum.repos.d/CentOS-*</span><br><span class="line">yum makecache</span><br><span class="line">yum update -y</span><br></pre></td></tr></table></figure><p>安装成功</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222103817.png" alt="image-20231118203938565"></p><h3 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h3><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222103584.png" alt="image-20231118204247014"></p><h3 id="配置Docker镜像加速器"><a href="#配置Docker镜像加速器" class="headerlink" title="配置Docker镜像加速器"></a>配置Docker镜像加速器</h3><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222103888.png" alt="image-20231118204825959"></p><p>登录阿里云</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222103226.png" alt="image-20231118205301984"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222103518.png" alt="image-20231118205500436"></p><p>执行</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222103667.png" alt="image-20231118205608837"></p><p>查看是否配置成功</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222104380.png" alt="image-20231118205728239"></p><h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222104750.png" alt="image-20231118205801023"></p><h3 id="Docker进程相关命令"><a href="#Docker进程相关命令" class="headerlink" title="Docker进程相关命令"></a>Docker进程相关命令</h3><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222104433.png" alt="image-20231118205827121"></p><h4 id="启动docker服务"><a href="#启动docker服务" class="headerlink" title="启动docker服务"></a>启动docker服务</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><h4 id="停止docker服务"><a href="#停止docker服务" class="headerlink" title="停止docker服务"></a>停止docker服务</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure><h4 id="重启docker服务"><a href="#重启docker服务" class="headerlink" title="重启docker服务"></a>重启docker服务</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h4 id="查看docker服务状态"><a href="#查看docker服务状态" class="headerlink" title="查看docker服务状态"></a>查看docker服务状态</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure><h4 id="设置开机启动docker服务"><a href="#设置开机启动docker服务" class="headerlink" title="设置开机启动docker服务"></a>设置开机启动docker服务</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><p>演示</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222104481.png" alt="image-20231118210207027"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222104811.png" alt="image-20231118210314068"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222104601.png" alt="image-20231118210349579"></p><h3 id="Docker镜像相关命令"><a href="#Docker镜像相关命令" class="headerlink" title="Docker镜像相关命令"></a>Docker镜像相关命令</h3><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222104073.png" alt="image-20231118210451012"></p><h4 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h4><p>查看本地所有的镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker images</span><br><span class="line">docker images –q # 查看所用镜像的id</span><br></pre></td></tr></table></figure><h4 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h4><p>从网络中查找需要的镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker search 镜像名称</span><br></pre></td></tr></table></figure><h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><p>从Docker仓库下载镜像到本地，镜像名称格式为 名称:版本号，如果版本号不指定则是最新的版本。 如果不知道镜像版本，可以去docker hub 搜索对应镜像查看。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull 镜像名称</span><br></pre></td></tr></table></figure><h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><p>删除本地镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rmi 镜像id # 删除指定本地镜像</span><br><span class="line">docker rmi `docker images -q` # 删除所有本地镜像</span><br></pre></td></tr></table></figure><p>演示</p><p>查看指定镜像版本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://hub.docker.com</span><br></pre></td></tr></table></figure><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222104146.png" alt="image-20231118211729005"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222104350.png" alt="image-20231118211903298"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222104370.png" alt="image-20231118212120394"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222104053.png" alt="image-20231119140320128"></p><h3 id="Docker容器相关命令"><a href="#Docker容器相关命令" class="headerlink" title="Docker容器相关命令"></a>Docker容器相关命令</h3><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222104504.png" alt="image-20231119140728720"></p><h4 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps # 查看正在运行的容器 </span><br><span class="line">docker ps –a # 查看所有容器</span><br></pre></td></tr></table></figure><h4 id="创建并启动容器"><a href="#创建并启动容器" class="headerlink" title="创建并启动容器"></a>创建并启动容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run 参数</span><br></pre></td></tr></table></figure><p>参数说明:</p><ul><li><code>-i</code>:保持容器运行。通常与 -t 同时使用。加入it这两个参数后，容器创建后自动进入容器中，退出容器后，容器自动关闭。</li><li><code>-t</code>:为容器重新分配一个伪输入终端，通常与 -i 同时使用。</li><li><code>-d</code>:以守护(后台)模式运行容器。创建一个容器在后台运行，需要使用docker exec 进入容器。退出后，容器不会关闭。</li><li><code>-it </code>创建的容器一般称为交互式容器，-id 创建的容器一般称为守护式容器</li><li><code>--name</code>:为创建的容器命名。</li></ul><p>演示</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222104960.png" alt="image-20231119142049706"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222104184.png" alt="image-20231119142219103"></p><p>以后台方式运行容器，并进入容器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@hecs-33111 ~]# docker run -id --name=c2 redis:5.0 /bin/bash</span><br><span class="line">3842cee27f9b97fa7fb512aa53f835351f38860ffd5a4dc0e19b9e36d7aadf54</span><br><span class="line">[root@hecs-33111 ~]# docker exec -it c2 /bin/bash</span><br><span class="line">root@3842cee27f9b:/data# </span><br></pre></td></tr></table></figure><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222104088.png" alt="image-20231119142659334"></p><h4 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec 参数 # 退出容器，容器不会关闭</span><br></pre></td></tr></table></figure><h4 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stop 容器名称</span><br></pre></td></tr></table></figure><h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker start 容器名称</span><br></pre></td></tr></table></figure><h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><p>如果容器是运行状态则删除失败，需要停止容器才能删除</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rm 容器名称</span><br></pre></td></tr></table></figure><h4 id="查看容器信息"><a href="#查看容器信息" class="headerlink" title="查看容器信息"></a>查看容器信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker inspect 容器名称</span><br></pre></td></tr></table></figure><p>演示</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222104228.png" alt="image-20231119143241802"></p><h2 id="Docker容器的数据卷"><a href="#Docker容器的数据卷" class="headerlink" title="Docker容器的数据卷"></a>Docker容器的数据卷</h2><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222104133.png" alt="image-20231119143344613"></p><h3 id="数据卷的概念"><a href="#数据卷的概念" class="headerlink" title="数据卷的概念"></a>数据卷的概念</h3><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222104278.png" alt="image-20231119143512053"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222104438.png" alt="image-20231119143520561"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222104487.png" alt="image-20231119143527847"></p><h3 id="配置数据卷"><a href="#配置数据卷" class="headerlink" title="配置数据卷"></a>配置数据卷</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run ... –v 宿主机目录(文件):容器内目录(文件) ...</span><br></pre></td></tr></table></figure><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222104451.png" alt="image-20231119150642838"></p><p>演示</p><p>创建centos容器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --name=c3 -v /root/data:/root/data_container centos /bin/bash</span><br></pre></td></tr></table></figure><p>观察创建的目录</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222104064.png" alt="image-20231119151234849"></p><p>观察到宿主机创建的数据卷</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222104173.png" alt="image-20231119151303778"></p><p>在宿主机data目录下创建文件</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222104022.png" alt="image-20231119151436997"></p><p>观察容器内的同步情况</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222105716.png" alt="image-20231119151518008"></p><p>在容器内修改文件</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222105583.png" alt="image-20231119151627073"></p><p>观察宿主机内同步情况</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222105205.png" alt="image-20231119151707877"></p><p>退出并关闭centos容器</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222105067.png" alt="image-20231119152447918"></p><p>观察宿主机数据卷是否还在</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222105020.png" alt="image-20231119152537404"></p><p>数据卷未丢失</p><p>重启启动容器</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222105372.png" alt="image-20231119152812943"></p><p>一个容器内同步多个数据卷</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --name=c2 -v ~/data2:/root/data2 -v ~/data3:/root/data3 centos</span><br></pre></td></tr></table></figure><p>容器内</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222105129.png" alt="image-20231119153548750"></p><p>宿主机</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222105338.png" alt="image-20231119153605557"></p><p>容器与容器之间的同步</p><p>创建两个容器c1,c2</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222105750.png" alt="image-20231119155040681"></p><p>进入容器c1并创建文件</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222105554.png" alt="image-20231119155244415"></p><p>进入容器c2观察同步情况</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222105228.png" alt="image-20231119155402217"></p><h3 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h3><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222105981.png" alt="image-20231119155535372"></p><h4 id="配置数据卷容器"><a href="#配置数据卷容器" class="headerlink" title="配置数据卷容器"></a><strong>配置数据卷容器</strong></h4><ol><li>创建启动c3数据卷容器，使用 –v 参数 设置数据卷</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run –it --name=c3 –v /volume centos:7 /bin/bash</span><br></pre></td></tr></table></figure><ol><li>创建启动 c1 c2 容器，使用 –-volumes-from 参数 设置数据卷</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run –it --name=c1 --volumes-from c3 centos:7 /bin/bash </span><br><span class="line">docker run –it --name=c2 --volumes-from c3 centos:7 /bin/bash</span><br></pre></td></tr></table></figure><p>演示</p><p>创建数据卷容器c3和两个测试同步容器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@hecs-33111 data]# docker run -id --name=c3 -v /volume centos</span><br><span class="line">5a43ebf4f327441ae82f9fdebe640f88125f03e35ddfd34e5a7e21982f39a48c</span><br><span class="line">[root@hecs-33111 data]# docker run -id --name=c1 --volumes-from c3 centos</span><br><span class="line">e2ceb7739b1f57cd5b76c2c155b23fe5d1dedb29b9b1fc80c6e7ac50f1dd9eaf</span><br><span class="line">[root@hecs-33111 data]# docker run -id --name=c2 --volumes-from c3 centos</span><br><span class="line">f8cc38cff52549d6be3e3604d679b1556fda4c5ad1641a1cee4bde7fc63da9d4</span><br></pre></td></tr></table></figure><p>在c1容器内修改数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@hecs-33111 data]# docker exec -it c1 /bin/bash</span><br><span class="line">[root@e2ceb7739b1f /]# cd volume/</span><br><span class="line">[root@e2ceb7739b1f volume]# ls</span><br><span class="line">[root@e2ceb7739b1f volume]# </span><br><span class="line">[root@e2ceb7739b1f volume]# touch test.txt</span><br><span class="line">[root@e2ceb7739b1f volume]# </span><br><span class="line">[root@e2ceb7739b1f volume]# ls</span><br><span class="line">test.txt</span><br></pre></td></tr></table></figure><p>观察c2容器数据变化,数据已经成功同步</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222107488.png" alt="image-20231119173008858"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222107540.png" alt="image-20231119203158768"></p><h2 id="Docker应用部署"><a href="#Docker应用部署" class="headerlink" title="Docker应用部署"></a>Docker应用部署</h2><h3 id="MsSQL部署"><a href="#MsSQL部署" class="headerlink" title="MsSQL部署"></a>MsSQL部署</h3><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222107486.png" alt="image-20231119203218070"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222107985.png" alt="image-20231119203229479"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222107531.png" alt="image-20231119203345769"></p><h4 id="搜索mysql镜像"><a href="#搜索mysql镜像" class="headerlink" title="搜索mysql镜像"></a>搜索mysql镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222107366.png" alt="image-20231119204432501"></p><h4 id="拉取mysql镜像"><a href="#拉取mysql镜像" class="headerlink" title="拉取mysql镜像"></a>拉取mysql镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.6</span><br></pre></td></tr></table></figure><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222107210.png" alt="image-20231119204625163"></p><h4 id="创建容器，设置端口映射、目录映射"><a href="#创建容器，设置端口映射、目录映射" class="headerlink" title="创建容器，设置端口映射、目录映射"></a>创建容器，设置端口映射、目录映射</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在/root目录下创建mysql目录用于存储mysql数据信息</span><br><span class="line">mkdir ~/mysql</span><br><span class="line">cd ~/mysql</span><br><span class="line">docker run -id \</span><br><span class="line">-p 3307:3306 \</span><br><span class="line">--name=c_mysql \</span><br><span class="line">-v $PWD/conf:/etc/mysql/conf.d \</span><br><span class="line">-v $PWD/logs:/logs \</span><br><span class="line">-v $PWD/data:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">mysql:5.6</span><br></pre></td></tr></table></figure><ul><li>参数说明：<ul><li><strong>-p 3307:3306</strong>：将容器的 3306 端口映射到宿主机的 3307 端口。</li><li><strong>-v $PWD&#x2F;conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d</strong>：将主机当前目录下的 conf&#x2F;my.cnf 挂载到容器的 &#x2F;etc&#x2F;mysql&#x2F;my.cnf。配置目录</li><li><strong>-v $PWD&#x2F;logs:&#x2F;logs</strong>：将主机当前目录下的 logs 目录挂载到容器的 &#x2F;logs。日志目录</li><li><strong>-v $PWD&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql</strong> ：将主机当前目录下的data目录挂载到容器的 &#x2F;var&#x2F;lib&#x2F;mysql 。数据目录</li><li><strong>-e MYSQL_ROOT_PASSWORD&#x3D;123456：</strong>初始化 root 用户的密码。</li></ul></li></ul><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222107797.png" alt="image-20231119204847664"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222107612.png" alt="image-20231119205037008"></p><h3 id="Tomcat部署"><a href="#Tomcat部署" class="headerlink" title="Tomcat部署"></a>Tomcat部署</h3><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222107315.png" alt="image-20231119213329980"></p><h4 id="搜索tomcat镜像"><a href="#搜索tomcat镜像" class="headerlink" title="搜索tomcat镜像"></a>搜索tomcat镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker search tomcat</span><br></pre></td></tr></table></figure><h4 id="拉取tomcat镜像"><a href="#拉取tomcat镜像" class="headerlink" title="拉取tomcat镜像"></a>拉取tomcat镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull tomcat</span><br></pre></td></tr></table></figure><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222107425.png" alt="image-20231119214222638"></p><h4 id="创建容器，设置端口映射、目录映射-1"><a href="#创建容器，设置端口映射、目录映射-1" class="headerlink" title="创建容器，设置端口映射、目录映射"></a>创建容器，设置端口映射、目录映射</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在/root目录下创建tomcat目录用于存储tomcat数据信息</span><br><span class="line">mkdir ~/tomcat</span><br><span class="line">cd ~/tomcat</span><br><span class="line">docker run -id --name=c_tomcat \</span><br><span class="line">-p 8080:8080 \</span><br><span class="line">-v $PWD:/usr/local/tomcat/webapps \</span><br><span class="line">tomcat </span><br></pre></td></tr></table></figure><ul><li><p>参数说明：</p><ul><li><p><strong>-p 8080:8080：</strong>将容器的8080端口映射到主机的8080端口</p><p><strong>-v $PWD:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps：</strong>将主机中当前目录挂载到容器的webapps</p></li></ul></li></ul><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222107691.png" alt="image-20231119214349524"></p><h4 id="使用外部机器访问tomcat"><a href="#使用外部机器访问tomcat" class="headerlink" title="使用外部机器访问tomcat"></a>使用外部机器访问tomcat</h4><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222117303.png" alt="image-20240222211738201"></p><h3 id="Nginx部署"><a href="#Nginx部署" class="headerlink" title="Nginx部署"></a>Nginx部署</h3><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222108594.png" alt="image-20231119214456006"></p><h4 id="搜索nginx镜像"><a href="#搜索nginx镜像" class="headerlink" title="搜索nginx镜像"></a>搜索nginx镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker search nginx</span><br></pre></td></tr></table></figure><h4 id="拉取nginx镜像"><a href="#拉取nginx镜像" class="headerlink" title="拉取nginx镜像"></a>拉取nginx镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure><h4 id="创建容器，设置端口映射、目录映射-2"><a href="#创建容器，设置端口映射、目录映射-2" class="headerlink" title="创建容器，设置端口映射、目录映射"></a>创建容器，设置端口映射、目录映射</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在/root目录下创建nginx目录用于存储nginx数据信息</span><br><span class="line">mkdir ~/nginx</span><br><span class="line">cd ~/nginx</span><br><span class="line">mkdir conf</span><br><span class="line">cd conf</span><br><span class="line"># 在~/nginx/conf/下创建nginx.conf文件,粘贴下面内容</span><br><span class="line">vim nginx.conf</span><br><span class="line">user  nginx;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">error_log  /var/log/nginx/error.log warn;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br><span class="line">docker run -id --name=c_nginx \</span><br><span class="line">-p 80:80 \</span><br><span class="line">-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">-v $PWD/logs:/var/log/nginx \</span><br><span class="line">-v $PWD/html:/usr/share/nginx/html \</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure><ul><li>参数说明：<ul><li><strong>-p 80:80</strong>：将容器的 80端口映射到宿主机的 80 端口。</li><li><strong>-v $PWD&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</strong>：将主机当前目录下的 &#x2F;conf&#x2F;nginx.conf 挂载到容器的 :&#x2F;etc&#x2F;nginx&#x2F;nginx.conf。配置目录</li><li><strong>-v $PWD&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx</strong>：将主机当前目录下的 logs 目录挂载到容器的&#x2F;var&#x2F;log&#x2F;nginx。日志目录</li></ul></li></ul><h4 id="使用外部机器访问nginx"><a href="#使用外部机器访问nginx" class="headerlink" title="使用外部机器访问nginx"></a>使用外部机器访问nginx</h4><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222108972.png" alt="1573652396669"></p><h3 id="Redis部署"><a href="#Redis部署" class="headerlink" title="Redis部署"></a>Redis部署</h3><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222108564.png" alt="image-20231119215440719"></p><h4 id="搜索redis镜像"><a href="#搜索redis镜像" class="headerlink" title="搜索redis镜像"></a>搜索redis镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker search redis</span><br></pre></td></tr></table></figure><h4 id="拉取redis镜像"><a href="#拉取redis镜像" class="headerlink" title="拉取redis镜像"></a>拉取redis镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull redis:5.0</span><br></pre></td></tr></table></figure><h4 id="创建容器，设置端口映射"><a href="#创建容器，设置端口映射" class="headerlink" title="创建容器，设置端口映射"></a>创建容器，设置端口映射</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -id --name=c_redis -p 6379:6379 redis:5.0</span><br></pre></td></tr></table></figure><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222108237.png" alt="image-20231119221014974"></p><h4 id="使用外部机器连接redis"><a href="#使用外部机器连接redis" class="headerlink" title="使用外部机器连接redis"></a>使用外部机器连接redis</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./redis-cli.exe -h 192.168.149.135 -p 6379</span><br></pre></td></tr></table></figure><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222108403.png" alt="image-20231120130715968"></p><h3 id="Docker镜像原理"><a href="#Docker镜像原理" class="headerlink" title="Docker镜像原理"></a>Docker镜像原理</h3><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222108245.png" alt="image-20231120130749819"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222108004.png" alt="image-20231120131008869"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222108316.png" alt="image-20231120131751168"></p><h3 id="镜像制作"><a href="#镜像制作" class="headerlink" title="镜像制作"></a><strong>镜像制作</strong></h3><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222108629.png" alt="image-20231120132440129"></p><p>演示</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222108435.png" alt="image-20231120133459889"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222108906.png" alt="image-20231120133726220"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222108519.png" alt="image-20231120133948978"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222108462.png" alt="image-20231120134315829"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222108680.png" alt="image-20231120134530599"></p><h3 id="Dockerfile概念"><a href="#Dockerfile概念" class="headerlink" title="Dockerfile概念"></a>Dockerfile概念</h3><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222108925.png" alt="image-20231120134838135"></p><h3 id="Dockerfile关键字"><a href="#Dockerfile关键字" class="headerlink" title="Dockerfile关键字"></a>Dockerfile关键字</h3><table><thead><tr><th>关键字</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>FROM</td><td>指定父镜像</td><td>指定dockerfile基于那个image构建</td></tr><tr><td>MAINTAINER</td><td>作者信息</td><td>用来标明这个dockerfile谁写的</td></tr><tr><td>LABEL</td><td>标签</td><td>用来标明dockerfile的标签 可以使用Label代替Maintainer 最终都是在docker image基本信息中可以查看</td></tr><tr><td>RUN</td><td>执行命令</td><td>执行一段命令 默认是&#x2F;bin&#x2F;sh 格式: RUN command 或者 RUN [“command” , “param1”,”param2”]</td></tr><tr><td>CMD</td><td>容器启动命令</td><td>提供启动容器时候的默认命令 和ENTRYPOINT配合使用.格式 CMD command param1 param2 或者 CMD [“command” , “param1”,”param2”]</td></tr><tr><td>ENTRYPOINT</td><td>入口</td><td>一般在制作一些执行就关闭的容器中会使用</td></tr><tr><td>COPY</td><td>复制文件</td><td>build的时候复制文件到image中</td></tr><tr><td>ADD</td><td>添加文件</td><td>build的时候添加文件到image中 不仅仅局限于当前build上下文 可以来源于远程服务</td></tr><tr><td>ENV</td><td>环境变量</td><td>指定build时候的环境变量 可以在启动的容器的时候 通过-e覆盖 格式ENV name&#x3D;value</td></tr><tr><td>ARG</td><td>构建参数</td><td>构建参数 只在构建的时候使用的参数 如果有ENV 那么ENV的相同名字的值始终覆盖arg的参数</td></tr><tr><td>VOLUME</td><td>定义外部可以挂载的数据卷</td><td>指定build的image那些目录可以启动的时候挂载到文件系统中 启动容器的时候使用 -v 绑定 格式 VOLUME [“目录”]</td></tr><tr><td>EXPOSE</td><td>暴露端口</td><td>定义容器运行的时候监听的端口 启动容器的使用-p来绑定暴露端口 格式: EXPOSE 8080 或者 EXPOSE 8080&#x2F;udp</td></tr><tr><td>WORKDIR</td><td>工作目录</td><td>指定容器内部的工作目录 如果没有创建则自动创建 如果指定&#x2F; 使用的是绝对地址 如果不是&#x2F;开头那么是在上一条workdir的路径的相对路径</td></tr><tr><td>USER</td><td>指定执行用户</td><td>指定build或者启动的时候 用户 在RUN CMD ENTRYPONT执行的时候的用户</td></tr><tr><td>HEALTHCHECK</td><td>健康检查</td><td>指定监测当前容器的健康监测的命令 基本上没用 因为很多时候 应用本身有健康监测机制</td></tr><tr><td>ONBUILD</td><td>触发器</td><td>当存在ONBUILD关键字的镜像作为基础镜像的时候 当执行FROM完成之后 会执行 ONBUILD的命令 但是不影响当前镜像 用处也不怎么大</td></tr><tr><td>STOPSIGNAL</td><td>发送信号量到宿主机</td><td>该STOPSIGNAL指令设置将发送到容器的系统调用信号以退出。</td></tr><tr><td>SHELL</td><td>指定执行脚本的shell</td><td>指定RUN CMD ENTRYPOINT 执行命令的时候 使用的shell</td></tr></tbody></table><h3 id="Dockerfile案例"><a href="#Dockerfile案例" class="headerlink" title="Dockerfile案例"></a>Dockerfile案例</h3><h4 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h4><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222108192.png" alt="image-20231120163713655"></p><p>准备好springboot jar包并传至宿主机的根目录</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222108870.png" alt="image-20231120164903532"></p><p>创建docker-files目录，并把jar包移动进去</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222108648.png" alt="image-20231120165116968"></p><p>创建dockerfile文件并编辑</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM java:8</span><br><span class="line">MAINTAINER itheima &lt;itheima@itcast.cn&gt;</span><br><span class="line">ADD HelloDocker-0.0.1-SNAPSHOT.jar app.jar</span><br><span class="line">CMD java -jar app.jar</span><br></pre></td></tr></table></figure><p>根据dockerfile制作镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -f ./springboot_dockerfile -t app .</span><br></pre></td></tr></table></figure><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222108972.png" alt="image-20231120170212253"></p><p>启动并做端口映射</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -id -p 9000:8080 app</span><br></pre></td></tr></table></figure><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222108677.png" alt="image-20231120170509684"></p><p>成功访问</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222108176.png" alt="image-20231120170920994"></p><h4 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h4><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222108085.png" alt="image-20231120171246537"></p><p>编辑dockerfile文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@hecs-33111 docker-files]# vim centos_dockerfile</span><br><span class="line">FROM centos:7</span><br><span class="line">MAINTAINER itheima&lt;itheima@itcast.cn&gt;</span><br><span class="line">RUN yum install -y vim</span><br><span class="line">WORKDIR /usr</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><p>构建镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@hecs-33111 docker-files]# docker build -f centos_dockerfile -t itheima_centos:1 .</span><br></pre></td></tr></table></figure><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222108545.png" alt="image-20231120174043683"></p><p>创建容器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --name=c5 itheima_centos:1</span><br></pre></td></tr></table></figure><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222108409.png" alt="image-20231120174230249"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222108513.png" alt="image-20231120174417280"></p><h2 id="Docker服务编排"><a href="#Docker服务编排" class="headerlink" title="Docker服务编排"></a>Docker服务编排</h2><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222108805.png" alt="image-20231120174501970"></p><h3 id="服务编排"><a href="#服务编排" class="headerlink" title="服务编排"></a>服务编排</h3><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222108943.png" alt="image-20231120174617528"></p><h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222109378.png" alt="image-20231120174712386"></p><h3 id="Docker-Compose-安装使用"><a href="#Docker-Compose-安装使用" class="headerlink" title="Docker Compose 安装使用"></a>Docker Compose 安装使用</h3><h4 id="一、安装Docker-Compose"><a href="#一、安装Docker-Compose" class="headerlink" title="一、安装Docker Compose"></a>一、安装Docker Compose</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Compose目前已经完全支持Linux、Mac OS和Windows，在我们安装Compose之前，需要先安装Docker。下面我 们以编译好的二进制包方式安装在Linux系统中。 </span><br><span class="line">curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br><span class="line"># 设置文件可执行权限 </span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"># 查看版本信息 </span><br><span class="line">docker-compose -version</span><br></pre></td></tr></table></figure><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222109236.png" alt="image-20231120181950479"></p><h4 id="二、卸载Docker-Compose"><a href="#二、卸载Docker-Compose" class="headerlink" title="二、卸载Docker Compose"></a>二、卸载Docker Compose</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 二进制包方式安装的，删除二进制文件即可</span><br><span class="line">rm /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h4 id="三、-使用docker-compose编排nginx-springboot项目"><a href="#三、-使用docker-compose编排nginx-springboot项目" class="headerlink" title="三、 使用docker compose编排nginx+springboot项目"></a>三、 使用docker compose编排nginx+springboot项目</h4><ol><li>创建docker-compose目录</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir ~/docker-compose</span><br><span class="line">cd ~/docker-compose</span><br></pre></td></tr></table></figure><ol><li>编写 docker-compose.yml 文件</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line">  nginx:</span><br><span class="line">   image: nginx</span><br><span class="line">   ports:</span><br><span class="line">    - 80:80</span><br><span class="line">   links:</span><br><span class="line">    - app</span><br><span class="line">   volumes:</span><br><span class="line">    - ./nginx/conf.d:/etc/nginx/conf.d</span><br><span class="line">  app:</span><br><span class="line">    image: app</span><br><span class="line">    expose:</span><br><span class="line">      - &quot;8080&quot;</span><br></pre></td></tr></table></figure><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222109494.png" alt="image-20231120182206246"></p><ol><li>创建.&#x2F;nginx&#x2F;conf.d目录</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p ./nginx/conf.d</span><br></pre></td></tr></table></figure><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222109273.png" alt="image-20231120182309055"></p><ol><li>在.&#x2F;nginx&#x2F;conf.d目录下 编写itheima.conf文件</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    access_log off;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://app:8080;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222109134.png" alt="image-20231120182520017"></p><ol><li>在~&#x2F;docker-compose 目录下 使用docker-compose 启动容器</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222109498.png" alt="image-20231120182758615"></p><ol><li>测试访问</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.149.135/hello</span><br></pre></td></tr></table></figure><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222109032.png" alt="image-20231120182940496"></p><h2 id="Docker私有仓库"><a href="#Docker私有仓库" class="headerlink" title="Docker私有仓库"></a>Docker私有仓库</h2><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222109515.png" alt="image-20231120183215288"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222109657.png" alt="image-20231120183254474"></p><h3 id="一、私有仓库搭建"><a href="#一、私有仓库搭建" class="headerlink" title="一、私有仓库搭建"></a>一、私有仓库搭建</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1、拉取私有仓库镜像 </span><br><span class="line">docker pull registry</span><br><span class="line"># 2、启动私有仓库容器 </span><br><span class="line">docker run -id --name=registry -p 5000:5000 registry</span><br><span class="line"># 3、打开浏览器 输入地址http://私有仓库服务器ip:5000/v2/_catalog，看到&#123;&quot;repositories&quot;:[]&#125; 表示私有仓库 搭建成功</span><br><span class="line"># 4、修改daemon.json   </span><br><span class="line">vim /etc/docker/daemon.json    </span><br><span class="line"># 在上述文件中添加一个key，保存退出。此步用于让 docker 信任私有仓库地址；注意将私有仓库服务器ip修改为自己私有仓库服务器真实ip </span><br><span class="line">&#123;&quot;insecure-registries&quot;:[&quot;私有仓库服务器ip:5000&quot;]&#125; </span><br><span class="line"># 5、重启docker 服务 </span><br><span class="line">systemctl restart docker</span><br><span class="line">docker start registry</span><br></pre></td></tr></table></figure><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222109617.png" alt="image-20231120201936298"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222109175.png" alt="image-20231120202727139"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222109795.png" alt="image-20231120203058041"></p><h3 id="二、将镜像上传至私有仓库"><a href="#二、将镜像上传至私有仓库" class="headerlink" title="二、将镜像上传至私有仓库"></a>二、将镜像上传至私有仓库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1、标记镜像为私有仓库的镜像     </span><br><span class="line">docker tag centos:7 私有仓库服务器IP:5000/centos:7</span><br><span class="line"> </span><br><span class="line"># 2、上传标记的镜像     </span><br><span class="line">docker push 私有仓库服务器IP:5000/centos:7</span><br></pre></td></tr></table></figure><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222109015.png" alt="image-20231120203333919"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222109308.png" alt="image-20231120204528268"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222109103.png" alt="image-20231120204549966"></p><h3 id="三、-从私有仓库拉取镜像"><a href="#三、-从私有仓库拉取镜像" class="headerlink" title="三、 从私有仓库拉取镜像"></a>三、 从私有仓库拉取镜像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#拉取镜像 </span><br><span class="line">docker pull 私有仓库服务器ip:5000/centos:7</span><br></pre></td></tr></table></figure><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222109927.png" alt="image-20231120204927944"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222109533.png" alt="image-20231120205000360"></p><h2 id="Docker-相关观念"><a href="#Docker-相关观念" class="headerlink" title="Docker 相关观念"></a>Docker 相关观念</h2><p>[<img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222109334.png" alt="image-20231120205102272"><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222110218.png"></p><h4 id="Docker容器化虚拟化与传统虚拟机比较"><a href="#Docker容器化虚拟化与传统虚拟机比较" class="headerlink" title="Docker容器化虚拟化与传统虚拟机比较"></a>Docker容器化虚拟化与传统虚拟机比较</h4><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222109822.png" alt="image-20231120205141989"><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222109959.png"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222109178.png" alt="image-20231120205344250"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402222110029.png" alt="image-20231120205344251"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/posts/33708.html"/>
      <url>/posts/33708.html</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMQ初体验"><a href="#RabbitMQ初体验" class="headerlink" title="RabbitMQ初体验"></a>RabbitMQ初体验</h1><p>🚧🚧🚧 暂待施工🚧🚧🚧</p><h2 id="初识MQ"><a href="#初识MQ" class="headerlink" title="初识MQ"></a>初识MQ</h2><h3 id="同步调用的优缺点"><a href="#同步调用的优缺点" class="headerlink" title="同步调用的优缺点"></a>同步调用的优缺点</h3><p><strong>同步通讯与异步通讯</strong></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202403021424159.png" alt="image-20240302142354005"></p><p>​同步调用的时效性高</p><p><strong>同步调用的问题</strong></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202403021433555.png" alt="image-20240302143310461"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202403021433547.png" alt="image-20240302143340461"></p><p><strong>总结</strong></p><p><strong>同步调用的优点</strong></p><ul><li>实时性好, <strong>时效性高</strong></li></ul><p><strong>同步调用的缺点</strong></p><ul><li><strong>耦合高</strong>, 系统需求更改导致维护, 更改困难</li><li><strong>性能吞吐量下降</strong>, 线性调用, 每次调用都要阻塞等待服务方响应, 导致性能下降</li><li><strong>资源浪费</strong>, 调用链每个服务都要等待响应过程, 无法释放请求占用的资源</li><li><strong>级联失败</strong>, 服务提供方出问题,所有调用方都会出问题, 多米诺骨牌</li></ul><h3 id="异步调用的优缺点"><a href="#异步调用的优缺点" class="headerlink" title="异步调用的优缺点"></a>异步调用的优缺点</h3><p><strong>异步调用方案</strong></p><p><strong>优势一   服务解耦</strong></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202403021438035.png" alt="image-20240302143821941"></p><p>​采用<strong>发布订阅模式</strong>, 支付服务只负责<strong>发布事件</strong>至<strong>Broker</strong>, 而其他服务只负责<strong>订阅</strong>相应的<strong>Broker</strong></p><p>实现了, 服务调用方和提供方的<strong>解耦</strong></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202403021444693.png" alt="image-20240302144400604"></p><p>​假如, 需求发生变化, 需要在支付成功事件后<strong>添加</strong>其他服务,  只需要<strong>添加相应的服务</strong>, 并让该<strong>服务订阅相应的事件</strong>(支付成功事件)</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202403021446055.png" alt="image-20240302144600965"></p><p>​假如, 需求又发生变化, 需要在支付成功事件后<strong>取消</strong>短信服务,  只需要让该服务(短信服务)<strong>取消订阅</strong>相应的事件即可</p><p><strong>优势二 :  性能提升, 吞吐量提高</strong></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202403021450873.png" alt="image-20240302145009790"></p><ul><li><p>采用 <strong>同步调用方案</strong> 最后耗时将会是 所有服务耗时之和  即 50 + 10 + 150 + 150 + 150 &#x3D; <strong>510 ms</strong></p></li><li><p>采用 <strong>异步调用方案</strong> 最后耗时则只是 支付服务和发布支付时间(不需要阻塞)之和 即 50 + 10 &#x3D; <strong>60 ms</strong></p></li></ul><p>​同时调用方不需要阻塞等待也<strong>避免</strong>的了<strong>资源浪费</strong>问题</p><p><strong>优势三</strong>  <strong>无级联失败风险</strong></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202403021459453.png" alt="image-20240302145955368"></p><pre><code> 即使仓储服务挂了, 也并不影响其他服务的正常调用, 只需让仓储服务重启重新读取消息即可,</code></pre><p><strong>不会</strong>导致<strong>级联失败</strong></p><p><strong>优势四  流量消峰</strong></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202403021506826.png" alt="image-20240302150621712"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202403021507271.png" alt="image-20240302150718238"></p><p>​就像洪水爆发时, 大坝<strong>蓄洪</strong>一样, 对于激增请求量, 使用队列存储起来, 让服务提供方按照正常的速度消费存储下的消息, 避免因请求激增导致服务压力过载崩掉</p><p>**总结: **</p><p><strong>异步通信的优点:</strong></p><ul><li><strong>耦合度低</strong></li><li><strong>吞吐量高</strong></li><li><strong>故障隔离</strong></li><li><strong>流量削峰</strong></li></ul><p>**异步通信的缺点: **</p><ul><li><strong>依赖于Broker</strong>的可靠性, 安全性, 吞吐能力</li><li><strong>架构复杂</strong>, 业务没有明显的流程线条, 不好追踪管理</li></ul><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>​<strong>MQ  ( MessageQueue )</strong>,  中文是<strong>消息队列</strong>，字面来看就是<strong>存放消息的队列</strong>。也就是事件驱动架构中的<strong>Broker</strong>。</p><table><thead><tr><th align="center"></th><th align="center">RabbitMQ</th><th align="center">ActiveMQ</th><th align="center">RocketMQ</th><th align="center">Kafka</th></tr></thead><tbody><tr><td align="center">公司社区</td><td align="center">Rabbit</td><td align="center">Apache</td><td align="center">阿里</td><td align="center">Apache</td></tr><tr><td align="center">开发语言</td><td align="center">Erlang</td><td align="center">Java</td><td align="center">Java</td><td align="center">Scala &amp; Java</td></tr><tr><td align="center">协议支持</td><td align="center">AMQP, XMPP, SMTP, STOMP</td><td align="center">OpenWire, STOMP, REST, XMPP, AMQP</td><td align="center">自定义协议</td><td align="center">自定义协议</td></tr><tr><td align="center">可用性</td><td align="center">高</td><td align="center">一般</td><td align="center">高</td><td align="center">高</td></tr><tr><td align="center">单机吞吐量</td><td align="center">一般</td><td align="center">差</td><td align="center">高</td><td align="center">非常高</td></tr><tr><td align="center">消息延迟</td><td align="center">微秒级</td><td align="center">毫秒级</td><td align="center">毫秒级</td><td align="center">毫秒以内</td></tr><tr><td align="center">消息可靠性</td><td align="center">高</td><td align="center">一般</td><td align="center">高</td><td align="center">一般</td></tr></tbody></table><h2 id="RabbitMQ快速入门"><a href="#RabbitMQ快速入门" class="headerlink" title="RabbitMQ快速入门"></a>RabbitMQ快速入门</h2><p><strong>RabbitMQ</strong>是基于<strong>Erlang语言</strong>开发的开源消息通信中间件，官网地址：<a href="https://www.rabbitmq.com/">https://www.rabbitmq.com</a></p><h3 id="常见消息模型"><a href="#常见消息模型" class="headerlink" title="常见消息模型"></a>常见消息模型</h3><p><strong>RabbitMQ</strong> <a href="https://www.rabbitmq.com/tutorials">官方文档</a>中提供了 5个Demo, 对应了几种不同的用法:</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202403021541118.png" alt="image-20240302154140024"></p><h2 id="BasicQueue"><a href="#BasicQueue" class="headerlink" title="BasicQueue"></a><strong>BasicQueue</strong></h2><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202403021542417.png" alt="image-20240302154219350"></p><p><strong>总结</strong></p><p>基本消息队列的消息发送流程</p><ul><li><p>创建并配置<code>ConnectionFactory</code></p></li><li><p>从<code>ConnectionFactory</code>获取<code>Connection</code></p></li><li><p>利用<code>Connection</code>创建<code>channel</code></p></li><li><p>利用<code>channel</code>声明队列</p></li><li><p>利用<code>channel.basicPublish()</code>向队列中发送消息</p></li></ul><p>基本消息队列的消息接受流程</p><ul><li><p>创建并配置<code>ConnectionFactory</code></p></li><li><p>从<code>ConnectionFactory</code>获取<code>Connection</code></p></li><li><p>利用<code>Connection</code>创建<code>channel</code></p></li><li><p>利用<code>channel</code>声明队列</p></li><li><p>定义<code>consumer.basicConsume()</code>的消费行为<code>handleDelivery()</code></p></li><li><p>利用<code>channel</code>将消费者与队列绑定</p></li></ul><h3 id="SpringAMQP"><a href="#SpringAMQP" class="headerlink" title="SpringAMQP"></a>SpringAMQP</h3><p><strong>什么是SpringAMQP</strong></p><p><a href="https://spring.io/projects/spring-amqp">Spring AMQP官网介绍</a></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202403021600662.png" alt="image-20240302160045581"></p><h2 id="Work-Queue"><a href="#Work-Queue" class="headerlink" title="Work Queue"></a>Work Queue</h2><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202403021715175.png" alt="image-20240302171519113"></p><p><strong>消息预取机制(preFetch)</strong></p><p><strong>Work模型的使用总结</strong></p><ul><li><strong>多个消费者</strong>绑定到<strong>一个队列</strong>，<strong>同一条消息</strong>只会被<strong>一个消费者</strong>处理</li><li>通过设置<strong>prefetch</strong>来控制消费者<strong>预取的消息数量</strong></li></ul><h2 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h2><p><strong>发布(Publish), 订阅(Subscribe)</strong></p><p><strong>发布订阅模式</strong>与之前案例的区别就是允许将<strong>同一消息发送给多个消费者</strong>。实现方式是加入了<code>exchange</code>(交换机)。</p><p>常见的<code>exchange</code>包括</p><ul><li><strong><code>Fanout</code>:  广播</strong></li><li><strong><code>Direct</code>: 路由</strong></li><li><strong><code>Topic</code>:  话题</strong></li></ul><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202403021758161.png" alt="image-20240302175831057"></p><h3 id="发布订阅-Fanout-Exchange"><a href="#发布订阅-Fanout-Exchange" class="headerlink" title="发布订阅- Fanout Exchange"></a><strong>发布订阅- Fanout Exchange</strong></h3><p><strong>FanoutExchange</strong>会将接收到的消息路由到<strong>每一个跟其绑定的queue</strong></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202403021802881.png" alt="image-20240302180259804"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202403021804953.png" alt="image-20240302180426865"></p><p> <strong>总结</strong></p><p><strong>交换机的作用是什么?</strong></p><ul><li>接收<code>publisher</code>发送的消息</li><li>将消息按照规则<strong>路由到与之绑定的队列</strong></li><li><strong>不能缓存消息</strong>，<strong>路由失败，消息丢失</strong></li><li><code>FanoutExchange</code>的会将消息<strong>路由到每个绑定的队列</strong></li></ul><p><strong>声明队列, 交换机, 绑定关系的Bean是什么?</strong></p><ul><li><strong>Queue</strong></li><li><strong>FanoutExchange</strong></li><li><strong>Binding</strong></li></ul><h3 id="发布订阅-Direct-Exchange"><a href="#发布订阅-Direct-Exchange" class="headerlink" title="发布订阅- Direct  Exchange"></a><strong>发布订阅- Direct  Exchange</strong></h3><p><strong><code>Direct Exchange</code><strong>会将接收到的消息根据规则路由到指定的<code>Queue</code>,因此称为</strong>路由模式(routes</strong>)。</p><ul><li>每一个<code>Queue</code>都与<code>Exchange</code>设置一个<code>BindingKey</code></li><li>发布者发送消息时，指定消息的<code>RoutingKey</code></li><li><code>Exchange</code>将消息路由到<code>BindingKey</code>与消息<code>RoutingKey</code>一致的队列</li></ul><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202403021819473.png" alt="image-20240302181910393"></p><p>还可以<strong>绑定多个key</strong>, 多个<code>Queue</code>绑定同一个key, 就实现了<code>Fanout Exchange</code>的效果, 所以说<code>Direct  Exchange</code>更灵活一些</p><p> <img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202403021820060.png" alt="image-20240302182035976"></p><p><strong>描述下Direct交换机与Fanout交换机的差异?</strong></p><ul><li><strong><code>Fanout</code></strong> <strong>交换机</strong>将消息路由给每一个与之绑定的<strong>队列</strong></li><li><strong><code>Direct</code><strong>交换机</strong>根据<code>RoutingKey</code>判断路由</strong>给哪个队列</li><li>如果<strong>多个队列</strong>具有<strong>相同的<code>Routing Key</code></strong>,则与<code>Fanout</code><strong>功能类似</strong></li></ul><p><strong>基于<code>RabbitListener</code>注解的声明队列与交换机有哪些常见的注解?</strong></p><ul><li><p><code>@QueueBanding</code></p></li><li><p><code>@Queue</code></p></li><li><p><code>@Exchange</code></p></li></ul><h3 id="发布订阅-Topic-Exchange"><a href="#发布订阅-Topic-Exchange" class="headerlink" title="发布订阅- Topic Exchange"></a><strong>发布订阅- Topic Exchange</strong></h3><p>​<code>Topic Exchange</code>与<code>Direct Exchange</code>类似，区别在于<code>routing Key</code>必须是<strong>多个单词的列表</strong>，并且以**<code>.</code>**分割</p><p>​<code>Queue</code>与<code>Exchange</code>指定的<code>BindgingKey</code>时可以使用通配符:</p><ul><li><code># </code> 代表0个或多个单词</li><li><code>*</code> 代表一个单词</li></ul><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202403021840133.png" alt="image-20240302184016983"></p><h2 id="消息转化器"><a href="#消息转化器" class="headerlink" title="消息转化器"></a>消息转化器</h2><p><code>Spring</code>的对<strong>消息对象的处理</strong>是由<code>org.springframework.amqp.support..converter.MessageConverter</code>来处理的。而<br>默认实现是<code>SimpleMessageConverter</code>,基于JDK的<code>ObjectOutputStream</code>完成<strong>序列化</strong>。</p><p><strong>SpringAMQP中消息的序列化和反序列化是怎么实现的？J</strong></p><ul><li>利用<code>MessageConverter</code>实现的，<strong>默认是JDK的序列化</strong></li><li>注意<strong>发送方与接收方</strong>必须使用<strong>相同的</strong><code>MessageConverter</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理</title>
      <link href="/posts/39826.html"/>
      <url>/posts/39826.html</url>
      
        <content type="html"><![CDATA[<h1 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h1><p>🚧🚧🚧 暂待施工🚧🚧🚧</p><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202402261235145.png" alt="image-20240226123512019"></p><p><strong>编译系统由哪些部分组成?</strong></p><blockquote><p>阶段程序指的是 特定阶段进行处理的程序</p><p>守护程序指的是  守护程序是指在整个编译程序的生命周期中一直在运行的程序</p><p>上面的定义是我自己瞎取的, 方便理解记忆</p></blockquote><p><strong>阶段程序</strong></p><ul><li>词法分析程序</li><li>语法分析程序</li><li>语义分析程序</li><li>中间代码生成程序</li><li>代码优化程序</li><li>目标代码生成程序</li></ul><p><strong>守护程序</strong></p><ul><li>信息表管理程序</li><li>错误检查和处理程序</li></ul><h2 id="四元式"><a href="#四元式" class="headerlink" title="四元式"></a>四元式</h2><p>规则:</p><ul><li>(运算符, 运算对象, 运算对象, 临时变量)</li><li>先处理优先级高的一部分, 然后向左遍历</li><li>每一次运算结果用一个临时变量存起来, 以便后续使用</li></ul><p>逆波兰式</p><p>规则:</p><ul><li>遇到字母直接写到答案里</li><li>遇到符号, 压入栈中</li><li>遇到成对的括号才出栈 </li><li>新加入的符号, 优先级必须大于(没有等于)原栈顶优先级, 否则栈中原符号出栈</li></ul><p><em>答案没有括号</em></p><p>例题:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">A+B*(C-D)+F/(C-D)^N</span><br></pre></td></tr></table></figure><p>答案</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ABCD-*+FCD-N^/+</span><br></pre></td></tr></table></figure><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>文法</p><p>产生式(规则)</p><p>非终结符   定义为  终结符</p><p>左部                          右部</p><p>句型  规则的右部</p><p>句子 完全由终结符组成的句型称为句子  </p><p>语言   句子的集合</p><p>闭包合正闭包</p><p>最左推导和最右推导</p><p>所有短语</p><p>(简单短语)直接短语</p><p>句柄 </p><h2 id="正规式转正规文法"><a href="#正规式转正规文法" class="headerlink" title="正规式转正规文法"></a>正规式转正规文法</h2><p>NFA, DFA, 最小化</p><p>初态集  不含集合终态</p><p>终态集    含有集合终态0</p><p>覆盖</p><h1 id="题目类型"><a href="#题目类型" class="headerlink" title="题目类型"></a>题目类型</h1><h2 id="句子推导"><a href="#句子推导" class="headerlink" title="句子推导"></a>句子推导</h2><ul><li><p>最左推导</p></li><li><p>最右推导</p></li></ul><h2 id="语法树的短语"><a href="#语法树的短语" class="headerlink" title="语法树的短语"></a>语法树的短语</h2><p>简单优先和算符优先</p><ul><li><p>非叶子结点的<strong>短语</strong></p></li><li><p>层数为2的非叶子结点的<strong>直接短语</strong></p></li><li><p>包含终结符, 出自己意外不含其他素短语 <strong>素短语</strong></p></li><li><p>最左非叶子结点的<strong>句柄</strong></p></li></ul><h2 id="文法二义性"><a href="#文法二义性" class="headerlink" title="文法二义性"></a>文法二义性</h2><p>需要一定的灵感</p><p>证明是否有二义性</p><p>找一个句子, 看从左和从右开始推导看语法树是否不一样 </p><h2 id="文法生成语言和已知语言生成文法"><a href="#文法生成语言和已知语言生成文法" class="headerlink" title="文法生成语言和已知语言生成文法"></a>文法生成语言和已知语言生成文法</h2><h4 id="文法及文法的类型（0型、1型、2型、3型文法）"><a href="#文法及文法的类型（0型、1型、2型、3型文法）" class="headerlink" title="文法及文法的类型（0型、1型、2型、3型文法）?"></a>文法及文法的类型（0型、1型、2型、3型文法）?</h4><h2 id="NFA和DFA"><a href="#NFA和DFA" class="headerlink" title="NFA和DFA"></a><code>NFA</code>和<code>DFA</code></h2><ul><li><p>???  </p></li><li><p>子集法 (<code>NFA-</code>&gt;<code>DFA</code>)</p></li><li><p>划分法</p></li></ul><h2 id="LL-1-自顶向下分析"><a href="#LL-1-自顶向下分析" class="headerlink" title="LL(1)自顶向下分析"></a><code>LL(1)</code>自顶向下分析</h2><ul><li><p>消除文法左递归和回溯</p></li><li><p>构造<code>LL(1)</code>的分析表</p></li><li><p>对字符串<code>#adbc</code>进行语法分析</p></li><li><p>First集   首非终结符集合</p></li><li><p>Follow集合  紧跟, 开始符 Follow集有<code>#</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之美----职责链模式</title>
      <link href="/posts/22915.html"/>
      <url>/posts/22915.html</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式之美—-职责链模式"><a href="#设计模式之美—-职责链模式" class="headerlink" title="设计模式之美—-职责链模式"></a>设计模式之美—-职责链模式</h1><p>本文将对责任链模式(职责链模式)分为四个部分进行讲解</p><ul><li>原理</li><li>实现</li><li>应用</li><li>练习</li></ul><p>让大家系统全面的学会使用责任链模式, 并应用到开发中去</p><h2 id="原理篇"><a href="#原理篇" class="headerlink" title="原理篇"></a>原理篇</h2><blockquote><p>大部分设计模式的核心是应对工程中的复杂性, 使得代码满足开闭原则,  提高代码扩展性</p></blockquote><p>职责链的英文名为<code>Chain Of Responsibility Design Pattern</code>, 在GoF的设计模式中的定义如下</p><blockquote><p>Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.</p></blockquote><p>​“将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。”</p><p>​实际上就是将<code>请求</code>通过类似链表的结构, 通过结点处理并线性的传递下去,直到请求完成或者没有下一个结点</p><p>​这里的结点是指单个处理请求的对象, 接受上一个结点处理后的结果并在处理后, 传递给下一个结点或者请求完成结束处理, 因为每个结点都承担着细粒度的职责, 所以称为<code>责任链模式</code></p><h2 id="实现篇"><a href="#实现篇" class="headerlink" title="实现篇"></a>实现篇</h2><p>​</p><p>​设计模式的实现往往多种多样, 可能因为语言特性(枚举单例)也可能因为算法(迭代或者递归),使得代码结构各异, 但核心思想是不会变得, 之后的设计模式, 我都会以Java为例做出实现, 因为Java算是比较典型且纯粹的面向对象编程, 其他语言的同学可以借助chatgpt转语言来理解, 本质是一样的</p><p>​职责链模式的实现分为三个结构, 分别是抽象处理器类(Handler), 处理器类(XXXHandler), 以及处理链(HandlerChain)</p><p><strong>抽象处理器类(Handler)</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理器的抽象类, 定义处理器结构, 方便后序扩展</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="comment">//指向下一个处理器</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Handler</span> <span class="variable">successor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//抽象处理方法, 具体处理器实现此方法,处理请求</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuccessor</span><span class="params">(Handler successor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>处理器类(XXXHandler)</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerA</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//判断当前请求是否在该处理器处理完成</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//.....处理逻辑</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//如果请求在当前处理器处理完成或者当前处理器是责任链上最后一个处理器, 停止传递</span></span><br><span class="line">    <span class="keyword">if</span> (!handled &amp;&amp; successor != <span class="literal">null</span>) &#123;</span><br><span class="line">      successor.handle();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerB</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//判断当前请求是否在该处理器处理完成</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//.....处理逻辑</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//如果请求在当前处理器处理完成或者当前处理器是责任链上最后一个处理器, 停止传递</span></span><br><span class="line">    <span class="keyword">if</span> (!handled &amp;&amp; successor != <span class="literal">null</span>) &#123;</span><br><span class="line">      successor.handle();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>处理链(HandlerChain)</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerChain</span> &#123;</span><br><span class="line">    <span class="comment">//通过头尾两个应用记录处理链位置信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Handler</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Handler</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在处理链尾部增加处理器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addHandler</span><span class="params">(Handler handler)</span> &#123;</span><br><span class="line">        handler.setSuccessor(<span class="literal">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == head) &#123;</span><br><span class="line">            head = handler;</span><br><span class="line">            tail = handler;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保证尾部永远指向最后一个处理器</span></span><br><span class="line">        tail.setSuccessor(handler);</span><br><span class="line">        tail = handler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HyuanandlerChain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerChain</span>();</span><br><span class="line">        chain.addHandler(<span class="keyword">new</span> <span class="title class_">HandlerA</span>());</span><br><span class="line">        chain.addHandler(<span class="keyword">new</span> <span class="title class_">HandlerB</span>());</span><br><span class="line">        chain.handle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典GoF的实现不够优雅, 处理器类中的handle()函数不仅包含业务逻辑, 还有对下一个处理器的调用, 对于不熟悉代码结构的程序员,在添加处理器调用时可能忘记调用下一个处理器, 可能会导致bug, 所以我们利用模板方法模式进行重构(让我想起Spring源码中AbstractBeanFactory中的doGetBean()方法), 将下一个处理器调用的逻辑抽象到模板中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">protected</span> <span class="type">Handler</span> <span class="variable">successor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuccessor</span><span class="params">(Handler successor)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.successor = successor;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//模板方法,将处理器调用逻辑抽象成一个final方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> doHandle();</span><br><span class="line">    <span class="keyword">if</span> (successor != <span class="literal">null</span> &amp;&amp; !handled) &#123;</span><br><span class="line">      successor.handle();</span><br><span class="line">    &#125;   </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//模板方法的扩展点,让子类具体处理器实现处理请求的逻辑</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">doHandle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerA</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">doHandle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerB</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">doHandle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// HandlerChain和Application代码不变</span></span><br></pre></td></tr></table></figure><p>我们发现责任链模式本质就是将请求 <code>线性传递</code>到每个处理逻辑上进行处理直到某个结点处理成功或者职责链到头</p><p>既然是线性结构,我们同样可以使用数组来实现责任链模式, 这种方式更加简单</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组实现的话,将传递的逻辑放到了HandlerChain中, 只需要实现handle逻辑即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHandler</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">handle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerA</span> <span class="keyword">implements</span> <span class="title class_">IHandler</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//...处理器处理逻辑</span></span><br><span class="line">    <span class="comment">//返回是否处理完成</span></span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerB</span> <span class="keyword">implements</span> <span class="title class_">IHandler</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//...处理器处理逻辑</span></span><br><span class="line">    <span class="comment">//返回是否处理完成</span></span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerChain</span> &#123;</span><br><span class="line">  <span class="comment">//通过动态数组存储每个处理器</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;IHandler&gt; handlers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">//在数组中添加处理器</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addHandler</span><span class="params">(IHandler handler)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.handlers.add(handler);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//迭代调用处理器的处理方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (IHandler handler : handlers) &#123;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> handler.handle();</span><br><span class="line">      <span class="comment">//如果在中间某个处理器中处理完成, 提前结束迭代, 不调用下一个处理器</span></span><br><span class="line">      <span class="keyword">if</span> (handled) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">HandlerChain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerChain</span>();</span><br><span class="line">    chain.addHandler(<span class="keyword">new</span> <span class="title class_">HandlerA</span>());</span><br><span class="line">    chain.addHandler(<span class="keyword">new</span> <span class="title class_">HandlerB</span>());</span><br><span class="line">    chain.handle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 GoF 给出的定义中，如果处理器链上的某个处理器能够处理这个请求，那就不会继续往下传递请求。实际上，职责链模式还有一种变体，那就是请求会被所有的处理器都处理一遍，不存在中途终止的情况。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现中省略boolean handled = false;即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="type">Handler</span> <span class="variable">successor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuccessor</span><span class="params">(Handler successor)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.successor = successor;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//不需要返回boolean了</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">    doHandle();</span><br><span class="line">    <span class="keyword">if</span> (successor != <span class="literal">null</span>) &#123;</span><br><span class="line">      successor.handle();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doHandle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">    doHandle();</span><br><span class="line">    <span class="keyword">if</span> (successor != <span class="literal">null</span>) &#123;</span><br><span class="line">      successor.handle();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们参照&lt;&lt;设计模式之美&gt;&gt;中, 灵活扩展算法的敏感词过滤框架来讲</p><blockquote><p>对于支持 UGC（User Generated Content，用户生成内容）的应用（比如论坛）来说，用户生成的内容（比如，在论坛中发表的帖子）可能会包含一些敏感词（比如涉黄、广告、反动等词汇）。针对这个应用场景，我们就可以利用职责链模式来过滤这些敏感词。</p><p>对于包含敏感词的内容，我们有两种处理方式，一种是直接禁止发布，另一种是给敏感词打马赛克（比如，用 *** 替换敏感词）之后再发布。第一种处理方式符合 GoF 给出的职责链模式的定义，第二种处理方式是职责链模式的变体。</p></blockquote><p>第一种</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SensitiveWordFilter</span> &#123;</span><br><span class="line">  </span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">doFilter</span><span class="params">(Content content)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//涉黄词过滤,  PoliticalWordFilter、AdsWordFilter类代码结构与SexyWordFilter类似,省略了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SexyWordFilter</span> <span class="keyword">implements</span> <span class="title class_">SensitiveWordFilter</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doFilter</span><span class="params">(Content content)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">legal</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> legal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//敏感词过滤链</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SensitiveWordFilterChain</span> &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span> List&lt;SensitiveWordFilter&gt; filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFilter</span><span class="params">(SensitiveWordFilter filter)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.filters.add(filter);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 如果不包含敏感词则返回ture</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">filter</span><span class="params">(Content content)</span> &#123;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">for</span> (SensitiveWordFilter filter : filters) &#123;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">if</span> (!filter.doFilter(content)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationDemo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SensitiveWordFilterChain</span> <span class="variable">filterChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SensitiveWordFilterChain</span>();</span><br><span class="line">    filterChain.addFilter(<span class="keyword">new</span> <span class="title class_">AdsWordFilter</span>());</span><br><span class="line">    filterChain.addFilter(<span class="keyword">new</span> <span class="title class_">SexyWordFilter</span>());</span><br><span class="line">    filterChain.addFilter(<span class="keyword">new</span> <span class="title class_">PoliticalWordFilter</span>());</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">legal</span> <span class="operator">=</span> filterChain.filter(<span class="keyword">new</span> <span class="title class_">Content</span>());</span><br><span class="line">    <span class="keyword">if</span> (!legal) &#123;</span><br><span class="line">      <span class="comment">// 不发表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 发表</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SensitiveWordFilter</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(Content content)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//涉黄词过滤,  PoliticalWordFilter、AdsWordFilter类代码结构与SexyWordFilter类似,省略了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SexyWordFilter</span> <span class="keyword">implements</span> <span class="title class_">SensitiveWordFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(Content content)</span> &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//..... 检查是否存在涉黄敏感词,存在则用***替换敏感词</span></span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SensitiveWordFilterChain</span> &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span> List&lt;SensitiveWordFilter&gt; filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFilter</span><span class="params">(SensitiveWordFilter filter)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.filters.add(filter);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">filter</span><span class="params">(Content content)</span> &#123;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">for</span> (SensitiveWordFilter filter : filters) &#123;</span><br><span class="line">      <span class="comment">//如果返回为true,说明中间处理器发现敏感词返回true,这种情况直接结束后序循环</span></span><br><span class="line">     filter.doFilter(content)</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你可能会说，我像下面这样也可以实现敏感词过滤功能，而且代码更加简单，为什么非要使用职责链模式呢？这是不是过度设计呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SensitiveWordFilter</span> &#123;</span><br><span class="line">  <span class="comment">// return true if content doesn&#x27;t contain sensitive words.</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">filter</span><span class="params">(Content content)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!filterSexyWord(content)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!filterAdsWord(content)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!filterPoliticalWord(content)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">filterSexyWord</span><span class="params">(Content content)</span> &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">filterAdsWord</span><span class="params">(Content content)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">filterPoliticalWord</span><span class="params">(Content content)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​应用设计模式主要是为了应对代码的复杂性，让其满足开闭原则，提高代码的扩展性。这里应用职责链模式也不例外</p><p><strong>首先, 我们来看, 职责链模式如何应对代码的复杂性</strong></p><p>将大的代码逻辑拆分成函数, 将大类拆分成小类, 是应对代码复杂性的常用方法, 职责链模式中,我们把各个敏感词过滤函数继续拆分成独立的类, 进一步简化了SensitiveWordFilter类, 让SenesitiveWordFilter类的代码不会过多, 过复杂.</p><p><strong>其次, 我们来看, 职责链模式如何让代码满足开闭原则, 提高代码的扩展性</strong></p><p>当我们考虑扩展新的过滤算法的时候, 比如, 我们还需要过滤特殊符号, 按照非职责链模式的代码实现,我们需要修改SensitiveWordFilter的代码, 违反开闭原则, 不过, 这样的修改比较集中,还可以接受的, 而职责链模式的实现方法更加优雅, 只需要新添加一个Filter类, 并且通过addFilter()函数将他添加到FilterChain中即可, 其他代码完全不需要修改</p><p>你可能会说，即便使用职责链模式来实现，当添加新的过滤算法的时候，还是要修改客户端代码（ApplicationDemo），这样做也没有完全符合开闭原则。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//实现一个新的处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewWordFilter</span> <span class="keyword">implements</span> <span class="title class_">SensitiveWordFilter</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doFilter</span><span class="params">(Content content)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">legal</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">   <span class="keyword">return</span> legal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationDemo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SensitiveWordFilterChain</span> <span class="variable">filterChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SensitiveWordFilterChain</span>();</span><br><span class="line">    filterChain.addFilter(<span class="keyword">new</span> <span class="title class_">AdsWordFilter</span>());</span><br><span class="line">    filterChain.addFilter(<span class="keyword">new</span> <span class="title class_">SexyWordFilter</span>());</span><br><span class="line">    filterChain.addFilter(<span class="keyword">new</span> <span class="title class_">PoliticalWordFilter</span>());</span><br><span class="line">     <span class="comment">//需要改动客户端代码,在职责链中添加新的处理器</span></span><br><span class="line">    filterChain.addFilter(<span class="keyword">new</span> <span class="title class_">NewWordFilter</span>());</span><br><span class="line">      </span><br><span class="line">    <span class="type">boolean</span> <span class="variable">legal</span> <span class="operator">=</span> filterChain.filter(<span class="keyword">new</span> <span class="title class_">Content</span>());</span><br><span class="line">    <span class="keyword">if</span> (!legal) &#123;</span><br><span class="line">      <span class="comment">// 不发表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 发表</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细化一下的话，我们可以把上面的代码分成两类：框架代码和客户端代码。其中，ApplicationDemo 属于客户端代码，也就是使用框架的代码。除 ApplicationDemo 之外的代码属于敏感词过滤框架代码。</p><p><em>假设敏感词过滤框架并不是我们开发维护的，而是我们引入的一个第三方框架，我们要扩展一个新的过滤算法，不可能直接去修改框架的源码。这个时候，利用职责链模式就能达到开篇所说的，在不修改框架源码的情况下，基于职责链模式提供的扩展点，来扩展新的功能。换句话说，我们在框架这个代码范围内实现了开闭原则。</em></p><p>除此之外, 利用职责链模式相对于不用职责链模式的实现方法, 还有一个好处, 就是配置过滤算法更加灵活了, 只需要使用某几个过滤算法</p><h2 id="应用篇"><a href="#应用篇" class="headerlink" title="应用篇"></a>应用篇</h2><p>​职责链模式常用在框架的开发中，为框架提供扩展点，让框架的使用者在不修改框架源码的情况下，基于扩展点添加新的功能。实际上，更具体点来说，职责链模式最常用来开发框架的<strong>过滤器</strong>和<strong>拦截器</strong></p><p>​</p><h3 id="Servlet-Filter"><a href="#Servlet-Filter" class="headerlink" title="Servlet Filter"></a>Servlet Filter</h3><p>​<code>Servlet Filter</code> 是 Java <code>Servlet 规范</code>中定义的组件，翻译成中文就是过滤器，它可以实现对 HTTP 请求的过滤功能，比如鉴权、限流、记录日志、验证参数等等。</p><p>​在实际项目中，我们该如何使用<code> Servlet Filter</code> 呢？我写了一个简单的示例代码，如下所示。添加一个过滤器，我们只需要定义一个实现 <code>javax.servlet.Filter </code>接口的过滤器类，并且将它配置在 <code>web.xml</code> 配置文件中。Web 容器启动的时候，会读取 <code>web.xml </code>中的配置，创建过滤器对象。当有请求到来的时候，会先经过过滤器，然后才由<code> Servlet</code> 来处理。</p><p>​</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="comment">// 在创建Filter时自动调用，</span></span><br><span class="line">    <span class="comment">// 其中filterConfig包含这个Filter的配置参数，比如name之类的（从配置文件中读取的）</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;拦截客户端发送来的请求.&quot;</span>);</span><br><span class="line">    chain.doFilter(request, response);</span><br><span class="line">    System.out.println(<span class="string">&quot;拦截发送给客户端的响应.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 在销毁Filter时自动调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在web.xml配置文件中如下配置：</span></span><br><span class="line">&lt;filter&gt;</span><br><span class="line">  &lt;filter-name&gt;logFilter&lt;/filter-name&gt;</span><br><span class="line">  &lt;filter-class&gt;com.xzg.cd.LogFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;logFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;<span class="comment">/*&lt;/url-pattern&gt;</span></span><br><span class="line"><span class="comment">&lt;/filter-mapping&gt;</span></span><br></pre></td></tr></table></figure><p>​我们发现，添加过滤器非常方便，不需要修改任何代码，定义一个实现 javax.servlet.Filter 的类，再改改配置就搞定了，完全符合开闭原则。</p><p>​<code>Servlet Filter</code>利用的正是职责链模式来保证如此好的扩展性</p><p>​<code>Servlet </code>只是一个规范，并不包含具体的实现，所以，<code>Servlet </code>中的 <code>FilterChain </code>只是一个接口定义。具体的实现类由遵从<code> Servlet</code> 规范的 Web 容器来提供，比如，<code>ApplicationFilterChain </code>类就是 Tomcat 提供的 <code>FilterChain </code>的实现类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ApplicationFilterChain</span> <span class="keyword">implements</span> <span class="title class_">FilterChain</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//当前执行到了哪个filter</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> n; <span class="comment">//filter的个数</span></span><br><span class="line">  <span class="keyword">private</span> ApplicationFilterConfig[] filters;</span><br><span class="line">  <span class="keyword">private</span> Servlet servlet;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; n) &#123;</span><br><span class="line">      <span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> filters[pos++];</span><br><span class="line">      <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> filterConfig.getFilter();</span><br><span class="line">      filter.doFilter(request, response, <span class="built_in">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// filter都处理完毕后，执行servlet</span></span><br><span class="line">      servlet.service(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFilter</span><span class="params">(ApplicationFilterConfig filterConfig)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (ApplicationFilterConfig filter:filters)</span><br><span class="line">      <span class="keyword">if</span> (filter==filterConfig)</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == filters.length) &#123;<span class="comment">//扩容</span></span><br><span class="line">      ApplicationFilterConfig[] newFilters = <span class="keyword">new</span> <span class="title class_">ApplicationFilterConfig</span>[n + INCREMENT];</span><br><span class="line">      System.arraycopy(filters, <span class="number">0</span>, newFilters, <span class="number">0</span>, n);</span><br><span class="line">      filters = newFilters;</span><br><span class="line">    &#125;</span><br><span class="line">    filters[n++] = filterConfig;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ApplicationFilterChain </code>中的 <code>doFilter()</code> 函数的代码实现比较有技巧，实际上是一个递归调用。</p><p>​这样实现主要是为了在一个 <code>doFilter() </code>方法中，支持双向拦截，既能拦截客户端发送来的请求，也能拦截发送给客户端的响应，你可以结合着 <code>LogFilter</code> 那个例子，以及对比待会要讲到的 <code>Spring Interceptor</code>.</p><h3 id="Spring-Interceptor"><a href="#Spring-Interceptor" class="headerlink" title="Spring Interceptor"></a>Spring Interceptor</h3><p>​<code>Servlet Filter</code>，有一个功能上跟它非常类似的东西，<code>Spring Interceptor</code>，，都用来实现对 HTTP 请求进行拦截处理。</p><p>​它们不同之处在于，<code>Servlet Filter</code> 是 <code>Servlet</code> 规范的一部分，实现依赖于 Web 容器。<code>Spring Interceptor</code> 是<code>Spring MVC</code>框架的一部分，由 <code>Spring MVC</code> 框架来提供实现。客户端发送的请求，会先经过 <code>Servlet Filter</code>，然后再经过 <code>Spring Interceptor</code>，最后到达具体的业务代码中。( <code>Filter</code>在 <code>Request</code> 抵达<code>Servlet</code> 之前进行过滤 以及<code>Servlet.service()</code>执行完返回<code>reponse</code>之后过滤; 而<code>Interceptor</code> 是在抵达 <code>DispatcherServlet</code> 之后根据请求路径找到对应的映射器候选者后<code>前置处理</code>候选者, 在候选者处理请求并视图解析器处理完成后<code>后置处理</code>)</p><p>​在项目中，我们该如何使用 <code>Spring Interceptor</code> 呢？</p><ul><li>声明拦截器类, 实现<code>HandlerInterceptor</code>接口, 实现<code>preHandler()</code>, <code>postHandler()</code>, ,<code>afterCompletion()</code>方法</li><li>通过配置文件中添加<code>&lt;mvc:interceptor&gt;</code>, 配置<code>&lt;mvc:mapping path=&quot;拦截路径&quot;/&gt;</code> , <code>&lt;bean class=&quot;拦截器实现类全限定名&quot; /&gt;</code>(也可以使用注解配置类)</li></ul><p>​</p><p>​<code>LogInterceptor</code> 实现的功能跟刚才的 <code>LogFilter</code> 完全相同，只是实现方式上稍有区别。<code>LogFilter</code> 对请求和响应的拦截是在 <code>doFilter() </code>一个函数中实现的，而 <code>LogInterceptor</code> 对请求的拦截在 <code>preHandle()</code> 中实现，对响应的拦截在 <code>postHandle()</code> 中实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 在处理请求之前被调用</span></span><br><span class="line">    <span class="comment">// 在此处可以执行一些预处理操作，如记录日志</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;拦截客户端发送来的请求.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 继续后续的处理</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 在处理请求后，视图渲染之前被调用</span></span><br><span class="line">    <span class="comment">// 在此处可以执行一些后处理操作，如修改响应内容或添加额外的响应头</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;拦截发送给客户端的响应.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 在请求处理完成后被调用，即视图渲染完成后被调用</span></span><br><span class="line">    <span class="comment">// 在此处可以执行一些清理工作，如释放资源或记录请求处理结果</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;这里总是被执行.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Spring MVC配置文件中配置interceptors</span></span><br><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">   &lt;mvc:interceptor&gt;</span><br><span class="line">       &lt;mvc:mapping path=<span class="string">&quot;/*&quot;</span>/&gt;</span><br><span class="line">       &lt;bean class=<span class="string">&quot;com.xzg.cd.LogInterceptor&quot;</span> /&gt;</span><br><span class="line">   &lt;/mvc:interceptor&gt;</span><br><span class="line">&lt;/mvc:interceptors&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<code>Spring interceptor</code></p><p>​也是基于职责链模式实现的。其中，<code>HandlerExecutionChain</code> 类是职责链模式中的处理器链。它的实现相较于 Tomcat 中的 <code>ApplicationFilterChain</code> 来说，逻辑更加清晰，不需要使用递归来实现，主要是因为它将请求和响应的拦截工作，拆分到了两个函数中实现。</p><p><code>HandlerExecutionChain</code> 的源码如下所示，同样对代码也进行了一些简化，只保留了关键代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HandlerExecutionChain 类定义了一个拦截器的执行链，为处理器提供拦截功能。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerExecutionChain</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object handler; <span class="comment">// 处理器对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HandlerInterceptor[] interceptors; <span class="comment">// 拦截器数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个拦截器到拦截器数组中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interceptor 要添加的拦截器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptor</span><span class="params">(HandlerInterceptor interceptor)</span> &#123;</span><br><span class="line">        initInterceptorList().add(interceptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在处理器执行前调用拦截器的预处理方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request  HTTP 请求对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response HTTP 响应对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否继续执行处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; interceptors.length; i++) &#123;</span><br><span class="line">                <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[i];</span><br><span class="line">                <span class="keyword">if</span> (!interceptor.preHandle(request, response, <span class="built_in">this</span>.handler)) &#123;</span><br><span class="line">                    triggerAfterCompletion(request, response, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在处理器执行后调用拦截器的后处理方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request  HTTP 请求对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response HTTP 响应对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mv       处理器返回的 ModelAndView 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">applyPostHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, ModelAndView mv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> interceptors.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[i];</span><br><span class="line">                interceptor.postHandle(request, response, <span class="built_in">this</span>.handler, mv);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在请求完成时调用拦截器的完成处理方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request  HTTP 请求对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response HTTP 响应对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex       请求处理过程中出现的异常（如果有）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">triggerAfterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Exception ex)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[i];</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    interceptor.afterCompletion(request, response, <span class="built_in">this</span>.handler, ex);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex2) &#123;</span><br><span class="line">                    logger.error(<span class="string">&quot;HandlerInterceptor.afterCompletion threw exception&quot;</span>, ex2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在 Spring 框架中，<code>DispatcherServlet</code> 的 <code>doDispatch()</code> 方法来分发请求，它在真正的业务逻辑执行前后，执行 <code>HandlerExecutionChain</code> 中的 <code>applyPreHandle()</code> 和 <code>applyPostHandle()</code> 函数，用来实现拦截的功能。</p><h2 id="练习篇"><a href="#练习篇" class="headerlink" title="练习篇"></a>练习篇</h2><p>尝试优化一下代码(案例来源)</p><p><strong>在本案例中我们模拟在618大促期间的业务系统上线审批流程场景</strong></p><p>像是这些一线电商类的互联网公司，阿里、京东、拼多多等，在618期间都会做一些运营活动场景以及提供的扩容备战，就像过年期间百度的红包一样。但是所有开发的这些系统都需要陆续的上线，因为临近618有时候也有一些紧急的调整的需要上线，但为了保障线上系统的稳定性是尽可能的减少上线的，也会相应的增强审批力度。就像一级响应、二级响应一样。</p><p>而这审批的过程在随着特定时间点会增加不同级别的负责人加入，每个人就像责任链模式中的每一个核心点。对于研发小伙伴并不需要关心具体的审批流程处理细节，只需要知道这个上线更严格，级别也更高，但对于研发人员来说同样是点击相同的提审按钮，等待审核。</p><p>接下来我们就模拟这样一个业务诉求场景，使用责任链的设计模式来实现此功能。</p><h3 id="场景简述"><a href="#场景简述" class="headerlink" title="场景简述"></a>场景简述</h3><h4 id="模拟审核服务"><a href="#模拟审核服务" class="headerlink" title="模拟审核服务"></a>模拟审核服务</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Date&gt; authMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Date&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">queryAuthInfo</span><span class="params">(String uId, String orderId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> authMap.get(uId.concat(orderId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">auth</span><span class="params">(String uId, String orderId)</span> &#123;</span><br><span class="line">        authMap.put(uId.concat(orderId), <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><ul><li>这里面提供了两个接口一个是查询审核结果(<code>queryAuthInfo</code>)、另外一个是处理审核(<code>auth</code>)。</li><li>这部分是把由谁审核的和审核的单子ID作为唯一key值记录到内存Map结构中。</li></ul><h3 id="待优化代码"><a href="#待优化代码" class="headerlink" title="待优化代码"></a>待优化代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">SimpleDateFormat</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<span class="comment">// 时间格式化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AuthInfo <span class="title function_">doAuth</span><span class="params">(String uId, String orderId, Date authDate)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 三级审批</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> AuthService.queryAuthInfo(<span class="string">&quot;1000013&quot;</span>, orderId);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == date) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AuthInfo</span>(<span class="string">&quot;0001&quot;</span>, <span class="string">&quot;单号：&quot;</span>, orderId, <span class="string">&quot; 状态：待三级审批负责人 &quot;</span>, <span class="string">&quot;王工&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二级审批</span></span><br><span class="line">        <span class="keyword">if</span> (authDate.after(f.parse(<span class="string">&quot;2020-06-01 00:00:00&quot;</span>)) &amp;&amp; authDate.before(f.parse(<span class="string">&quot;2020-06-25 23:59:59&quot;</span>))) &#123;</span><br><span class="line">            date = AuthService.queryAuthInfo(<span class="string">&quot;1000012&quot;</span>, orderId);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> == date) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AuthInfo</span>(<span class="string">&quot;0001&quot;</span>, <span class="string">&quot;单号：&quot;</span>, orderId, <span class="string">&quot; 状态：待二级审批负责人 &quot;</span>, <span class="string">&quot;张经理&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一级审批</span></span><br><span class="line">        <span class="keyword">if</span> (authDate.after(f.parse(<span class="string">&quot;2020-06-11 00:00:00&quot;</span>)) &amp;&amp; authDate.before(f.parse(<span class="string">&quot;2020-06-20 23:59:59&quot;</span>))) &#123;</span><br><span class="line">            date = AuthService.queryAuthInfo(<span class="string">&quot;1000011&quot;</span>, orderId);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> == date) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AuthInfo</span>(<span class="string">&quot;0001&quot;</span>, <span class="string">&quot;单号：&quot;</span>, orderId, <span class="string">&quot; 状态：待一级审批负责人 &quot;</span>, <span class="string">&quot;段总&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AuthInfo</span>(<span class="string">&quot;0001&quot;</span>, <span class="string">&quot;单号：&quot;</span>, orderId, <span class="string">&quot; 状态：审批完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><ul><li>这里从上到下分别判断了在指定时间范围内由不同的人员进行审批，就像618上线的时候需要三个负责人都审批才能让系统进行上线。</li><li>像是这样的功能看起来很简单的，但是实际的业务中会有很多部门，但如果这样实现就很难进行扩展，并且在改动扩展调整也非常麻烦。</li></ul><hr><p>参考:  </p><p> <a href="https://time.geekbang.org/column/intro/100039001">设计模式之美 (geekbang.org)</a></p><p>[重学 Java 设计模式：实战责任链模式「模拟618电商大促期间，项目上线流程多级负责人审批场景」 | 小傅哥 bugstack 虫洞栈](<a href="https://bugstack.cn/md/develop/design-pattern/2020-06-18-%E9%87%8D%E5%AD%A6">https://bugstack.cn/md/develop/design-pattern/2020-06-18-重学</a> Java 设计模式《实战责任链模式》.html)</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 设计模式之美 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用代码模板</title>
      <link href="/posts/45076.html"/>
      <url>/posts/45076.html</url>
      
        <content type="html"><![CDATA[<h1 id="【Java版本】常用代码模板"><a href="#【Java版本】常用代码模板" class="headerlink" title="【Java版本】常用代码模板"></a>【Java版本】常用代码模板</h1><h1 id="——-基础算法——"><a href="#——-基础算法——" class="headerlink" title="——-基础算法——-"></a>——-基础算法——-</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><strong>代码模板</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 递归终止条件，如果左边界大于等于右边界则认为递归结束</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设定一个分界值，这里是（left + right）/ 2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> arr[left + right &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 左右提前预留一个位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">// 等效于do while</span></span><br><span class="line">        <span class="comment">// 当数值小于分界值时持续遍历，直到找到第一个大于等于分界值的索引</span></span><br><span class="line">        <span class="comment">// 如果是逆序则调整两个while循环</span></span><br><span class="line">        <span class="keyword">while</span> (arr[++i] &lt; p)</span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">while</span> (arr[--j] &gt; p)</span><br><span class="line">            ;</span><br><span class="line">        <span class="comment">// 交换左右两侧不符合预期的数值</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于分界值取的是left + right &gt;&gt; 1，因此递归取的是left，j j + 1，right</span></span><br><span class="line">    quickSort(arr, left, j);</span><br><span class="line">    quickSort(arr, j + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习题</strong></p><p><a href="https://leetcode.cn/problems/sort-an-array/">912. 排序数组</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] quickSort(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">       <span class="comment">// 待补全的代码模板</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><strong>代码模板</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 递归终止条件，如果左边界大于等于右边界则认为递归结束</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设定一个分界值，这里是（left + right）/ 2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 切割</span></span><br><span class="line">    arr = mergeSort(arr, left, mid);</span><br><span class="line">    arr = mergeSort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="comment">// 归并，长度刚好是 left 到 right</span></span><br><span class="line">    <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 用来归并的索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 如果是逆序则调整if条件</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">            temp[k++] = arr[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        temp[k++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">        temp[k++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据归并后的数组重新赋值排序后的数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = left, j = <span class="number">0</span>; i &lt;= right; i++, j++) &#123;</span><br><span class="line">        arr[i] = temp[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习题</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] mergeSort(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right) &#123;</span><br><span class="line">   <span class="comment">// 待补全的代码模板</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><h4 id="精准查找"><a href="#精准查找" class="headerlink" title="精准查找"></a>精准查找</h4><p><strong>代码模板</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (l + <span class="number">1</span> != r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习题</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> binarySearch(nums, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// 待补全的模板代码</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="左右查找"><a href="#左右查找" class="headerlink" title="左右查找"></a>左右查找</h4><p><strong>代码模板</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">leftBinarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l + <span class="number">1</span> != r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= nums.length || nums[r] != target  ) &#123;</span><br><span class="line">            r = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;   </span><br><span class="line">   </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[left, right]被划分成[left, mid - 1]和[mid, right]时使用：  </span></span><br><span class="line"><span class="comment">// 或者称之为右二分查询，查找右侧最后一个满足条件的数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">rightBinarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l + <span class="number">1</span> != r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (l &lt; <span class="number">0</span> || l &gt;= nums.length || nums[l] != target ) &#123;</span><br><span class="line">            l = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习题</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == nums || <span class="number">0</span> == nums.length) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> leftBinarySearch(nums, target);</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> rightBinarySearch(nums, target);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">leftBinarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;  </span><br><span class="line">      <span class="comment">// 待补全的模板代码</span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">rightBinarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;  </span><br><span class="line">    <span class="comment">// 待补全的模板代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查x是否满足某种性质  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">double</span> x)</span> &#123;  </span><br><span class="line">   <span class="comment">/* ... */</span>  a</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// eps 表示精度，取决于题目对精度的要求，默认负六次方</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="variable">EPS</span> <span class="operator">=</span> <span class="number">1e-6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">floatBinarySearch</span><span class="params">(<span class="type">double</span> left, <span class="type">double</span> right)</span> &#123;  </span><br><span class="line">   <span class="keyword">while</span> (right - left &gt; EPS) &#123;  </span><br><span class="line">      <span class="type">double</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;  </span><br><span class="line">      <span class="keyword">if</span> (check(mid)) &#123;  </span><br><span class="line">         right = mid;  </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">         left = mid;  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> left;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/792/">模板题 AcWing 790. 数的三次方根</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;  </span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">      <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);  </span><br><span class="line">      <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> in.nextDouble();  </span><br><span class="line">      <span class="type">Double</span> <span class="variable">left</span> <span class="operator">=</span> -Double.MAX_VALUE;  </span><br><span class="line">      <span class="type">Double</span> <span class="variable">right</span> <span class="operator">=</span> Double.MAX_VALUE;  </span><br><span class="line">      <span class="comment">// 由于负六次方精度不够</span></span><br><span class="line">      <span class="keyword">while</span> (right - left &gt; <span class="number">1e-8</span>) &#123;  </span><br><span class="line">         <span class="type">Double</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;  </span><br><span class="line">         <span class="keyword">if</span> (mid * mid * mid &gt;= x) &#123;  </span><br><span class="line">            right = mid;  </span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            left = mid;  </span><br><span class="line">         &#125;  </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">// 注意格式化输出字符串</span></span><br><span class="line">      System.out.printf(<span class="string">&quot;%.6f&quot;</span>, left);  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> pow(a, n - <span class="number">1</span>) * a;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> pow (a, n / <span class="number">2</span>);</span><br><span class="line">       <span class="keyword">return</span> t </span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) res * = a;</span><br><span class="line">        a *= a;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 大数据加法  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">add</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B)</span> &#123;  </span><br><span class="line">    <span class="comment">// 默认A &gt; B，如果不满足则对调</span></span><br><span class="line">   <span class="keyword">if</span> (A.size() &lt; B.size()) &#123;  </span><br><span class="line">      <span class="keyword">return</span> add(B, A);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">   List&lt;Integer&gt; C = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; A.size(); i++) &#123;  </span><br><span class="line">      t += A.get(i);  </span><br><span class="line">      <span class="comment">// 如果在B的范围内，则加B</span></span><br><span class="line">      <span class="keyword">if</span> (i &lt; B.size()) &#123;  </span><br><span class="line">         t += B.get(i);  </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">// C记录余数</span></span><br><span class="line">      C.add(t % <span class="number">10</span>);  </span><br><span class="line">      t /= <span class="number">10</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">// 进位</span></span><br><span class="line">   <span class="keyword">if</span> (t != <span class="number">0</span>) &#123;  </span><br><span class="line">      C.add(t);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">// 去掉开头的零</span></span><br><span class="line">   <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.get(C.size() - <span class="number">1</span>) == <span class="number">0</span>) &#123;  </span><br><span class="line">      C.remove(C.size() - <span class="number">1</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> C;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Leetcode</code>暂无练习题, 可用以下代码进行练习</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;  </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;  </span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;  </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;  </span><br><span class="line"><span class="keyword">import</span> java.util.List;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;  </span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">       <span class="comment">// 由于数据量较大，使用BufferedReader读取数据</span></span><br><span class="line">       <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));  </span><br><span class="line">       <span class="type">String</span> <span class="variable">A</span> <span class="operator">=</span> in.readLine();  </span><br><span class="line">       List&lt;Integer&gt; aList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> A.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">          aList.add(A.charAt(i) - <span class="string">&#x27;0&#x27;</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="type">String</span> <span class="variable">B</span> <span class="operator">=</span> in.readLine();  </span><br><span class="line">       List&lt;Integer&gt; bList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> B.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">          bList.add(B.charAt(i) - <span class="string">&#x27;0&#x27;</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">       List&lt;Integer&gt; cList = add(aList, bList);  </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cList.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">          System.out.print(cList.get(i));  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">// 关闭资源</span></span><br><span class="line">       in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**  </span></span><br><span class="line"><span class="comment">    * 大数据加法  </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">add</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B)</span> &#123;  </span><br><span class="line">      <span class="comment">// 模板</span></span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B)</span> &#123;  </span><br><span class="line">    <span class="comment">// 优先比较数组长度，长度更大，数值更大</span></span><br><span class="line">   <span class="keyword">if</span> (A.size() != B.size()) &#123;  </span><br><span class="line">      <span class="keyword">return</span> A.size() &gt; B.size();  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> A.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">      <span class="keyword">if</span> (A.get(i) == B.get(i)) &#123;  </span><br><span class="line">         <span class="keyword">continue</span>;  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">return</span> A.get(i) &gt; B.get(i);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 大数据减法  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">subtract</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B)</span> &#123;  </span><br><span class="line">   <span class="keyword">if</span> (!compare(A, B)) &#123;  </span><br><span class="line">      System.out.print(<span class="string">&quot;-&quot;</span>);  </span><br><span class="line">      <span class="keyword">return</span> subtract(B, A);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">   List&lt;Integer&gt; C = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; A.size(); i++) &#123;  </span><br><span class="line">      t = A.get(i) - t;  </span><br><span class="line">      <span class="keyword">if</span> (i &lt; B.size()) &#123;  </span><br><span class="line">         t -= B.get(i);  </span><br><span class="line">      &#125;  </span><br><span class="line">      C.add((t + <span class="number">10</span>) % <span class="number">10</span>);  </span><br><span class="line">      <span class="keyword">if</span> (t &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">         t = <span class="number">1</span>;  </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">         t = <span class="number">0</span>;  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.get(C.size() - <span class="number">1</span>) == <span class="number">0</span>) &#123;  </span><br><span class="line">      C.remove(C.size() - <span class="number">1</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> C;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;  </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;  </span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;  </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;  </span><br><span class="line"><span class="keyword">import</span> java.util.List;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;  </span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">      <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));  </span><br><span class="line">      <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> in.readLine();  </span><br><span class="line">      List&lt;Integer&gt; A = getIntegerList(s);  </span><br><span class="line">      s = in.readLine();  </span><br><span class="line">      List&lt;Integer&gt; B = getIntegerList(s);  </span><br><span class="line">      List&lt;Integer&gt; C = subtract(A, B);  </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> C.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">         System.out.print(C.get(i));  </span><br><span class="line">      &#125;  </span><br><span class="line">      in.close();  </span><br><span class="line">   &#125;  </span><br><span class="line"></span><br><span class="line">   <span class="comment">/**  </span></span><br><span class="line"><span class="comment">    * 由于是大数据，因此用BufferedReader读取 根据读取的字符串转换成集合  </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">getIntegerList</span><span class="params">(String s)</span> &#123;  </span><br><span class="line">      List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(s.length());  </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">         res.add(Character.getNumericValue(s.charAt(i)));  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">return</span> res;  </span><br><span class="line">   &#125;  </span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B)</span> &#123;  </span><br><span class="line">      <span class="keyword">if</span> (A.size() != B.size()) &#123;  </span><br><span class="line">         <span class="keyword">return</span> A.size() &gt; B.size();  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> A.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">         <span class="keyword">if</span> (A.get(i) == B.get(i)) &#123;  </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="keyword">return</span> A.get(i) &gt; B.get(i);  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line"></span><br><span class="line">   <span class="comment">/**  </span></span><br><span class="line"><span class="comment">    * 大数据减法  </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">subtract</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B)</span> &#123;  </span><br><span class="line">      <span class="keyword">if</span> (!compare(A, B)) &#123;  </span><br><span class="line">         System.out.print(<span class="string">&quot;-&quot;</span>);  </span><br><span class="line">         <span class="keyword">return</span> subtract(B, A);  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">      List&lt;Integer&gt; C = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; A.size(); i++) &#123;  </span><br><span class="line">         t = A.get(i) - t;  </span><br><span class="line">         <span class="keyword">if</span> (i &lt; B.size()) &#123;  </span><br><span class="line">            t -= B.get(i);  </span><br><span class="line">         &#125;  </span><br><span class="line">         C.add((t + <span class="number">10</span>) % <span class="number">10</span>);  </span><br><span class="line">         <span class="keyword">if</span> (t &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">            t = <span class="number">1</span>;  </span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            t = <span class="number">0</span>;  </span><br><span class="line">         &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.get(C.size() - <span class="number">1</span>) == <span class="number">0</span>) &#123;  </span><br><span class="line">         C.remove(C.size() - <span class="number">1</span>);  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">return</span> C;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度乘低精度"><a href="#高精度乘低精度" class="headerlink" title="高精度乘低精度"></a>高精度乘低精度</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 大数据乘法  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">subtract</span><span class="params">(List&lt;Integer&gt; A, Integer b)</span> &#123;  </span><br><span class="line">   List&lt;Integer&gt; C = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">   <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;  </span><br><span class="line">      C.add(<span class="number">0</span>);  </span><br><span class="line">      <span class="keyword">return</span> C;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; A.size(); i++) &#123;  </span><br><span class="line">      t += A.get(i) * b;  </span><br><span class="line">      C.add(t % <span class="number">10</span>);  </span><br><span class="line">      t /= <span class="number">10</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">if</span> (t != <span class="number">0</span>) &#123;  </span><br><span class="line">      C.add(t);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.get(C.size() - <span class="number">1</span>) == <span class="number">0</span>) &#123;  </span><br><span class="line">      C.remove(C.size() - <span class="number">1</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> C;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;  </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;  </span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;  </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;  </span><br><span class="line"><span class="keyword">import</span> java.util.List;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;  </span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">      <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));  </span><br><span class="line">      <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> in.readLine();  </span><br><span class="line">      List&lt;Integer&gt; A = getIntegerList(s);  </span><br><span class="line">      <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> Integer.parseInt(in.readLine());  </span><br><span class="line">      List&lt;Integer&gt; C = subtract(A, b);  </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> C.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">         System.out.print(C.get(i));  </span><br><span class="line">      &#125;  </span><br><span class="line">      in.close();  </span><br><span class="line">   &#125;  </span><br><span class="line"></span><br><span class="line">   <span class="comment">/**  </span></span><br><span class="line"><span class="comment">    * 由于是大数据，因此用BufferedReader读取 根据读取的字符串转换成集合  </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">getIntegerList</span><span class="params">(String s)</span> &#123;  </span><br><span class="line">      List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(s.length());  </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">         res.add(Character.getNumericValue(s.charAt(i)));  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">return</span> res;  </span><br><span class="line">   &#125;  </span><br><span class="line"></span><br><span class="line">   <span class="comment">/**  </span></span><br><span class="line"><span class="comment">    * 大数据乘法  </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">subtract</span><span class="params">(List&lt;Integer&gt; A, Integer b)</span> &#123;  </span><br><span class="line">      List&lt;Integer&gt; C = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">      <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;  </span><br><span class="line">         C.add(<span class="number">0</span>);  </span><br><span class="line">         <span class="keyword">return</span> C;  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; A.size(); i++) &#123;  </span><br><span class="line">         t += A.get(i) * b;  </span><br><span class="line">         C.add(t % <span class="number">10</span>);  </span><br><span class="line">         t /= <span class="number">10</span>;  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">if</span> (t != <span class="number">0</span>) &#123;  </span><br><span class="line">         C.add(t);  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.get(C.size() - <span class="number">1</span>) == <span class="number">0</span>) &#123;  </span><br><span class="line">         C.remove(C.size() - <span class="number">1</span>);  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">return</span> C;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度除以低精度"><a href="#高精度除以低精度" class="headerlink" title="高精度除以低精度"></a>高精度除以低精度</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 大数据除法  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">divide</span><span class="params">(List&lt;Integer&gt; A, Integer b)</span> &#123;  </span><br><span class="line">   <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">   List&lt;Integer&gt; C = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> A.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">      t = t * <span class="number">10</span> + A.get(i);  </span><br><span class="line">      C.add(t / b);  </span><br><span class="line">      t %= b;  </span><br><span class="line">   &#125;  </span><br><span class="line">   Collections.reverse(C);  </span><br><span class="line">   <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.get(C.size() - <span class="number">1</span>) == <span class="number">0</span>) &#123;  </span><br><span class="line">      C.remove(C.size() - <span class="number">1</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">// 为了方便传递，放在了数组的最后一位，因此输出时需要从倒数第二位开始  </span></span><br><span class="line">   C.add(t);  </span><br><span class="line">   <span class="keyword">return</span> C;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;  </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;  </span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;  </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;  </span><br><span class="line"><span class="keyword">import</span> java.util.Collections;  </span><br><span class="line"><span class="keyword">import</span> java.util.List;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;  </span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">      <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));  </span><br><span class="line">      <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> in.readLine();  </span><br><span class="line">      List&lt;Integer&gt; A = getIntegerList(s);  </span><br><span class="line">      <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> Integer.parseInt(in.readLine());  </span><br><span class="line">      List&lt;Integer&gt; C = divide(A, b);  </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> C.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">         System.out.print(C.get(i));  </span><br><span class="line">      &#125;  </span><br><span class="line">      System.out.println();  </span><br><span class="line">      System.out.print(C.get(C.size() - <span class="number">1</span>));  </span><br><span class="line">      in.close();  </span><br><span class="line">   &#125;  </span><br><span class="line"></span><br><span class="line">   <span class="comment">/**  </span></span><br><span class="line"><span class="comment">    * 由于是大数据，因此用BufferedReader读取 根据读取的字符串转换成集合  </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">getIntegerList</span><span class="params">(String s)</span> &#123;  </span><br><span class="line">      List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(s.length());  </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">         res.add(Character.getNumericValue(s.charAt(i)));  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">return</span> res;  </span><br><span class="line">   &#125;  </span><br><span class="line"></span><br><span class="line">   <span class="comment">/**  </span></span><br><span class="line"><span class="comment">    * 大数据除法  </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">divide</span><span class="params">(List&lt;Integer&gt; A, Integer b)</span> &#123;  </span><br><span class="line">      <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">      List&lt;Integer&gt; C = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> A.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">         t = t * <span class="number">10</span> + A.get(i);  </span><br><span class="line">         C.add(t / b);  </span><br><span class="line">         t %= b;  </span><br><span class="line">      &#125;  </span><br><span class="line">      Collections.reverse(C);  </span><br><span class="line">      <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.get(C.size() - <span class="number">1</span>) == <span class="number">0</span>) &#123;  </span><br><span class="line">         C.remove(C.size() - <span class="number">1</span>);  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="comment">// 为了方便传递，放在了数组的最后一位，因此输出时需要从倒数第二位开始  </span></span><br><span class="line">      C.add(t);  </span><br><span class="line">      <span class="keyword">return</span> C;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前缀和和差分"><a href="#前缀和和差分" class="headerlink" title="前缀和和差分"></a>前缀和和差分</h2><h3 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h3><p><strong>代码模板</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PreSum</span> &#123;</span><br><span class="line">    <span class="comment">// 前缀和数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] preSum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输入一个数组，构造前缀和 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PreSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// preSum[0] = 0，便于计算累加和</span></span><br><span class="line">        preSum = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 计算 nums 的累加和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; preSum.length; i++) &#123;</span><br><span class="line">            preSum[i] = preSum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 查询闭区间 [left, right] 的累加和 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> preSum[right + <span class="number">1</span>] - preSum[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>练习题</strong></p><p><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line">    PreSum preSum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        preSum = <span class="keyword">new</span> <span class="title class_">PreSum</span>(nums);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> preSum.sumRange(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PreSum</span> &#123;</span><br><span class="line">    <span class="comment">// 待补全的模板代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><p><strong>代码模板</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">preSum</span> &#123;</span><br><span class="line">     <span class="comment">// 定义：preSum[i][j] 记录 matrix 中子矩阵 [0, 0, i-1, j-1] 的元素和</span></span><br><span class="line">       <span class="keyword">private</span> <span class="type">int</span>[][] preSum;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">preSum</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">           <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 构造前缀和矩阵</span></span><br><span class="line">           preSum = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                   <span class="comment">// 计算每个矩阵 [0, 0, i, j] 的元素和</span></span><br><span class="line">                   preSum[i][j] = preSum[i - <span class="number">1</span>][j]</span><br><span class="line">                       + preSum[i][j - <span class="number">1</span>]</span><br><span class="line">                       + matrix[i - <span class="number">1</span>][j -<span class="number">1</span>]</span><br><span class="line">                       - preSum[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"> <span class="comment">// 计算子矩阵 [x1, y1, x2, y2] 的元素和</span></span><br><span class="line">       <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRegion</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> &#123;</span><br><span class="line">           <span class="comment">// 目标矩阵之和由四个相邻矩阵运算获得</span></span><br><span class="line">           <span class="keyword">return</span> preSum[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>]</span><br><span class="line">               - preSum[x1][y2 + <span class="number">1</span>]</span><br><span class="line">               - preSum[x2 + <span class="number">1</span>][y1]</span><br><span class="line">               + preSum[x1][y1];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>练习题</strong></p><p><a href="https://leetcode.cn/problems/max-sum-of-rectangle-no-larger-than-k/">363. 矩形区域不超过 K 的最大数值和</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSumSubmatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">preSum</span> <span class="variable">numMatrix</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">preSum</span>(matrix);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i; k &lt; matrix.length; k++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> j; l &lt; matrix[<span class="number">0</span>].length; l++) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> numMatrix.sumRegion(i, j, k, l);</span><br><span class="line">                        <span class="keyword">if</span> (temp &gt; target) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            res = res &gt; temp ? res : temp;</span><br><span class="line">                        </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">preSum</span> &#123;</span><br><span class="line"><span class="comment">// 待补全的模板代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h3><p><strong>代码模板</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Difference</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>[] diff;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Difference</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        diff = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        diff[i] += val;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; diff.length) &#123;</span><br><span class="line">            diff[j + <span class="number">1</span>] -= val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] result() &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[diff.length];</span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习题</strong></p><p><a href="https://leetcode.cn/problems/corporate-flight-bookings/">1109. 航班预订统计</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] corpFlightBookings(<span class="type">int</span>[][] bookings, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">Difference</span> <span class="variable">diff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Difference</span>(res);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bookings.length; i++) &#123;</span><br><span class="line">            diff.update(bookings[i][<span class="number">0</span>] - <span class="number">1</span>, bookings[i][<span class="number">1</span>] - <span class="number">1</span>, bookings[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> diff.result();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Difference</span> &#123;</span><br><span class="line">   <span class="comment">// 待补全的模板代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h3><p><strong>代码模板</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Difference</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] matrix; <span class="comment">// 存储原始矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] diff; <span class="comment">// 存储差分矩阵</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Difference</span><span class="params">(<span class="type">int</span>[][] nums)</span> &#123;</span><br><span class="line">        matrix = nums;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length; <span class="comment">// 矩阵行数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length; <span class="comment">// 矩阵列数</span></span><br><span class="line">        diff = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>]; <span class="comment">// 差分矩阵的大小比原始矩阵多1</span></span><br><span class="line">        <span class="comment">// 计算差分矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="comment">// 更新差分矩阵</span></span><br><span class="line">                update(i, j, i, j, matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新差分矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 更新对应位置的数量</span></span><br><span class="line">        diff[x1][y1] += val;</span><br><span class="line">        <span class="comment">// 右下角的方格减去val</span></span><br><span class="line">        diff[x2 + <span class="number">1</span>][y1] -= val;</span><br><span class="line">        <span class="comment">// 右下角的方格减去val</span></span><br><span class="line">        diff[x1][y2 + <span class="number">1</span>] -= val;</span><br><span class="line">        <span class="comment">// 左上角的方格加上val</span></span><br><span class="line">        diff[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取更新后的矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] result() &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length; <span class="comment">// 矩阵行数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length; <span class="comment">// 矩阵列数</span></span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][m]; <span class="comment">// 存储更新后的矩阵</span></span><br><span class="line">        res[<span class="number">0</span>][<span class="number">0</span>] = diff[<span class="number">0</span>][<span class="number">0</span>]; <span class="comment">// 差分矩阵的第一个元素即为更新后的矩阵的第一个元素</span></span><br><span class="line">        <span class="comment">// 计算第一列的元素值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res[i][<span class="number">0</span>] = res[i - <span class="number">1</span>][<span class="number">0</span>] + diff[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算第一行的元素值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            res[<span class="number">0</span>][i] = res[<span class="number">0</span>][i - <span class="number">1</span>] + diff[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算其他位置的元素值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="comment">// 使用差分矩阵计算当前位置的值</span></span><br><span class="line">                res[i][j] = res[i - <span class="number">1</span>][j] + res[i][j - <span class="number">1</span>] - res[i - <span class="number">1</span>][j - <span class="number">1</span>] + diff[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习题</strong></p><p><a href="https://leetcode.cn/problems/increment-submatrices-by-one/">2536. 子矩阵元素加 1</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] rangeAddQueries(<span class="type">int</span> n, <span class="type">int</span>[][] queries) &#123;</span><br><span class="line">        <span class="type">Difference</span> <span class="variable">diffeMatrix</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Difference</span>(<span class="keyword">new</span> <span class="title class_">int</span>[n][n]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; queries.length; i++) &#123; </span><br><span class="line">            diffeMatrix.update(queries[i][<span class="number">0</span>],</span><br><span class="line">                            queries[i][<span class="number">1</span>],</span><br><span class="line">                            queries[i][<span class="number">2</span>],</span><br><span class="line">                            queries[i][<span class="number">3</span>],</span><br><span class="line">                            <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> diffeMatrix.result();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Difference</span> &#123;</span><br><span class="line">       <span class="comment">// 待补全的代码模板 </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="位1的个数-汉明权重"><a href="#位1的个数-汉明权重" class="headerlink" title="位1的个数(汉明权重)"></a>位1的个数(汉明权重)</h3><p><strong>代码模板</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int hammingWeight(int n) &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = n; i != 0; i -= (i &amp; -i)) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习题</strong></p><p><a href="https://leetcode.cn/problems/number-of-1-bits/">191. 位1的个数</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 待补全的代码模板 </span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h2><h3 id="同向指针"><a href="#同向指针" class="headerlink" title="同向指针"></a>同向指针</h3><p><strong>代码模板</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (fast &lt; nums.length()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (check()) &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        slow ++;</span><br><span class="line">    &#125;</span><br><span class="line">    fast ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习题</strong></p><h3 id="异向指针"><a href="#异向指针" class="headerlink" title="异向指针"></a>异向指针</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int l = 0;</span><br><span class="line">int r = nums.length - 1;</span><br><span class="line"></span><br><span class="line">while (l &lt;= r) &#123;</span><br><span class="line">// do something</span><br><span class="line">l ++;</span><br><span class="line">r --;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><h3 id="模板题-AcWing-802-区间和"><a href="#模板题-AcWing-802-区间和" class="headerlink" title="模板题 AcWing 802. 区间和"></a><a href="https://www.acwing.com/problem/content/804/">模板题 AcWing 802. 区间和</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 去重 + 排序  </span></span><br><span class="line">List&lt;Integer&gt; distinctSorterAlls = alls.stream().distinct().sorted()  </span><br><span class="line">      .collect(Collectors.toList());  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 离散化映射，把离散化的下标映射到连续的数组下标 + 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] item : add) &#123;  </span><br><span class="line">   <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Collections.binarySearch(distinctSorterAlls, item[<span class="number">0</span>]) + <span class="number">1</span>;  </span><br><span class="line">   a[index] += item[<span class="number">1</span>];  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 前缀和  </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= distinctSorterAlls.size(); i++) &#123;  </span><br><span class="line">   s[i] = s[i - <span class="number">1</span>] + a[i];  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 离散化映射，把离散化的下标映射到连续的数组下标 + 1 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] item : query) &#123;  </span><br><span class="line">   <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> Collections.binarySearch(distinctSorterAlls, item[<span class="number">0</span>]) + <span class="number">1</span>;  </span><br><span class="line">   <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> Collections.binarySearch(distinctSorterAlls, item[<span class="number">1</span>]) + <span class="number">1</span>;  </span><br><span class="line">   System.out.println(s[r] - s[l - <span class="number">1</span>]);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/804/">模板题 AcWing 802. 区间和</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;  </span><br><span class="line"><span class="keyword">import</span> java.util.Collections;  </span><br><span class="line"><span class="keyword">import</span> java.util.List;  </span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;  </span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;  </span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">300000</span>;  </span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">      <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);  </span><br><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();  </span><br><span class="line">      <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> in.nextInt();  </span><br><span class="line">      List&lt;Integer&gt; alls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">      <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[N];  </span><br><span class="line">      <span class="type">int</span>[] s = <span class="keyword">new</span> <span class="title class_">int</span>[N];  </span><br><span class="line">      List&lt;<span class="type">int</span>[]&gt; add = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">      List&lt;<span class="type">int</span>[]&gt; query = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;  </span><br><span class="line">         <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> in.nextInt();  </span><br><span class="line">         <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> in.nextInt();  </span><br><span class="line">         add.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x, c&#125;);  </span><br><span class="line">         alls.add(x);  </span><br><span class="line">      &#125;  </span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;  </span><br><span class="line">         <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> in.nextInt();  </span><br><span class="line">         <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> in.nextInt();  </span><br><span class="line">         query.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;l, r&#125;);  </span><br><span class="line">         alls.add(l);  </span><br><span class="line">         alls.add(r);  </span><br><span class="line">      &#125;  </span><br><span class="line"></span><br><span class="line">      <span class="comment">// 去重 + 排序  </span></span><br><span class="line">      List&lt;Integer&gt; distinctSorterAlls = alls.stream().distinct().sorted()  </span><br><span class="line">            .collect(Collectors.toList());  </span><br><span class="line"></span><br><span class="line">      <span class="comment">// 离散化映射，把离散化的下标映射到连续的数组下标 + 1      </span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span>[] item : add) &#123;  </span><br><span class="line">         <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Collections.binarySearch(distinctSorterAlls, item[<span class="number">0</span>]) + <span class="number">1</span>;  </span><br><span class="line">         a[index] += item[<span class="number">1</span>];  </span><br><span class="line">      &#125;  </span><br><span class="line"></span><br><span class="line">      <span class="comment">// 前缀和  </span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= distinctSorterAlls.size(); i++) &#123;  </span><br><span class="line">         s[i] = s[i - <span class="number">1</span>] + a[i];  </span><br><span class="line">      &#125;  </span><br><span class="line"></span><br><span class="line">      <span class="comment">// 离散化映射，把离散化的下标映射到连续的数组下标 + 1      </span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span>[] item : query) &#123;  </span><br><span class="line">         <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> Collections.binarySearch(distinctSorterAlls, item[<span class="number">0</span>]) + <span class="number">1</span>;  </span><br><span class="line">         <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> Collections.binarySearch(distinctSorterAlls, item[<span class="number">1</span>]) + <span class="number">1</span>;  </span><br><span class="line">         System.out.println(s[r] - s[l - <span class="number">1</span>]);  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h2><p><strong>代码模板</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">LinkedList&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Arrays.sort(intervals, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]); </span><br><span class="line">    res.add(intervals[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span>[] cur = intervals[i];</span><br><span class="line">        <span class="type">int</span>[] last = res.getLast();</span><br><span class="line">        <span class="keyword">if</span> (cur[<span class="number">0</span>] &lt;= last[<span class="number">1</span>]) &#123;</span><br><span class="line">            last[<span class="number">1</span>] = Math.max(last[<span class="number">1</span>], cur[<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习题</strong></p><p><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="comment">// 待补全的模板代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="——-图论算法——"><a href="#——-图论算法——" class="headerlink" title="——-图论算法——-"></a>——-图论算法——-</h2><h3 id="构建邻接表"><a href="#构建邻接表" class="headerlink" title="构建邻接表"></a>构建邻接表</h3><p><strong>代码模板</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt;[] buildGraph(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">    <span class="comment">// 初始化邻接表</span></span><br><span class="line">    List&lt;Integer&gt;[] graph = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        graph[i] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 填充邻接表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] edge : prerequisites) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">1</span>], to = edge[<span class="number">0</span>];</span><br><span class="line">        graph[from].add(to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="环路检测"><a href="#环路检测" class="headerlink" title="环路检测"></a>环路检测</h3><p><strong>代码模板</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正在遍历的路径上的结点</span></span><br><span class="line"><span class="type">boolean</span>[] onPath;</span><br><span class="line"><span class="comment">// 访问过的结点</span></span><br><span class="line"><span class="type">boolean</span>[] visited;</span><br><span class="line"><span class="comment">// 是否存在环</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasCycle</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="type">int</span> cur)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (onPath[cur]) &#123;</span><br><span class="line">        hasCycle = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (visited[cur] || hasCycle) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将结点标志为已遍历</span></span><br><span class="line">    visited[cur] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 开始遍历s结点</span></span><br><span class="line">    onPath[cur] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> next : graph[cur]) &#123;</span><br><span class="line">        traverse(graph,  next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结点s遍历完成</span></span><br><span class="line">    onPath[cur] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模板题</strong></p><p><a href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正在遍历的路径上的结点</span></span><br><span class="line">    <span class="type">boolean</span>[] onPath;</span><br><span class="line">    <span class="comment">// 访问过的结点has</span></span><br><span class="line">    <span class="type">boolean</span>[] visited;</span><br><span class="line">    <span class="comment">// 是否存在环</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasCycle</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt;[] graph = buildGraph(numCourses, prerequisites);</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[numCourses];</span><br><span class="line">        onPath = <span class="keyword">new</span> <span class="title class_">boolean</span>[numCourses];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="comment">// 遍历图中的所有节点</span></span><br><span class="line">            traverse(graph, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只要没有循环依赖可以完成所有课程</span></span><br><span class="line">        <span class="keyword">return</span> !hasCycle;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">        <span class="comment">// 待补全的模板代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt;[] buildGraph(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="comment">// 待补全的模板代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p><strong>代码模板</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正在遍历的路径上的结点</span></span><br><span class="line"><span class="type">boolean</span>[] onPath;</span><br><span class="line"><span class="comment">// 访问过的结点</span></span><br><span class="line"><span class="type">boolean</span>[] visited;</span><br><span class="line"><span class="comment">// 是否存在环</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasCycle</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 后序遍历结果</span></span><br><span class="line">List&lt;Integer&gt; postorder = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓扑排序就是将后序遍历翻转</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] topologicalSort(<span class="type">int</span> num, <span class="type">int</span>[][] depends) &#123;</span><br><span class="line">    List&lt;Integer&gt;[] graph = buildGraph(num, depends);</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[num];</span><br><span class="line">    onPath = <span class="keyword">new</span> <span class="title class_">boolean</span>[num];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        traverse(graph, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasCycle) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.reverse(postorder);</span><br><span class="line">    <span class="keyword">return</span> postorder.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="type">int</span> cur)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (onPath[cur]) &#123;</span><br><span class="line">        hasCycle = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (visited[cur] || hasCycle) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[cur] = <span class="literal">true</span>;</span><br><span class="line">    onPath[cur] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> next : graph[cur]) &#123;</span><br><span class="line">        traverse(graph, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postorder.add(cur);</span><br><span class="line">    onPath[cur] = <span class="literal">false</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p><strong>模板题</strong></p><p><a href="https://leetcode.cn/problems/course-schedule-ii/">210. 课程表 II</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="keyword">return</span> topologicalSort(numCourses, prerequisites);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topologicalSort(<span class="type">int</span> num, <span class="type">int</span>[][] depends) &#123;</span><br><span class="line">       <span class="comment">// 待补全的模板代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="type">int</span> cur)</span> &#123;</span><br><span class="line">       <span class="comment">// 待补全的模板代码</span></span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt;[] buildGraph(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">       <span class="comment">// 待补全的模板代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p><strong>代码模板</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UF</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        parent[rootP] = rootQ;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">        <span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x != parent[x]) &#123;</span><br><span class="line">            parent[x] = find(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">        <span class="comment">// 迭代写法</span></span><br><span class="line">        <span class="comment">// while (parent[x] != x) &#123;</span></span><br><span class="line">            <span class="comment">// parent[x] = parent[parent[x]];</span></span><br><span class="line">            <span class="comment">// x = parent[x];</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return x;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习题</strong></p><p><a href="https://leetcode.cn/problems/satisfiability-of-equality-equations/">990. 等式方程的可满足性</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equationsPossible</span><span class="params">(String[] equations)</span> &#123;</span><br><span class="line">        <span class="type">UF</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UF</span>(<span class="number">26</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; equations.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getOperator(equations[i]).equals(<span class="string">&quot;==&quot;</span>)) &#123;</span><br><span class="line">                uf.union(getLeft(equations[i]), getRight(equations[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; equations.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getOperator(equations[i]).equals(<span class="string">&quot;!=&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uf.connected(getLeft(equations[i]), getRight(equations[i])))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getOperator</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.substring(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getLeft</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.substring(<span class="number">0</span>, <span class="number">1</span>).charAt(<span class="number">0</span>) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getRight</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.substring(<span class="number">3</span>).charAt(<span class="number">0</span>) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="comment">// 待补全的模板代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## -------面试常考-------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 二叉树前中后序遍历</span><br><span class="line"></span><br><span class="line">### 递归</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**代码模板**</span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">order</span><span class="params">(List&lt;Integer&gt; res, TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == root) <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    res.add(root.val);</span><br><span class="line">  order(res, root.left);</span><br><span class="line">    order(res, root.right);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="comment">// order(res, root.left);</span></span><br><span class="line">    <span class="comment">// res.add(root.val);</span></span><br><span class="line">    <span class="comment">// order(res, root.right);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="comment">// order(res, root.left);</span></span><br><span class="line">    <span class="comment">// order(res, root.right);</span></span><br><span class="line">    <span class="comment">// res.add(root.val);</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h3><p>颜色标记法</p><ul><li>白色 : 第一次访问为白色, 需要”变色”成黑色(此处为在顶部多放置一个null结点来表示变色操作) </li><li>黑色:  结点为黑色, 可直接取出进行操作</li></ul><p><strong>代码模板</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">orderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == root) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != stack.peek()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 前序遍历</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != node.right) stack.push(node.right);</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != node.left) stack.push(node.left);</span><br><span class="line">                stack.push(node);</span><br><span class="line">                stack.push(<span class="literal">null</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 中序遍历</span></span><br><span class="line">                <span class="comment">// if (null != node.right) stack.push(node.right);</span></span><br><span class="line">                <span class="comment">// stack.push(node);</span></span><br><span class="line">                <span class="comment">// stack.push(null);</span></span><br><span class="line">                <span class="comment">// if (null != node.left) stack.push(node.left);</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 后序遍历</span></span><br><span class="line">                <span class="comment">// stack.push(node);</span></span><br><span class="line">                <span class="comment">// stack.push(null);</span></span><br><span class="line">                <span class="comment">// if (null != node.right) stack.push(node.right);</span></span><br><span class="line">                <span class="comment">// if (null != node.left) stack.push(node.left);</span></span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                res.add(node.val);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>模板题</strong></p><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/?envType=daily-question&envId=2024-02-11">144. 二叉树的前序遍历 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/?envType=daily-question&envId=2024-02-10">94. 二叉树的中序遍历 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/description/?envType=daily-question&envId=2024-02-12">145. 二叉树的后序遍历 - 力扣（LeetCode）</a></p><h2 id="蓝桥杯"><a href="#蓝桥杯" class="headerlink" title="蓝桥杯"></a>蓝桥杯</h2><h3 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h3><p>求<code>1 - n</code>之间的素数</p><h4 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span>[] getPrimes(<span class="type">int</span> n) &#123;</span><br><span class="line"><span class="type">boolean</span>[] primes = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">primes[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!primes[i]) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i * i; j &lt;= n; j += i) &#123;</span><br><span class="line">primes[j] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> primes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试程序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">boolean</span>[] result = getPrimes(<span class="number">100</span>);</span><br><span class="line">IntStream.range(<span class="number">0</span>, result.length)</span><br><span class="line">        .filter(i -&gt; !result[i]) </span><br><span class="line">        .forEach(i -&gt; System.out.print(i + <span class="string">&quot; &quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="欧拉筛-线性筛"><a href="#欧拉筛-线性筛" class="headerlink" title="欧拉筛(线性筛)"></a>欧拉筛(线性筛)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] getPrimes(<span class="type">int</span> n) &#123;</span><br><span class="line"><span class="type">int</span>[] primes = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line"><span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">primes[++pos] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; i* primes[j] &lt;= n; j++) &#123;</span><br><span class="line">vis[i * primes[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> primes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试程序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] result = getPrimes(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">Arrays.stream(result)</span><br><span class="line">.filter(i -&gt; i != <span class="number">0</span>)</span><br><span class="line">        .forEach(i -&gt; System.out.print(i + <span class="string">&quot; &quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小公倍数和最大公约数"><a href="#最小公倍数和最大公约数" class="headerlink" title="最小公倍数和最大公约数"></a>最小公倍数和最大公约数</h3><h4 id="求最大公约数"><a href="#求最大公约数" class="headerlink" title="求最大公约数"></a>求最大公约数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">gcd</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">        c = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试程序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">System.out.println(gcd(a, b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求最小公倍数"><a href="#求最小公倍数" class="headerlink" title="求最小公倍数"></a>求最小公倍数</h4><p>同上求最大公约数</p><p>测试程序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">System.out.println(a * b / gcd(a, b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速输入输出模板"><a href="#快速输入输出模板" class="headerlink" title="快速输入输出模板"></a>快速输入输出模板</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.StreamTokenizer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Template</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">BufferedWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">StreamTokenizer</span> <span class="variable">cin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in)));</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">PrintWriter</span> <span class="variable">cout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">cin.ordinaryChars(<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">cin.wordChars(<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">cin.ordinaryChar(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">cin.wordChars(<span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="comment">//int a = nextInt();</span></span><br><span class="line"><span class="comment">//long b = nextLong();</span></span><br><span class="line"><span class="comment">//double c = nextDouble();</span></span><br><span class="line"><span class="comment">//String d = nextString();</span></span><br><span class="line"><span class="comment">//cout.println(a);</span></span><br><span class="line"><span class="comment">//cout.println(b);</span></span><br><span class="line"><span class="comment">//cout.println(c);</span></span><br><span class="line"><span class="comment">//cout.println(d);</span></span><br><span class="line">cout.flush();</span><br><span class="line">closeAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">cin.nextToken();</span><br><span class="line"><span class="keyword">return</span> Integer.parseInt(cin.sval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">nextLong</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">cin.nextToken();</span><br><span class="line"><span class="keyword">return</span> Long.parseLong(cin.sval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">nextDouble</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">cin.nextToken();</span><br><span class="line"><span class="keyword">return</span> Double.parseDouble(cin.sval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">nextString</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">cin.nextToken();</span><br><span class="line"><span class="keyword">return</span> cin.sval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeAll</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">in.close();</span><br><span class="line">out.close();</span><br><span class="line">cout.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 代码模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MESI缓存一致性协议</title>
      <link href="/posts/43255.html"/>
      <url>/posts/43255.html</url>
      
        <content type="html"><![CDATA[<p>⚠️⚠️⚠️ 注意!!!  本文还未完成,⚠️⚠️⚠️</p><p><a href="https://www.bilibili.com/video/BV1fK4y1E7NC/?spm_id_from=333.337.search-card.all.click&vd_source=a2cdc337163157715ec6605c77937a77">缓存一致性协议MESI_哔哩哔哩_bilibili</a></p><p>目前大多数PC的CUP都是多核</p><p>我们知道根据摩尔定律, CPU性能每隔18个月就会翻一倍(即使在10年后逐渐失效)</p><p>在经典的冯诺依曼体系中, 存储器和计算器的IO导致的性能低下已经越发的突出</p><p>由此,大多CPU都会存在缓存这一中间设备, 利用局部性原理, 将热点数据存储在缓存中</p><p>目前大多设备为三级缓存</p><p>其中L1, L2缓存为单个CPU私有(可能由于CPU架构而不同), L3缓存为共享, 但这并不是本节讨论的重点,接下来, 我们直接将缓存抽象为每个CPU核心所私有的</p><p>缓存的引入,极大的降低了IO效率, 提升了CPU整体的效率,但是多核架构下, 引入缓存会出现一致性问题</p><p>什么时一致性问题呢?</p><p>我们举个最简单的例子</p><p>CPU公有两个核心</p><p>P1  P2</p><p>现在内存中有一个全局变量 n  &#x3D; 1, 被两个核心共享</p><p>目前两个核心缓存都不存在这个全局变量(缓存引入后, CPU只直接操作缓存, 操作内存需要先读入缓存再写入缓存, 但是写入的时间并不确定)</p><p>假设 P1 P2的目的都是让全局变量加1, 那么我们预期的结果是  最后 n &#x3D; 3</p><p>但是下面的执行流程会得出不一样的结果</p><p>P1 读入缓存 n &#x3D; 1. 再缓存中+1 n &#x3D; 2</p><p>之后P1还未把缓存写入内存, P2开始了操作</p><p>P2 读入缓存 n &#x3D; 1. 再缓存中+1 n &#x3D; 2</p><p>P1 写入内存 n &#x3D; 2 覆盖了原本内存中的n &#x3D; 1</p><p>P2 写入内存 n &#x3D; 2 覆盖了原本内存中的n &#x3D; 2</p><p>最后内存中的值是n &#x3D; 2</p><p>这就是我们所说的一致性问题, 因为副本的更新不能即时的刷入内存中导致的(操作的原子性)</p><p>那么我们直接让每个操作都原子性不就好了? </p><p>于是引入了第一种解决方案</p><p>锁总线, 每次操作只能有一个核心执行, 这显然是极其低效的, 直接PASS</p><p>总线嗅探机制(其实还有基于目录的缓存一致性协议)</p><p>写失效(Write Through)</p><p>写更新(Write Back)</p><p><a href="https://www.alibabacloud.com/blog/memory-model-and-synchronization-primitive---part-1-memory-barrier_597460">https://www.alibabacloud.com/blog/memory-model-and-synchronization-primitive---part-1-memory-barrier_597460</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之美导学</title>
      <link href="/posts/1358.html"/>
      <url>/posts/1358.html</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要学习设计模式"><a href="#为什么要学习设计模式" class="headerlink" title="为什么要学习设计模式?"></a>为什么要学习设计模式?</h1><p><em>越早学习设计模式越好,有些东西早点知道,才能在日后一直发挥作用</em></p><p>在计算机五大件(计组, 计网, 操作系统, 编译原理, 设计模式)中</p><ul><li><p>数据结构和算法研究如何高效实现</p></li><li><p>设计模式研究如何保证代码的可维护性</p></li></ul><p>总结</p><ul><li>应对面试中的设计模式相关问题</li><li>告别被别人吐槽的烂代码(talk is cheap, show me your code)</li><li>提高复杂代码的设计和开发能力</li><li>让读源码,学框架事半功倍</li><li>为职场发展做铺垫</li></ul><p>​</p><p>在日常开发中用过哪些设计模式?</p><p>使用代理模式进行共性话处理,比如AOP思想,将非业务功能和业务功能解耦</p><ul><li>事务的处理 @Translation</li><li>系统间上下文的传递ThreadLocal+ restTemplate#intercept等等</li></ul><p>使用工厂 + 策略</p><ul><li>不同优惠种类的计算</li><li>定制化功能的解耦</li></ul><p>观察者模式 : 这个模式的思想在很多中间件(mq, zookeeper, netty等等)可以看到银子</p><ul><li>通过领域事件解耦业务</li><li>理解eventloop, epoll等等</li><li>通过watch实现动态配置, HA等等</li></ul><p>职责链模式: pipeline思想</p><ul><li>filter</li><li>理解netty中的各种handler</li></ul><h1 id="从哪些维度评价代码质量的好坏-如何具备写高质量代码的能力"><a href="#从哪些维度评价代码质量的好坏-如何具备写高质量代码的能力" class="headerlink" title="从哪些维度评价代码质量的好坏?如何具备写高质量代码的能力?"></a>从哪些维度评价代码质量的好坏?如何具备写高质量代码的能力?</h1><h2 id="如何评价代码质量的高低"><a href="#如何评价代码质量的高低" class="headerlink" title="如何评价代码质量的高低?"></a>如何评价代码质量的高低?</h2><p>代码质量高低的指标是从不同维度进行评价且具有很大的主观性</p><p>且指标之间并不独立,维度可能重合</p><p>而且评价很难量化,并非非黑即白</p><p>最常用的评价标准</p><ul><li><strong>可维护性</strong></li><li><strong>可读性</strong></li><li><strong>可扩展性</strong></li><li>灵活性</li><li>简介性</li><li>可复用性</li><li>可测试性</li></ul><h2 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h2><p>维护代码事件远远大于编码时间</p><p>维护无外乎 修改bug, 修改老代码, 添加新代码</p><p>易维护是指在不破坏原有代码设计, 不引入新的bug的情况下, 能快速地修改或者添加代码</p><p>可维护性由人而定, 很主观</p><h2 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h2><p><em>Google 内部甚至专门有个认证就叫作 Readability。只有拿到这个认证的工程师，才有资格在 code review 的时候，批准别人提交代码。</em></p><p>可见代码的可读性有多重要，毕竟，代码被阅读的次数远远超过被编写和执行的次数。</p><p>查看代码是否符合编码规范, 命名是否达意, 注释是否详尽, 函数是否长短合适, 模块划分是否清晰, 是否符合高内聚低耦合等等</p><p>code review是一个很好的测验代码可读性地手段. 如果同事可以轻松地读懂你写的代码,那说明你的代码可读性很好</p><h2 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h2><p>代码是否易于扩展</p><p>代码预留一些功能扩展点,不会因为添加一个功能,改动大量的原始代码</p><p>“对修改关闭, 对扩展开放”</p><h2 id="灵活性"><a href="#灵活性" class="headerlink" title="灵活性"></a>灵活性</h2><p>很抽象,不好下定义</p><p>举例场景可以被称为 代码写的灵活</p><ul><li>添加新的功能时, 原有代码已经预留好了扩展点, 不需要修改原代码,只需要在扩展点添加新的代码即可(扩展性)</li><li>实现一个功能,发现原有代码中,已经抽象出很多底层可复用的模块(可复用性)</li><li>使用某组接口时,这组接口可以应对各种使用场景,满足不同的的需求.(易用)</li></ul><h2 id="简洁性"><a href="#简洁性" class="headerlink" title="简洁性"></a>简洁性</h2><p>KISS原则 “Keep it Simple , Stupid”</p><p>编程经验不足的程序员喜欢在项目中引入一些复杂的设计模式,认为这样才能体现出技术水平</p><p>真正的高手能云淡风轻的用最简单的方式解决最复杂的问题</p><h2 id="可复用性"><a href="#可复用性" class="headerlink" title="可复用性"></a>可复用性</h2><p>尽量减少重复代码的编写,复用已有的代码</p><p>Don’t Reapeat your self</p><h2 id="可测试性"><a href="#可测试性" class="headerlink" title="可测试性"></a>可测试性</h2><p>代码可测试性差,比较难写单元测试,那基本说明代码设计有问题</p><h2 id="如何写出高质量的代码"><a href="#如何写出高质量的代码" class="headerlink" title="如何写出高质量的代码?"></a>如何写出高质量的代码?</h2><p>如何写出易维护,易读, 易扩展,灵活, 简洁, 可复用, 可测试的代码?</p><p>需要掌握一些更加细化,更加能落地的编程方法论</p><p>面向对象的设计思想, 设计原则, 设计模式, 编码规范, 重构技巧</p><h1 id="面向对象-设计原则-设计模式-编程规范-重构-这五者之间的关系"><a href="#面向对象-设计原则-设计模式-编程规范-重构-这五者之间的关系" class="headerlink" title="面向对象,设计原则, 设计模式,编程规范, 重构,这五者之间的关系?"></a>面向对象,设计原则, 设计模式,编程规范, 重构,这五者之间的关系?</h1><p><strong>极客时间 设计模式之美 大纲,学习框架</strong></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202309160909847.png" alt="image-20230916090931099"></p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>主流编程范式(面向过程, 面向对象, 函数式)中的主流.</p><p>面向对象具有丰富的特性(继承,封装.多态,抽象),可以实现很多复杂的设计思路,是很多设计原则,设计模式编码实现的基础</p><p>接下来需要掌握</p><ul><li>面向对象的四大特性 : 封装, 抽象, 继承, 多态</li><li>面向对象编程与面向过程编程的区别和联系</li><li>面向对象分析, 面向对象设计, 面向对象编程</li><li>接口类和抽象类的区别以及各自的应用场景</li><li>基于接口而非实现的编程设计思想</li><li>多用组合少用继承的设计思想</li><li>面向过程的贫血模式和面向对象的充血模型</li></ul><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>设计原则这里比较抽象,不能单纯的记忆,需要掌握其设计初衷,解决哪些编程问题,有那些应用场景</p><ul><li>SOLD原则-SRP 单一职责原则</li><li>SOLD原则-OCP 开闭原则</li><li>SOLD原则-LSP 里式替换原则</li><li>SOLD原则-ISP接口隔离原则</li><li>SOLD原则-DIP依赖倒置原则</li><li>DRY原则, KISS原则, YAGNI原则, LOD法则</li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式相较设计原则没那么抽象,难点在原了解他们都能解决哪些问题, 掌握典型的应用场景, 冰冻的不过度应用</p><p>23种经典设计模式,随着语言的严谨,一些设计模式(Singleton)随之过时,甚至成了反模式,一些内置在编程语言中(比如Iterator), 另外还有一些新模式的诞生(Monostate)</p><p>学习设计模式要有侧重点,对常用的设计模式,我们要多花时间理解掌握,对于不常用的只需要稍微了解即可</p><h3 id="创建型-5"><a href="#创建型-5" class="headerlink" title="创建型(5)"></a>创建型(5)</h3><p><strong>常用</strong>: <strong>单例, 工厂模式(工厂方法和抽象工厂), 建造者模式</strong></p><p>不常用: 原型模式</p><h3 id="结构型-7"><a href="#结构型-7" class="headerlink" title="结构型(7)"></a>结构型(7)</h3><p>常用: 代理模式, 桥接模式, 装饰器模式, 适配器模式</p><p>不常用: 门面模式, 组合模式, 享元模式</p><h3 id="行为型-11"><a href="#行为型-11" class="headerlink" title="行为型(11)"></a>行为型(11)</h3><p>常用: 观察者模式, 模板模式, 策略模式, 职责链模式,迭代器模式, 状态模式</p><p>不常用: 访问者模式, 备忘录模式, 命令模式, 解释器模式, 中介模式</p><h2 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h2><p>主要解决的是代码可读性问题,相对设计原则, 设计模式, 更加具体,更加片中代码细节</p><p>是最起码要掌握的</p><p>比如 : 给变量,类,函数命名, 如何写代码注释, 函数不宜过长, 参数不能过多</p><p>已经有很多经典书籍了,没时间,看20条也够用</p><p>编码规范没有单独作为一个模块来讲解,而是放到重构中,重构分为大重构和小重构,小重构利用的知识点基本上就是编码规范</p><h2 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h2><p>软件开发中,只要软件在不停的迭代,就没有一劳永逸的设计,随着需求的变化, 代码的不断堆砌,原有设计必然存在这样那样的问题,针对这些问题,我们需要进行代码重构,重构是软件开发中重要的一环, 持续重构是保证代码质量不下降的有效手段,能避免代码孵化到无可救药的地步</p><p>我们前面讲的面向对象, 设计原则, 设计模式 一个重要的应用场景就是在代码重构的时候, 虽然设计模式可以提高代码的可扩展性,但过度不恰当地使用,也会增加代码地复杂度, 影响代码地可读性, <strong>开发初期特别必须, 我们不要过度设计</strong>,应用复杂地设计模式.而是当代码出现问题时,在针对问题进行重构,避免前期地过度设计</p><ul><li>重构地目的(why), 对象(what), 时机(when), 方法(how) ;</li><li>保证重构不出错地技术手段, :  单元测试和代码的可测试性</li><li>两种不同规模的重构: 大重构(大规模高层次) 和 小重构(小规模低层次)</li></ul><h3 id="五者间的联系"><a href="#五者间的联系" class="headerlink" title="五者间的联系"></a>五者间的联系</h3><ul><li><p>面向对象丰富的特性(继承, 封装, 多态, 抽象)可以实现很多复杂的设计思路, 是很多设计原则, 设计模式等编码实现的基础</p></li><li><p>设计原则是指导我们代码设计的一些经验总结, 对于某些场景下,是否应该应用某种设计模式,具有指导意义. 比如, “开闭原则”是很多设计模式(策略, 模板等)的指导原则</p></li><li><p>设计模式是针对软件开发中经常遇到的设计问题,总结出来的一套解决方案或者设计思想, 主要目的是提高代码的可扩展性. 设计原则比设计模式更抽象, 设计模式更加具体,更加可执行</p></li><li><p>编程方式主要解决的是代码的可读性问题. 它相较于设计原则, 设计模式,更加具体,更加偏重代码细节,更加能落地. 持续的小重构依赖的理论基础主要是编程规范</p></li><li><p>重构作为保持代码质量不下降的有效手段,利用的激素hi面向对象, 设计原则,设计模式,编码规范这些理论</p></li></ul><p>锐评</p><p><em>再好的理论,应用不到实际中也是白费,对于提升代码质量,最有效的是编码规范,其次才是设计原则,再次是代码重构, 最后才是面向对象和设计模式</em></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之美----适配器模式</title>
      <link href="/posts/2193.html"/>
      <url>/posts/2193.html</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式之美—适配器模式"><a href="#设计模式之美—适配器模式" class="headerlink" title="设计模式之美—适配器模式"></a>设计模式之美—适配器模式</h1><p>本文将对责任链模式(职责链模式)分为四个部分进行讲解</p><ul><li>原理</li><li>实现</li><li>应用</li><li>练习</li></ul><p>让大家系统全面的学会使用责任链模式, 并应用到开发中去</p><h2 id="原理篇"><a href="#原理篇" class="headerlink" title="原理篇"></a>原理篇</h2><blockquote><p>一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。</p></blockquote><p><strong>适配器模式</strong>的英文翻译是 <strong>Adapter Design Pattern</strong>, 在GoF的设计模式中的定义如下</p><blockquote><p>Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.</p></blockquote><p>​“将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。”</p><p>​实际上就是将<code>请求</code>通过类似链表的结构, 通过结点处理并线性的传递下去,直到请求完成或者没有下一个结点</p><p>​这里的结点是指单个处理请求的对象, 接受上一个结点处理后的结果并在处理后, 传递给下一个结点或者请求完成结束处理, 因为每个结点都承担着细粒度的职责, 所以称为<code>责任链模式</code></p><h2 id="实现篇"><a href="#实现篇" class="headerlink" title="实现篇"></a>实现篇</h2><p>​</p><p>职责链模式的实现分为三个部分, 分别是目标接口(Target) , 适配器类(Adaptee), 适配器类(Adapter)</p><ul><li><p>目标接口（Target）：当前系统业务所期待的接口，它可以是抽象类或接口</p></li><li><p>适配者类（Adaptee）：它是被访问和适配的现存组件库中的组件接口。</p></li><li><p>适配器类（Adapter）：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</p></li></ul><p>适配器模式有两种实现方式</p><ul><li>类适配器模式</li><li>对象适配器模式</li></ul><p>类适配器使用继承关系进行实现, 对象适配器使用组合关系进行实现如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类适配器: 基于继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">fc</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fa</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fb</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fc</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptor</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.fa();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...重新实现f2()...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对象适配器：基于组合</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">fc</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fa</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fb</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fc</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptor</span> <span class="keyword">implements</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Adaptor</span><span class="params">(Adaptee adaptee)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">    adaptee.fa(); <span class="comment">//委托给Adaptee</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...重新实现f2()...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fc</span><span class="params">()</span> &#123;</span><br><span class="line">    adaptee.fc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如何选择这两种设计模式呢? 判断标准有两个 一种时<strong>Adaptee接口的个数</strong>, 另一个是<strong>Adaptee和Target接口的契合程度</strong></p><ul><li>如果 Adaptee <strong>接口并不多</strong>，那两种实现方式都可以(通常使用对象适配器, 因为<strong>组合优于继承</strong>)</li><li>如果 Adaptee <strong>接口很多</strong>，而且 Adaptee 和 ITarget 接口定义<strong>大部分都相同</strong>，那我们推荐使用<strong>类适配器</strong>，因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方式，Adaptor 的代码量要少一些。</li><li>如果 Adaptee 接口<strong>很多</strong>，而且 Adaptee 和 ITarget 接口定义<strong>大部分都不相同</strong>，那我们推荐使用<strong>对象适配器</strong>，因为组合结构相对于继承更加灵活。</li></ul><h2 id="应用篇"><a href="#应用篇" class="headerlink" title="应用篇"></a>应用篇</h2><p>​适配器模式的原理和实现都讲完了, 都不复杂, 那么我们该在哪些情况下使用适配器模式呢?</p><p>​就如同定义一般, 适配器模式的应用场景其实就是”接口不兼容”, 具体细化可以分为这么5种场景</p><p>​</p><ul><li>封装有缺陷的接口设计</li><li>统一多个类的接口设计</li><li>替换依赖的外部系统</li><li>兼容老版本接口</li><li>适配不同格式的数据</li></ul><h3 id="封装有缺陷的接口设计"><a href="#封装有缺陷的接口设计" class="headerlink" title="封装有缺陷的接口设计"></a>封装有缺陷的接口设计</h3><p>假如我们依赖的外部接口在设计上存在缺陷(大量静态方法, 方法参数过多, 性能低下, 方法名丑陋), 引入后会影响我们自身代码的可维护性, 为了隔离这种设计上的缺陷, 我们希望对提供的接口进行二次封装, 抽象出更好的接口设计, 这里我们可以使用适配器模式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CD</span> &#123; <span class="comment">//这个类来自外部sdk，我们无权修改它的代码</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticFunction1</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uglyNamingFunction2</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tooManyParamsFunction3</span><span class="params">(<span class="type">int</span> paramA, <span class="type">int</span> paramB, ...)</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lowPerformanceFunction4</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用适配器模式进行重构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">function1</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">function2</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">fucntion3</span><span class="params">(ParamsWrapperDefinition paramsWrapper)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">function4</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意：适配器类的命名不一定非得末尾带Adaptor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CDAdaptor</span> <span class="keyword">extends</span> <span class="title class_">CD</span> <span class="keyword">implements</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function1</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="built_in">super</span>.staticFunction1();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.uglyNamingFucntion2();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function3</span><span class="params">(ParamsWrapperDefinition paramsWrapper)</span> &#123;</span><br><span class="line">     <span class="built_in">super</span>.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...reimplement it...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统一多个类的接口设计"><a href="#统一多个类的接口设计" class="headerlink" title="统一多个类的接口设计"></a>统一多个类的接口设计</h3><p>某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。</p><p>假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率，我们引入了<strong>多款第三方敏感词过滤系统</strong>，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感词。但是，<strong>每个系统提供的过滤接口都是不同的</strong>。这就意味着我们没法复用一套逻辑来调用各个系统。这个时候，我们就可以使用适配器模式，将所有系统的接口适配为统一的接口定义，这样我们可以复用调用敏感词过滤的代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ASensitiveWordsFilter</span> &#123; <span class="comment">// A敏感词过滤系统提供的接口</span></span><br><span class="line">  <span class="comment">//text是原始文本，函数输出用***替换敏感词之后的文本</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">filterSexyWords</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">filterPoliticalWords</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BSensitiveWordsFilter</span>  &#123; <span class="comment">// B敏感词过滤系统提供的接口</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">filter</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CSensitiveWordsFilter</span> &#123; <span class="comment">// C敏感词过滤系统提供的接口</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">filter</span><span class="params">(String text, String mask)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 未使用适配器模式之前的代码：代码的可测试性、扩展性不好</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RiskManagement</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">ASensitiveWordsFilter</span> <span class="variable">aFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ASensitiveWordsFilter</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">BSensitiveWordsFilter</span> <span class="variable">bFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BSensitiveWordsFilter</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">CSensitiveWordsFilter</span> <span class="variable">cFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CSensitiveWordsFilter</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">filterSensitiveWords</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">maskedText</span> <span class="operator">=</span> aFilter.filterSexyWords(text);</span><br><span class="line">    maskedText = aFilter.filterPoliticalWords(maskedText);</span><br><span class="line">    maskedText = bFilter.filter(maskedText);</span><br><span class="line">    maskedText = cFilter.filter(maskedText, <span class="string">&quot;***&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> maskedText;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用适配器模式进行改造</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ISensitiveWordsFilter</span> &#123; <span class="comment">// 统一接口定义</span></span><br><span class="line">  String <span class="title function_">filter</span><span class="params">(String text)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ASensitiveWordsFilterAdaptor</span> <span class="keyword">implements</span> <span class="title class_">ISensitiveWordsFilter</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> ASensitiveWordsFilter aFilter;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">filter</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">maskedText</span> <span class="operator">=</span> aFilter.filterSexyWords(text);</span><br><span class="line">    maskedText = aFilter.filterPoliticalWords(maskedText);</span><br><span class="line">    <span class="keyword">return</span> maskedText;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...</span></span><br><span class="line"><span class="comment">// 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，</span></span><br><span class="line"><span class="comment">// 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RiskManagement</span> &#123; </span><br><span class="line">  <span class="keyword">private</span> List&lt;ISensitiveWordsFilter&gt; filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSensitiveWordsFilter</span><span class="params">(ISensitiveWordsFilter filter)</span> &#123;</span><br><span class="line">    filters.add(filter);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">filterSensitiveWords</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">maskedText</span> <span class="operator">=</span> text;</span><br><span class="line">    <span class="keyword">for</span> (ISensitiveWordsFilter filter : filters) &#123;</span><br><span class="line">      maskedText = filter.filter(maskedText);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maskedText;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="替换依赖的外部系统"><a href="#替换依赖的外部系统" class="headerlink" title="替换依赖的外部系统"></a>替换依赖的外部系统</h3><p>当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动。具体的代码示例如下所示</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部系统A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">fa</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fa</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在我们的项目中，外部系统A的使用示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> IA a;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Demo</span><span class="params">(IA a)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.a = a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Demo</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>(<span class="keyword">new</span> <span class="title class_">A</span>());</span><br><span class="line"><span class="comment">// 将外部系统A替换成外部系统B</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BAdaptor</span> implemnts IA &#123;</span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">BAdaptor</span><span class="params">(B b)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.b= b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fa</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    b.fb();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，</span></span><br><span class="line"><span class="comment">// 只需要将BAdaptor如下注入到Demo即可。</span></span><br><span class="line"><span class="type">Demo</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>(<span class="keyword">new</span> <span class="title class_">BAdaptor</span>(<span class="keyword">new</span> <span class="title class_">B</span>()));</span><br></pre></td></tr></table></figure><h3 id="兼容老版本接口"><a href="#兼容老版本接口" class="headerlink" title="兼容老版本接口"></a>兼容老版本接口</h3><p>在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为 deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。这也可以粗略地看作适配器模式的一个应用场景。同样，我还是通过一个例子，来进一步解释一下。</p><p>JDK1.0 中包含一个遍历集合容器的类 Enumeration。JDK2.0 对这个类进行了重构，将它改名为 Iterator 类，并且对它的代码实现做了优化。但是考虑到如果将 Enumeration 直接从 JDK2.0 中删除，那使用 JDK1.0 的项目如果切换到 JDK2.0，代码就会编译不通过。为了避免这种情况的发生，我们必须把项目中所有使用到 Enumeration 的地方，都修改为使用 Iterator 才行。</p><p>单独一个项目做 Enumeration 到 Iterator 的替换，勉强还能接受。但是，使用 Java 开发的项目太多了，一次 JDK 的升级，导致所有的项目不做代码修改就会编译报错，这显然是不合理的。这就是我们经常所说的不兼容升级。为了做到兼容使用低版本 JDK 的老代码，我们可以暂时保留 Enumeration 类，并将其实现替换为直接调用 Itertor。代码示例如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Collections</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Emueration <span class="title function_">emumeration</span><span class="params">(<span class="keyword">final</span> Collection c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Enumeration</span>() &#123;</span><br><span class="line">      <span class="type">Iterator</span> <span class="variable">i</span> <span class="operator">=</span> c.iterator();</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasMoreElments</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i.hashNext();</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">public</span> Object <span class="title function_">nextElement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i.next():</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适配不同格式的数据"><a href="#适配不同格式的数据" class="headerlink" title="适配不同格式的数据"></a>适配不同格式的数据</h3><p>前面我们讲到，适配器模式主要用于接口的适配，实际上，它还可以用在不同格式的数据之间的适配。比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用。再比如，Java 中的 Arrays.asList() 也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stooges = Arrays.asList(<span class="string">&quot;Larry&quot;</span>, <span class="string">&quot;Moe&quot;</span>, <span class="string">&quot;Curly&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="代理、桥接、装饰器、适配器-4-种设计模式的区别"><a href="#代理、桥接、装饰器、适配器-4-种设计模式的区别" class="headerlink" title="代理、桥接、装饰器、适配器 4 种设计模式的区别"></a>代理、桥接、装饰器、适配器 4 种设计模式的区别</h2><p>代理、桥接、装饰器、适配器，这 4 种模式是比较常用的结构型设计模式。它们的代码结构非常相似。笼统来说，它们都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封装原始类。</p><p><strong>代理模式：</strong>代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。</p><p><strong>桥接模式：</strong>桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。</p><p><strong>装饰器模式：</strong>装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。</p><p><strong>适配器模式：</strong>适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。</p><h2 id="练习篇"><a href="#练习篇" class="headerlink" title="练习篇"></a>练习篇</h2><p>以OSS服务为例</p><p>OSS服务提供方可能是阿里云OOS, 京东云OSS, 腾讯云OSS这样的第三方服务, 也可以是自建的Minio对象存储服务</p><p>但无论是第三方提供的OSS服务还是MinioOSS, 服务jar包对外提供服务的接口大不相同</p><p>而随着我们业务的发展, 第三方服务提供方可能产生变化</p><p>为此, 我们不能将第三方服务提供的接口直接耦合进代码中</p><p>合适的方式是我们自定义出一个需求接口(Target), 通过适配器模式</p><p>将不同服务提供方提供的接口(Adaptee)适配到我们的需求接口(Target)中</p><p>这样我们的Service层就可以只与需求接口(Target)耦合, 即使第三方服务提供商发生变化, 我们只需要切换相应的代理类即可</p><p>Service层的逻辑不需要发生改动</p><p>此处(Service与代理类是组合关系, 代理类提供更细粒度的OSS功能)</p><hr><p>参考:  </p><p> <a href="https://time.geekbang.org/column/intro/100039001">设计模式之美 (geekbang.org)</a></p><p>[重学 Java 设计模式：实战责任链模式「模拟618电商大促期间，项目上线流程多级负责人审批场景」 | 小傅哥 bugstack 虫洞栈](</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 设计模式之美 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计原则与思想</title>
      <link href="/posts/65361.html"/>
      <url>/posts/65361.html</url>
      
        <content type="html"><![CDATA[<h1 id="设计原则与思想-面向对象"><a href="#设计原则与思想-面向对象" class="headerlink" title="设计原则与思想: 面向对象"></a>设计原则与思想: 面向对象</h1><h1 id="我们在讨论面向对象的时候-我们到底在谈论什么"><a href="#我们在讨论面向对象的时候-我们到底在谈论什么" class="headerlink" title="我们在讨论面向对象的时候,我们到底在谈论什么?"></a>我们在讨论面向对象的时候,我们到底在谈论什么?</h1><h2 id="什么是面向对象编程和面向对象编程语言"><a href="#什么是面向对象编程和面向对象编程语言" class="headerlink" title="什么是面向对象编程和面向对象编程语言?"></a>什么是面向对象编程和面向对象编程语言?</h2><ul><li>面向对象编程是一种编程范式或编程风格, 它以类或对象作为组织代码的基本单元, 并将封装, 抽象, 继承, 多态四个特性,作为代码设计和实现的基石</li><li>面向对象编程语言是支持类或对象的语法机制, 并由现成的语法机制,能方便地实现面向对象编程四大特性(封装, 抽象, 继承, 多态)的编程语言</li></ul><h2 id="面向对象语言和面向对象编程语言之间地关系"><a href="#面向对象语言和面向对象编程语言之间地关系" class="headerlink" title="面向对象语言和面向对象编程语言之间地关系"></a>面向对象语言和面向对象编程语言之间地关系</h2><ul><li><p>面向过程语言也可以实现面向对象编程</p></li><li><p>面向对象语言也会写出面向过程编程</p></li></ul><h2 id="如何判定一个编程语言是否面向对象编程语言"><a href="#如何判定一个编程语言是否面向对象编程语言" class="headerlink" title="如何判定一个编程语言是否面向对象编程语言"></a>如何判定一个编程语言是否面向对象编程语言</h2><p>并没有严格地定义,面向对象语言要求宽泛,并不一定要求具有所有的四大特性, 只要某种编程语言支持类, 对象语法机制,那几本上就可以说这种编程语言是面向对象编程语言了</p><h2 id="什么是面向对象分析和面向对象设计"><a href="#什么是面向对象分析和面向对象设计" class="headerlink" title="什么是面向对象分析和面向对象设计?"></a>什么是面向对象分析和面向对象设计?</h2><p>OOA, OOD, OOP 软件开发流程</p><p>面向对象分析就是搞清楚做什么, 面向对象设计就是搞清楚怎么做,. 两个阶段地产出就是类的设计,包括程序被拆解为哪些类, 每个类有哪些属性方法,类与类之间如何交互等等</p><h1 id="封装-抽象-继承-多态可以解决哪些编程问题"><a href="#封装-抽象-继承-多态可以解决哪些编程问题" class="headerlink" title="封装, 抽象, 继承,多态可以解决哪些编程问题?]"></a>封装, 抽象, 继承,多态可以解决哪些编程问题?]</h1><h2 id="封装特性"><a href="#封装特性" class="headerlink" title="封装特性"></a>封装特性</h2><p>封装也叫信息隐藏或者数据访问保护. 类通过暴露有限的访问接口,授权外部仅能通过类提供的范式来访问内部信息或者数据.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wallet</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> createTime;</span><br><span class="line">  <span class="keyword">private</span> BigDecimal balance;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> balanceLastModifiedTime;</span><br><span class="line">  <span class="comment">// ...省略其他属性...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Wallet</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.id = IdGenerator.getInstance().generate();</span><br><span class="line">     <span class="built_in">this</span>.createTime = System.currentTimeMillis();</span><br><span class="line">     <span class="built_in">this</span>.balance = BigDecimal.ZERO;</span><br><span class="line">     <span class="built_in">this</span>.balanceLastModifiedTime = System.currentTimeMillis();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意：下面对get方法做了代码折叠，是为了减少代码所占文章的篇幅</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.id; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCreateTime</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.createTime; &#125;</span><br><span class="line">  <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.balance; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getBalanceLastModifiedTime</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.balanceLastModifiedTime;  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increaseBalance</span><span class="params">(BigDecimal increasedAmount)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (increasedAmount.compareTo(BigDecimal.ZERO) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidAmountException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.balance.add(increasedAmount);</span><br><span class="line">    <span class="built_in">this</span>.balanceLastModifiedTime = System.currentTimeMillis();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decreaseBalance</span><span class="params">(BigDecimal decreasedAmount)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (decreasedAmount.compareTo(BigDecimal.ZERO) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidAmountException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (decreasedAmount.compareTo(<span class="built_in">this</span>.balance) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientAmountException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.balance.subtract(decreasedAmount);</span><br><span class="line">    <span class="built_in">this</span>.balanceLastModifiedTime = System.currentTimeMillis();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它需要编程语言提供权限访问控制语法来支持, 例如Java中的public protected, public 关键字</p><p>封装: </p><ul><li>保护数据不被随意修改 ,提高代码的可维护性</li><li>仅暴露有限的必要接口,提高类的易用性(不需要调用者了解过多的细节) 冰箱的按钮多少,出错的概率</li></ul><h2 id="抽象特性"><a href="#抽象特性" class="headerlink" title="抽象特性"></a>抽象特性</h2><p>抽象讲解如何隐藏方法的具体实现, 让使用者只需要关心方法提供了哪些功能, 不需要知道这些功能如何实现.</p><p>抽象通过接口类或者抽象类来实现, 但也不需要特殊的语法机制来支持,命名时也要有抽象思维,getAliyunPicture()    —- &gt;    getPicture()</p><p>抽象存在的意义: </p><ul><li>提高代码的可扩展性,维护性,修改实现不需要改变定义,减少代码改动的范围</li><li>处理复杂系统的有效手段,能有效过滤不必关注的信息</li></ul><h2 id="继承特性"><a href="#继承特性" class="headerlink" title="继承特性"></a>继承特性</h2><p>继承用来表示类之间的is-a关系,分为两种模式</p><ul><li>单继承</li><li>多继承</li></ul><p>为了实现继承这个特性,编程语言需要提供特殊的语法机制来支持</p><p>继承存在的意义:</p><ul><li>继承主要用来解决代码复用的问题(也可以用组合来实现),特定情况下用继承的is-关系非常符合人类的思维方式,从设计来说也有一种设计美感</li></ul><p>​过度使用继承时错误的,例如在阅读代码时过多层次会增加代码阅读负担, 同时继承的复用会导致子类和父类耦合过高,继承特性很受争议</p><h2 id="多态特性"><a href="#多态特性" class="headerlink" title="多态特性"></a>多态特性</h2><p>三个语法机制实现多态</p><ul><li>语法要支持父类引用可以引用子类对象</li><li>语法要支持继承</li><li>语法要支持子类重写父类方法</li></ul><p>除了”继承加方法重写”还有接口类语法 ,  duck-typing语法(动态语言支持)</p><p>接口类语法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">  String <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">  String <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Array</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String[] data;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">remove</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">  <span class="comment">//...省略其他方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> LinkedListNode head;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">remove</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">  <span class="comment">//...省略其他方法... </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Iterator iterator)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">      System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">arrayIterator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    print(arrayIterator);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">linkedListIterator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">    print(linkedListIterator);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>duck-typing</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">record</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(“I write a log into file.”)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DB</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">record</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(“I insert data into db. ”)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">recorder</span>):</span><br><span class="line">    recorder.record()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo</span>():</span><br><span class="line">    logger = Logger()</span><br><span class="line">    db = DB()</span><br><span class="line">    test(logger)</span><br><span class="line">    test(db)</span><br></pre></td></tr></table></figure><p>多态的意义:</p><ul><li>提高代码扩展性和复用性,很多设计模式, 设计原则, 编程技巧的代码实现基础</li></ul><h1 id="面向对象相比面向过程有哪些优势-面向过程真的过时了吗"><a href="#面向对象相比面向过程有哪些优势-面向过程真的过时了吗" class="headerlink" title="面向对象相比面向过程有哪些优势? 面向过程真的过时了吗?"></a>面向对象相比面向过程有哪些优势? 面向过程真的过时了吗?</h1><p>总有人拿面向对象语言写面向过程风格的代码</p><h2 id="什么是面向过程编程与面向过程编程语言"><a href="#什么是面向过程编程与面向过程编程语言" class="headerlink" title="什么是面向过程编程与面向过程编程语言?"></a>什么是面向过程编程与面向过程编程语言?</h2><p>面向对象定义</p><ul><li>面向对象过程编程是一种编程范式, 是以类和对象作为基本单元, 以封装, 抽象, 继承,多态为基石来设计和实现代码</li><li>面向对象编程语言是支持类和对象的语法机制,并有现成的语法机制, 能方便地实现面向对象编程地四大特性地编程语言</li></ul><p>面向过程定义</p><ul><li>面向过程编程也是一种编程范式,它以过程(方法, 函数, 操作)作为组织代码的基本单元, 以数据(成员变量, 属性)与方法相分离为最主要的特点.面向过程风格是一种流程化的编程风格,通过拼接一组顺序执行的方法来操作数据完成一项功能</li><li>面向过程编程语言,最大特点是不支持类和对象两个语法概念,不支持丰富的面向对象的编程特性,仅支持面向过程编程</li></ul><p>假设我们有一个记录了用户信息的文本文件users.txt,每行文本的格式是name&amp;age&amp;gender(比如，小王&amp;28&amp;男)。我们希望写一个程序，从users..txt文件中逐行读取用户信息，然后格式化成<br>name\tage\tgender(其中，\t是分隔符)这种文本格式，并且按照age从小到大排序之后，<br>重新写入到另一个文本文件formatted_.users..txt中,</p><p> 用面向过程和面向对象两种编程风格，编写出来的代码有什么不同。</p><p>面向过程</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">char</span> gender[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> User <span class="title function_">parse_to_user</span><span class="params">(<span class="type">char</span>* text)</span> &#123;</span><br><span class="line">  <span class="comment">// 将text(“小王&amp;28&amp;男”)解析成结构体struct User</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">format_to_text</span><span class="params">(<span class="keyword">struct</span> User user)</span> &#123;</span><br><span class="line">  <span class="comment">// 将结构体struct User格式化成文本（&quot;小王\t28\t男&quot;）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort_users_by_age</span><span class="params">(<span class="keyword">struct</span> User users[])</span> &#123;</span><br><span class="line">  <span class="comment">// 按照年龄从小到大排序users</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">format_user_file</span><span class="params">(<span class="type">char</span>* origin_file_path, <span class="type">char</span>* new_file_path)</span> &#123;</span><br><span class="line">  <span class="comment">// open files...</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">User</span> <span class="title">users</span>[1024];</span> <span class="comment">// 假设最大1024个用户</span></span><br><span class="line">  <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123; <span class="comment">// read until the file is empty</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">User</span> <span class="title">user</span> =</span> parse_to_user(line);</span><br><span class="line">    users[count++] = user;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  sort_users_by_age(users);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">    <span class="type">char</span>* formatted_user_text = format_to_text(users[i]);</span><br><span class="line">    <span class="comment">// write to new file...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// close files...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">char</span>** args, <span class="type">int</span> argv)</span> &#123;</span><br><span class="line">  format_user_file(<span class="string">&quot;/home/zheng/user.txt&quot;</span>, <span class="string">&quot;/home/zheng/formatted_users.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>面向对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> String gender;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age, String gender)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.gender = gender;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> User <span class="title function_">praseFrom</span><span class="params">(String userInfoText)</span> &#123;</span><br><span class="line">    <span class="comment">// 将text(“小王&amp;28&amp;男”)解析成类User</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">formatToText</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 将类User格式化成文本（&quot;小王\t28\t男&quot;）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserFileFormatter</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">format</span><span class="params">(String userFile, String formattedUserFile)</span> &#123;</span><br><span class="line">    <span class="comment">// Open files...</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">users</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">// read until file is empty </span></span><br><span class="line">      <span class="comment">// read from file into userText...</span></span><br><span class="line">      <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> User.parseFrom(userText);</span><br><span class="line">      users.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// sort users by age...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; users.size(); ++i) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">formattedUserText</span> <span class="operator">=</span> user.formatToText();</span><br><span class="line">      <span class="comment">// write to new file...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// close files...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">UserFileFormatter</span> <span class="variable">userFileFormatter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserFileFormatter</span>();</span><br><span class="line">    userFileFormatter.format(<span class="string">&quot;/home/zheng/users.txt&quot;</span>, <span class="string">&quot;/home/zheng/formatted_users.txt&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面向对象编程相比面向过程编程有哪些优势"><a href="#面向对象编程相比面向过程编程有哪些优势" class="headerlink" title="面向对象编程相比面向过程编程有哪些优势"></a>面向对象编程相比面向过程编程有哪些优势</h2><ul><li><p>对于大规模程序的开发,程序的处理流程并非单一主线, 而是错综复杂的玩转结构.面向对象编程比起面向过程编程,更能应对这种复杂类型的程序开发</p></li><li><p>面向对象编程丰富的特性.利用这些特性编写出来的代码,更易扩展,易维护,易复用</p></li><li><p>编程语言和机器打交道的方式的演进规律中,我们可以总结出: 面向对象编程语言比面向过程编程语言,更加人性化,更加高级,更加智能</p></li></ul><h1 id="哪些代码设计看似是面向对象-实际是面向过程的"><a href="#哪些代码设计看似是面向对象-实际是面向过程的" class="headerlink" title="哪些代码设计看似是面向对象,实际是面向过程的?"></a>哪些代码设计看似是面向对象,实际是面向过程的?</h1><h2 id="滥用getter-setter方法"><a href="#滥用getter-setter方法" class="headerlink" title="滥用getter,setter方法"></a>滥用<code>getter</code>,<code>setter</code>方法</h2><p>​违反封装特性,将面向对象编程风格退化为面向过程编程风格</p><p><strong>在设计类时尽量不要给属性定义setter方法, 除此之外,尽管getter方法相对于setter方法要安全,但是如果返回的是集合容器,也要防范集合内部数据被修改的危险</strong></p><h2 id="滥用全局变量-Constants-和全局方法-Utils"><a href="#滥用全局变量-Constants-和全局方法-Utils" class="headerlink" title="滥用全局变量(Constants)和全局方法(Utils)"></a>滥用全局变量(Constants)和全局方法(Utils)</h2><p>将数据和操作分离, 不是面向对象,但也有一定好处</p><h3 id="Utils改进策略"><a href="#Utils改进策略" class="headerlink" title="Utils改进策略"></a><code>Utils</code>改进策略</h3><p>​判定表标准:  在定义<code>Utils</code>类之前, 你要问一下自己,:</p><ul><li><p>**你真的需要单独定义这样一个<code>Utils</code>类吗? **</p></li><li><p><strong>是否可以把<code>Utils</code>类中地某些方法定义到其它类中呢?</strong></p></li></ul><p>​回答完这些问题,你还是觉得确实有必要去定义这样一个<code>Utils</code>类, 那么<strong>大胆地去定义它吧(不要为了面向对象, 随意抽象一个父类)</strong> ,因为在面向对象编程中, 我们也并不是完全排斥面向过程风格的代码.  只要能为我们写好代码,贡献力量,我们就可以适度地去使用  </p><h3 id="Constants改进策略"><a href="#Constants改进策略" class="headerlink" title="Constants改进策略"></a>Constants改进策略</h3><p>​当<code>Constants</code>类中包含很多常量定义的时候,依赖这个类的代码就会很多, 每次修改Constants类,都会导致依赖它的类文件重新编译,因此会浪费很多不必要的编译时间, 对于一个非常大的工程项目,编译一次救药花费几分钟,甚至几十分钟, 每次进行单元测试都会出发一次编译的过程,编译过程会影响我们的开发效率</p><p>改进<code>Constants</code>类 两种思路: </p><ul><li>将<code>Constants</code>拆分为功能更加单一的多个类</li><li>不单独设计<code>Constants</code>常量类,而是哪个类用到了某个常量,将常量定义到这个类中(让我想到了注解)</li></ul><p>​<strong><code>Constants</code>类, <code>Utils</code>类的设计问题</strong>, 对于这两种类的设计, 我们尽量能做到职责单一,定义一些细化到的类, 比如有<code>RedisConstatns</code>, <code>FileUtils</code>, 而不是定义一个大而全的<code>Constants</code>类, <code>Utils</code>类. 除此之外,如果能将这些类中的属性和方法, 划分归并到其他业务中,  那是最好不过的了, 能极大地提高类的内举行和代码地可复用性</p><h2 id="定义数据和方法分离的类"><a href="#定义数据和方法分离的类" class="headerlink" title="定义数据和方法分离的类"></a>定义数据和方法分离的类</h2><pre><code>     传统`MVC`结构分为`Model`层, `Controller`层, `View`层这三层</code></pre><p>​逻辑上分为 <code>Controller</code>层, <code>Service</code>层, <code>Repository</code>层</p><p>​数据上定义<code>VO</code>(View Object) <code>BO</code>(Business Object)  <code>Entity</code></p><p>这是典型的面向过程的编程风格</p><p>​这种开发模式叫做基于<code>贫血模型</code>的开发模型, 是我们现在非常常用的一种Web项目的开发模式.(日后会讲)</p><p>​面向对象编程比面向过程编程难一些,不经意就写成面向过程了</p><p>​我们在写一些微小程序时,或者一个数据处理相关的代码, 以算法为主, 数据为辅, 脚本是的面向过程编码风格就更加适合一些,而且面向过程本身就是面向对象的基础, 面向对象编程离不开基础的面向过程编程.</p><p>​不管使用面向对象还是面向过程哪种风格来写代码, 我们最终的目的还是写出易维护, 易读, 易复用, 易扩展的高质量代码. 只要能控制面向过程编程风格的一些弊端, 控制好它的副作用, 在掌握范围内为我们所用, 我们大可不避讳在面向对象编程中写面向过程风格的代码</p><p>优秀评论(笑死看不懂)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.用she实现自动化脚本做的服务编排，一般都是面向过程，一步一步的。而k8s的编排却是</span><br><span class="line">面向对象的，因为它为这个顺序流抽象出了很多角色，将原本一步一步的顺序操作转变成了多</span><br><span class="line">个角色间的轮转和交互。</span><br><span class="line">2.从接触ddd才走出javaer举面向对象旗，干面向过程勾当的局面。所谓为什么“充血模型”不流</span><br><span class="line">行，我认为不外呼两个。一，规范的领域模型对于底层基础架构来说并不友好（缺少stge</span><br><span class="line">t)，所以会导致规范的领域模型与现有基础架构不贴合，切很难开发出完全贴合的基础架</span><br><span class="line">构，进而引深出，合理的业务封装却阻碍关于复用通用抽象的矛盾。二，合理的业务封装，需</span><br><span class="line">要在战略上对业务先做合理的归类分割和抽象。而这个前置条件很少也不好达成。进而缺少前</span><br><span class="line">置设计封装出来的“充血模型”会有种四不像的味道，反而加剧了业务的复杂性，还不如“贫血</span><br><span class="line">模型”来得实用。事实上快节奏下，前置战略设计往往都是不足的，所以想构建优秀的“充血模</span><br><span class="line">型”架构，除了要对业务领域和领域设计有足够的认知，在重构手法和重构意愿上还要有一定</span><br><span class="line">讲究和追求，这样才能让项目以“充血模型”持续且良性的迭代。</span><br><span class="line">3.“充血模型”相对于“贫血模型”有什么好处？从我的经验来看，可读性其实可能“贫血模型”还好</span><br><span class="line">一点，这也可能有思维惯性的原因在里面。但从灵活和扩展性来说“充血模型”会优秀很多，因</span><br><span class="line">为好的“充血模型&quot;”往往意味着边界清晰（耦合低），功能内敛（高内聚）。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="接口vs抽象类的区别-如何用普通的类模拟抽象类和接口"><a href="#接口vs抽象类的区别-如何用普通的类模拟抽象类和接口" class="headerlink" title="接口vs抽象类的区别? 如何用普通的类模拟抽象类和接口?"></a>接口vs抽象类的区别? 如何用普通的类模拟抽象类和接口?</h1><p>C++不支持抽象类, python不支持抽象类也不支持接口</p><h3 id="什么是抽象类和接口-区别在哪里"><a href="#什么是抽象类和接口-区别在哪里" class="headerlink" title="什么是抽象类和接口? 区别在哪里?"></a>什么是抽象类和接口? 区别在哪里?</h3><p>典型的抽象类的使用场景(模板设计模式)</p><p>​<code>Logger</code>是一个记录日志的抽象类,<code>FileLogger</code>和<code>MessageQueueLogger</code>继承<code>Logger</code>, 分别实现两种不同的日志记录方式:  记录日志到文件中和记录日志到消息队列中.</p><p>​<code>FileLogger</code>和<code>MessageQueueLogger</code>两个子类服用了父类<code>Logger</code>中的<code>name</code>, <code>enabled</code>, <code>minPermittedLevel</code>属性和<code>log()</code>方法, 但因为这两个子类写日志的方式不同, 它们又各自重写了父类中的<code>doLog()</code>方法</p><p>抽象类:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> enabled;</span><br><span class="line">  <span class="keyword">private</span> Level minPermittedLevel;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Logger</span><span class="params">(String name, <span class="type">boolean</span> enabled, Level minPermittedLevel)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.enabled = enabled;</span><br><span class="line">    <span class="built_in">this</span>.minPermittedLevel = minPermittedLevel;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String message)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">loggable</span> <span class="operator">=</span> enabled &amp;&amp; (minPermittedLevel.intValue() &lt;= level.intValue());</span><br><span class="line">    <span class="keyword">if</span> (!loggable) <span class="keyword">return</span>;</span><br><span class="line">    doLog(level, message);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doLog</span><span class="params">(Level level, String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象类的子类：输出日志到文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Writer fileWriter;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">FileLogger</span><span class="params">(String name, <span class="type">boolean</span> enabled,</span></span><br><span class="line"><span class="params">    Level minPermittedLevel, String filepath)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, enabled, minPermittedLevel);</span><br><span class="line">    <span class="built_in">this</span>.fileWriter = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(filepath); </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doLog</span><span class="params">(Level level, String mesage)</span> &#123;</span><br><span class="line">    <span class="comment">// 格式化level和message,输出到日志文件</span></span><br><span class="line">    fileWriter.write(...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象类的子类: 输出日志到消息中间件(比如kafka)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageQueueLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> MessageQueueClient msgQueueClient;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MessageQueueLogger</span><span class="params">(String name, <span class="type">boolean</span> enabled,</span></span><br><span class="line"><span class="params">    Level minPermittedLevel, MessageQueueClient msgQueueClient)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, enabled, minPermittedLevel);</span><br><span class="line">    <span class="built_in">this</span>.msgQueueClient = msgQueueClient;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doLog</span><span class="params">(Level level, String mesage)</span> &#123;</span><br><span class="line">    <span class="comment">// 格式化level和message,输出到消息中间件</span></span><br><span class="line">    msgQueueClient.send(...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义接口:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口实现类：鉴权过滤器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthencationFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">    <span class="comment">//...鉴权逻辑..</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口实现类：限流过滤器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimitFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">    <span class="comment">//...限流逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 过滤器使用Demo</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">  <span class="comment">// filters.add(new AuthencationFilter());</span></span><br><span class="line">  <span class="comment">// filters.add(new RateLimitFilter());</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;Filter&gt; filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRpcRequest</span><span class="params">(RpcRequest req)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (Filter filter : filters) &#123;</span><br><span class="line">        filter.doFilter(req);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(RpcException e) &#123;</span><br><span class="line">      <span class="comment">// ...处理过滤结果...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...省略其他处理逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​抽象类实际就是类, 只不过是一种特殊的类,这种类不能被实例化对象, 只能被子类继承. 继承关系是一种<code>is-a</code>关系来说, 接口表示一种 <code>has-a</code>关系, 表示具有某些功能, 对于接口, 有一种更加抽象的叫法,那就是协议(contract).</p><h3 id="抽象类和接口能解决什么编程问题"><a href="#抽象类和接口能解决什么编程问题" class="headerlink" title="抽象类和接口能解决什么编程问题?"></a>抽象类和接口能解决什么编程问题?</h3><p>抽象类是为了代码复用而生的</p><p>但普通类也可以实现代码复用, 那么抽象类有什么独特作用吗?</p><p>抽象类是 <code>is-a</code> </p><p>接口时 <code>has-a</code></p><p>我们还是拿之前那个打印日志的例子来讲解。我们先对上面的代码做下改造。在改造之后的代<br>码中，<code>Logger</code>不再是抽象类，只是一个普通的父类，删除了<code>Logger</code>中<code>log()</code>、<code>doLog()</code>方法，<br>新增了<code>isLoggablet()</code>方法。<code>FileLogger</code>和<code>MessageQueueLogger</code>还是继承<code>Logger</code>父类，以达<br>到代码复用的目的。具体的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类：非抽象类，就是普通的类. 删除了log(),doLog()，新增了isLoggable().</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> enabled;</span><br><span class="line">  <span class="keyword">private</span> Level minPermittedLevel;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Logger</span><span class="params">(String name, <span class="type">boolean</span> enabled, Level minPermittedLevel)</span> &#123;</span><br><span class="line">    <span class="comment">//...构造函数不变，代码省略...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isLoggable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">loggable</span> <span class="operator">=</span> enabled &amp;&amp; (minPermittedLevel.intValue() &lt;= level.intValue());</span><br><span class="line">    <span class="keyword">return</span> loggable;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类：输出日志到文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Writer fileWriter;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">FileLogger</span><span class="params">(String name, <span class="type">boolean</span> enabled,</span></span><br><span class="line"><span class="params">    Level minPermittedLevel, String filepath)</span> &#123;</span><br><span class="line">    <span class="comment">//...构造函数不变，代码省略...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String mesage)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isLoggable()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 格式化level和message,输出到日志文件</span></span><br><span class="line">    fileWriter.write(...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类: 输出日志到消息中间件(比如kafka)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageQueueLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> MessageQueueClient msgQueueClient;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MessageQueueLogger</span><span class="params">(String name, <span class="type">boolean</span> enabled,</span></span><br><span class="line"><span class="params">    Level minPermittedLevel, MessageQueueClient msgQueueClient)</span> &#123;</span><br><span class="line">    <span class="comment">//...构造函数不变，代码省略...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String mesage)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isLoggable()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 格式化level和message,输出到消息中间件</span></span><br><span class="line">    msgQueueClient.send(...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个设计思路虽然达到了代码复用的目的，但是无法使用多态特性了。像下面这样编写代码，<br>就会出现编译错误，因为<code>Logger</code>中并没有定义<code>log()</code>方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileLogger</span>(<span class="string">&quot;access-log&quot;</span>, <span class="literal">true</span>, Level.WARN, <span class="string">&quot;/users/wangzheng/access.log&quot;</span>);</span><br><span class="line">logger.log(Level.ERROR, <span class="string">&quot;This is a test log message.&quot;</span>);</span><br></pre></td></tr></table></figure><p>你可能会说，这个问题解决起来很简单啊。我们在Logger父类中，定义一个空的<code>Iog()</code>方法，<br>让子类重写父类的<code>1og ()</code>方法，实现自己的记录日志的逻辑，不就可以了吗？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="comment">// ...省略部分代码...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String mesage)</span> &#123; <span class="comment">// do nothing... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="comment">// ...省略部分代码...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String mesage)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isLoggable()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 格式化level和message,输出到日志文件</span></span><br><span class="line">    fileWriter.write(...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageQueueLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="comment">// ...省略部分代码...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String mesage)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isLoggable()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 格式化level和message,输出到消息中间件</span></span><br><span class="line">    msgQueueClient.send(...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但它显然没有之前抽象类的实现思路优雅</p><ul><li>Logger中定义一个空的方法,可读性差</li><li>当创建一个新的子类继承Logger父类的时候, 我们又可能会忘记重新实现log()方法,之前的抽象类会强制子类重写<code>log()</code>方法</li><li>Logger可以被实例化,增加类被误用的风险</li></ul><p>其他语言即使不支持接口特性, 也可以模拟接口</p><h1 id="为什么基于接口而非实现编程-有必要为每个类都定义接口吗"><a href="#为什么基于接口而非实现编程-有必要为每个类都定义接口吗" class="headerlink" title="为什么基于接口而非实现编程? 有必要为每个类都定义接口吗?"></a>为什么基于接口而非实现编程? 有必要为每个类都定义接口吗?</h1>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 设计模式之美 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针问题</title>
      <link href="/posts/33830.html"/>
      <url>/posts/33830.html</url>
      
        <content type="html"><![CDATA[<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h4 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h4><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong>。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><br><span class="line">int len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2]</span><br><span class="line">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3]</span><br><span class="line">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 100</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//快指针寻找新数组中的元素，慢指针g</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">       <span class="keyword">while</span> (fast != nums.length) &#123;</span><br><span class="line">           <span class="keyword">if</span> (nums[fast] != val) &#123;</span><br><span class="line">               nums[slow++] = nums[fast]; </span><br><span class="line">           &#125;</span><br><span class="line">           fast++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h4><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/#">思路</a></p><p>难度简单733</p><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br><span class="line">解释：平方后，数组变为 [16,1,0,9,100]</span><br><span class="line">排序后，数组变为 [0,1,9,16,100]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按 <strong>非递减顺序</strong> 排序</li></ul><p><strong>进阶：</strong></p><ul><li>请你设计时间复杂度为 <code>O(n)</code> 的算法解决本问题</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> result[] = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j &amp;&amp; cur &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] * nums[i] &gt;= nums[j] * nums[j]) &#123;</span><br><span class="line">                result[cur--] = nums[i] * nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result[cur--] = nums[j] * nums[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">line</span> <span class="operator">=</span> <span class="number">0</span>, column = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">boundary</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">stopValue</span> <span class="operator">=</span> n * n;</span><br><span class="line">        <span class="type">int</span>[][] matrix = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];  </span><br><span class="line">        <span class="keyword">while</span> (value &lt; stopValue) &#123;</span><br><span class="line">            <span class="keyword">for</span> (; column &lt; boundary - <span class="number">1</span>; column++) &#123;</span><br><span class="line">                matrix[line][column] = value;</span><br><span class="line">                value++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (; line &lt; boundary - <span class="number">1</span>; line++) &#123;</span><br><span class="line">                matrix[line][column] = value;</span><br><span class="line">                value++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (; column &gt; n - boundary; column--) &#123;</span><br><span class="line">                matrix[line][column] = value;</span><br><span class="line">                value++; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (; line &gt; n - boundary; line--) &#123;</span><br><span class="line">                matrix[line][column] = value;</span><br><span class="line">                value++;</span><br><span class="line">            &#125;</span><br><span class="line">            column++;</span><br><span class="line">            line++;</span><br><span class="line">            boundary--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) matrix[line][column] = value;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></h4><p>难度简单1174</p><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [], val = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [7,7,7,7], val = 7</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>列表中的节点数目在范围 <code>[0, 104]</code> 内</li><li><code>1 &lt;= Node.val &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 50</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>,head);</span><br><span class="line">        <span class="type">ListNode</span>  <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.next.val == val) &#123;</span><br><span class="line"></span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h4><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/#">思路</a></p><p>难度中等1733</p><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 100</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">null</span> != cur.next &amp;&amp; <span class="literal">null</span> != cur.next.next) &#123;</span><br><span class="line">            slow = cur.next;</span><br><span class="line">            fast = slow.next;</span><br><span class="line">            slow.next = fast.next;</span><br><span class="line">            fast.next = slow;</span><br><span class="line">            cur.next = fast;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯暴搜-排列组合问题全解</title>
      <link href="/posts/53015.html"/>
      <url>/posts/53015.html</url>
      
        <content type="html"><![CDATA[<h2 id="回溯算法模板"><a href="#回溯算法模板" class="headerlink" title="回溯算法模板"></a>回溯算法模板</h2><p>回溯算法和DFS很像, 本质都是是一种暴力枚举算法, 不过回溯算法是遍历树枝, DFS是在遍历结点</p><p>回溯问题需要思考如下三个问题</p><ul><li>路径: 做出的选择</li><li>选择列表: 当前可以做的选择</li><li>结束条件: 到达决策底层无需或者无法进一步选择</li></ul><p>伪代码模板(python)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">路径, 选择列表</span>):</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><p>本质上就是对一棵递归树进行选择和撤回,在合适的位置(前序和后续)进行选择和记录</p><p>以下是全排列代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 记录「路径」</span></span><br><span class="line">        LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 「路径」中的元素会被标记为 true，避免重复使用</span></span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        </span><br><span class="line">        backtrack(nums, track, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 路径：记录在 track 中</span></span><br><span class="line">    <span class="comment">// 选择列表：nums 中不存在于 track 的那些元素（used[i] 为 false）</span></span><br><span class="line">    <span class="comment">// 结束条件：nums 中的元素全都在 track 中出现</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, LinkedList&lt;Integer&gt; track, <span class="type">boolean</span>[] used)</span> &#123;</span><br><span class="line">        <span class="comment">// 触发结束条件</span></span><br><span class="line">        <span class="keyword">if</span> (track.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>(track));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 排除不合法的选择</span></span><br><span class="line">            <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">                <span class="comment">// nums[i] 已经在 track 中，跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            track.add(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 进入下一层决策树</span></span><br><span class="line">            backtrack(nums, track, used);</span><br><span class="line">            <span class="comment">// 取消选择</span></span><br><span class="line">            track.removeLast();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="排列组合的基本情况"><a href="#排列组合的基本情况" class="headerlink" title="排列组合的基本情况"></a>排列组合的基本情况</h2><p>关键是如何在合适位置怎样的进行剪枝和记录</p><p>类似我们可以将问题分类成三类</p><ul><li><p>子集</p></li><li><p>组合</p></li><li><p>排列</p></li></ul><p>按照给出数组是否可选元素是否可以复选又可以分为三类</p><ul><li>元素无重不可复选</li><li>元素可重不可复选</li><li>元素无重可复选</li></ul><p>元素可重复可选其实就是无重可复选</p><p>比如输入 <code>nums = [1,2,3]</code>，算法应该返回如下子集：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ [],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3] ]</span><br></pre></td></tr></table></figure><p>子集问题是对每次选择进行记录所以在遍历决策树的前序位置将路径添加到结果集中</p><p><strong>我们通过保证元素之间的相对顺序不变来防止出现重复的子集</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 记录回溯算法的递归路径</span></span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主函数</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        backtrack(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯算法核心函数，遍历子集问题的回溯树</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序位置，每个节点的值都是一个子集</span></span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(track));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回溯算法标准框架</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            track.addLast(nums[i]);</span><br><span class="line">            <span class="comment">// 通过 start 参数控制树枝的遍历，避免产生重复的子集</span></span><br><span class="line">            backtrack(nums, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            track.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>组合问题</p><p><strong>组合就是对应长度的子集</strong></p><p>实际上就是在子集问题的基础上加一层判断,只有当子集中元素的个数等于组合数的长度时才记录</p><p>比如我们要组合 <code>nums = [1,2,3]</code>中的两个数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ [1,2],[1,3],[2,3] ]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 记录回溯算法的递归路径</span></span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主函数</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        backtrack(<span class="number">1</span>, n, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (k == track.size()) &#123;</span><br><span class="line">            <span class="comment">// 遍历到了第 k 层，收集当前节点的值</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(track));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回溯算法标准框架</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 选择</span></span><br><span class="line">            track.addLast(i);</span><br><span class="line">            <span class="comment">// 通过 start 参数控制树枝的遍历，避免产生重复的子集</span></span><br><span class="line">            backtrack(i + <span class="number">1</span>, n, k);</span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            track.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从最简单的子集问题推广到需要加判断条件和start的组合问题以及加判断条件和used数组的排列问题</p><h2 id="排列组合复杂情况"><a href="#排列组合复杂情况" class="headerlink" title="排列组合复杂情况"></a>排列组合复杂情况</h2><p>对于回溯的排列组合问题上述元素均为无重复且不可复选的情况</p><p>实际可以分为三类</p><ul><li>无重复不可复选</li><li>有重复不可复选</li><li>无重复可复选</li></ul><p>有重复可复选的情况本质和无重复可复选一样(既然可复选,元素重不重复都一样,等价于无重复可复选)</p><p>无重复不可复选就是最基本的情况,上面已经讲过了</p><p>下面谈谈有重复不可复选的情况</p><p>子集问题</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 先排序，让相同的元素靠在一起</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtrack(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="comment">// 前序位置，每个节点的值都是一个子集</span></span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(track));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 剪枝逻辑，值相同的相邻树枝，只遍历第一条</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            track.addLast(nums[i]);</span><br><span class="line">            backtrack(nums, i + <span class="number">1</span>);</span><br><span class="line">            track.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>组合</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 先排序，让相同的元素靠在一起</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtrack(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">         <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length == track.size()) &#123;</span><br><span class="line">            <span class="comment">// 遍历到了第 k 层，收集当前节点的值</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(track));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 剪枝逻辑，值相同的相邻树枝，只遍历第一条</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            track.addLast(nums[i]);</span><br><span class="line">            backtrack(nums, i + <span class="number">1</span>);</span><br><span class="line">            track.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>排列</p><p>假设输入为 <code>nums = [1,2,2&#39;]</code>，标准的全排列算法会得出如下答案：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    [1,2,2&#x27;],[1,2&#x27;,2],</span><br><span class="line">    [2,1,2&#x27;],[2,2&#x27;,1],</span><br><span class="line">    [2&#x27;,1,2],[2&#x27;,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>显然，这个结果存在重复，比如 <code>[1,2,2&#39;]</code> 和 <code>[1,2&#39;,2]</code> 应该只被算作同一个排列，但被算作了两个不同的排列。</p><p>所以现在的关键在于，如何设计剪枝逻辑，把这种重复去除掉？</p><p><strong>答案是，保证相同元素在排列中的相对位置保持不变</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span>[] used;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 先排序，让相同的元素靠在一起</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        backtrack(nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (track.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>(track));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 新添加的剪枝逻辑，固定相同的元素在排列中的相对位置,保证同一层不出现相同的值</span></span><br><span class="line">           <span class="comment">//当出现重复元素时，比如输入 nums = [1,2,2&#x27;,2&#x27;&#x27;]，2&#x27; 只有在 2 已经被使用的情况下才会被选择，同理，`2&#x27;&#x27;` 只有在 2&#x27; 已经被使用的情况下才会被选择，这就保证了相同元素在排列中的相对位置保证固定</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 如果前面的相邻相等元素没有用过，则跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            track.add(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            backtrack(nums);</span><br><span class="line">            track.removeLast();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>当出现重复元素时，比如输入 <code>nums = [1,2,2&#39;,2&#39;&#39;]</code>，<code>2&#39;</code> 只有在 <code>2</code> 已经被使用的情况下才会被选择，同理，<code>2&#39;&#39;</code> 只有在 <code>2&#39;</code> 已经被使用的情况下才会被选择，这就保证了相同元素在排列中的相对位置保证固定</strong>。</p><p>这样的写法也可以,保证同一层不出现相同的值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (track.size() == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录之前树枝上元素的值</span></span><br><span class="line">    <span class="comment">// 题目说 -10 &lt;= nums[i] &lt;= 10，所以初始化为特殊值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">prevNum</span> <span class="operator">=</span> -<span class="number">666</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == prevNum) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 记录这条树枝上的值</span></span><br><span class="line">        prevNum = nums[i];</span><br><span class="line"></span><br><span class="line">        backtrack(nums, track);</span><br><span class="line"></span><br><span class="line">        track.removeLast();</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红蓝二分法，边界判定不用愁</title>
      <link href="/posts/28847.html"/>
      <url>/posts/28847.html</url>
      
        <content type="html"><![CDATA[<h1 id="closed-book-blue-book-红蓝二分法-解题"><a href="#closed-book-blue-book-红蓝二分法-解题" class="headerlink" title=":closed_book::blue_book:红蓝二分法 解题"></a>:closed_book::blue_book:红蓝二分法 解题</h1><p>​</p><h2 id="mag-红蓝二分法讲解："><a href="#mag-红蓝二分法讲解：" class="headerlink" title=":mag:红蓝二分法讲解："></a>:mag:红蓝二分法讲解：</h2><p><strong>特此声明：本文模板非原创，核心内容均转自B站 五点七边 ，本人主要进行简要介绍，相应题目代码展示，持续更新中……</strong></p><p>关于红蓝二分法，五点七边以给出很不错的讲解：</p><p><a href="https://www.bilibili.com/video/BV1d54y1q7k7/?spm_id_from=333.999.0.0&vd_source=a2cdc337163157715ec6605c77937a77">二分查找为什么总是写错？_哔哩哔哩_bilibili</a></p><p><code>leetcode</code> 大佬讲解红蓝二分法</p><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/lan-hong-hua-fen-fa-dan-mo-ban-miao-sha-e7r40/">蓝红二分法单模板秒杀二分查找</a></p><h2 id="star2-二分的本质："><a href="#star2-二分的本质：" class="headerlink" title=":star2:二分的本质："></a>:star2:二分的本质：</h2><p>​如果我们能够通过某种方式将一个区间<strong>划分成两个区间，左边区间满足某种特性；右边区间不满足某种特性</strong>。<br>​那么我们就能够通过二分法来寻找左区间的右边端点或者右区间的左边端点</p><p>​<strong>有单调性一定可以二分，但是二分不一定要有单调性</strong></p><p>​通常二分法的思路是通过二分<strong>不断缩小结果范围</strong>直到确认结果或者区间不存在</p><p>​而红蓝二分法则是<strong>逆向思路</strong>，通过<strong>不断扩大非结果区间的范围</strong>直到直到确认结果或者区间不存在</p><p>​</p><p>​通常二分法的思路对应的各种左闭右闭或者左闭右开往往面临繁琐的边界问题，虽然通过大量练习也能熟能生巧，但红蓝二分提供的简易思路可以摒弃复杂的边界问题，更加贴近二分的本质——<strong>循环不变量</strong></p><p>​大家写二分法经常写乱，主要是因为<strong>对区间的定义没有想清楚，区间的定义就是不变量</strong>。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则。</p><p>红蓝二分模板：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">l = -<span class="number">1</span>, r = N;<span class="comment">//初始化，保证l和r不在搜索区间内部，保证循环不变量</span></span><br><span class="line"><span class="keyword">while</span> l + <span class="number">1</span> != <span class="type">r</span></span><br><span class="line">    <span class="variable">m</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>           <span class="comment">//此处预防越界，只是和(l + r) / 2写法不同</span></span><br><span class="line">    <span class="keyword">if</span> <span class="title function_">isBlue</span><span class="params">(m)</span>  <span class="comment">// isBlue()是抽象出来的用来判断特性的方法</span></span><br><span class="line">        l = m</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        r = m</span><br><span class="line"><span class="keyword">return</span> l or r<span class="comment">//因题而异        </span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="grey-question-二分题目总结"><a href="#grey-question-二分题目总结" class="headerlink" title=":grey_question:二分题目总结"></a>:grey_question:二分题目总结</h2><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202302282125488.png" alt="image-20230228210901759"></p><h3 id="完全有序"><a href="#完全有序" class="headerlink" title="完全有序"></a>完全有序</h3><ul><li><em>梦开始的地方，基础的二分查找</em></li></ul><h4 id="star-704-二分查找"><a href="#star-704-二分查找" class="headerlink" title=":star: 704.二分查找"></a>:star: 704.<a href="https://leetcode.cn/problems/binary-search/">二分查找</a></h4><p><a href="https://leetcode.cn/problems/binary-search/">力扣题目链接(opens new window)</a></p><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例 1:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9     </span><br><span class="line">输出: 4       </span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4     </span><br></pre></td></tr></table></figure><p>1<br>2<br>3</p><p>示例 2:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2     </span><br><span class="line">输出: -1        </span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1        </span><br></pre></td></tr></table></figure><p>1<br>2<br>3</p><p>提示：</p><ul><li>你可以假设 nums 中的所有元素是不重复的。</li><li>n 将在 [1, 10000]之间。</li><li>nums 的每个元素都将在 [-9999, 9999]之间。</li></ul><p>红蓝二分法解法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>, r = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(l + <span class="number">1</span> != r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] == target) <span class="keyword">return</span> m;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &gt; target) r = m;</span><br><span class="line">            <span class="keyword">else</span> l = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35.搜索插入位置"></a>35.<a href="https://leetcode.cn/problems/search-insert-position/">搜索插入位置</a></h4><ul><li><em>二分查找的变式，感受查找边界</em></li></ul><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p>示例 1:</p><ul><li>输入: [1,3,5,6], 5</li><li>输出: 2</li></ul><p>示例 2:</p><ul><li>输入: [1,3,5,6], 2</li><li>输出: 1</li></ul><p>示例 3:</p><ul><li>输入: [1,3,5,6], 7</li><li>输出: 4</li></ul><p>示例 4:</p><ul><li>输入: [1,3,5,6], 0</li><li>输出: 0</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>, r = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (l + <span class="number">1</span> != r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &gt;= target) r = m;</span><br><span class="line">            <span class="keyword">else</span> l = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="star-34-在排序数组中查找元素的第一个和最后一个位置"><a href="#star-34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title=":star:34. 在排序数组中查找元素的第一个和最后一个位置"></a>:star:<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h4><ul><li>二分查找边界的复合，进一步感受边界</li></ul><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [], target = 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>nums</code> 是一个非递减数组</li><li><code>-109 &lt;= target &lt;= 109</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> result[] = &#123;getLeft(nums,target),getRight(nums,target)&#125;;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getLeft</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>, r = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (l + <span class="number">1</span> != r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &gt;= target) r = m;</span><br><span class="line">            <span class="keyword">else</span> l = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r == nums.length || nums[r] != target  ) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getRight</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>, r = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (l + <span class="number">1</span> != r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &lt;= target) l = m;</span><br><span class="line">            <span class="keyword">else</span> r = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l == -<span class="number">1</span> || nums[l] != target) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="不完全有序"><a href="#不完全有序" class="headerlink" title="不完全有序"></a>不完全有序</h3><p>(旋转排序数组系列)</p><ul><li>局部有序，注意循环不变量</li></ul><h4 id="star-153-寻找旋转排序数组中的最小值"><a href="#star-153-寻找旋转排序数组中的最小值" class="headerlink" title=":star:153. 寻找旋转排序数组中的最小值"></a>:star:<a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></h4><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p><ul><li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li><li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li></ul><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p><p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2]</span><br><span class="line">输出：0</span><br><span class="line">解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [11,13,15,17]</span><br><span class="line">输出：11</span><br><span class="line">解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 5000</code></li><li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li><li><code>nums</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li></ul><p>解法一</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>, r = nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums[m] &lt;= nums[r - <span class="number">1</span>]) &#123;</span><br><span class="line">            r = m;</span><br><span class="line">            <span class="keyword">while</span> (l + <span class="number">1</span> != r) &#123;</span><br><span class="line">                m = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (nums[m] &lt;= nums[r]) r = m;</span><br><span class="line">                <span class="keyword">else</span> l = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            l = m;</span><br><span class="line">            <span class="keyword">while</span> (l + <span class="number">1</span> != r) &#123;</span><br><span class="line">                m = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (nums[m] &gt;= nums[l]) l = m;</span><br><span class="line">                <span class="keyword">else</span> r = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[r];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法二、</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> l=-<span class="number">1</span>, r=n;</span><br><span class="line">        <span class="keyword">while</span> (l+<span class="number">1</span> != r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> r == n ? nums[n-<span class="number">1</span>] : nums[r];</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[r];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="star-154-寻找旋转排序数组中的最小值-II"><a href="#star-154-寻找旋转排序数组中的最小值-II" class="headerlink" title=":star:154. 寻找旋转排序数组中的最小值 II"></a><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/">:star:154. 寻找旋转排序数组中的最小值 II</a></h4><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,4,4,5,6,7]</code> 在变化后可能得到：</p><ul><li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,4]</code></li><li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,4,4,5,6,7]</code></li></ul><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p><p>给你一个可能存在 <strong>重复</strong> 元素值的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p><p>你必须尽可能减少整个过程的操作步骤。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3,5]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 5000</code></li><li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li><li><code>nums</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li></ul><p><strong>进阶：</strong>这道题与 <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/">寻找旋转排序数组中的最小值</a> 类似，但 <code>nums</code> 可能包含重复元素。允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (nums[r] == nums[<span class="number">0</span>] &amp;&amp; r &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> nums[r];</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        ++r;</span><br><span class="line">        n = r;</span><br><span class="line">        <span class="keyword">while</span> (l+<span class="number">1</span> != r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> r == n ? last : nums[r];</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[r];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="star-33-搜索旋转排序数组"><a href="#star-33-搜索旋转排序数组" class="headerlink" title=":star:33. 搜索旋转排序数组"></a>:star:<a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h4><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1], target = 0</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 中的每个值都 <strong>独一无二</strong></li><li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li><li><code>-104 &lt;= target &lt;= 104</code></li></ul><h4 id="star-81-搜索旋转排序数组-II"><a href="#star-81-搜索旋转排序数组-II" class="headerlink" title=":star:81. 搜索旋转排序数组 II"></a>:star:<a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/">81. 搜索旋转排序数组 II</a></h4><p>已知存在一个按非降序排列的整数数组 <code>nums</code> ，数组中的值不必互不相同。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong> ，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,4,4,5,6,6,7]</code> 在下标 <code>5</code> 处经旋转后可能变为 <code>[4,5,6,6,7,0,1,2,4,4]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p>你必须尽可能减少整个操作步骤。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,5,6,0,0,1,2], target = 0</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,5,6,0,0,1,2], target = 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li><li><code>-104 &lt;= target &lt;= 104</code></li></ul><p><strong>进阶：</strong></p><ul><li>这是 <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/">搜索旋转排序数组</a> 的延伸题目，本题中的 <code>nums</code> 可能包含重复元素。</li><li>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> findMin(nums);</span><br><span class="line">        System.out.println(t);</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>, r = n;</span><br><span class="line">        <span class="keyword">if</span> (nums[t] &lt;= target &amp;&amp; target &lt;= nums[n - <span class="number">1</span>]) &#123;</span><br><span class="line">            l = t - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l + <span class="number">1</span> != r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (r + l) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &gt; target) r = m;</span><br><span class="line">            <span class="keyword">else</span> l = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        n = nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (nums[r] == nums[<span class="number">0</span>] &amp;&amp; r &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> nums[r];</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        ++r;</span><br><span class="line">        n = r;</span><br><span class="line">        <span class="keyword">while</span> (l+<span class="number">1</span> != r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> r == n ? last : nums[r];</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="star-162-寻找峰值"><a href="#star-162-寻找峰值" class="headerlink" title=":star:162. 寻找峰值"></a>:star:<a href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值</a></h4><p>峰值元素是指其值严格大于左右相邻值的元素。</p><p>给你一个整数数组 <code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可。</p><p>你可以假设 <code>nums[-1] = nums[n] = -∞</code> 。</p><p>你必须实现时间复杂度为 <code>O(log n)</code> 的算法来解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：3 是峰值元素，你的函数应该返回其索引 2。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,1,3,5,6,4]</span><br><span class="line">输出：1 或 5 </span><br><span class="line">解释：你的函数可以返回索引 1，其峰值元素为 2；</span><br><span class="line">     或者返回索引 5， 其峰值元素为 6。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li><li>对于所有有效的 <code>i</code> 都有 <code>nums[i] != nums[i + 1]</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>, r = nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l + <span class="number">1</span> != r) &#123;</span><br><span class="line">           m = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">           <span class="keyword">if</span> (m &gt;= nums.length - <span class="number">1</span>) r = m;  </span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ( nums[m] &gt; nums[m+<span class="number">1</span>]) r = m;</span><br><span class="line">           <span class="keyword">else</span> l = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><h4 id="star-74-搜索二维矩阵"><a href="#star-74-搜索二维矩阵" class="headerlink" title=":star:74. 搜索二维矩阵"></a>:star:<a href="https://leetcode.cn/problems/search-a-2d-matrix/">74. 搜索二维矩阵</a></h4><p>难度中等</p><p>编写一个高效的算法来判断 <code>m x n</code> 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><ul><li>每行中的整数从左到右按升序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。</li></ul><p><strong>示例 1：</strong></p><p><img src="/%E7%BA%A2%E8%93%9D%E4%BA%8C%E5%88%86%E6%B3%95%E2%80%94%E2%80%94%E4%B8%80%E7%A7%8D%E4%BA%8C%E5%88%86%E6%B3%95%E7%9A%84%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF.assets/mat.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/%E7%BA%A2%E8%93%9D%E4%BA%8C%E5%88%86%E6%B3%95%E2%80%94%E2%80%94%E4%B8%80%E7%A7%8D%E4%BA%8C%E5%88%86%E6%B3%95%E7%9A%84%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF.assets/mat2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>-104 &lt;= matrix[i][j], target &lt;= 104</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>, r = matrix.length * matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">while</span> (l + <span class="number">1</span> != r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> get(matrix,m);</span><br><span class="line">            <span class="keyword">if</span> (value == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; target) r = m;</span><br><span class="line">            <span class="keyword">else</span> l = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index / n, j = index % n;</span><br><span class="line">        <span class="keyword">return</span> matrix[i][j]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="367-有效的完全平方数"><a href="#367-有效的完全平方数" class="headerlink" title="367. 有效的完全平方数"></a><a href="https://leetcode.cn/problems/valid-perfect-square/">367. 有效的完全平方数</a></h4><p>给你一个正整数 num 。如果 num 是一个完全平方数，则返回 true ，否则返回 false 。</p><p>完全平方数 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。</p><p>不能使用任何内置的库函数，如  sqrt 。</p><p>示例 1：</p><p>输入：num &#x3D; 16<br>输出：true<br>解释：返回 true ，因为 4 * 4 &#x3D; 16 且 4 是一个整数。<br>示例 2：</p><p>输入：num &#x3D; 14<br>输出：false<br>解释：返回 false ，因为 3.742 * 3.742 &#x3D; 14 但 3.742 不是一个整数。</p><p>提示：</p><p>1 &lt;&#x3D; num &lt;&#x3D; 231 - 1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接暴力用大数了</span></span><br><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">l</span> <span class="operator">=</span>BigInteger.valueOf(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">r</span> <span class="operator">=</span>BigInteger.valueOf((num &gt;&gt; <span class="number">1</span>) + <span class="number">2</span>);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">x</span> <span class="operator">=</span> BigInteger.valueOf(num);</span><br><span class="line">        BigInteger m;</span><br><span class="line">        <span class="keyword">while</span> (!l.add(BigInteger.ONE).equals(r)) &#123;</span><br><span class="line">            m = l.add(r).divide(BigInteger.TWO);</span><br><span class="line">            <span class="keyword">if</span> (m.multiply(m).equals(x)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m.multiply(m).compareTo(x) == -<span class="number">1</span>) l = m;</span><br><span class="line">            <span class="keyword">else</span> r = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根 "></a><a href="https://leetcode.cn/problems/sqrtx/">69. x 的平方根 </a></h4><p>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</p><p>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</p><p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p><p>示例 1：</p><p>输入：x &#x3D; 4<br>输出：2<br>示例 2：</p><p>输入：x &#x3D; 8<br>输出：2<br>解释：8 的算术平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。</p><p>提示：</p><p>0 &lt;&#x3D; x &lt;&#x3D; 231 - 1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暴力大数</span></span><br><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">l</span> <span class="operator">=</span> BigInteger.valueOf(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">r</span> <span class="operator">=</span> BigInteger.valueOf((x &gt;&gt; <span class="number">1</span>) + <span class="number">2</span>);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">num</span> <span class="operator">=</span> BigInteger.valueOf(x); </span><br><span class="line">        <span class="keyword">while</span> (!l.add(BigInteger.ONE).equals(r)) &#123;</span><br><span class="line">            <span class="type">BigInteger</span> <span class="variable">m</span> <span class="operator">=</span> l.add(r).divide(BigInteger.TWO);</span><br><span class="line">            <span class="keyword">if</span> (m.multiply(m).compareTo(num) == <span class="number">1</span>) r = m;</span><br><span class="line">            <span class="keyword">else</span> l = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l.intValue(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">2</span> || x == <span class="number">3</span> || x == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//上面两行均是为了防止 m == 0的情况，而后面为什么要用x/m&lt;m 而不是 m*m&gt;x则是为了防止越界错误</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span> , r = (x &gt;&gt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (l + <span class="number">1</span> != r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + ((r - l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (x / m &lt; m) r = m;</span><br><span class="line">            <span class="keyword">else</span> l = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="/posts/28769.html"/>
      <url>/posts/28769.html</url>
      
        <content type="html"><![CDATA[<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>🚧🚧🚧 暂待施工🚧🚧🚧</p><p><a href="https://www.cnblogs.com/eniac12/p/5558848.html">Sedgewick的红黑树 - SteveWang - 博客园 (cnblogs.com)</a></p><p>主要性质</p><ul><li><p>叶根黑</p></li><li><p>红黑</p></li><li><p>黑高</p></li><li><p>有则黑</p></li></ul><p>自平衡方式</p><ul><li>左旋</li><li>右旋</li><li>变色</li></ul><p>插入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">157 -&gt; 12</span><br></pre></td></tr></table></figure><ul><li>父节点是黑结点, 直接插入, 不会破坏(-&gt; 200)</li><li>父节点是红色, 需要自平衡<ul><li>父和叔结点为红, 父结点, 叔结点和爷结点颜色反转 (-&gt;250)</li><li>父为红, 叔为黑<ul><li>孙父爷在一条直线上, 父和爷颜色反转, 父爷旋转(-&gt;260) </li><li>孙父爷不在一条直线上, 父和孙 先旋转成一条直线 再执行上一条(-&gt;220[复习上一条] -&gt; 210)</li></ul></li></ul></li></ul><p><img src="C:/Users/zs/AppData/Roaming/Typora/typora-user-images/image-20240316133257672.png" alt="image-20240316133257672"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArraysList源码分析</title>
      <link href="/posts/16070.html"/>
      <url>/posts/16070.html</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h1><p>Hey 大家好，我是 Shio👋。今天我们将深入探讨<code> Java</code> 的<code>ArrayList</code>源码, <code>ArrayList</code> 是Java提供的动态数组容器, 和Java中数组相比， 它能够动态增加长度。</p><p>其继承了<code>AbstractList</code>, 并且实现了<code>List</code>, <code>RandomAccess</code>, <code>Cloneable</code>, <code>Serializable</code>接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这些接口代表的含义如下：</p><ul><li><code>List</code>代表他是一个列表， 支持添加，删除， 查找操作， 可存放重复元素</li><li><code>RandomAccess</code> 是一个标记接口， 代表实现类支持随机访问（根据元素序号快速获取元素对象）</li><li><code>Cloneable</code>是一个标记接口， 代表实现类具有拷贝能力（可以调用<code>Object.clone()</code>方法进行拷贝）</li><li><code>Serializable</code>是一个标记接口， 代表实现类可以进行序列化操作（可以转化为字节流进行持久化或者网络传输），同时其<code>ArrayList</code>也实现了<code>readObject()</code> 和<code>writeObject()</code>方法自定义序列化(后面会讲)</li></ul><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>我们先从最高频的扩容开始</p><p>先从<code>ArrayList</code>初始化说起， <code>ArrayList</code>有三种方式来初始化</p><ul><li>无参, 初始容量设为10, 赋值一个默认容量为空的数组(<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>)</li><li>携带初始容量参数, 如果&gt;0, 直接初始化一个该容量的数组, &#x3D; 0赋值为空数组(<code>EMPTY_ELEMENTDATA</code>), &lt;0 抛出非法参数异常</li><li>携带<code>Collection</code>集合, 调用集合的<code>toArray</code>数组方法, 直接赋值为转化后的数组, 之后进行判断, 如果转化后数组&gt;0, 但数组类型不为Object数组则调用<code>Arrays.copyOf()进行转换</code> ,否则赋值空数组(<code>EMPTY_ELEMENTDATA</code>)</li></ul><p>&#x2F;&#x2F; 此处不理解为什么要判断数组类型可以看这篇博客</p><p><a href="https://blog.csdn.net/weixin_39452731/article/details/100189934"><code>elementData.getClass() != Object[].class</code></a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;<span class="comment">//初始容量大于0</span></span><br><span class="line">        <span class="comment">//创建initialCapacity大小的数组</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;<span class="comment">//初始容量等于0</span></span><br><span class="line">        <span class="comment">//创建空数组</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//初始容量小于0，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span> + initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment"> *如果指定的集合为null，throws NullPointerException。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可见, 如果以无参构造创建<code>ArrayList</code>, 实际初始化为一个空数组, 而之后只有到第一次真正添加元素时, 才会真正分配容量, 将数组扩容为10</p><p>扩容的起始点是发生在<code>add</code>方法中</p><p>每次次增加元素前都会进行<code>ensureCapacityInternal(size + 1)</code>操作, 该方法用于在合适时机进行扩容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount</span></span><br><span class="line">    <span class="comment">// 这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们进入<code>ensureCapacityInternal(size + 1)</code>, 发现其实际调用了<code>ensureExplicitCapacity()</code>方法</p><p>当然在调用之前还调用了一个<code>calculateCapacity</code></p><p>这个方法主要是用来判断<code>ArrayList</code>是否是调用无参构造实例化的, 如果是的话, 就和选择返回默认容量, 否则就是传入的最小容量</p><p>其实这里也解答了一个问题就是为什么要定义两个空数组</p><ul><li><code>EMPTY_ELEMENTDATA</code>是初始化时指定大小为0是赋值的, 之后会一步一步按照1.5倍慢慢扩容</li><li><code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>则是无参默认赋值的, 在第一次增加元素时,会通过<code>calculateCapacity</code>以<code>DEFAULT_CAPACITY</code>(10)进行扩容</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 确保内部容量达到指定的最小容量。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据给定的最小容量和当前数组元素来计算所需容量。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则直接返回最小容量</span></span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们接着跟踪, 来到了<code> ensureExplicitCapacity</code>, 这里只进行了两个操作, 增加修改次数, 还有判断是否需要扩容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否需要扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//判断当前数组容量是否足以存储minCapacity个元素</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//调用grow方法进行扩容</span></span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于来到了最核心的方法<code>grow()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">// 将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">    <span class="comment">// 我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">    <span class="comment">// 如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由此我们可以梳理出整个扩容的逻辑, 影响的几个分支</p><p>第一个是在构造方法中, 选择赋值的是<code>EMPTY_ELEMENTDATA</code> 还是 <code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code></p><p>第二个是在<code>calculateCapacity()</code>方法中的<code>if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)  return Math.max(DEFAULT_CAPACITY, minCapacity);</code>, 如果是无参默认构造方法赋的初值(也就是<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>) 那么返回的<code>minCapacity</code>就是</p><p>第三个是在<code>grow()</code>方法中的<code>if (newCapacity - minCapacity &lt; 0)   newCapacity = minCapacity;</code></p><p>确认最终选择是扩容大小 为  数组长度的1.5倍大小 还是 方法传入的 <code>minCapacityInternal</code></p><h3 id="面试总结"><a href="#面试总结" class="headerlink" title="面试总结"></a>面试总结</h3><p>我在看<code>ArrayList</code>扩容机制,</p><p>从他创建对象, 一开始选择的构造函数就开始决定之后的扩容策略了</p><p><code>ArrayList</code>源码中有两个成员变量, 一个是<code>EMPTY_ELEMENTDATA</code> (空元素数据)一个是 <code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>(默认容量空元素数据),这两个都是大小为0的空数组</p><p>他俩的区别是什么呢</p><p>如果说<code>new  ArrayList </code>对象时选择的是默认空参构造方法, 则赋值 <code>默认容量空元素数据</code> , 如果是确定容量为0, 或者是传入一个空的<code>Collection</code>集合, 那么就会赋值为<code>空元素数据</code>, 具体怎样影响扩容策略我们后面说</p><p>扩容机制发生在每次增加元素时, 比如<code>add</code>或者<code>addAll</code>方法中, 在增加元素之前都会调用<code>ensureCapacity</code>方法,通过这个方法选在合适的时机扩容合适的大小, 在传入参数时当前输入 + 1</p><p>在这个方法里会调用<code>calculateCapacity()</code>, 如果<code>ArrayList</code>在构造时,为默认空参构造, 他就在让传入的当前数组大小 + 1和<code>DefaultCapacity</code>中选择最大的作为<code>minCapacity</code></p><p>这个<code>minCapacity</code>在最后的扩容方法<code>grow()</code>中会当前数组大小的1.5倍进行比较, 选择最大的作为最终的扩容大小</p><p>也就是说, 如果你用默认构造函数第一次扩容时,他会给你扩容到10的大小, 如果不是, 而是指定大小为0, 那么就会扩容到 1 的大小(1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 6 -&gt; 9 -&gt; 13)会多出很多次扩容, 我想这么做的原因, 可能时源码作者考虑到有些时候不需要10这么大的容量或者扩容机制, 所以如果使用者指定容量大小的话, 那么扩容机制就按照比较 数组容量 + 1 和 数组当前大小1.5的最大值的方式慢慢扩容</p><h3 id="缩容机制"><a href="#缩容机制" class="headerlink" title="缩容机制"></a>缩容机制</h3><p>既然<code>ArrayList</code>有默认的缩容机制, 那么是否有缩容机制呢? </p><p>答案是没有</p><p>无论<code>remove</code>还是<code>clear</code>都不会改变现有数组的大小, 而是将数组的相应位置元素设置为null, 便于垃圾回收器回收, 如果想要缩容, 必须手动去掉哟<code>trimToSize</code>方法, 达到缩容的目的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">()</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//判断当前容量与数组长度的大小关系</span></span><br><span class="line">        <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        <span class="comment">//如果size小于elementData.length，则将数组拷贝到长度为size的数组中，如果size==0，则将elementData 置为空数组，&#123;&#125;</span></span><br><span class="line">            elementData = (size == <span class="number">0</span>)</span><br><span class="line">              ? EMPTY_ELEMENTDATA</span><br><span class="line">              : Arrays.copyOf(elementData, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="源码概览"><a href="#源码概览" class="headerlink" title="源码概览"></a>源码概览</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空数组（用于空实例）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于默认大小空实例的共享空数组实例。</span></span><br><span class="line">    <span class="comment">//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存ArrayList数据的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList 所包含的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果传入的参数大于0，创建initialCapacity大小的数组</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果传入的参数等于0，创建空数组</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//其他情况，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span> +</span><br><span class="line">                    initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认无参构造函数</span></span><br><span class="line"><span class="comment">     * DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="comment">//将指定集合转换为数组</span></span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="comment">//如果elementData数组的长度不为0</span></span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                <span class="comment">//将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组</span></span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 其他情况，用空数组代替</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">()</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">            elementData = (size == <span class="number">0</span>)</span><br><span class="line">                    ? EMPTY_ELEMENTDATA</span><br><span class="line">                    : Arrays.copyOf(elementData, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//下面是ArrayList的扩容机制</span></span><br><span class="line"><span class="comment">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span></span><br><span class="line"><span class="comment">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> minCapacity 所需的最小容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">//如果是true，minExpand的值为0，如果是false,minExpand的值为10</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minExpand</span> <span class="operator">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">                <span class="comment">// any size if not default element table</span></span><br><span class="line">                ? <span class="number">0</span></span><br><span class="line">                <span class="comment">// larger than default for default empty table. It&#x27;s already</span></span><br><span class="line">                <span class="comment">// supposed to be at default size.</span></span><br><span class="line">                : DEFAULT_CAPACITY;</span><br><span class="line">        <span class="comment">//如果最小容量大于已有的最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">            ensureExplicitCapacity(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据给定的最小容量和当前数组元素来计算所需容量。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则直接返回最小容量</span></span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保内部容量达到指定的最小容量。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否需要扩容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">        <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class="line">        <span class="comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class="line">        <span class="comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较minCapacity和 MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">                Integer.MAX_VALUE :</span><br><span class="line">                MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中的元素数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此列表不包含元素，则返回 true 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//注意=和==的区别</span></span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此列表包含指定的元素，则返回true 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span></span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i] == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="comment">//equals()方法比较</span></span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i] == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="built_in">super</span>.clone();</span><br><span class="line">            <span class="comment">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span></span><br><span class="line">            v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">            v.modCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// 这不应该发生，因为我们是可以克隆的</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。</span></span><br><span class="line"><span class="comment">     * 返回的数组将是“安全的”，因为该列表不保留对它的引用。</span></span><br><span class="line"><span class="comment">     * （换句话说，这个方法必须分配一个新的数组）。</span></span><br><span class="line"><span class="comment">     * 因此，调用者可以自由地修改返回的数组结构。</span></span><br><span class="line"><span class="comment">     * 注意：如果元素是引用类型，修改元素的内容会影响到原列表中的对象。</span></span><br><span class="line"><span class="comment">     * 此方法充当基于数组和基于集合的API之间的桥梁。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;</span></span><br><span class="line"><span class="comment">     * 返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。</span></span><br><span class="line"><span class="comment">     * 否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。</span></span><br><span class="line"><span class="comment">     * 如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。</span></span><br><span class="line"><span class="comment">     * （这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">            <span class="comment">// 新建一个运行时类型的数组，但是ArrayList数组的内容</span></span><br><span class="line">            <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">        <span class="comment">//调用System提供的arraycopy()方法实现数组之间的复制</span></span><br><span class="line">        System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">            a[size] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Positional Access Operations</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中指定位置的元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用指定的元素替换此列表中指定位置的元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="comment">//对index进行界限检查</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="comment">//返回原来在这个位置的元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在此列表中的指定位置插入指定的元素。</span></span><br><span class="line"><span class="comment">     * 先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class="line"><span class="comment">     * 再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index,</span><br><span class="line">                    numMoved);</span><br><span class="line">        elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="comment">//从列表中删除的元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。</span></span><br><span class="line"><span class="comment">     * 返回true，如果此列表包含指定的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Private remove method that skips bounds checking and does not</span></span><br><span class="line"><span class="comment">     * return the value removed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index,</span><br><span class="line">                    numMoved);</span><br><span class="line">        elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中删除所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把数组中所有的元素的值设为null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            elementData[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                    numMoved);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。</span></span><br><span class="line"><span class="comment">     * 将任何后续元素移动到左侧（减少其索引）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">removeRange</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - toIndex;</span><br><span class="line">        System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                numMoved);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newSize</span> <span class="operator">=</span> size - (toIndex - fromIndex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> newSize; i &lt; size; i++) &#123;</span><br><span class="line">            elementData[i] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查给定的索引是否在范围内。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * add和addAll使用的rangeCheck的一个版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheckForAdd</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回IndexOutOfBoundsException细节信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">outOfBoundsMsg</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Index: &quot;</span> + index + <span class="string">&quot;, Size: &quot;</span> + size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从此列表中删除指定集合中包含的所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="comment">//如果此列表被修改则返回true</span></span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 仅保留此列表中包含在指定集合中的元素。</span></span><br><span class="line"><span class="comment">     * 换句话说，从此列表中删除其中不包含在指定集合中的所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。</span></span><br><span class="line"><span class="comment">     * 指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。</span></span><br><span class="line"><span class="comment">     * 返回的列表迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index: &quot;</span> + index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回列表中的列表迭代器（按适当的顺序）。</span></span><br><span class="line"><span class="comment">     * 返回的列表迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以正确的顺序返回该列表中的元素的迭代器。</span></span><br><span class="line"><span class="comment">     * 返回的迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArrayLists </tag>
            
            <tag> Java源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/posts/60354.html"/>
      <url>/posts/60354.html</url>
      
        <content type="html"><![CDATA[<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><p>🚧🚧🚧 暂待施工🚧🚧🚧</p><p><strong>01背包</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span>[] weight, <span class="type">int</span>[] value, <span class="type">int</span> bagSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">goods</span> <span class="operator">=</span> weight.length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[goods + <span class="number">1</span>][bagSize + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= goods; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= bagSize; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(</span><br><span class="line">                    dp[i - <span class="number">1</span>][j],</span><br><span class="line">                    dp[i - <span class="number">1</span>][j - weight[i - <span class="number">1</span>]] + value[i - <span class="number">1</span>]</span><br><span class="line">                    );</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[goods][bagSize];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>滚动数组 压缩空间</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span>[] weight, <span class="type">int</span>[] value, <span class="type">int</span> bagSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">goods</span> <span class="operator">=</span> weight.length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[bagSize + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= goods; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> bagSize; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= weight[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[j] = Math.max(</span><br><span class="line">                dp[j],</span><br><span class="line">                    dp[j - weight[i - <span class="number">1</span>]] + value[i - <span class="number">1</span>]</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[bagSize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap 源码分析</title>
      <link href="/posts/undefined.html"/>
      <url>/posts/undefined.html</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap-源码解析"><a href="#HashMap-源码解析" class="headerlink" title="HashMap 源码解析"></a>HashMap 源码解析</h1><p>Hey 大家好，我是 Shio👋。今天我们将深入探讨 Java 的<code>HashMap</code>源码, <code>HashMap</code> 是Java提供的存放键值对的容器, 其最大的特点是大多情况下可以通过<code>O(1)</code>的时间复杂度通过键来获取值</p><p>其底层是由数组 + 链表的组成的，链表主要是用拉链法解决Hash冲突 ， 在<code>JDK1.8</code>之后引入了树化机制 ，在达到一定条件后，会将链表转化为红黑树。</p><h2 id="扰动函数"><a href="#扰动函数" class="headerlink" title="扰动函数"></a>扰动函数</h2><p>HashMap通过调用键的<code>hashCode()</code>方法获取hash值，然后通过扰动函数，使hash值在最后和数组长度取余（<code>(n - 1) &amp; hash</code>）后分布的更为均匀</p><p>扰动函数就是为了防止一些实现比较差的hashCode()， 使得使用扰动函数后， 减少哈希碰撞的概率。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现其实就是用高16位和低16位进行异或操作</p><table><thead><tr><th>位操作</th><th>0 和 0</th><th>0 和 1</th><th>1 和 0</th><th>1 和 1</th></tr></thead><tbody><tr><td>&amp;</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>|</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>^</td><td>0</td><td>1</td><td>1</td><td>0</td></tr></tbody></table><p>选高16位和低16位来增加随机性，而使用异或操作，主要是因为0和1分布结果更为平均（均为50%）</p><h2 id="Hash冲突"><a href="#Hash冲突" class="headerlink" title="Hash冲突"></a>Hash冲突</h2><p>Hash冲突就是指，当hash值最后映射的数组位置元素不为空时的情况，解决的办法有很多，诸如线性探测法，拉链法等等，而<code>HashMap</code>选用的是拉链法，但是拉链法有个缺点，就是假如<code>Hash</code>冲突过于频繁，会导致<code>HashMap</code>获取元素的时间复杂度由O(1)骤降为O(n)，为了避免这种情况，JDK1.8引入了，树化机制，当数组长度大于等于64， 并且链表长度大于8时，会执行<code>treeifyBin()</code>方法，将链表转化为红黑树</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>首先我们看<code>HashMap</code>的的类属性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;</span><br><span class="line">    <span class="comment">// 默认的初始容量是16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 默认的负载因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数大于等于这个值时会转成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数小于等于这个值时树转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 桶中结构转化为红黑树对应的table的最小容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储元素的数组，总是2的幂次倍</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table;</span><br><span class="line">    <span class="comment">// 一个包含了映射中所有键值对的集合视图</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line">    <span class="comment">// 阈值(容量*负载因子) 当实际大小超过阈值时，会进行扩容</span></span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line">    <span class="comment">// 负载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>LoadFactor负载因子</li></ul><p>loadFactor负载因子是控制数组存放数组元素的疏密程度</p><p>loadFactor太大会导致Hash冲突概率过大，在<code>HashMap</code>中不断存放数据，当数量超过16*0.75就会对当前16的容量进行扩容，而扩容过程涉及到rehash，复制数据等操作，所以很消耗性能, 所以一次扩容2倍</p><h3 id="链表Node结点"><a href="#链表Node结点" class="headerlink" title="链表Node结点"></a>链表Node结点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承自 Map.Entry&lt;K,V&gt;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">int</span> hash;<span class="comment">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span></span><br><span class="line">       <span class="keyword">final</span> K key;<span class="comment">//键</span></span><br><span class="line">       V value;<span class="comment">//值</span></span><br><span class="line">       <span class="comment">// 指向下一个节点</span></span><br><span class="line">       Node&lt;K,V&gt; next;</span><br><span class="line">       Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.hash = hash;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line">        <span class="comment">// 重写hashCode()方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重写 equals() 方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="树结点类源码"><a href="#树结点类源码" class="headerlink" title="树结点类源码"></a>树结点类源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// 父</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;    <span class="comment">// 左</span></span><br><span class="line">        TreeNode&lt;K,V&gt; right;   <span class="comment">// 右</span></span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="type">boolean</span> red;           <span class="comment">// 判断颜色</span></span><br><span class="line">        TreeNode(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回根节点</span></span><br><span class="line">        <span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">root</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="built_in">this</span>, p;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p = r.parent) == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                r = p;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><code>HashMap</code>有四个构造方法</p><ul><li>默认无参构造函数</li><li>参数为另一个Map的构造函数</li><li>指定“容量大小”的构造函数</li><li>指定“容量大小”和“负载因子”的构造函数</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all   other fields defaulted</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 包含另一个“Map”的构造函数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">     putMapEntries(m, <span class="literal">false</span>);<span class="comment">//下面会分析到这个方法</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指定“容量大小”和“负载因子”的构造函数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">         initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">     <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">     <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">     <span class="comment">// 初始容量暂时存放到 threshold ，在resize中再赋值给 newCap 进行table初始化</span></span><br><span class="line">     <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h2><h3 id="1-HashMap的内部数据结构"><a href="#1-HashMap的内部数据结构" class="headerlink" title="1. HashMap的内部数据结构"></a>1. HashMap的内部数据结构</h3><p>数组 + 链表, 在1.8 后, 数组是动态扩容的, 负载因子为0.75, 当插入结点数量 &gt;&#x3D; HashMap容量 * 负载因子就会进行扩容, 数组大小乘2, 当链表长度 &gt;&#x3D; 8 并且 容量 &gt;&#x3D; 64, 那么链表会转化为红黑树, 提高查询效率, 当结点数量 &lt;&#x3D; 6的时候会把树转化为链表</p><h3 id="2-HashMap允许空键空值么"><a href="#2-HashMap允许空键空值么" class="headerlink" title="2. HashMap允许空键空值么"></a>2. HashMap允许空键空值么</h3><p><code>HashMap</code> 最多只允许一个键为<code>null</code>(null映射为数组索引为0处)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">      <span class="type">int</span> h;</span><br><span class="line">      <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">      <span class="comment">// ^：按位异或</span></span><br><span class="line">      <span class="comment">// &gt;&gt;&gt;: 无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">      <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>所有的null都会映射到数组索引为0处, 由上可知 <code>e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))</code> 成立, 所以会进行覆盖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">           Object k;</span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">               <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">               e.value = value;</span><br><span class="line">               e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       modCount++;</span><br><span class="line">       addEntry(hash, key, value, i);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>总结, HashMap 允许存null值, 但是只能存一个, 后面存的会将前面存的value覆盖</p><h3 id="影响HashMap性能的重要参数"><a href="#影响HashMap性能的重要参数" class="headerlink" title="影响HashMap性能的重要参数"></a>影响HashMap性能的重要参数</h3><ul><li><code>loadFactor</code> 负载因子</li><li><code>threshold (capacity * loadFactor) </code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;</span><br><span class="line">    <span class="comment">// 默认的初始容量是16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 默认的负载因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数大于等于这个值时会转成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数小于等于这个值时树转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 桶中结构转化为红黑树对应的table的最小容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储元素的数组，总是2的幂次倍</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table;</span><br><span class="line">    <span class="comment">// 一个包含了映射中所有键值对的集合视图</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line">    <span class="comment">// 阈值(容量*负载因子) 当实际大小超过阈值时，会进行扩容</span></span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line">    <span class="comment">// 负载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="HashMap中put-的工作原理"><a href="#HashMap中put-的工作原理" class="headerlink" title="HashMap中put()的工作原理"></a>HashMap中put()的工作原理</h3><p><img src="https://img-blog.csdnimg.cn/20200618150149962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTQxNzcz,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p><h3 id="HashMap底层数组长度为何为2的n次方"><a href="#HashMap底层数组长度为何为2的n次方" class="headerlink" title="HashMap底层数组长度为何为2的n次方"></a>HashMap底层数组长度为何为2的n次方</h3><ul><li>HashMap 通过hash值对数组长度取的余数来作为存储数组的索引, 如果数组长度是2的次方, 存在一个高效的取余技巧, hash &amp;  (length - 1), 速度和效率上比直接取模要快很多</li></ul><h3 id="1-8中做了哪些优化优化？"><a href="#1-8中做了哪些优化优化？" class="headerlink" title="1.8中做了哪些优化优化？"></a>1.8中做了哪些优化优化？</h3><ul><li><code>数组+链表改成了数组+链表或红黑树</code></li><li><code>链表的插入方式从头插法改成了尾插法</code></li><li><code>扩容的时候1.7需要对原数组中的元素进行重新hash定位在新数组的位置，1.8采用更简单的判断逻辑，位置不变或索引+旧容量大小；</code></li><li>在插入时，1.7先判断是否需要扩容，再插入，1.8先进行插入，插入完成再判断是否需要扩容；</li></ul><h3 id="HashMap线程安全方面会出现什么问题"><a href="#HashMap线程安全方面会出现什么问题" class="headerlink" title="HashMap线程安全方面会出现什么问题"></a>HashMap线程安全方面会出现什么问题</h3><ul><li>在jdk1.7中，在多线程环境下，扩容时会造成环形链或数据丢失。</li><li>在jdk1.8中，在多线程环境下，会发生数据覆盖的情况</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java源码 </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个方法团灭 nSum 问题</title>
      <link href="/posts/44501.html"/>
      <url>/posts/44501.html</url>
      
        <content type="html"><![CDATA[<h1 id="一个方法团灭-nSum-问题"><a href="#一个方法团灭-nSum-问题" class="headerlink" title="一个方法团灭 nSum 问题"></a>一个方法团灭 nSum 问题</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/two-sum/">1. Two Sumopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和open in new window</a></td><td align="center">🟢</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/3sum/">15. 3Sumopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/3sum/">15. 三数之和open in new window</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/">167. Two Sum II - Input Array Is Sortedopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组open in new window</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/4sum/">18. 4Sumopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/4sum/">18. 四数之和open in new window</a></td><td align="center">🟠</td></tr><tr><td align="center">-</td><td align="center"><a href="https://leetcode.cn/problems/1fGaJU/">剑指 Offer II 007. 数组中和为 0 的三个数open in new window</a></td><td align="center">🟠</td></tr></tbody></table><p>经常刷力扣的读者肯定知道鼎鼎有名的 <code>twoSum</code> 问题，不过除了 <code>twoSum</code> 问题，力扣上面还有 <code>3Sum</code>，<code>4Sum</code> 问题，以后如果想出个 <code>5Sum</code>，<code>6Sum</code> 也不是不可以。</p><p>总结来说，这类 <code>nSum</code> 问题就是给你输入一个数组 <code>nums</code> 和一个目标和 <code>target</code>，让你从 <code>nums</code> 选择 <code>n</code> 个数，使得这些数字之和为 <code>target</code>。</p><p>那么，对于这种问题有没有什么好办法用套路解决呢？本文就由浅入深，层层推进，用一个函数来解决所有 <code>nSum</code> 类型的问题。</p><p>提前说一下，对于本篇文章探讨的题目，使用 C++ 编写的代码更简洁易懂些，所以本文给出的都是 C++ 代码，你可以自行翻译成熟悉的语言。</p><h3 id="一、twoSum-问题"><a href="#一、twoSum-问题" class="headerlink" title="#一、twoSum 问题"></a><a href="https://labuladong.online/algo/practice-in-action/nsum/#%E4%B8%80%E3%80%81twosum-%E9%97%AE%E9%A2%98">#</a>一、twoSum 问题</h3><p>我先来编一道 twoSum 题目：</p><p>如果假设输入一个数组 <code>nums</code> 和一个目标和 <code>target</code>，<strong>请你返回 <code>nums</code> 中能够凑出 <code>target</code> 的两个元素的值</strong>，比如输入 <code>nums = [1,3,5,6], target = 9</code>，那么算法返回两个元素 <code>[3,6]</code>。可以假设只有且仅有一对儿元素可以凑出 <code>target</code>。</p><p>我们可以先对 <code>nums</code> 排序，然后利用前文 <a href="https://labuladong.online/algo/essential-technique/array-two-pointers-summary/">双指针技巧</a> 写过的左右双指针技巧，从两端相向而行就行了：</p><p>java 🤖cpp 🟢python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：java 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span></span><br><span class="line"><span class="comment">// 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 cpp 代码对比查看。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数 nums 是长度为 n 的数组，target 是目标值</span></span><br><span class="line"><span class="comment">// 返回长度为 2 的数组，表示 nums 中恰好有两个元素的和为 target</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="comment">// 先对数组排序</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="comment">// 左右指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[lo] + nums[hi];</span><br><span class="line">        <span class="comment">// 根据 sum 和 target 的比较，移动左右指针</span></span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            lo++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            hi--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nums[lo], nums[hi]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以解决这个问题，力扣第 1 题「<a href="https://leetcode.cn/problems/two-sum/">两数之和open in new window</a>」和力扣第 167 题「<a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">两数之和 II - 输入有序数组open in new window</a>」稍加修改就可以用类似的思路解决，我这里就不写了。</p><p>不过我要继续魔改题目，把这个题目变得更泛化，更困难一点：</p><p><strong><code>nums</code> 中可能有多对儿元素之和都等于 <code>target</code>，请你的算法返回所有和为 <code>target</code> 的元素对儿，其中不能出现重复</strong>。</p><p>函数签名如下：</p><p>java 🤖cpp 🟢python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：java 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span></span><br><span class="line"><span class="comment">// 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 cpp 代码对比查看。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">twoSumTarget</span><span class="params">(List&lt;Integer&gt; nums, <span class="type">int</span> target)</span></span><br></pre></td></tr></table></figure><p>比如说输入为 <code>nums = [1,3,1,2,2,3], target = 4</code>，那么算法返回的结果就是：<code>[[1,3],[2,2]]</code>（注意，我要求返回元素，而不是索引）。</p><p>对于修改后的问题，关键难点是现在可能有多个和为 <code>target</code> 的数对儿，还不能重复，比如上述例子中 <code>[1,3]</code> 和 <code>[3,1]</code> 就算重复，只能算一次。</p><p>首先，基本思路肯定还是排序加双指针：</p><p>🌟</p><hr><p>🌟</p><p>java 🤖cpp 🟢python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：java 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span></span><br><span class="line"><span class="comment">// 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 cpp 代码对比查看。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">twoSumTarget</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// 先对数组排序</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[lo] + nums[hi];</span><br><span class="line">        <span class="comment">// 根据 sum 和 target 的比较，移动左右指针</span></span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            lo++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            hi--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;Integer&gt; pair = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            pair.add(nums[lo]);</span><br><span class="line">            pair.add(nums[hi]);</span><br><span class="line">            res.add(pair);</span><br><span class="line">            lo++;</span><br><span class="line">            hi--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这样实现会造成重复的结果，比如说 <code>nums = [1,1,1,2,2,3,3], target = 4</code>，得到的结果中 <code>[1,3]</code> 肯定会重复。</p><p>出问题的地方在于 <code>sum == target</code> 条件的 if 分支，当给 <code>res</code> 加入一次结果后，<code>lo</code> 和 <code>hi</code> 不仅应该相向而行，而且应该跳过所有重复的元素：</p><p><img src="https://labuladong.online/algo/images/nSum/1.jpeg" alt="img"></p><p>所以，可以对双指针的 while 循环做出如下修改：</p><p>java 🤖cpp 🟢python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：java 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span></span><br><span class="line"><span class="comment">// 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 cpp 代码对比查看。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[lo] + nums[hi];</span><br><span class="line">    <span class="comment">// 记录索引 lo 和 hi 最初对应的值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> nums[lo], right = nums[hi];</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; target)</span><br><span class="line">        lo++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target)</span><br><span class="line">        hi--;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        res.add(Arrays.asList(left, right));</span><br><span class="line">        <span class="comment">// 跳过所有重复的元素</span></span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以保证一个答案只被添加一次，重复的结果都会被跳过，可以得到正确的答案。不过，受这个思路的启发，其实前两个 if 分支也是可以做一点效率优化，跳过相同的元素：</p><p>java 🤖cpp 🟢python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：java 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span></span><br><span class="line"><span class="comment">// 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 cpp 代码对比查看。</span></span><br><span class="line"></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; <span class="title function_">twoSumTarget</span><span class="params">(List&lt;Integer&gt; nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// nums 数组必须有序</span></span><br><span class="line">    Collections.sort(nums);</span><br><span class="line">    <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums.get(lo) + nums.get(hi);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> nums.get(lo), right = nums.get(hi);</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums.get(lo) == left) lo++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums.get(hi) == right) hi--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.add(Arrays.asList(left, right));</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums.get(lo) == left) lo++;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums.get(hi) == right) hi--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，一个通用化的 <code>twoSum</code> 函数就写出来了，请确保你理解了该算法的逻辑，我们后面解决 <code>3Sum</code> 和 <code>4Sum</code> 的时候会复用这个函数。</p><p>这个函数的时间复杂度非常容易看出来，双指针操作的部分虽然有那么多 while 循环，但是时间复杂度还是 <code>O(N)</code>，而排序的时间复杂度是 <code>O(NlogN)</code>，所以这个函数的时间复杂度是 <code>O(NlogN)</code>。</p><h3 id="二、3Sum-问题"><a href="#二、3Sum-问题" class="headerlink" title="#二、3Sum 问题"></a><a href="https://labuladong.online/algo/practice-in-action/nsum/#%E4%BA%8C%E3%80%813sum-%E9%97%AE%E9%A2%98">#</a>二、3Sum 问题</h3><p>这是力扣第 15 题「<a href="https://leetcode.cn/problems/3sum/">三数之和open in new window</a>」：</p><details class="hint-container details" open="" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1rem 0px; padding: 1.5rem; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary style="position: relative; margin: -1.5rem -1.5rem 0.5em; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer;"><strong style="font-weight: 600;">15. 三数之和</strong>&nbsp;|<span>&nbsp;</span><a target="_blank" href="https://leetcode.cn/problems/3sum/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|<span>&nbsp;</span><a target="_blank" href="https://leetcode.com/problems/3sum/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个整数数组<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">nums</code><span>&nbsp;</span>，判断是否存在三元组<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">[nums[i], nums[j], nums[k]]</code><span>&nbsp;</span>满足<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">i != j</code>、<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">i != k</code><span>&nbsp;</span>且<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">j != k</code><span>&nbsp;</span>，同时还满足<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">nums[i] + nums[j] + nums[k] == 0</code><span>&nbsp;</span>。请</p><p style="line-height: 1.6; overflow-wrap: break-word;">你返回所有和为<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">0</code><span>&nbsp;</span>且不重复的三元组。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">注意：</strong>答案中不可以包含重复的三元组。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>nums = [-1,0,1,2,-1,-4]<strong style="font-weight: 600;">输出：</strong>[[-1,-1,2],[-1,0,1]]<strong style="font-weight: 600;">解释：</strong>nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>nums = [0,1,1]<strong style="font-weight: 600;">输出：</strong>[]<strong style="font-weight: 600;">解释：</strong>唯一可能的三元组和不为 0 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>nums = [0,0,0]<strong style="font-weight: 600;">输出：</strong>[[0,0,0]]<strong style="font-weight: 600;">解释：</strong>唯一可能的三元组和为 0 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">3 &lt;= nums.length &lt;= 3000</code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">-10<sup>5</sup><span>&nbsp;</span>&lt;= nums[i] &lt;= 10<sup>5</sup></code></li></ul></div></details><p>题目就是让我们找 <code>nums</code> 中和为 0 的三个元素，返回所有可能的三元组（triple），函数签名如下：</p><p>java 🤖cpp 🟢python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：java 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span></span><br><span class="line"><span class="comment">// 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 cpp 代码对比查看。</span></span><br><span class="line"></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span>;</span><br></pre></td></tr></table></figure><p>这样，我们再泛化一下题目，不要光和为 0 的三元组了，计算和为 <code>target</code> 的三元组吧，同上面的 <code>twoSum</code> 一样，也不允许重复的结果：</p><p>java 🤖cpp 🟢python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：java 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span></span><br><span class="line"><span class="comment">// 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 cpp 代码对比查看。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 求和为 0 的三元组</span></span><br><span class="line">    <span class="keyword">return</span> threeSumTarget(nums, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSumTarget</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// 输入数组 nums，返回所有和为 target 的三元组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题怎么解决呢？<strong>很简单，穷举呗</strong>。现在我们想找和为 <code>target</code> 的三个数字，那么对于第一个数字，可能是什么？<code>nums</code> 中的每一个元素 <code>nums[i]</code> 都有可能！</p><p>那么，确定了第一个数字之后，剩下的两个数字可以是什么呢？其实就是和为 <code>target - nums[i]</code> 的两个数字呗，那不就是 <code>twoSum</code> 函数解决的问题么🤔</p><p>可以直接写代码了，需要把 <code>twoSum</code> 函数稍作修改即可复用：</p><p>java 🤖cpp 🟢python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：java 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span></span><br><span class="line"><span class="comment">// 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 cpp 代码对比查看。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从 nums[start] 开始，计算有序数组</span></span><br><span class="line"><span class="comment"> * nums 中所有和为 target 的二元组 */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">twoSumTarget</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// 左指针改为从 start 开始，其他不变</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> start, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算数组 nums 中所有和为 target 的三元组 */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSumTarget</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// 数组得排个序</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 穷举 threeSum 的第一个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 对 target - nums[i] 计算 twoSum</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; tuples =</span><br><span class="line">            twoSumTarget(nums, i + <span class="number">1</span>, target - nums[i]);</span><br><span class="line">        <span class="comment">// 如果存在满足条件的二元组，再加上 nums[i] 就是结果三元组</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; tuple : tuples) &#123;</span><br><span class="line">            tuple.add(nums[i]);</span><br><span class="line">            res.add(tuple);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 跳过第一个数字重复的情况，否则会出现重复结果</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，类似 <code>twoSum</code>，<code>3Sum</code> 的结果也可能重复，比如输入是 <code>nums = [1,1,1,2,3], target = 6</code>，结果就会重复。</p><p><strong>关键点在于，不能让第一个数重复，至于后面的两个数，我们复用的 <code>twoSum</code> 函数会保证它们不重复</strong>。所以代码中必须用一个 while 循环来保证 <code>3Sum</code> 中第一个元素不重复。</p><p>至此，<code>3Sum</code> 问题就解决了，时间复杂度不难算，排序的复杂度为 <code>O(NlogN)</code>，<code>twoSumTarget</code> 函数中的双指针操作为 <code>O(N)</code>，<code>threeSumTarget</code> 函数在 for 循环中调用 <code>twoSumTarget</code> 所以总的时间复杂度就是 <code>O(NlogN + N^2) = O(N^2)</code>。</p><h3 id="三、4Sum-问题"><a href="#三、4Sum-问题" class="headerlink" title="#三、4Sum 问题"></a><a href="https://labuladong.online/algo/practice-in-action/nsum/#%E4%B8%89%E3%80%814sum-%E9%97%AE%E9%A2%98">#</a>三、4Sum 问题</h3><p>这是力扣第 18 题「<a href="https://leetcode.cn/problems/4sum/">四数之和open in new window</a>」：</p><details class="hint-container details" open="" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1rem 0px; padding: 1.5rem; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary style="position: relative; margin: -1.5rem -1.5rem 0.5em; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer;"><strong style="font-weight: 600;">18. 四数之和</strong>&nbsp;|<span>&nbsp;</span><a target="_blank" href="https://leetcode.cn/problems/4sum/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|<span>&nbsp;</span><a target="_blank" href="https://leetcode.com/problems/4sum/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个由<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">n</code><span>&nbsp;</span>个整数组成的数组&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">nums</code><span>&nbsp;</span>，和一个目标值<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">target</code><span>&nbsp;</span>。请你找出并返回满足下述全部条件且<strong style="font-weight: 600;">不重复</strong>的四元组&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">[nums[a], nums[b], nums[c], nums[d]]</code>&nbsp;（若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">0 &lt;= a, b, c, d&nbsp;&lt; n</code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">a</code>、<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">b</code>、<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">c</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">d</code><span>&nbsp;</span><strong style="font-weight: 600;">互不相同</strong></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">你可以按<span>&nbsp;</span><strong style="font-weight: 600;">任意顺序</strong><span>&nbsp;</span>返回答案 。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>nums = [1,0,-1,0,-2,2], target = 0<strong style="font-weight: 600;">输出：</strong>[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>nums = [2,2,2,2,2], target = 8<strong style="font-weight: 600;">输出：</strong>[[2,2,2,2]]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 &lt;= nums.length &lt;= 200</code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">-10<sup>9</sup><span>&nbsp;</span>&lt;= nums[i] &lt;= 10<sup>9</sup></code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">-10<sup>9</sup><span>&nbsp;</span>&lt;= target &lt;= 10<sup>9</sup></code></li></ul></div></details><p>函数签名如下：</p><p>java 🤖cpp 🟢python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：java 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span></span><br><span class="line"><span class="comment">// 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 cpp 代码对比查看。</span></span><br><span class="line"></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>;</span><br></pre></td></tr></table></figure><p>都到这份上了，<code>4Sum</code> 完全就可以用相同的思路：穷举第一个数字，然后调用 <code>3Sum</code> 函数计算剩下三个数，最后组合出和为 <code>target</code> 的四元组。</p><p>java 🤖cpp 🟢python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：java 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span></span><br><span class="line"><span class="comment">// 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 cpp 代码对比查看。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从 nums[start] 开始，计算有序数组</span></span><br><span class="line"><span class="comment"> * nums 中所有和为 target 的三元组 */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSumTarget</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// i 从 start 开始穷举，其他都不变</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; n; i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 穷举 fourSum 的第一个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 对 target - nums[i] 计算 threeSum</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; </span><br><span class="line">            triples = threeSumTarget(nums, i + <span class="number">1</span>, target - nums[i]);</span><br><span class="line">        <span class="comment">// 如果存在满足条件的三元组，再加上 nums[i] 就是结果四元组</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; triple : triples) &#123;</span><br><span class="line">            triple.add(nums[i]);</span><br><span class="line">            res.add(triple);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fourSum 的第一个数不能重复</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，按照相同的套路，<code>4Sum</code> 问题就解决了，时间复杂度的分析和之前类似，for 循环中调用了 <code>threeSumTarget</code> 函数，所以总的时间复杂度就是 <code>O(N^3)</code>。</p><p>注意我们把 <code>threeSumTarget</code> 函数签名中的 <code>target</code> 变量设置为 <code>long</code> 类型，因为本题说了 <code>nums[i]</code> 和 <code>target</code> 的取值都是 <code>[-10^9, 10^9]</code>，<code>int</code> 类型的话会造成溢出。</p><h3 id="四、100Sum-问题？"><a href="#四、100Sum-问题？" class="headerlink" title="#四、100Sum 问题？"></a><a href="https://labuladong.online/algo/practice-in-action/nsum/#%E5%9B%9B%E3%80%81100sum-%E9%97%AE%E9%A2%98">#</a>四、100Sum 问题？</h3><p>在 LeetCode 上，<code>4Sum</code> 就到头了，<strong>但是回想刚才写 <code>3Sum</code> 和 <code>4Sum</code> 的过程，实际上是遵循相同的模式的</strong>。我相信你只要稍微修改一下 <code>4Sum</code> 的函数就可以复用并解决 <code>5Sum</code> 问题，然后解决 <code>6Sum</code> 问题……</p><p>那么，如果我让你求 <code>100Sum</code> 问题，怎么办呢？其实我们可以观察上面这些解法，统一出一个 <code>nSum</code> 函数：</p><p>java 🤖cpp 🟢python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：java 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span></span><br><span class="line"><span class="comment">// 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 cpp 代码对比查看。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注意：调用这个函数之前一定要先给 nums 排序 */</span></span><br><span class="line"><span class="comment">// n 填写想求的是几数之和，start 从哪个索引开始计算（一般填 0），target 填想凑出的目标和</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">nSumTarget</span><span class="params">(</span></span><br><span class="line"><span class="params">    List&lt;Integer&gt; nums, <span class="type">int</span> n, <span class="type">int</span> start, <span class="type">long</span> target)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> nums.size();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 至少是 2Sum，且数组大小不应该小于 n</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span> || sz &lt; n) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// 2Sum 是 base case</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 双指针那一套操作</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> start, hi = sz - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums.get(lo) + nums.get(hi);</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> nums.get(lo), right = nums.get(hi);</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums.get(lo) == left) lo++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums.get(hi) == right) hi--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.add(Arrays.asList(left, right));</span><br><span class="line">                <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums.get(lo) == left) lo++;</span><br><span class="line">                <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums.get(hi) == right) hi--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// n &gt; 2 时，递归计算 (n-1)Sum 的结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; sz; i++) &#123;</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; </span><br><span class="line">                sub = nSumTarget(nums, n - <span class="number">1</span>, i + <span class="number">1</span>, target - nums.get(i));</span><br><span class="line">            <span class="keyword">for</span> (List&lt;Integer&gt; arr : sub) &#123;</span><br><span class="line">                <span class="comment">// (n-1)Sum 加上 nums[i] 就是 nSum</span></span><br><span class="line">                arr.add(nums.get(i));</span><br><span class="line">                res.add(arr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; sz - <span class="number">1</span> &amp;&amp; nums.get(i) == nums.get(i + <span class="number">1</span>)) i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，看起来很长，实际上就是把之前的题目解法合并起来了，<code>n == 2</code> 时是 <code>twoSum</code> 的双指针解法，<code>n &gt; 2</code> 时就是穷举第一个数字，然后递归调用计算 <code>(n-1)Sum</code>，组装答案。</p><p>根据之前几道题的时间复杂度可以推算，本函数的时间复杂度应该是 <code>O(N^(n-1))</code>，<code>N</code> 为数组的长度，<code>n</code> 为组成和的数字的个数。</p><p><strong>需要注意的是，调用这个 <code>nSumTarget</code> 函数之前一定要先给 <code>nums</code> 数组排序</strong>，因为 <code>nSumTarget</code> 是一个递归函数，如果在 <code>nSumTarget</code> 函数里调用排序函数，那么每次递归都会进行没有必要的排序，效率会非常低。</p><p>比如说现在我们写 LeetCode 上的 <code>4Sum</code> 问题：</p><p>java 🤖cpp 🟢python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：java 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span></span><br><span class="line"><span class="comment">// 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 cpp 代码对比查看。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="comment">// n 为 4，从 nums[0] 开始计算和为 target 的四元组</span></span><br><span class="line">    <span class="keyword">return</span> nSumTarget(nums, <span class="number">4</span>, <span class="number">0</span>, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details data-v-fb30874b="" id="div_4sum" class="hint-container details" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1.6em 0px; padding: 1rem 0px 0px; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary data-v-fb30874b="" style="position: relative; margin: -1.5rem 0px -0.5rem; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer; display: flex; align-items: center; font-size: large;"><strong data-v-fb30874b="" style="font-weight: 600;">🌈 代码可视化动画 🌈</strong><span data-v-fb30874b="" class="font-icon icon iconfont icon-resize" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-left: auto; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-refresh" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-link" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle;"></span></summary><div data-v-fb30874b="" class="resizable" style="width: 774.091px; max-width: 100%; height: 70vh; max-height: 70vh; overflow: auto; resize: both;"><iframe data-v-fb30874b="" id="iframe_4sum" src="https://labuladong.online/algo-visualize/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>再比如 LeetCode 的 <code>3Sum</code> 问题，找 <code>target == 0</code> 的三元组：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// n 为 3，从 nums[0] 开始计算和为 0 的三元组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">nSumTarget</span>(nums, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details data-v-fb30874b="" id="div_3sum" class="hint-container details" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1.6em 0px; padding: 1rem 0px 0px; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary data-v-fb30874b="" style="position: relative; margin: -1.5rem 0px -0.5rem; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer; display: flex; align-items: center; font-size: large;"><strong data-v-fb30874b="" style="font-weight: 600;">🌈 代码可视化动画 🌈</strong><span data-v-fb30874b="" class="font-icon icon iconfont icon-resize" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-left: auto; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-refresh" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-link" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle;"></span></summary><div data-v-fb30874b="" class="resizable" style="width: 774.091px; max-width: 100%; height: 70vh; max-height: 70vh; overflow: auto; resize: both;"><iframe data-v-fb30874b="" id="iframe_3sum" src="https://labuladong.online/algo-visualize/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>那么，如果让你计算 <code>100Sum</code> 问题，直接调用这个函数就完事儿了。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法时空复杂度分析实用指南</title>
      <link href="/posts/44500.html"/>
      <url>/posts/44500.html</url>
      
        <content type="html"><![CDATA[<h1 id="算法时空复杂度分析实用指南"><a href="#算法时空复杂度分析实用指南" class="headerlink" title="算法时空复杂度分析实用指南"></a>算法时空复杂度分析实用指南</h1><p>我以前的文章主要都是讲解算法的原理和解题的思维，对时间复杂度和空间复杂度的分析经常一笔带过，主要是基于以下两个原因：</p><p>1、对于偏小白的读者，我希望你集中精力理解算法原理。如果加入太多偏数学的内容，很容易把人劝退。</p><p>2、正确理解常用算法底层原理，是进行复杂度的分析的前提。尤其是递归相关的算法，只有你从树的角度进行思考和分析，才能正确分析其复杂度。</p><p>鉴于现在历史文章已经涵盖了所有常见算法的核心原理，所以我专门写一篇时空复杂度的分析指南，授人以鱼不如授人以渔，教给你一套通用的方法分析任何算法的时空复杂度。</p><p>本文会篇幅较长，会涵盖如下几点：</p><p>1、Big O 表示法的几个基本特点。</p><p>2、非递归算法中的时间复杂度分析。</p><p>3、数据结构 API 的效率衡量方法（摊还分析）。</p><p>4、递归算法的时间&#x2F;空间复杂度的分析方法，这部分是重点，我会用动态规划和回溯算法举例。</p><p>废话不多说了，接下来一个个看。</p><h3 id="Big-O-表示法"><a href="#Big-O-表示法" class="headerlink" title="#Big O 表示法"></a><a href="https://labuladong.online/algo/essential-technique/complexity-analysis/#big-o-%E8%A1%A8%E7%A4%BA%E6%B3%95">#</a>Big O 表示法</h3><p>首先看一下 Big O 记号的数学定义：</p><blockquote><p><code>O(g(n))</code> &#x3D; { <code>f(n)</code>: 存在正常量 <code>c</code> 和 <code>n_0</code>，使得对所有 <code>n ≥ n_0</code>，有 <code>0 ≤ f(n) ≤ c*g(n)</code> }</p></blockquote><p>我们常用的这个符号 <code>O</code> 其实代表一个函数的集合，比如 <code>O(n^2)</code> 代表着一个由 <code>g(n) = n^2</code> 派生出来的一个函数集合；我们说一个算法的时间复杂度为 <code>O(n^2)</code>，意思就是描述该算法的复杂度的函数属于这个函数集合之中。</p><p><strong>理论上，你看明白这个抽象的数学定义，就可以解答你关于 Big O 表示法的一切疑问了</strong>。</p><p>但考虑到大部分人看到数学定义就头晕，我给你列举两个复杂度分析中会用到的特性，记住这两个就够用了。</p><p><strong>1、只保留增长速率最快的项，其他的项可以省略</strong>。</p><p>首先，乘法和加法中的常数因子都可以忽略不计，比如下面的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">O(2N + <span class="number">100</span>) = O(N)</span><br><span class="line">O(<span class="number">2</span>^(N+<span class="number">1</span>)) = O(<span class="number">2</span> * <span class="number">2</span>^N) = O(<span class="number">2</span>^N)</span><br><span class="line">O(M + 3N + <span class="number">99</span>) = O(M + N)</span><br></pre></td></tr></table></figure><p>当然，不要见到常数就消，有的常数消不得：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">O(<span class="number">2</span>^(2N)) = O(<span class="number">4</span>^N)</span><br></pre></td></tr></table></figure><p>除了常数因子，增长速率慢的项在增长速率快的项面前也可以忽略不计：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">O(N^<span class="number">3</span> + <span class="number">999</span> * N^<span class="number">2</span> + <span class="number">999</span> * N) = O(N^<span class="number">3</span>)</span><br><span class="line">O((N + <span class="number">1</span>) * <span class="number">2</span>^N) = O(N * <span class="number">2</span>^N + <span class="number">2</span>^N) = O(N * <span class="number">2</span>^N)</span><br></pre></td></tr></table></figure><p>以上列举的都是最简单常见的例子，这些例子都可以被 Big O 记号的定义正确解释。如果你遇到更复杂的复杂度场景，也可以根据定义来判断自己的复杂度表达式是否正确。</p><p><strong>2、Big O 记号表示复杂度的「上界」</strong>。</p><p>换句话说，只要你给出的是一个上界，用 Big O 记号表示就都是正确的。</p><p>比如如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    print(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果说这是一个算法，那么显然它的时间复杂度是 <code>O(N)</code>。但如果你非要说它的时间复杂度是 <code>O(N^2)</code>，理论上讲是可以的，因为 <code>O</code> 记号表示一个上界嘛，这个算法的时间复杂度确实不会超过 <code>N^2</code> 这个上界呀，虽然这个上界不够「紧」，但符合定义，所以理论上说也没毛病。</p><p>上述例子太简单，非要扩大它的时间复杂度上界显得没什么意义。但有些算法的复杂度会和算法的输入数据有关，没办法提前给出一个特别精确的时间复杂度，那么在这种情况下，用 Big O 记号扩大时间复杂度的上界就变得有意义了。</p><p>比如前文 <a href="https://labuladong.online/algo/essential-technique/dynamic-programming-framework/">动态规划核心框架</a> 中讲到的凑零钱问题的暴力递归解法，核心代码框架如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：要凑出金额 n，至少要 dp(coins, n) 个硬币</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (amount &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;</span><br><span class="line">        dp(coins, amount - coin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>amount = 11, coins = [1,2,5]</code> 时，算法的递归树就长这样：</p><p><img src="https://labuladong.online/algo/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/5.jpg" alt="img"></p><p>后文会具体讲递归算法的时间复杂度计算方法，现在我们先求一下这棵递归树上的节点个数吧。</p><p>假设金额 <code>amount</code> 的值为 <code>N</code>，<code>coins</code> 列表中元素个数为 <code>K</code>，那么这棵递归树就是一棵 <code>K</code> 叉树。但这棵树的生长和 <code>coins</code> 列表中的硬币面额有直接的关系，所以这棵树的形状会很不规则，导致我们很难精确地求出树上节点的总数。</p><p>对于这种情况，比较简单的处理方式就是按最坏情况做近似处理：</p><p>这棵树的高度有多高？不知道，那就按最坏情况来处理，假设全都是面额为 1 的硬币，这种情况下树高为 <code>N</code>。</p><p>这棵树的结构是什么样的？不知道，那就按最坏情况来处理，假设它是一棵满 <code>K</code> 叉树好了。</p><p>那么，这棵树上共有多少节点？都按最坏情况来处理，高度为 <code>N</code> 的一棵满 <code>K</code> 叉树，其节点总数为等比数列求和公式 <code>(K^N - 1)/(K - 1)</code>，用 Big O 表示就是 <code>O(K^N)</code>。</p><p>当然，我们知道这棵树上的节点数其实没有这么多，但用 <code>O(K^N)</code> 表示一个上界是没问题的。</p><p><strong>所以，有时候你自己估算出来的时间复杂度和别人估算的复杂度不同，并不一定代表谁算错了，可能你俩都是对的，只是是估算的精度不同</strong>。</p><p>理论上，我们当然希望得到一个比较准确比较「紧」的上界，但想得到准确的上界对数学的功力有一定要求，我们针对面试刷题的话不妨退而求其次，只要数量级（线性&#x2F;指数级&#x2F;对数级&#x2F;平方级等）能对上就没问题。</p><p>在算法领域，除了用 Big O 表示渐进上界，还有渐进下界、渐进紧确界等边界的表示方法，有兴趣的读者可以自行搜索。不过从实用的角度看，以上对 Big O 记号表示法的讲解就够用了。</p><h3 id="非递归算法分析"><a href="#非递归算法分析" class="headerlink" title="#非递归算法分析"></a><a href="https://labuladong.online/algo/essential-technique/complexity-analysis/#%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90">#</a>非递归算法分析</h3><p>非递归算法的空间复杂度一般很容易计算，你看它有没有申请数组之类的存储空间就行了，所以我主要说下时间复杂度的分析。</p><p>🌟</p><hr><p>🌟</p><p>非递归算法中嵌套循环很常见，大部分场景下，只需把每一层的复杂度相乘就是总的时间复杂度：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 复杂度 O(N*W)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> <span class="number">1</span>; w &lt;= W; w++) &#123;</span><br><span class="line">        dp[i][w] = ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 + 2 + ... + n = n/2 + (n^2)/2</span></span><br><span class="line"><span class="comment">// 用 Big O 表示化简为 O(n^2)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">        dp[i][j] = ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但有时候只看嵌套循环的层数并不准确，还得看算法<strong>具体在做什么</strong>，比如前文 <a href="https://labuladong.online/algo/practice-in-action/nsum/">一文秒杀所有 nSum 问题</a> 中就有这样一段代码：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 左右双指针</span></span><br><span class="line"><span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>, hi = nums.length;</span><br><span class="line"><span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[lo] + nums[hi];</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> nums[lo], right = nums[hi];</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码看起来很复杂，大 while 循环里面套了好多小 while 循环，感觉这段代码的时间复杂度应该是 <code>O(N^2)</code>（<code>N</code> 代表 <code>nums</code> 的长度）？</p><p><strong>其实，你只需要搞清楚代码到底在干什么，就能轻松计算出正确的复杂度了</strong>。</p><p>这段代码就是个 <a href="https://labuladong.online/algo/essential-technique/array-two-pointers-summary/">左右双指针</a> 嘛，<code>lo</code> 是左边的指针，<code>hi</code> 是右边的指针，这两个指针相向而行，相遇时外层 while 结束。</p><p>甭管多复杂的逻辑，你看 <code>lo</code> 指针一直在往右走（<code>lo++</code>），<code>hi</code> 指针一直在往左走（<code>hi--</code>），它俩有没有回退过？没有。</p><p>所以这段算法的逻辑就是 <code>lo</code> 和 <code>hi</code> 不断相向而行，相遇时算法结束，那么它的时间复杂度就是线性的 <code>O(N)</code>。</p><p>类似的，你看前文 <a href="https://labuladong.online/algo/essential-technique/sliding-window-framework/">滑动窗口算法核心框架</a> 给出的滑动窗口算法模板：</p><p>java 🤖cpp 🟢python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：java 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span></span><br><span class="line"><span class="comment">// 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 cpp 代码对比查看。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">slidingWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; need = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t.toCharArray()) &#123;</span><br><span class="line">        need.put(c, need.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 双指针，维护 [left, right) 为窗口</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">        <span class="comment">// 增大窗口</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">        right++;</span><br><span class="line">        window.put(c, window.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window.get(c) &gt; need.getOrDefault(c, <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">            <span class="comment">// 缩小窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            window.put(d, window.getOrDefault(d, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍一看也是个嵌套循环，但仔细观察，发现这也是个双指针技巧，<code>left</code> 和 <code>right</code> 指针从 0 开始，一直向右移，直到移动到 <code>s</code> 的末尾结束外层 while 循环，没有回退过。</p><p>那么该算法做的事情就是把 <code>left</code> 和 <code>right</code> 两个指针从 0 移动到 <code>N</code>（<code>N</code> 代表字符串 <code>s</code> 的长度），所以滑动窗口算法的时间复杂度为线性的 <code>O(N)</code>。</p><h3 id="数据结构分析"><a href="#数据结构分析" class="headerlink" title="#数据结构分析"></a><a href="https://labuladong.online/algo/essential-technique/complexity-analysis/#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90">#</a>数据结构分析</h3><p>因为数据结构会用来存储数据，其 API 的执行效率可能受到其中存储的数据的影响，所以衡量数据结构 API 效率的方法和衡量普通算法函数效率的方法是有一些区别的。</p><p>就拿我们常见的数据结构举例，比如很多语言都提供动态数组，可以自动进行扩容和缩容。在它的尾部添加元素的时间复杂度是 <code>O(1)</code>。但当底层数组扩容时会分配新内存并把原来的数据搬移到新数组中，这个时间复杂度就是 <code>O(N)</code> 了，那我们能说在数组尾部添加元素的时间复杂度就是 <code>O(N)</code> 吗？</p><p>再比如哈希表也会在负载因子达到某个阈值时进行扩容和 rehash，时间复杂度也会达到 <code>O(N)</code>，那么我们为什么还说哈希表对单个键值对的存取效率是 <code>O(1)</code> 呢？</p><p>提示</p><p>我的 <a href="https://labuladong.online/algo/ds-class/">数据结构精品课</a> 中有具体介绍常用数据结构的底层原理，有兴趣的读者可以参考。</p><p>答案就是，<strong>如果想衡量数据结构类中的某个方法的时间复杂度，不能简单地看最坏时间复杂度，而应该看摊还（平均）时间复杂度</strong>。</p><p>比如说后文 <a href="https://labuladong.online/algo/data-structure/monotonic-queue/">特殊数据结构：单调队列</a> 实现的单调队列类：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 单调队列的实现 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonotonicQueue</span> &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">        <span class="comment">// 将小于 e 的元素全部删除</span></span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty() &amp;&amp; q.getLast() &lt; e) &#123;</span><br><span class="line">            q.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        q.addLast(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">        <span class="comment">// e 可能已经在 push 的时候被删掉了</span></span><br><span class="line">        <span class="comment">// 所以需要额外判断一下</span></span><br><span class="line">        <span class="keyword">if</span> (e == q.getFirst()) &#123;</span><br><span class="line">            q.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准的队列实现中，<code>push</code> 和 <code>pop</code> 方法的时间复杂度应该都是 <code>O(1)</code>，但这个 <code>MonotonicQueue</code> 类的 <code>push</code> 方法包含一个循环，其复杂度取决于参数 <code>e</code>，最好情况下是 <code>O(1)</code>，而最坏情况下复杂度应该是 <code>O(N)</code>，<code>N</code> 为队列中的元素个数。</p><p>对于这种情况，我们用平均时间复杂度来衡量 <code>push</code> 方法的效率比较合理。虽然它包含循环，但它的平均时间复杂度依然为 <code>O(1)</code>。</p><p><strong>计算平均时间复杂度最常用的方法叫做「聚合分析」，思路如下</strong>：</p><p>给你一个空的 <code>MonotonicQueue</code>，然后请你执行 <code>N</code> 个 <code>push, pop</code> 组成的操作序列，请问这 <code>N</code> 个操作所需的总时间复杂度是多少？</p><p>因为这 <code>N</code> 个操作最多就是让 <code>O(N)</code> 个元素入队再出队，每个元素只会入队和出队一次，所以这 <code>N</code> 个操作的总时间复杂度是 <code>O(N)</code>。</p><p>那么平均下来，一次操作的时间复杂度就是 <code>O(N)/N = O(1)</code>，也就是说 <code>push</code> 和 <code>pop</code> 方法的平均时间复杂度都是 <code>O(1)</code>。</p><p>类似的，想想之前说的数据结构扩容的场景，你添加 <code>N</code> 个元素，也许 <code>N</code> 次操作中的某一次操作恰好触发了扩容，导致时间复杂度提高，但不可能每次操作都触发扩容吧？所以总的时间复杂度依然保持在 <code>O(N)</code>，均摊到每一次操作上，其平均时间复杂度依然是 <code>O(1)</code>。</p><h3 id="递归算法分析"><a href="#递归算法分析" class="headerlink" title="#递归算法分析"></a><a href="https://labuladong.online/algo/essential-technique/complexity-analysis/#%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90">#</a>递归算法分析</h3><p>对很多人来说，递归算法的时间复杂度是比较难分析的。但如果你有 <a href="https://labuladong.online/algo/essential-technique/abstraction-of-algorithm/">框架思维</a>，明白所有递归算法的本质是树的遍历，那么分析起来应该没什么难度。</p><p>计算算法的时间复杂度，无非就是看这个算法做了些啥事儿，花了多少时间。而递归算法做的事情就是遍历一棵递归树，在树上的每个节点所做一些事情罢了。</p><p>所以：</p><p><strong>递归算法的时间复杂度 &#x3D; 递归的次数 x 函数本身的时间复杂度</strong></p><p><strong>递归算法的空间复杂度 &#x3D; 递归堆栈的深度 + 算法申请的存储空间</strong></p><p>或者再说得直观一点：</p><p><strong>递归算法的时间复杂度 &#x3D; 递归树的节点个数 x 每个节点的时间复杂度</strong></p><p><strong>递归算法的空间复杂度 &#x3D; 递归树的高度 + 算法申请的存储空间</strong></p><p>函数递归的原理是操作系统维护的函数堆栈，所以递归栈的空间消耗也需要算在空间复杂度之内，这一点不要忘了。</p><p><strong>首先说一下动态规划算法</strong>，还是拿前文 <a href="https://labuladong.online/algo/essential-technique/dynamic-programming-framework/">动态规划核心框架</a> 中讲到的凑零钱问题举例，它的暴力递归解法主体如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="comment">// 时间 O(K)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">subProblem</span> <span class="operator">=</span> dp(coins, amount - coin);</span><br><span class="line">        <span class="keyword">if</span> (subProblem == -<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        res = Math.min(res, subProblem + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res == Integer.MAX_VALUE ? -<span class="number">1</span> : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>amount = 11, coins = [1,2,5]</code> 时，该算法的递归树就长这样：</p><p><img src="https://labuladong.online/algo/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/5.jpg" alt="img"></p><p>刚才说了这棵树上的节点个数为 <code>O(K^N)</code>，那么每个节点消耗的时间复杂度是多少呢？其实就是这个 <code>dp</code> 函数本身的复杂度。</p><p>你看 <code>dp</code> 函数里面有个 for 循环遍历长度为 <code>K</code> 的 <code>coins</code> 列表，所以函数本身的复杂度为 <code>O(K)</code>，故该算法总的时间复杂度为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">O(K^N) * O(K) = O(K^(N+<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>当然，之前也说了，这个复杂度只是一个粗略的上界，并不准确，真实的效率肯定会高一些。</p><p>这个算法的空间复杂度很容易分析：</p><p><code>dp</code> 函数本身没有申请数组之类的，所以算法申请的存储空间为 <code>O(1)</code>；而 <code>dp</code> 函数的堆栈深度为递归树的高度 <code>O(N)</code>，所以这个算法的空间复杂度为 <code>O(N)</code>。</p><p>暴力递归解法的分析结束，但这个解法存在重叠子问题，通过备忘录消除重叠子问题的冗余计算之后，相当于在原来的递归树上进行剪枝：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 备忘录，空间 O(N)</span></span><br><span class="line">memo = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">Arrays.fill(memo, -<span class="number">666</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 查备忘录，防止重复计算</span></span><br><span class="line">    <span class="keyword">if</span> (memo[amount] != -<span class="number">666</span>)</span><br><span class="line">        <span class="keyword">return</span> memo[amount];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="comment">// 时间 O(K)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">subProblem</span> <span class="operator">=</span> dp(coins, amount - coin);</span><br><span class="line">        <span class="keyword">if</span> (subProblem == -<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        res = Math.min(res, subProblem + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把计算结果存入备忘录</span></span><br><span class="line">    memo[amount] = (res == Integer.MAX_VALUE) ? -<span class="number">1</span> : res;</span><br><span class="line">    <span class="keyword">return</span> memo[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过备忘录剪掉了大量节点之后，虽然函数本身的时间复杂度依然是 <code>O(K)</code>，但大部分递归在函数开头就立即返回了，根本不会执行到 for 循环那里，所以可以认为递归函数执行的次数（递归树上的节点）减少了，从而时间复杂度下降。</p><p>剪枝之后还剩多少节点呢？根据备忘录剪枝的原理，相同「状态」不会被重复计算，所以剪枝之后剩下的节点数就是「状态」的数量，即 <code>memo</code> 的大小 <code>N</code>。</p><p>所以，对于带备忘录的动态规划算法的时间复杂度，以下几种理解方式都是等价的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  递归的次数 x 函数本身的时间复杂度</span><br><span class="line">= 递归树节点个数 x 每个节点的时间复杂度</span><br><span class="line">= 状态个数 x 计算每个状态的时间复杂度</span><br><span class="line">= 子问题个数 x 解决每个子问题的时间复杂度</span><br><span class="line">= O(N) * O(K)</span><br><span class="line">= O(NK)</span><br></pre></td></tr></table></figure><p>像「状态」「子问题」属于动态规划类型问题特有的词汇，但时间复杂度本质上还是递归次数 x 函数本身复杂度，换汤不换药罢了。反正你爱怎么说怎么说吧，别把自己绕进去就行。</p><p>备忘录优化解法的空间复杂度也不难分析：</p><p><code>dp</code> 函数的堆栈深度为「状态」的个数，依然是 <code>O(N)</code>，而算法申请了一个大小为 <code>O(N)</code> 的备忘录 <code>memo</code> 数组，所以总的空间复杂度为 <code>O(N) + O(N) = O(N)</code>。</p><p>虽然用 Big O 表示法来看，优化前后的空间复杂度相同，不过显然优化解法消耗的空间要更多，所以用备忘录进行剪枝也被称为「用空间换时间」。</p><p>如果你把自顶向下带备忘录的解法进一步改写成自底向上的迭代解法：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="comment">// 空间 O(N)</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 时间 O(KN)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - coin &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i] = Math.min(dp[i], <span class="number">1</span> + dp[i - coin]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (dp[amount] == amount + <span class="number">1</span>) ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该解法的时间复杂度不变，但已经不存在递归，所以空间复杂度中不需要考虑堆栈的深度，只需考虑 <code>dp</code> 数组的存储空间，虽然用 Big O 表示法来看，该算法的空间复杂度依然是 <code>O(N)</code>，但该算法的实际空间消耗是更小的，所以自底向上迭代的动态规划是各方面性能最好的。</p><p><strong>接下来说一下回溯算法</strong>，需要你看过前文 <a href="https://labuladong.online/algo/essential-technique/permutation-combination-subset-all-in-one/">回溯算法秒杀排列组合问题的 9 种变体</a>，下面我会以标准的全排列问题和子集问题的解法为例，分析一下其时间复杂度。</p><p><strong>先看标准全排列问题</strong>（元素无重不可复选）的核心函数 <code>backtrack</code>：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回溯算法计算全排列</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">// 到达叶子节点，收集路径值，时间 O(N)</span></span><br><span class="line">    <span class="keyword">if</span> (track.size() == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非叶子节点，遍历所有子节点，时间 O(N)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">            <span class="comment">// 剪枝逻辑</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        track.addLast(nums[i]);</span><br><span class="line">        backtrack(nums);</span><br><span class="line">        <span class="comment">// 取消选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>nums = [1,2,3]</code> 时，<code>backtrack</code> 其实在遍历这棵递归树：</p><p><img src="/%E7%AE%97%E6%B3%95%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97.assets/7-17079252851306.jpeg" alt="img"></p><p>假设输入的 <code>nums</code> 数组长度为 <code>N</code>，那么这个 <code>backtrack</code> 函数递归了多少次？<code>backtrack</code> 函数本身的复杂度是多少？</p><p>先看看 <code>backtrack</code> 函数本身的时间复杂度，即树中每个节点的复杂度。</p><p>对于非叶子节点，会执行 for 循环，复杂度为 <code>O(N)</code>；对于叶子节点，不会执行循环，但将 <code>track</code> 中的值拷贝到 <code>res</code> 列表中也需要 <code>O(N)</code> 的时间，**所以 <code>backtrack</code> 函数本身的时间复杂度为 <code>O(N)</code>**。</p><p>注</p><p>函数本身（每个节点）的时间复杂度并不是树枝的条数。看代码，每个节点都会执行整个 for 循环，所以每个节点的复杂度都是 <code>O(N)</code>。</p><p>再来看看 <code>backtrack</code> 函数递归了多少次，即这个排列树上有多少个节点。</p><p>第 0 层（根节点）有 <code>P(N, 0) = 1</code> 个节点。</p><p>第 1 层有 <code>P(N, 1) = N</code> 个节点。</p><p>第 2 层有 <code>P(N, 2) = N x (N - 1)</code> 个节点。</p><p>第 3 层有 <code>P(N, 3) = N x (N - 1) x (N - 2)</code> 个节点。</p><p>以此类推，其中 <code>P</code> 就是我们高中学过的排列数函数。</p><p>全排列的回溯树高度为 <code>N</code>，所以节点总数为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">P(N, <span class="number">0</span>) + P(N, <span class="number">1</span>) + P(N, <span class="number">2</span>) + ... + P(N, N)</span><br></pre></td></tr></table></figure><p>这一堆排列数累加不好算，粗略估计一下上界吧，把它们全都扩大成 <code>P(N, N) = N!</code>，**那么节点总数的上界就是 <code>O(N\*N!)</code>**。</p><p>现在就可以得出算法的总时间复杂度：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  递归的次数 x 函数本身的时间复杂度</span><br><span class="line">= 递归树节点个数 x 每个节点的时间复杂度</span><br><span class="line">= O(N*N!) * O(N)</span><br><span class="line">= O(N^<span class="number">2</span> * N!)</span><br></pre></td></tr></table></figure><p>当然，由于计算节点总数的时候我们为了方便计算把累加项扩大了很多，所以这个结果肯定也是偏大的，不过用来描述复杂度的上界还是可以接受的。</p><p>分析下该算法的空间复杂度：</p><p><code>backtrack</code> 函数的递归深度为递归树的高度 <code>O(N)</code>，而算法需要存储所有全排列的结果，即需要申请的空间为 <code>O(N*N!)</code>。**所以总的空间复杂度为 <code>O(N\*N!)</code>**。</p><p><strong>最后看下标准子集问题</strong>（元素无重不可复选）的核心函数 <code>backtrack</code>：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回溯算法计算所有子集（幂集）</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个节点的值都是一个子集，O(N)</span></span><br><span class="line">    res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(track));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历子节点，O(N)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.addLast(nums[i]);</span><br><span class="line">        backtrack(nums, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>nums = [1,2,3]</code> 时，<code>backtrack</code> 其实在遍历这棵递归树：</p><p><img src="/%E7%AE%97%E6%B3%95%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97.assets/5-17079252851308.jpeg" alt="img"></p><p>假设输入的 <code>nums</code> 数组长度为 <code>N</code>，那么这个 <code>backtrack</code> 函数递归了多少次？<code>backtrack</code> 函数本身的复杂度是多少？</p><p>先看看 <code>backtrack</code> 函数本身的时间复杂度，即树中每个节点的复杂度。</p><p><code>backtrack</code> 函数在前序位置都会将 <code>track</code> 列表拷贝到 <code>res</code> 中，消耗 <code>O(N)</code> 的时间，且会执行一个 for 循环，也消耗 <code>O(N)</code> 的时间，**所以 <code>backtrack</code> 函数本身的时间复杂度为 <code>O(N)</code>**。</p><p>再来看看 <code>backtrack</code> 函数递归了多少次，即这个排列树上有多少个节点。</p><p>那就直接看图一层一层数呗：</p><p>第 0 层（根节点）有 <code>C(N, 0) = 1</code> 个节点。</p><p>第 1 层有 <code>C(N, 1) = N</code> 个节点。</p><p>第 2 层有 <code>C(N, 2)</code> 个节点。</p><p>第 3 层有 <code>C(N, 3)</code> 个节点。</p><p>以此类推，其中 <code>C</code> 就是我们高中学过的组合数函数。</p><p>由于这棵组合树的高度为 <code>N</code>，组合数求和公式是高中学过的，**所以总的节点数为 <code>2^N</code>**：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">C(N, <span class="number">0</span>) + C(N, <span class="number">1</span>) + C(N, <span class="number">2</span>) + ... + C(N, N) = <span class="number">2</span>^N</span><br></pre></td></tr></table></figure><p>就算你忘记了组合数求和公式，其实也可以推导出来节点总数：因为 <code>N</code> 个元素的所有子集（幂集）数量为 <code>2^N</code>，而这棵树的每个节点代表一个子集，所以树的节点总数也为 <code>2^N</code>。</p><p>那么，现在就可以得出算法的总复杂度：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  递归的次数 x 函数本身的时间复杂度</span><br><span class="line">= 递归树节点个数 x 每个节点的时间复杂度</span><br><span class="line">= O(<span class="number">2</span>^N) * O(N)</span><br><span class="line">= O(N*<span class="number">2</span>^N)</span><br></pre></td></tr></table></figure><p>分析下该算法的空间复杂度：</p><p><code>backtrack</code> 函数的递归深度为递归树的高度 <code>O(N)</code>，而算法需要存储所有子集的结果，粗略估算下需要申请的空间为 <code>O(N*2^N)</code>，**所以总的空间复杂度为 <code>O(N\*2^N)</code>**。</p><p>到这里，标准排列&#x2F;子集问题的时间复杂度就分析完了，前文 <a href="https://labuladong.online/algo/essential-technique/permutation-combination-subset-all-in-one/">回溯算法秒杀排列组合问题的 9 种变体</a> 中的其他问题变形都可以按照类似的逻辑分析，这些就留给你自己分析吧。</p><h3 id="最后总结"><a href="#最后总结" class="headerlink" title="#最后总结"></a><a href="https://labuladong.online/algo/essential-technique/complexity-analysis/#%E6%9C%80%E5%90%8E%E6%80%BB%E7%BB%93">#</a>最后总结</h3><p>本文篇幅较大，我简单总结下重点：</p><p>1、Big O 标记代表一个函数的集合，用它表示时空复杂度时代表一个上界，所以如果你和别人算的复杂度不一样，可能你们都是对的，只是精确度不同罢了。</p><p>2、时间复杂度的分析不难，关键是你要透彻理解算法到底干了什么事。非递归算法中嵌套循环的复杂度依然可能是线性的；数据结构 API 需要用平均时间复杂度衡量性能；递归算法本质是遍历递归树，时间复杂度取决于递归树中节点的个数（递归次数）和每个节点的复杂度（递归函数本身的复杂度）。</p><p>好了，能看到这里，真得给你鼓掌。需要说明的是，本文给出的一些复杂度都是比较粗略的估算，上界都不是很「紧」，如果你不满足于粗略的估算，想计算更「紧」更精确的上界，就需要比较好的数学功底了。不过从面试笔试的角度来说，掌握这些基本分析技术已经足够应对了。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔试「骗分」套路</title>
      <link href="/posts/36851.html"/>
      <url>/posts/36851.html</url>
      
        <content type="html"><![CDATA[<h1 id="算法笔试「骗分」套路"><a href="#算法笔试「骗分」套路" class="headerlink" title="算法笔试「骗分」套路"></a>算法笔试「骗分」套路</h1><p>首先回答一个问题，刷力扣题是直接在网页上刷比较好还是在本地 IDE 上刷比较好？</p><p>如果是牛客网笔试那种自己处理输入输出的判题形式，一定要在 IDE 上写，这个没啥说的，但<strong>像力扣这种判题形式，我个人偏好直接在网页上刷</strong>，原因有二：</p><p><strong>1、方便</strong></p><p>因为力扣有的数据结构是自定的，比如说 <code>TreeNode</code>，<code>ListNode</code> 这种，在本地你还得把这个类 copy 过去。</p><p>而且在 IDE 上没办法测试，写完代码之后还得粘贴到网页上跑测试数据，那还不如直接网页上写呢。</p><p>算法又不是工程代码，量都比较小，IDE 的自动补全带来的收益基本可以忽略不计。</p><p><strong>2、实用</strong></p><p>到时候面试的时候，面试官给你出的算法题大都是希望你直接在网页上完成的，最好是边写边讲你的思路。</p><p>如果平时练习的时候就习惯没有 IDE 的自动补全，习惯手写代码大脑编译，到时候面试的时候写代码就能更快更从容。</p><p>之前我面快手的时候，有个面试官让我 <a href="https://labuladong.online/algo/data-structure/lru-cache/">实现 LRU 算法</a>，我直接把双链表的实现、哈希链表的实现，在网页上全写出来了，而且一次无 bug 跑通，可以看到面试官惊讶的表情😂</p><p>我秋招能当 offer 收割机，很大程度上就是因为手写算法这一关超出面试官的预期，其实都是因为之前在网页上刷题练出来的。</p><p>当然，实在不想在网页上刷，也可以用我的 vscode 刷题插件或者 JetBrains 刷题插件，插件和我的网站内容都有完美的融合：</p><p><img src="https://labuladong.online/algo/images/others/%E5%85%A8%E5%AE%B6%E6%A1%B6.jpg" alt="img"></p><p>接下来介绍几个很实用的「投机取巧」的办法和调试技巧，全方位提高你通过笔试的概率。</p><p>🌟</p><hr><p>🌟</p><h3 id="避实就虚"><a href="#避实就虚" class="headerlink" title="#避实就虚"></a><a href="https://labuladong.online/algo/other-skills/tips-in-exam/#%E9%81%BF%E5%AE%9E%E5%B0%B1%E8%99%9A">#</a>避实就虚</h3><p>大家也知道，大部分笔试题目都需要你自己来处理输入数据，然后让程序打印输出。判题的底层原理是，把你程序的输出用 Linux 重定向符 <code>&gt;</code> 写到文件里面，然后比较你的输出和正确答案是否相同。</p><p>那么有的问题难点就变得形同虚设，我们可以偷工减料，举个简化的例子，假设题目说给你输入一串用空格分隔的字符，告诉你这代表一个单链表，请你把这个单链表翻转，并且强调，一定要把输入的数字转化成单链表之后再翻转哦！</p><p>那你怎么做？真就自己定义一个 <code>ListNode</code> 单链表节点类，然后再写代码把输入转化成一个单链表，然后再用让人头晕的指针操作去老老实实翻转单链表？</p><p>搞清楚我们是来 AC 题目的，不是来学习算法思维的，判题系统是无法准确判断的算法逻辑的，只能判断你的输出是否正确。所以取巧的做法是直接把输入存到数组里，然后用 <a href="https://labuladong.online/algo/essential-technique/array-two-pointers-summary/">双指针技巧</a> 几行代码给它翻转了，然后打印出来完事儿。</p><p>我就见过不少这种题目，比如题目说输入的是一个单链表，让我分组翻转链表，而且还特别强调要用递归实现，就是我们后文 <a href="https://labuladong.online/algo/data-structure/reverse-nodes-in-k-group/">K 个一组翻转链表</a> 的算法。嗯，如果用数组进行翻转，两分钟就写出来了，嘿嘿。</p><p>还有我们后文 <a href="https://labuladong.online/algo/data-structure/flatten-nested-list-iterator/">扁平化嵌套列表</a> 讲到的题目，思路很巧妙，但是在笔试中遇到时，输入是一个形如 <code>[1,[4,[6]]]</code> 的字符串，那直接用正则表达式把数字抽出来，就是一个扁平化的列表了……</p><h3 id="巧用随机数"><a href="#巧用随机数" class="headerlink" title="#巧用随机数"></a><a href="https://labuladong.online/algo/other-skills/tips-in-exam/#%E5%B7%A7%E7%94%A8%E9%9A%8F%E6%9C%BA%E6%95%B0">#</a>巧用随机数</h3><p>再说一个鸡贼的技巧，注意那些输出为「二值」的题目，二值就是类似布尔值，或者 0 和 1 这种组合有限的。</p><p>比如说很多题目是这样，巴拉巴拉给你说一堆条件，然后问你输入的数据能不能达成这些条件，如果能的话请输出 <code>YES</code>，不能的话输出 <code>NO</code>。</p><p>如果你会做当然好，如果不会做怎么办？</p><p>首先这样提交一下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下 case 通过率，假设是 60%，那么说明结果为 <code>YES</code> 有 60% 的概率，所以可以这样写代码：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 60% 的概率输出 YES，40% 的概率输出 NO</span></span><br><span class="line">        System.out.println((<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt() % <span class="number">100</span>) &lt; <span class="number">60</span> ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嘿嘿，这题你可以不会，但是一定要在力所能及的范围内做到极致！</p><h3 id="编程语言的选择"><a href="#编程语言的选择" class="headerlink" title="#编程语言的选择"></a><a href="https://labuladong.online/algo/other-skills/tips-in-exam/#%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E9%80%89%E6%8B%A9">#</a>编程语言的选择</h3><p>仅从做算法题的角度来说，我个人比较建议使用 Java 作为笔试的编程语言。因为 JetBrain 家的 IntelliJ 实在是太香了，相比其他语言的编辑器，不仅有 <code>psvm</code> 和 <code>sout</code> 这样的快捷命令（你要是连这都不知道，赶紧面壁去），而且可以帮你检查出很多笔误，比如说 <code>while</code> 循环里面忘记递增变量，或者 <code>return</code> 语句错写到循环里这种由于疏忽所导致的问题。</p><p>C++ 也还行，但是我觉得没有 Java 好用。我印象中 C++ 连个分割字符串的 <code>split</code> 函数都没有，光这点我就不想用 C++ 了……</p><p>还有一点，C++ 代码对时间的限制高，别的语言时间限制 4000ms，C++ 限制 2000ms，我觉得挺吃亏的。怪不得看别人用 C++ 写算法，为了提高速度，都不用标准库的 <code>vector</code> 容器，非要用原始的 <code>int[]</code> 数组，我看着都头疼。</p><p>Python 的话我刷题用的比较少，因为我不太喜欢用动态语言，不好调试。不过这个语言确实提供很多实用的功能，如果你深谙 Python 的套路，可以在某些时候投机取巧。比如说我们前文写到的 <a href="https://labuladong.online/algo/data-structure/implement-calculator/">表达式求值算法</a> 是一个困难级别的算法，但如果用 Python 内置的 <code>exec</code> 函数，直接就能算出答案。</p><p>这个在笔试里肯定是很占便宜的，因为之前说了，我们要的是结果，没人在乎你是怎么得到结果的。</p><h3 id="解法代码分层"><a href="#解法代码分层" class="headerlink" title="#解法代码分层"></a><a href="https://labuladong.online/algo/other-skills/tips-in-exam/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81%E5%88%86%E5%B1%82">#</a>解法代码分层</h3><p>代码分层应该算是一种比较好的习惯，可以增加写代码的速度和降低调试的难度。</p><p>简单说就是，不要把所有代码都写在 <code>main</code> 函数里面，我一直使用的套路是，<code>main</code> 函数负责接收数据，加一个 <code>solution</code> 函数负责统一处理数据和输出答案，然后再用诸如 <code>backtrack</code> 这样一个函数处理具体的算法逻辑。</p><p>举个例子，比如说一道题，我决定用带备忘录的动态规划求解，代码的大致结构是这样：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 主要负责接收数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[][] orders = <span class="keyword">new</span> <span class="title class_">int</span>[N][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            orders[i][<span class="number">0</span>] = scanner.nextInt();</span><br><span class="line">            orders[i][<span class="number">1</span>] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 委托 solution 进行求解</span></span><br><span class="line">        solution(orders);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span>[][] orders)</span> &#123;</span><br><span class="line">        <span class="comment">// 排除一些基本的边界情况</span></span><br><span class="line">        <span class="keyword">if</span> (orders.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;None&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 委托 dp 函数执行具体的算法逻辑</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> dp(orders, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 负责输出结果</span></span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 备忘录</span></span><br><span class="line">    <span class="keyword">static</span> HashMap&lt;String, Integer&gt; memo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[][] orders, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="comment">// 具体的算法逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你看这样分层是不是很清楚，每个函数都有自己主要负责的任务，如果哪里出了问题，你也容易 debug。</p><p>倒不是说要把代码写得多规范，至于 <code>private</code> 这种约束免了也无妨，变量用拼音命名也 OK，关键是别把代码直接全写到 <code>main</code> 函数里面，真的乱，不出错也罢，一旦出错，估计要花一番功夫调试了，找不到问题乱了阵脚，那是要尽量避免的。</p><h3 id="如何给算法-debug"><a href="#如何给算法-debug" class="headerlink" title="#如何给算法 debug"></a><a href="https://labuladong.online/algo/other-skills/tips-in-exam/#%E5%A6%82%E4%BD%95%E7%BB%99%E7%AE%97%E6%B3%95-debug">#</a>如何给算法 debug</h3><p>代码的错误是无法避免的，有时候可能整个思路都错了，有时候可能是某些细节问题，比如 <code>i</code> 和 <code>j</code> 写反了，这种问题怎么排查？</p><p>我想一般的算法问题肯定不难排查，肉眼检查应该都没啥问题，再不济 <code>print</code> 打印一些关键变量的值，总能发现问题。</p><p><strong>比较让人头疼的的应该是递归算法的问题排查</strong>。</p><p>如果没有一定的经验，函数递归的过程很难被正确理解，所以这里就重点讲讲如何高效 debug 递归算法。</p><p>有的读者可能会说，把算法 copy 到 IDE 里面，然后打断点一步步跟着走不就行了吗？</p><p>这个方法肯定是可以的，但是之前的文章多次说过，递归函数最好从一个全局的角度理解，而不要跳进具体的细节。</p><p>如果你对递归还不够熟悉，没有一个全局的视角，这种一步步打断点的方式也容易把人绕进去。</p><p><strong>我的建议是直接在递归函数内部打印关键值，配合缩进，直观地观察递归函数执行情况</strong>。</p><p>最能提升我们 debug 效率的是缩进，除了解法函数，我们新定义一个函数 <code>printIndent</code> 和一个全局变量 <code>count</code>：</p><p>java 🤖cpp 🟢python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：java 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span></span><br><span class="line"><span class="comment">// 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 cpp 代码对比查看。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量，记录递归函数的递归层数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入 n，打印 n 个 tab 缩进</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">printIndent</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，套路来了：</p><p><strong>在递归函数的开头，调用 <code>printIndent(count++)</code> 并打印关键变量；然后在所有 <code>return</code> 语句之前调用 <code>printIndent(--count)</code> 并打印返回值</strong>。</p><p>举个具体的例子，比如说上篇文章 <a href="https://labuladong.online/algo/dynamic-programming/freedom-trail/">练琴时悟出的一个动态规划算法</a> 中实现了一个递归的 <code>dp</code> 函数，大致的结构如下：</p><p>java 🤖cpp 🟢python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：java 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span></span><br><span class="line"><span class="comment">// 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 cpp 代码对比查看。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(String ring, <span class="type">int</span> i, String key, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="comment">/* base case */</span></span><br><span class="line">    <span class="keyword">if</span> (j == key.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 状态转移 */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k : charToIndex.get(key.charAt(j))) &#123;</span><br><span class="line">        res = Math.min(res, dp(ring, j, key, i + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个递归的 <code>dp</code> 函数在我进行了 debug 之后，变成了这样：</p><p>java 🤖cpp 🟢python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：java 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span></span><br><span class="line"><span class="comment">// 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 cpp 代码对比查看。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">printIndent</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(String ring, <span class="type">int</span> i, String key, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="comment">// printIndent(count++);</span></span><br><span class="line">    <span class="comment">// System.out.format(&quot;i = %d, j = %d%n&quot;, i, j);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == key.length()) &#123;</span><br><span class="line">        <span class="comment">// printIndent(--count);</span></span><br><span class="line">        <span class="comment">// System.out.println(&quot;return 0&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k : charToIndex.get(key.charAt(j))) &#123;</span><br><span class="line">        res = Math.min(res, dp(ring, j, key, i + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printIndent(--count);</span></span><br><span class="line">    <span class="comment">// System.out.format(&quot;return %d%n&quot;, res);</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>就是在函数开头和所有 <code>return</code> 语句对应的地方加上一些打印代码</strong>。</p><p>如果去掉注释，执行一个测试用例，输出如下：</p><p><img src="https://labuladong.online/algo/images/%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7/1.jpg" alt="img"></p><p>这样，我们通过对比对应的缩进就能知道每次递归时输入的关键参数 <code>i, j</code> 的值，以及每次递归调用返回的结果是多少。</p><p><strong>最重要的是，这样可以比较直观地看出递归过程，你有没有发现这就是一棵递归树</strong>？</p><p><img src="https://labuladong.online/algo/images/%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7/2.jpg" alt="img"></p><p>前文 <a href="https://labuladong.online/algo/essential-technique/dynamic-programming-framework/">动态规划套路详解</a> 说过，理解递归函数最重要的就是画出递归树，这样打印一下，连递归树都不用自己画了，而且还能清晰地看出每次递归的返回值。</p><p><strong>可以说，这是对刷题「幸福感」提升最大的一个小技巧，比 IDE 打断点要高效</strong>。</p><h3 id="考前复习策略"><a href="#考前复习策略" class="headerlink" title="#考前复习策略"></a><a href="https://labuladong.online/algo/other-skills/tips-in-exam/#%E8%80%83%E5%89%8D%E5%A4%8D%E4%B9%A0%E7%AD%96%E7%95%A5">#</a>考前复习策略</h3><p>考前就别和某一道算法题死磕了，不划算。</p><p>应该尽可能多的看各种各样的题目，思考五分钟，想不出来解法的话直接看别人的答案。看懂思路就行了，甚至自己写一遍都没必要，因为比较浪费时间。</p><p>笔试的时候最怕的是没思路，所以把各种题型都过目一下，起码心里不会慌，只要有思路，平均一道题二三十分钟搞定还是不难的。</p><p>前面不是说了么，没有什么问题是暴力穷举解决不了的，直接用 <a href="https://labuladong.online/algo/essential-technique/backtrack-framework/">回溯算法套路框架</a> 硬上，大不了加个备忘录，不就成 <a href="https://labuladong.online/algo/essential-technique/dynamic-programming-framework/">动态规划套路框架</a> 了么，再大不了这题我不做了么，暴力过上 60% 的 case 也挺 OK 的。</p><p>别的不多说了，套路这个东西，说来简单，一点就透，但问题是不点就不透。本文我简单介绍了几个笔试算法的技巧，各位好好品味~</p><p>最后，请秋招的同学多向身边的朋友推荐 labuladong 公众号。算法真的没那么难，这一切只是手段而已，过算法笔试拿 offer 才是目的。为了达到目的，套路是必须的，可以少走很多弯路，你的朋友会感谢你的，我也会感谢你的😏</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kruskal 最小生成树算法</title>
      <link href="/posts/34586.html"/>
      <url>/posts/34586.html</url>
      
        <content type="html"><![CDATA[<h1 id="Kruskal-最小生成树算法"><a href="#Kruskal-最小生成树算法" class="headerlink" title="Kruskal 最小生成树算法"></a>Kruskal 最小生成树算法</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/connecting-cities-with-minimum-cost/">1135. Connecting Cities With Minimum Costopen in new window</a>🔒</td><td align="center"><a href="https://leetcode.cn/problems/connecting-cities-with-minimum-cost/">1135. 最低成本联通所有城市open in new window</a>🔒</td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/min-cost-to-connect-all-points/">1584. Min Cost to Connect All Pointsopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/min-cost-to-connect-all-points/">1584. 连接所有点的最小费用open in new window</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/graph-valid-tree/">261. Graph Valid Treeopen in new window</a>🔒</td><td align="center"><a href="https://leetcode.cn/problems/graph-valid-tree/">261. 以图判树open in new window</a>🔒</td><td align="center">🟠</td></tr></tbody></table><p>图论中知名度比较高的算法应该就是 <a href="https://labuladong.online/algo/data-structure/dijkstra/">Dijkstra 最短路径算法</a>，<a href="https://labuladong.online/algo/data-structure/topological-sort/">环检测和拓扑排序</a>，<a href="https://labuladong.online/algo/data-structure/bipartite-graph/">二分图判定算法</a> 以及今天要讲的最小生成树（Minimum Spanning Tree）算法了。</p><p>最小生成树算法主要有 Prim 算法（普里姆算法）和 Kruskal 算法（克鲁斯卡尔算法）两种，这两种算法虽然都运用了贪心思想，但从实现上来说差异还是蛮大的。</p><p>本文先来讲比较简单易懂的 Kruskal 算法，然后在下一篇文章 <a href="https://labuladong.online/algo/data-structure/prim/">Prim 算法模板</a> 中聊 Prim 算法。</p><p>Kruskal 算法其实很容易理解和记忆，其关键是要熟悉并查集算法，如果不熟悉，建议先看下前文 <a href="https://labuladong.online/algo/data-structure/union-find/">Union-Find 并查集算法</a>。</p><p>接下来，我们从最小生成树的定义说起。</p><h3 id="什么是最小生成树"><a href="#什么是最小生成树" class="headerlink" title="#什么是最小生成树"></a><a href="https://labuladong.online/algo/data-structure/kruskal/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91">#</a>什么是最小生成树</h3><p><strong>先说「树」和「图」的根本区别：树不会包含环，图可以包含环</strong>。</p><p>如果一幅图没有环，完全可以拉伸成一棵树的模样。说的专业一点，树就是「无环连通图」。</p><p>那么什么是图的「生成树」呢，其实按字面意思也好理解，就是在图中找一棵包含图中的所有节点的树。专业点说，生成树是含有图中所有顶点的「无环连通子图」。</p><p>容易想到，一幅图可以有很多不同的生成树，比如下面这幅图，红色的边就组成了两棵不同的生成树：</p><p><img src="https://labuladong.online/algo/images/kruskal/1.png" alt="img"></p><p>对于加权图，每条边都有权重，所以每棵生成树都有一个权重和。比如上图，右侧生成树的权重和显然比左侧生成树的权重和要小。</p><p><strong>那么最小生成树很好理解了，所有可能的生成树中，权重和最小的那棵生成树就叫「最小生成树」</strong>。</p><p>提示</p><p>一般来说，我们都是在<strong>无向加权图</strong>中计算最小生成树的，所以使用最小生成树算法的现实场景中，图的边权重一般代表成本、距离这样的标量。</p><p>在讲 Kruskal 算法之前，需要回顾一下 Union-Find 并查集算法。</p><p>🌟</p><hr><p>🌟</p><h3 id="Union-Find-并查集算法"><a href="#Union-Find-并查集算法" class="headerlink" title="#Union-Find 并查集算法"></a><a href="https://labuladong.online/algo/data-structure/kruskal/#union-find-%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95">#</a>Union-Find 并查集算法</h3><p>刚才说了，图的生成树是含有其所有顶点的「无环连通子图」，最小生成树是权重和最小的生成树。</p><p>那么说到连通性，相信老读者应该可以想到 Union-Find 并查集算法，用来高效处理图中联通分量的问题。</p><p>前文 <a href="https://labuladong.online/algo/data-structure/union-find/">Union-Find 并查集算法详解</a> 详细介绍了 Union-Find 算法的实现原理和一些应用场景，主要运用路径压缩技巧提高连通分量的判断效率。</p><p>如果不了解 Union-Find 算法的读者可以去看前文，为了节约篇幅，本文直接给出 Union-Find 算法的实现：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="comment">// 连通分量个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">// 存储每个节点的父节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// n 为图中节点的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UF</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将节点 p 和节点 q 连通</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        parent[rootQ] = rootP;</span><br><span class="line">        <span class="comment">// 两个连通分量合并成一个连通分量</span></span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断节点 p 和节点 q 是否连通</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">        <span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">            parent[x] = find(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回图中的连通分量个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kruskal 算法的一个难点是保证生成树的合法性，因为在构造生成树的过程中，你首先得保证生成的那玩意是棵树（不包含环）对吧，那么 Union-Find 算法就是帮你干这个事儿的。怎么做到的呢？先来看看力扣第 261 题「<a href="https://leetcode.cn/problems/graph-valid-tree/">以图判树open in new window</a>」，我描述下题目：</p><p>给你输入编号从 <code>0</code> 到 <code>n - 1</code> 的 <code>n</code> 个结点，和一个无向边列表 <code>edges</code>（每条边用节点二元组表示），请你判断输入的这些边组成的结构是否是一棵树。</p><p>函数签名如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">validTree</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span>;</span><br></pre></td></tr></table></figure><p>比如输入如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">n = 5</span><br><span class="line">edges = [[0,1], [0,2], [0,3], [1,4]]</span><br></pre></td></tr></table></figure><p>这些边构成的是一棵树，算法应该返回 true：</p><p><img src="https://labuladong.online/algo/images/kruskal/2.png" alt="img"></p><p>但如果输入：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">n = 5</span><br><span class="line">edges = [[0,1],[1,2],[2,3],[1,3],[1,4]]</span><br></pre></td></tr></table></figure><p>形成的就不是树结构了，因为包含环：</p><p><img src="https://labuladong.online/algo/images/kruskal/3.png" alt="img"></p><p><strong>对于这道题，我们可以思考一下，什么情况下加入一条边会使得树变成图（出现环）</strong>？</p><p>显然，像下面这样添加边会出现环：</p><p><img src="https://labuladong.online/algo/images/kruskal/4.png" alt="img"></p><p>而这样添加边则不会出现环：</p><p><img src="https://labuladong.online/algo/images/kruskal/5.png" alt="img"></p><p>总结一下规律就是：</p><p><strong>对于添加的这条边，如果该边的两个节点本来就在同一连通分量里，那么添加这条边会产生环；反之，如果该边的两个节点不在同一连通分量里，则添加这条边不会产生环</strong>。</p><p>而判断两个节点是否连通（是否在同一个连通分量中）就是 Union-Find 算法的拿手绝活，所以这道题的解法代码如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断输入的若干条边是否能构造出一棵树结构</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">validTree</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化 0...n-1 共 n 个节点</span></span><br><span class="line">    <span class="type">UF</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UF</span>(n);</span><br><span class="line">    <span class="comment">// 遍历所有边，将组成边的两个节点进行连接</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 若两个节点已经在同一连通分量中，会产生环</span></span><br><span class="line">        <span class="keyword">if</span> (uf.connected(u, v)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这条边不会产生环，可以是树的一部分</span></span><br><span class="line">        uf.union(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 要保证最后只形成了一棵树，即只有一个连通分量</span></span><br><span class="line">    <span class="keyword">return</span> uf.count() == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="comment">// 见上文代码实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你能够看懂这道题的解法思路，那么掌握 Kruskal 算法就很简单了。</p><h3 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="#Kruskal 算法"></a><a href="https://labuladong.online/algo/data-structure/kruskal/#kruskal-%E7%AE%97%E6%B3%95">#</a>Kruskal 算法</h3><p>所谓最小生成树，就是图中若干边的集合（我们后文称这个集合为 <code>mst</code>，最小生成树的英文缩写），你要保证这些边：</p><p>1、包含图中的所有节点。</p><p>2、形成的结构是树结构（即不存在环）。</p><p>3、权重和最小。</p><p>有之前题目的铺垫，前两条其实可以很容易地利用 Union-Find 算法做到，关键在于第 3 点，如何保证得到的这棵生成树是权重和最小的。</p><p>这里就用到了贪心思路：</p><p><strong>将所有边按照权重从小到大排序，从权重最小的边开始遍历，如果这条边和 <code>mst</code> 中的其它边不会形成环，则这条边是最小生成树的一部分，将它加入 <code>mst</code> 集合；否则，这条边不是最小生成树的一部分，不要把它加入 <code>mst</code> 集合</strong>。</p><p>这样，最后 <code>mst</code> 集合中的边就形成了最小生成树，下面我们看两道例题来运用一下 Kruskal 算法。</p><p>第一题是力扣第 1135 题「<a href="https://leetcode.cn/problems/connecting-cities-with-minimum-cost/">最低成本联通所有城市open in new window</a>」，这是一道标准的最小生成树问题：</p><details class="hint-container details" open="" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1rem 0px; padding: 1.5rem; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary style="position: relative; margin: -1.5rem -1.5rem 0.5em; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer;"><strong style="font-weight: 600;">1135. 最低成本联通所有城市</strong>&nbsp;|<span>&nbsp;</span><a target="_blank" href="https://leetcode.cn/problems/connecting-cities-with-minimum-cost/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|<span>&nbsp;</span><a target="_blank" href="https://leetcode.com/problems/connecting-cities-with-minimum-cost/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">想象一下你是个城市基建规划者，地图上有&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">n</code>&nbsp;座城市，它们按以&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1</code><span>&nbsp;</span>到&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">n</code>&nbsp;的次序编号。</p><p style="line-height: 1.6; overflow-wrap: break-word;">给你整数<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">n</code><span>&nbsp;</span>和一个数组&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">conections</code>，其中&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">connections[i] = [x<sub>i</sub>, y<sub>i</sub>, cost<sub>i</sub>]</code>&nbsp;表示将城市&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">x<sub>i</sub></code>&nbsp;和城市&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">y<sub>i</sub></code>&nbsp;连接所要的<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">cost<sub>i</sub></code>（<strong style="font-weight: 600;">连接是双向的</strong>）。</p><p style="line-height: 1.6; overflow-wrap: break-word;">返回连接所有城市的<strong style="font-weight: 600;">最低成本</strong>，每对城市之间<strong style="font-weight: 600;">至少</strong>有一条路径。如果无法连接所有<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">n</code>&nbsp;个城市，返回<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">-1</code></p><p style="line-height: 1.6; overflow-wrap: break-word;">该<span>&nbsp;</span><strong style="font-weight: 600;">最小成本</strong><span>&nbsp;</span>应该是所用全部连接成本的总和。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/07/27/1314_ex2.png" style="max-width: 100%; cursor: zoom-in;"></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>n = 3, conections = [[1,2,5],[1,3,6],[2,3,1]]<strong style="font-weight: 600;">输出：</strong>6<strong style="font-weight: 600;">解释：</strong>选出任意 2 条边都可以连接所有城市，我们从中选取成本最小的 2 条。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/07/27/1314_ex1.png" style="max-width: 100%; cursor: zoom-in;"></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>n = 4, conections = [[1,2,3],[3,4,4]]<strong style="font-weight: 600;">输出：</strong>-1<strong style="font-weight: 600;">解释：</strong>即使连通所有的边，也无法连接所有城市。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 &lt;= n &lt;= 10<sup>4</sup></code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 &lt;= connections.length &lt;= 10<sup>4</sup></code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">connections[i].length == 3</code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 &lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt;= n</code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">x<sub>i</sub>&nbsp;!= y<sub>i</sub></code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">0 &lt;= cost<sub>i</sub>&nbsp;&lt;= 10<sup>5</sup></code></li></ul></div></details><p>函数签名如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minimumCost</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] connections)</span>;</span><br></pre></td></tr></table></figure><p>每座城市相当于图中的节点，连通城市的成本相当于边的权重，连通所有城市的最小成本即是最小生成树的权重之和。</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minimumCost</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] connections)</span> &#123;</span><br><span class="line">    <span class="comment">// 城市编号为 1...n，所以初始化大小为 n + 1</span></span><br><span class="line">    <span class="type">UF</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UF</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 对所有边按照权重从小到大排序</span></span><br><span class="line">    Arrays.sort(connections, (a, b) -&gt; (a[<span class="number">2</span>] - b[<span class="number">2</span>]));</span><br><span class="line">    <span class="comment">// 记录最小生成树的权重之和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mst</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] edge : connections) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> edge[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 若这条边会产生环，则不能加入 mst</span></span><br><span class="line">        <span class="keyword">if</span> (uf.connected(u, v)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若这条边不会产生环，则属于最小生成树</span></span><br><span class="line">        mst += weight;</span><br><span class="line">        uf.union(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保证所有节点都被连通</span></span><br><span class="line">    <span class="comment">// 按理说 uf.count() == 1 说明所有节点被连通</span></span><br><span class="line">    <span class="comment">// 但因为节点 0 没有被使用，所以 0 会额外占用一个连通分量</span></span><br><span class="line">    <span class="keyword">return</span> uf.count() == <span class="number">2</span> ? mst : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="comment">// 见上文代码实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题就解决了，整体思路和上一道题非常类似，你可以认为树的判定算法加上按权重排序的逻辑就变成了 Kruskal 算法。</p><p>再来看看力扣第 1584 题「<a href="https://leetcode.cn/problems/min-cost-to-connect-all-points/">连接所有点的最小费用open in new window</a>」：</p><details class="hint-container details" open="" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1rem 0px; padding: 1.5rem; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary style="position: relative; margin: -1.5rem -1.5rem 0.5em; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer;"><strong style="font-weight: 600;">1584. 连接所有点的最小费用</strong>&nbsp;|<span>&nbsp;</span><a target="_blank" href="https://leetcode.cn/problems/min-cost-to-connect-all-points/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|<span>&nbsp;</span><a target="_blank" href="https://leetcode.com/problems/min-cost-to-connect-all-points/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">points</code>&nbsp;数组，表示 2D 平面上的一些点，其中&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp;。</p><p style="line-height: 1.6; overflow-wrap: break-word;">连接点&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">[x<sub>i</sub>, y<sub>i</sub>]</code><span>&nbsp;</span>和点&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">[x<sub>j</sub>, y<sub>j</sub>]</code>&nbsp;的费用为它们之间的<span>&nbsp;</span><strong style="font-weight: 600;">曼哈顿距离</strong>&nbsp;：<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">|x<sub>i</sub><span>&nbsp;</span>- x<sub>j</sub>| + |y<sub>i</sub><span>&nbsp;</span>- y<sub>j</sub>|</code>&nbsp;，其中&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">|val|</code>&nbsp;表示&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">val</code>&nbsp;的绝对值。</p><p style="line-height: 1.6; overflow-wrap: break-word;">请你返回将所有点连接的最小总费用。只有任意两点之间<span>&nbsp;</span><strong style="font-weight: 600;">有且仅有</strong>&nbsp;一条简单路径时，才认为所有点都已连接。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://assets.leetcode.com/uploads/2020/08/26/d.png" style="max-width: 100%; height: 268px; width: 214px; background: rgb(229, 229, 229); cursor: zoom-in;"></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>points = [[0,0],[2,2],[3,10],[5,2],[7,0]]<strong style="font-weight: 600;">输出：</strong>20<strong style="font-weight: 600;">解释：</strong><img alt="" src="https://assets.leetcode.com/uploads/2020/08/26/c.png" style="max-width: 100%; height: 268px; width: 214px; background: rgb(229, 229, 229); cursor: zoom-in;">我们可以按照上图所示连接所有点得到最小总费用，总费用为 20 。注意到任意两个点之间只有唯一一条路径互相到达。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>points = [[3,12],[-2,5],[-4,1]]<strong style="font-weight: 600;">输出：</strong>18</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>points = [[0,0],[1,1],[1,0],[-1,1]]<strong style="font-weight: 600;">输出：</strong>4</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 4：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>points = [[-1000000,-1000000],[1000000,1000000]]<strong style="font-weight: 600;">输出：</strong>4000000</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 5：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>points = [[0,0]]<strong style="font-weight: 600;">输出：</strong>0</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 &lt;= points.length &lt;= 1000</code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">-10<sup>6</sup>&nbsp;&lt;= x<sub>i</sub>, y<sub>i</sub><span>&nbsp;</span>&lt;= 10<sup>6</sup></code></li><li>所有点&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">(x<sub>i</sub>, y<sub>i</sub>)</code>&nbsp;两两不同。</li></ul></div></details><p>比如题目给的例子：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">points = [[0,0],[2,2],[3,10],[5,2],[7,0]]</span><br></pre></td></tr></table></figure><p>算法应该返回 20，按如下方式连通各点：</p><p><img src="https://labuladong.online/algo/images/kruskal/example.png" alt="img"></p><p>函数签名如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minCostConnectPoints</span><span class="params">(<span class="type">int</span>[][] points)</span>;</span><br></pre></td></tr></table></figure><p>很显然这也是一个标准的最小生成树问题：每个点就是无向加权图中的节点，边的权重就是曼哈顿距离，连接所有点的最小费用就是最小生成树的权重和。</p><p>所以解法思路就是先生成所有的边以及权重，然后对这些边执行 Kruskal 算法即可：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minCostConnectPoints</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> points.length;</span><br><span class="line">    <span class="comment">// 生成所有边及权重</span></span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">xi</span> <span class="operator">=</span> points[i][<span class="number">0</span>], yi = points[i][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">xj</span> <span class="operator">=</span> points[j][<span class="number">0</span>], yj = points[j][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 用坐标点在 points 中的索引表示坐标点</span></span><br><span class="line">            edges.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;</span><br><span class="line">                i, j, Math.abs(xi - xj) + Math.abs(yi - yj)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将边按照权重从小到大排序</span></span><br><span class="line">    Collections.sort(edges, (a, b) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">2</span>] - b[<span class="number">2</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 执行 Kruskal 算法</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mst</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">UF</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UF</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> edge[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 若这条边会产生环，则不能加入 mst</span></span><br><span class="line">        <span class="keyword">if</span> (uf.connected(u, v)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若这条边不会产生环，则属于最小生成树</span></span><br><span class="line">        mst += weight;</span><br><span class="line">        uf.union(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="comment">// 见上文代码实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题做了一个小的变通：每个坐标点是一个二元组，那么按理说应该用五元组表示一条带权重的边，但这样的话不便执行 Union-Find 算法；所以我们用 <code>points</code> 数组中的索引代表每个坐标点，这样就可以直接复用之前的 Kruskal 算法逻辑了。</p><p>通过以上三道算法题，相信你已经掌握了 Kruskal 算法，主要的难点是利用 Union-Find 并查集算法向最小生成树中添加边，配合排序的贪心思路，从而得到一棵权重之和最小的生成树。</p><p>最后说下 Kruskal 算法的复杂度分析：</p><p>假设一幅图的节点个数为 <code>V</code>，边的条数为 <code>E</code>，首先需要 <code>O(E)</code> 的空间装所有边，而且 Union-Find 算法也需要 <code>O(V)</code> 的空间，所以 Kruskal 算法总的空间复杂度就是 <code>O(V + E)</code>。</p><p>时间复杂度主要耗费在排序，需要 <code>O(ElogE)</code> 的时间，Union-Find 算法所有操作的复杂度都是 <code>O(1)</code>，套一个 for 循环也不过是 <code>O(E)</code>，所以总的时间复杂度为 <code>O(ElogE)</code>。</p><p>本文就到这里，关于 Prim 最小生成树算法，我们在 <a href="https://labuladong.online/algo/data-structure/prim/">Prim 算法模板</a> 中聊。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git原理之最近公共祖先</title>
      <link href="/posts/56524.html"/>
      <url>/posts/56524.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git原理之最近公共祖先"><a href="#Git原理之最近公共祖先" class="headerlink" title="Git原理之最近公共祖先"></a>Git原理之最近公共祖先</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/">1644. Lowest Common Ancestor of a Binary Tree IIopen in new window</a>🔒</td><td align="center"><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-ii/">1644. 二叉树的最近公共祖先 IIopen in new window</a>🔒</td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/">1650. Lowest Common Ancestor of a Binary Tree IIIopen in new window</a>🔒</td><td align="center"><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iii/">1650. 二叉树的最近公共祖先 IIIopen in new window</a>🔒</td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iv/">1676. Lowest Common Ancestor of a Binary Tree IVopen in new window</a>🔒</td><td align="center"><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iv/">1676. 二叉树的最近公共祖先 IVopen in new window</a>🔒</td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. Lowest Common Ancestor of a Binary Search Treeopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先open in new window</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. Lowest Common Ancestor of a Binary Treeopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先open in new window</a></td><td align="center">🟠</td></tr><tr><td align="center">-</td><td align="center"><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先open in new window</a></td><td align="center">🟢</td></tr><tr><td align="center">-</td><td align="center"><a href="https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - II. 二叉树的最近公共祖先open in new window</a></td><td align="center">🟢</td></tr></tbody></table><p>Info</p><p>在开头先打个广告，我的 <a href="https://labuladong.online/algo/tree-class/">手把手刷二叉树课程open in new window</a> 按照公式和套路讲解了 150 道二叉树题目，只需一顿饭钱，就能手把手带你刷完二叉树分类的题目，迅速掌握递归思维，让你豁然开朗。我绝对有这个信心，信不信，可以等你看完我的二叉树算法系列文章再做评判。</p><p>如果说笔试的时候经常遇到各种动归回溯这类稍有难度的题目，那么面试会倾向于一些比较经典的问题，难度不算大，而且也比较实用。</p><p>本文就用 Git 引出一个经典的算法问题：最近公共祖先（Lowest Common Ancestor，简称 LCA）。</p><p><code>git pull</code> 这个命令我们经常会用，它默认是使用 <code>merge</code> 方式将远端别人的修改拉到本地；如果带上参数 <code>git pull -r</code>，就会使用 <code>rebase</code> 的方式将远端修改拉到本地。</p><p>这二者最直观的区别就是：<code>merge</code> 方式合并的分支会看到很多「分叉」，而 <code>rebase</code> 方式合并的分支就是一条直线。但无论哪种方式，如果存在冲突，Git 都会检测出来并让你手动解决冲突。</p><p>那么问题来了，Git 是如何检测两条分支是否存在冲突的呢？</p><p>以 <code>rebase</code> 命令为例，比如下图的情况，我站在 <code>dev</code> 分支执行 <code>git rebase master</code>，然后 <code>dev</code> 就会接到 <code>master</code> 分支之上：</p><p><img src="https://labuladong.online/algo/images/%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/1.jpeg" alt="img"></p><p>这个过程中，Git 是这么做的：</p><p>首先，找到这两条分支的最近公共祖先 <code>LCA</code>，然后从 <code>master</code> 节点开始，重演 <code>LCA</code> 到 <code>dev</code> 几个 <code>commit</code> 的修改，如果这些修改和 <code>LCA</code> 到 <code>master</code> 的 <code>commit</code> 有冲突，就会提示你手动解决冲突，最后的结果就是把 <code>dev</code> 的分支完全接到 <code>master</code> 上面。</p><p>那么，Git 是如何找到两条不同分支的最近公共祖先的呢？这就是一个经典的算法问题了，下面我来由浅入深讲一讲。</p><p>🌟</p><hr><p>🌟</p><h3 id="寻找一个元素"><a href="#寻找一个元素" class="headerlink" title="#寻找一个元素"></a><a href="https://labuladong.online/algo/practice-in-action/lowest-common-ancestor-summary/#%E5%AF%BB%E6%89%BE%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0">#</a>寻找一个元素</h3><p>先不管最近公共祖先问题，我请你实现一个简单的算法：</p><p>给你输入一棵<strong>没有重复元素</strong>的二叉树根节点 <code>root</code> 和一个目标值 <code>val</code>，请你写一个函数寻找树中值为 <code>val</code> 的节点。</p><p>函数签名如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span>;</span><br></pre></td></tr></table></figure><p>这个函数应该很容易实现对吧，比如我这样写代码：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：在以 root 为根的二叉树中寻找值为 val 的节点</span></span><br><span class="line">TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 看看 root.val 是不是要找的</span></span><br><span class="line">    <span class="keyword">if</span> (root.val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// root 不是目标节点，那就去左子树找</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, val);</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左子树找不着，那就去左子树找</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, val);</span><br><span class="line">    <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实在找不到了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码应该不用我多解释了，我下面基于这段代码做一些简单的改写，请你分析一下我的改动会造成什么影响。</p><p>提示</p><p>如果你没读过前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">东哥带你刷二叉树（纲领篇）</a>，强烈建议阅读一下，理解二叉树前中后序遍历的奥义。</p><p>首先，我修改一下 return 的位置：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="keyword">if</span> (root.val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// root 不是目标节点，去左右子树寻找</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, val);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, val);</span><br><span class="line">    <span class="comment">// 看看哪边找到了</span></span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码也可以达到目的，但是实际运行的效率会低一些，原因也很简单，如果你能够在左子树找到目标节点，还有没有必要去右子树找了？没有必要。但这段代码还是会去右子树找一圈，所以效率相对差一些。</p><p>更进一步，我把对 <code>root.val</code> 的判断从前序位置移动到后序位置：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先去左右子树寻找</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, val);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, val);</span><br><span class="line">    <span class="comment">// 后序位置，看看 root 是不是目标节点</span></span><br><span class="line">    <span class="keyword">if</span> (root.val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// root 不是目标节点，再去看看哪边的子树找到了</span></span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码相当于你先去左右子树找，然后才检查 <code>root</code>，依然可以到达目的，但是效率会进一步下降。<strong>因为这种写法必然会遍历二叉树的每一个节点</strong>。</p><p>对于之前的解法，你在前序位置就检查 <code>root</code>，如果输入的二叉树根节点的值恰好就是目标值 <code>val</code>，那么函数直接结束了，其他的节点根本不用搜索。</p><p>但如果你在后序位置判断，那么就算根节点就是目标节点，你也要去左右子树遍历完所有节点才能判断出来。</p><p>最后，我再改一下题目，现在不让你找值为 <code>val</code> 的节点，而是寻找值为 <code>val1</code> <strong>或</strong> <code>val2</code> 的节点，函数签名如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val1, <span class="type">int</span> val2)</span>;</span><br></pre></td></tr></table></figure><p>这和我们第一次实现的 <code>find</code> 函数基本上是一样的，而且你应该知道可以有多种写法，我选择这样写代码：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：在以 root 为根的二叉树中寻找值为 val1 或 val2 的节点</span></span><br><span class="line">TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val1, <span class="type">int</span> val2)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置，看看 root 是不是目标值</span></span><br><span class="line">    <span class="keyword">if</span> (root.val == val1 || root.val == val2) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去左右子树寻找</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, val1, val2);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, val1, val2);</span><br><span class="line">    <span class="comment">// 后序位置，已经知道左右子树是否存在目标值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么要写这样一个奇怪的 <code>find</code> 函数呢？因为最近公共祖先系列问题的解法都是把这个函数作为框架的</strong>。</p><p>下面一道一道题目来看。</p><h3 id="秒杀五道题目"><a href="#秒杀五道题目" class="headerlink" title="#秒杀五道题目"></a><a href="https://labuladong.online/algo/practice-in-action/lowest-common-ancestor-summary/#%E7%A7%92%E6%9D%80%E4%BA%94%E9%81%93%E9%A2%98%E7%9B%AE">#</a>秒杀五道题目</h3><p>先来看看力扣第 236 题「<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先open in new window</a>」：</p><p>给你输入一棵<strong>不含重复值</strong>的二叉树，以及<strong>存在于树中的</strong>两个节点 <code>p</code> 和 <code>q</code>，请你计算 <code>p</code> 和 <code>q</code> 的最近公共祖先节点。</p><p>注</p><p>后文我用 <code>LCA</code>（Lowest Common Ancestor）作为最近公共祖先节点的缩写。</p><p>比如输入这样一棵二叉树：</p><p><img src="https://labuladong.online/algo/images/%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/2.jpg" alt="img"></p><p>如果 <code>p</code> 是节点 <code>6</code>，<code>q</code> 是节点 <code>7</code>，那么它俩的 <code>LCA</code> 就是节点 <code>5</code>：</p><p><img src="https://labuladong.online/algo/images/%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/3.jpg" alt="img"></p><p>当然，<code>p</code> 和 <code>q</code> 本身也可能是 <code>LCA</code>，比如这种情况 <code>q</code> 本身就是 <code>LCA</code> 节点：</p><p><img src="https://labuladong.online/algo/images/%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/4.jpg" alt="img"></p><p>两个节点的最近公共祖先其实就是这两个节点向根节点的「延长线」的交汇点，那么对于任意一个节点，它怎么才能知道自己是不是 <code>p</code> 和 <code>q</code> 的最近公共祖先？</p><p><strong>如果一个节点能够在它的左右子树中分别找到 <code>p</code> 和 <code>q</code>，则该节点为 <code>LCA</code> 节点</strong>。</p><p>这就要用到之前实现的 <code>find</code> 函数了，只需在后序位置添加一个判断逻辑，即可改造成寻找最近公共祖先的解法代码：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> find(root, p.val, q.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在二叉树中寻找 val1 和 val2 的最近公共祖先节点</span></span><br><span class="line">TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val1, <span class="type">int</span> val2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="keyword">if</span> (root.val == val1 || root.val == val2) &#123;</span><br><span class="line">        <span class="comment">// 如果遇到目标值，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, val1, val2);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, val1, val2);</span><br><span class="line">    <span class="comment">// 后序位置，已经知道左右子树是否存在目标值</span></span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前节点是 LCA 节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>find</code> 函数的后序位置，如果发现 <code>left</code> 和 <code>right</code> 都非空，就说明当前节点是 <code>LCA</code> 节点，即解决了第一种情况：</p><p><img src="https://labuladong.online/algo/images/%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/3.jpg" alt="img"></p><p>在 <code>find</code> 函数的前序位置，如果找到一个值为 <code>val1</code> 或 <code>val2</code> 的节点则直接返回，恰好解决了第二种情况：</p><p><img src="https://labuladong.online/algo/images/%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/4.jpg" alt="img"></p><p>因为题目说了 <code>p</code> 和 <code>q</code> 一定存在于二叉树中(这点很重要），所以即便我们遇到 <code>q</code> 就直接返回，根本没遍历到 <code>p</code>，也依然可以断定 <code>p</code> 在 <code>q</code> 底下，<code>q</code> 就是 <code>LCA</code> 节点。</p><p>这样，标准的最近公共祖先问题就解决了，接下来看看这个题目有什么变体。</p><p>比如力扣第 1676 题「<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iv/">二叉树的最近公共祖先 IVopen in new window</a>」：</p><p>依然给你输入一棵不含重复值的二叉树，但这次不是给你输入 <code>p</code> 和 <code>q</code> 两个节点了，而是给你输入一个包含若干节点的列表 <code>nodes</code>（这些节点都存在于二叉树中），让你算这些节点的最近公共祖先。</p><p>函数签名如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode[] nodes)</span>;</span><br></pre></td></tr></table></figure><p>比如还是这棵二叉树：</p><p><img src="https://labuladong.online/algo/images/%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/2.jpg" alt="img"></p><p>输入 <code>nodes = [7,4,6]</code>，那么函数应该返回节点 <code>5</code>。</p><p>看起来怪吓人的，实则解法逻辑是一样的，把刚才的代码逻辑稍加改造即可解决这道题：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode[] nodes)</span> &#123;</span><br><span class="line">    <span class="comment">// 将列表转化成哈希集合，便于判断元素是否存在</span></span><br><span class="line">    HashSet&lt;Integer&gt; values = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (TreeNode node : nodes) &#123;</span><br><span class="line">        values.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> find(root, values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在二叉树中寻找 values 的最近公共祖先节点</span></span><br><span class="line">TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, HashSet&lt;Integer&gt; values)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="keyword">if</span> (values.contains(root.val))&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, values);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, values);</span><br><span class="line">    <span class="comment">// 后序位置，已经知道左右子树是否存在目标值</span></span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前节点是 LCA 节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有刚才的铺垫，你类比一下应该不难理解这个解法。</p><p><strong>不过需要注意的是，这两道题的题目都明确告诉我们这些节点必定存在于二叉树中，如果没有这个前提条件，就需要修改代码了</strong>。</p><p>比如力扣第 1644 题「<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-ii/">二叉树的最近公共祖先 IIopen in new window</a>」：</p><p>给你输入一棵<strong>不含重复值</strong>的二叉树的，以及两个节点 <code>p</code> 和 <code>q</code>，如果 <code>p</code> 或 <code>q</code> 不存在于树中，则返回空指针，否则的话返回 <code>p</code> 和 <code>q</code> 的最近公共祖先节点。</p><p>在解决标准的最近公共祖先问题时，我们在 <code>find</code> 函数的前序位置有这样一段代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前序位置</span></span><br><span class="line"><span class="keyword">if</span> (root.val == val1 || root.val == val2) &#123;</span><br><span class="line">    <span class="comment">// 如果遇到目标值，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我也进行了解释，因为 <code>p</code> 和 <code>q</code> 都存在于树中，所以这段代码恰好可以解决最近公共祖先的第二种情况：</p><p><img src="https://labuladong.online/algo/images/%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/4.jpg" alt="img"></p><p>但对于这道题来说，<code>p</code> 和 <code>q</code> 不一定存在于树中，所以你不能遇到一个目标值就直接返回，而应该对二叉树进行<strong>完全搜索</strong>（遍历每一个节点），如果发现 <code>p</code> 或 <code>q</code> 不存在于树中，那么是不存在 <code>LCA</code> 的。</p><p>回想我在文章开头分析的几种 <code>find</code> 函数的写法，哪种写法能够对二叉树进行完全搜索来着？</p><p>这种：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先去左右子树寻找</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, val);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, val);</span><br><span class="line">    <span class="comment">// 后序位置，判断 root 是不是目标节点</span></span><br><span class="line">    <span class="keyword">if</span> (root.val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// root 不是目标节点，再去看看哪边的子树找到了</span></span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么解决这道题也是类似的，我们只需要把前序位置的判断逻辑放到后序位置即可：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 用于记录 p 和 q 是否存在于二叉树中</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">foundP</span> <span class="operator">=</span> <span class="literal">false</span>, foundQ = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">res</span> <span class="operator">=</span> find(root, p.val, q.val);</span><br><span class="line">        <span class="keyword">if</span> (!foundP || !foundQ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p 和 q 都存在二叉树中，才有公共祖先</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在二叉树中寻找 val1 和 val2 的最近公共祖先节点</span></span><br><span class="line">    TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val1, <span class="type">int</span> val2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, val1, val2);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, val1, val2);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 后序位置，判断当前节点是不是 LCA 节点</span></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 后序位置，判断当前节点是不是目标值</span></span><br><span class="line">        <span class="keyword">if</span> (root.val == val1 || root.val == val2) &#123;</span><br><span class="line">            <span class="comment">// 找到了，记录一下</span></span><br><span class="line">            <span class="keyword">if</span> (root.val == val1) foundP = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (root.val == val2) foundQ = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样改造，对二叉树进行完全搜索，同时记录 <code>p</code> 和 <code>q</code> 是否同时存在树中，从而满足题目的要求。</p><p>接下来，我们再变一变，如果让你在二叉搜索树中寻找 <code>p</code> 和 <code>q</code> 的最近公共祖先，应该如何做呢？</p><p>提示</p><p>二叉搜索树相关的题目详解见 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAxODQxMDM0Mw==&action=getalbum&album_id=2121995456690946054">东哥带你刷二叉搜索树open in new window</a>。</p><p>看力扣第 235 题「<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">二叉搜索树的最近公共祖先open in new window</a>」：</p><p>给你输入一棵不含重复值的<strong>二叉搜索树</strong>，以及<strong>存在于树中</strong>的两个节点 <code>p</code> 和 <code>q</code>，请你计算 <code>p</code> 和 <code>q</code> 的最近公共祖先节点。</p><p>把之前的解法代码复制过来肯定也可以解决这道题，但没有用到 BST「左小右大」的性质，显然效率不是最高的。</p><p>在标准的最近公共祖先问题中，我们要在后序位置通过左右子树的搜索结果来判断当前节点是不是 <code>LCA</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, val1, val2);</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, val1, val2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序位置，判断当前节点是不是 LCA 节点</span></span><br><span class="line"><span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**但对于 BST 来说，根本不需要老老实实去遍历子树，由于 BST 左小右大的性质，将当前节点的值与 <code>val1</code> 和 <code>val2</code> 作对比即可判断当前节点是不是 <code>LCA</code>**：</p><p>假设 <code>val1 &lt; val2</code>，那么 <code>val1 &lt;= root.val &lt;= val2</code> 则说明当前节点就是 <code>LCA</code>；若 <code>root.val</code> 比 <code>val1</code> 还小，则需要去值更大的右子树寻找 <code>LCA</code>；若 <code>root.val</code> 比 <code>val2</code> 还大，则需要去值更小的左子树寻找 <code>LCA</code>。</p><p>依据这个思路就可以写出解法代码：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="comment">// 保证 val1 较小，val2 较大</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">val1</span> <span class="operator">=</span> Math.min(p.val, q.val);</span><br><span class="line">    <span class="type">int</span> <span class="variable">val2</span> <span class="operator">=</span> Math.max(p.val, q.val);</span><br><span class="line">    <span class="keyword">return</span> find(root, val1, val2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 BST 中寻找 val1 和 val2 的最近公共祖先节点</span></span><br><span class="line">TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val1, <span class="type">int</span> val2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; val2) &#123;</span><br><span class="line">        <span class="comment">// 当前节点太大，去左子树找</span></span><br><span class="line">        <span class="keyword">return</span> find(root.left, val1, val2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; val1) &#123;</span><br><span class="line">        <span class="comment">// 当前节点太小，去右子树找</span></span><br><span class="line">        <span class="keyword">return</span> find(root.right, val1, val2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// val1 &lt;= root.val &lt;= val2</span></span><br><span class="line">    <span class="comment">// 则当前节点就是最近公共祖先</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看最后一道最近公共祖先的题目吧，力扣第 1650 题「<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iii/">二叉树的最近公共祖先 IIIopen in new window</a>」，这次输入的二叉树节点比较特殊，包含指向父节点的指针：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line">    Node parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>给你输入一棵存在于二叉树中的两个节点 <code>p</code> 和 <code>q</code>，请你返回它们的最近公共祖先，函数签名如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node <span class="title function_">lowestCommonAncestor</span><span class="params">(Node p, Node q)</span>;</span><br></pre></td></tr></table></figure><p>由于节点中包含父节点的指针，所以二叉树的根节点就没必要输入了。</p><p><strong>这道题其实不是公共祖先的问题，而是单链表相交的问题</strong>，你把 <code>parent</code> 指针想象成单链表的 <code>next</code> 指针，题目就变成了：</p><p>给你输入两个单链表的头结点 <code>p</code> 和 <code>q</code>，这两个单链表必然会相交，请你返回相交点。</p><p><img src="https://labuladong.online/algo/images/%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/5.png" alt="img"></p><p>我在前文 <a href="https://labuladong.online/algo/essential-technique/linked-list-skills-summary/">单链表的六大解题套路</a> 中详细讲解过求链表交点的问题，具体思路在本文就不展开了，直接给出本题的解法代码：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node <span class="title function_">lowestCommonAncestor</span><span class="params">(Node p, Node q)</span> &#123;</span><br><span class="line">    <span class="comment">// 施展链表双指针技巧</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">a</span> <span class="operator">=</span> p, b = q;</span><br><span class="line">    <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">        <span class="comment">// a 走一步，如果走到根节点，转到 q 节点</span></span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">null</span>) a = q;</span><br><span class="line">        <span class="keyword">else</span>           a = a.parent;</span><br><span class="line">        <span class="comment">// b 走一步，如果走到根节点，转到 p 节点</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span>) b = p;</span><br><span class="line">        <span class="keyword">else</span>           b = b.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，5 道最近公共祖先的题目就全部讲完了，前 3 道题目从一个基本的 <code>find</code> 函数衍生出解法，后 2 道比较特殊，分别利用了 BST 和单链表相关的技巧，希望本文对你有启发。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>东哥带你刷二叉搜索树（构造篇）</title>
      <link href="/posts/36030.html"/>
      <url>/posts/36030.html</url>
      
        <content type="html"><![CDATA[<h1 id="东哥带你刷二叉搜索树（构造篇）"><a href="#东哥带你刷二叉搜索树（构造篇）" class="headerlink" title="东哥带你刷二叉搜索树（构造篇）"></a>东哥带你刷二叉搜索树（构造篇）</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/">95. Unique Binary Search Trees IIopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 IIopen in new window</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/unique-binary-search-trees/">96. Unique Binary Search Treesopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树open in new window</a></td><td align="center">🟠</td></tr></tbody></table><p>Info</p><p>在开头先打个广告，我的 <a href="https://labuladong.online/algo/tree-class/">手把手刷二叉树课程open in new window</a> 按照公式和套路讲解了 150 道二叉树题目，只需一顿饭钱，就能手把手带你刷完二叉树分类的题目，迅速掌握递归思维，让你豁然开朗。我绝对有这个信心，信不信，可以等你看完我的二叉树算法系列文章再做评判。</p><p>之前写了两篇手把手刷 BST 算法题的文章，<a href="https://labuladong.online/algo/data-structure/bst-part1/">第一篇</a> 讲了中序遍历对 BST 的重要意义，<a href="https://labuladong.online/algo/data-structure/bst-part2/">第二篇</a> 写了 BST 的基本操作。</p><p>本文就来写手把手刷 BST 系列的第三篇，循序渐进地讲两道题，如何计算所有有效 BST。</p><p>第一道题是力扣第 96 题「<a href="https://leetcode.cn/problems/unique-binary-search-trees/">不同的二叉搜索树open in new window</a>」，给你输入一个正整数 <code>n</code>，请你计算，存储 <code>&#123;1,2,3...,n&#125;</code> 这些值共有多少种不同的 BST 结构。</p><p>函数签名如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span>;</span><br></pre></td></tr></table></figure><p>比如说输入 <code>n = 3</code>，算法返回 5，因为共有如下 5 种不同的 BST 结构存储 <code>&#123;1,2,3&#125;</code>：</p><p><img src="https://labuladong.online/algo/images/BST3/2.jpg" alt="img"></p><p>这就是一个正宗的穷举问题，那么什么方式能够正确地穷举有效 BST 的数量呢？</p><p>我们前文说过，不要小看「穷举」，这是一件看起来简单但是比较有技术含量的事情，问题的关键就是不能数漏，也不能数多，你咋整？</p><p>之前 <a href="https://labuladong.online/algo/data-structure/binary-tree-part1/">手把手刷二叉树第一期</a> 说过，二叉树算法的关键就在于明确根节点需要做什么，其实 BST 作为一种特殊的二叉树，核心思路也是一样的。</p><p>🌟</p><hr><p>🌟</p><p>举个例子，比如给算法输入 <code>n = 5</code>，也就是说用 <code>&#123;1,2,3,4,5&#125;</code> 这些数字去构造 BST。</p><p>首先，这棵 BST 的根节点总共有几种情况？</p><p>显然有 5 种情况对吧，因为每个数字都可以作为根节点。</p><p>比如说我们固定 <code>3</code> 作为根节点，这个前提下能有几种不同的 BST 呢？</p><p>根据 BST 的特性，根节点的左子树都比根节点的值小，右子树的值都比根节点的值大。</p><p>所以如果固定 <code>3</code> 作为根节点，左子树节点就是 <code>&#123;1,2&#125;</code> 的组合，右子树就是 <code>&#123;4,5&#125;</code> 的组合。</p><p><strong>左子树的组合数和右子树的组合数乘积</strong>就是 <code>3</code> 作为根节点时的 BST 个数。</p><p><img src="https://labuladong.online/algo/images/BST3/1.jpeg" alt="img"></p><p>我们这是说了 <code>3</code> 为根节点这一种特殊情况，其实其他的节点也是一样的。</p><p>那你可能会问，我们可以一眼看出 <code>&#123;1,2&#125;</code> 和 <code>&#123;4,5&#125;</code> 有几种组合，但是怎么让算法进行计算呢？</p><p>其实很简单，只需要递归就行了，我们可以写这样一个函数：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：闭区间 [lo, hi] 的数字能组成 count(lo, hi) 种 BST</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span> lo, <span class="type">int</span> hi)</span>;</span><br></pre></td></tr></table></figure><p>根据这个函数的定义，结合刚才的分析，可以写出代码：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 主函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算闭区间 [1, n] 组成的 BST 个数</span></span><br><span class="line">    <span class="keyword">return</span> count(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算闭区间 [lo, hi] 组成的 BST 个数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (lo &gt; hi) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) &#123;</span><br><span class="line">        <span class="comment">// i 的值作为根节点 root</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> count(lo, i - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> count(i + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="comment">// 左右子树的组合数乘积是 BST 的总数</span></span><br><span class="line">        res += left * right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 base case，显然当 <code>lo &gt; hi</code> 闭区间 <code>[lo, hi]</code> 肯定是个空区间，也就对应着空节点 null，虽然是空节点，但是也是一种情况，所以要返回 1 而不能返回 0。</p><p>这样，题目的要求已经实现了，但是时间复杂度非常高，肯定存在重叠子问题。</p><p>前文动态规划相关的问题多次讲过消除重叠子问题的方法，无非就是加一个备忘录：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 备忘录</span></span><br><span class="line"><span class="type">int</span>[][] memo;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 备忘录的值初始化为 0</span></span><br><span class="line">    memo = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> count(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt; hi) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 查备忘录</span></span><br><span class="line">    <span class="keyword">if</span> (memo[lo][hi] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[lo][hi];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo; mid &lt;= hi; mid++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> count(lo, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> count(mid + <span class="number">1</span>, hi);</span><br><span class="line">        res += left * right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将结果存入备忘录</span></span><br><span class="line">    memo[lo][hi] = res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details data-v-fb30874b="" id="div_unique-binary-search-trees" class="hint-container details" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1.6em 0px; padding: 1rem 0px 0px; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary data-v-fb30874b="" style="position: relative; margin: -1.5rem 0px -0.5rem; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer; display: flex; align-items: center; font-size: large;"><strong data-v-fb30874b="" style="font-weight: 600;">🥳 代码可视化动画 🥳</strong><span data-v-fb30874b="" class="font-icon icon iconfont icon-resize" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-left: auto; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-refresh" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-link" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle;"></span></summary><div data-v-fb30874b="" class="resizable" style="width: 774.091px; max-width: 100%; height: 70vh; max-height: 70vh; overflow: auto; resize: both;"><iframe data-v-fb30874b="" id="iframe_unique-binary-search-trees" src="https://labuladong.online/algo-visualize/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>这样，这道题就完全解决了。</p><p>那么，如果给一个进阶题目，不止让你计算有几个不同的 BST，而是要你构建出所有有效的 BST，如何实现这个算法呢？</p><p>这道题就是力扣第 95 题「<a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/">不同的二叉搜索树 IIopen in new window</a>」，让你构建所有 BST，函数签名如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;TreeNode&gt; <span class="title function_">generateTrees</span><span class="params">(<span class="type">int</span> n)</span>;</span><br></pre></td></tr></table></figure><p>比如说输入 <code>n = 3</code>，算法返回一个列表，列表中存储着如下五棵 BST 的根节点：</p><p><img src="https://labuladong.online/algo/images/BST3/2.jpg" alt="img"></p><p><strong>明白了上道题构造有效 BST 的方法，这道题的思路也是一样的</strong>：</p><p>1、穷举 <code>root</code> 节点的所有可能。</p><p>2、递归构造出左右子树的所有有效 BST。</p><p>3、给 <code>root</code> 节点穷举所有左右子树的组合。</p><p>我们可以直接看代码：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/* 主函数 */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 构造闭区间 [1, n] 组成的 BST </span></span><br><span class="line">        <span class="keyword">return</span> build(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造闭区间 [lo, hi] 组成的 BST */</span></span><br><span class="line">    List&lt;TreeNode&gt; <span class="title function_">build</span><span class="params">(<span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        List&lt;TreeNode&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (lo &gt; hi) &#123;</span><br><span class="line">            <span class="comment">// 这里需要装一个 null 元素，这样才能让下面的两个内层 for 循环都能进入，正确地创建出叶子节点</span></span><br><span class="line">            <span class="comment">// 举例来说吧，什么时候会进到这个 if 语句？当你创建叶子节点的时候，对吧。</span></span><br><span class="line">            <span class="comment">// 那么如果你这里不加 null，直接返回空列表，那么下面的内层两个 for 循环都无法进入</span></span><br><span class="line">            <span class="comment">// 你的那个叶子节点就没有创建出来，看到了吗？所以这里要加一个 null，确保下面能把叶子节点做出来</span></span><br><span class="line">            res.add(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、穷举 root 节点的所有可能。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) &#123;</span><br><span class="line">            <span class="comment">// 2、递归构造出左右子树的所有有效 BST。</span></span><br><span class="line">            List&lt;TreeNode&gt; leftTree = build(lo, i - <span class="number">1</span>);</span><br><span class="line">            List&lt;TreeNode&gt; rightTree = build(i + <span class="number">1</span>, hi);</span><br><span class="line">            <span class="comment">// 3、给 root 节点穷举所有左右子树的组合。</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode left : leftTree) &#123;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode right : rightTree) &#123;</span><br><span class="line">                    <span class="comment">// i 作为根节点 root 的值</span></span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(i);</span><br><span class="line">                    root.left = left;</span><br><span class="line">                    root.right = right;</span><br><span class="line">                    res.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details data-v-fb30874b="" id="div_unique-binary-search-trees-ii" class="hint-container details" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1.6em 0px; padding: 1rem 0px 0px; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary data-v-fb30874b="" style="position: relative; margin: -1.5rem 0px -0.5rem; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer; display: flex; align-items: center; font-size: large;"><strong data-v-fb30874b="" style="font-weight: 600;">🥳 代码可视化动画 🥳</strong><span data-v-fb30874b="" class="font-icon icon iconfont icon-resize" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-left: auto; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-refresh" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-link" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle;"></span></summary><div data-v-fb30874b="" class="resizable" style="width: 774.091px; max-width: 100%; height: 70vh; max-height: 70vh; overflow: auto; resize: both;"><iframe data-v-fb30874b="" id="iframe_unique-binary-search-trees-ii" src="https://labuladong.online/algo-visualize/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>这样，两道题都解决了。</p><p>本文就到这里，更多经典的二叉树习题以及递归思维的训练，请参见 <a href="https://labuladong.online/algo/tree-class/">手把手带你刷通二叉树open in new window</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>东哥带你刷二叉树（后序篇）</title>
      <link href="/posts/34753.html"/>
      <url>/posts/34753.html</url>
      
        <content type="html"><![CDATA[<h1 id="东哥带你刷二叉树（后序篇）"><a href="#东哥带你刷二叉树（后序篇）" class="headerlink" title="东哥带你刷二叉树（后序篇）"></a>东哥带你刷二叉树（后序篇）</h1><p>本文是承接 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">东哥带你刷二叉树（纲领篇）</a> 的第四篇文章，主要讲二叉树后序位置的妙用，复述下前文关于后序遍历的描述：</p><blockquote><p>前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。</p><p><strong>那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了</strong>。</p></blockquote><p>多说无益，我们直接看题，这是力扣第 652 题「<a href="https://leetcode.cn/problems/find-duplicate-subtrees/">寻找重复的子树open in new window</a>」：</p><details class="hint-container details" open="" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1rem 0px; padding: 1.5rem; border-radius: 0.5rem; background: var(--detail-bg-color); color: rgb(44, 62, 80); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, STHeiti, &quot;Microsoft YaHei&quot;, SimSun, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1.5rem -1.5rem 0.5em; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer;"><strong style="font-weight: 600;">652. 寻找重复的子树</strong>&nbsp;|<span>&nbsp;</span><a target="_blank" href="https://leetcode.cn/problems/find-duplicate-subtrees/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|<span>&nbsp;</span><a target="_blank" href="https://leetcode.com/problems/find-duplicate-subtrees/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一棵二叉树的根节点<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">root</code><span>&nbsp;</span>，返回所有<span>&nbsp;</span><strong style="font-weight: 600;">重复的子树<span>&nbsp;</span></strong>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">对于同一类的重复子树，你只需要返回其中任意<span>&nbsp;</span><strong style="font-weight: 600;">一棵<span>&nbsp;</span></strong>的根结点即可。</p><p style="line-height: 1.6; overflow-wrap: break-word;">如果两棵树具有<strong style="font-weight: 600;"><span>&nbsp;</span>相同的结构</strong><span>&nbsp;</span>和<span>&nbsp;</span><strong style="font-weight: 600;">相同的结点值<span>&nbsp;</span></strong>，则认为二者是<span>&nbsp;</span><strong style="font-weight: 600;">重复<span>&nbsp;</span></strong>的。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://assets.leetcode.com/uploads/2020/08/16/e1.jpg" style="max-width: 100%; height: 236px; width: 300px; cursor: zoom-in;"></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>root = [1,2,3,4,null,2,4,null,null,4]<strong style="font-weight: 600;">输出：</strong>[[2,4],[4]]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><img alt="" src="https://assets.leetcode.com/uploads/2020/08/16/e2.jpg" style="max-width: 100%; height: 125px; width: 200px; cursor: zoom-in;"></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>root = [2,1,1]<strong style="font-weight: 600;">输出：</strong>[[1]]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><img alt="" src="https://assets.leetcode.com/uploads/2020/08/16/e33.jpg" style="max-width: 100%; height: 202px; width: 300px; cursor: zoom-in;"></strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>root = [2,2,2,3,null,3,null]<strong style="font-weight: 600;">输出：</strong>[[2,3],[3]]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>树中的结点数在<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">[1, 5000]</code><span>&nbsp;</span>范围内。</li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">-200 &lt;= Node.val &lt;= 200</code></li></ul></div></details><p>函数签名如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;TreeNode&gt; <span class="title function_">findDuplicateSubtrees</span><span class="params">(TreeNode root)</span>;</span><br></pre></td></tr></table></figure><p>我来简单解释下题目，输入是一棵二叉树的根节点 <code>root</code>，返回的是一个列表，里面装着若干个二叉树节点，这些节点对应的子树在原二叉树中是存在重复的。</p><p>说起来比较绕，举例来说，比如输入如下的二叉树：</p><p><img src="https://labuladong.online/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%913/1.png" alt="img"></p><p>首先，节点 4 本身可以作为一棵子树，且二叉树中有多个节点 4：</p><p><img src="https://labuladong.online/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%913/2.png" alt="img"></p><p>类似的，还存在两棵以 2 为根的重复子树：</p><p><img src="https://labuladong.online/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%913/3.png" alt="img"></p><p>那么，我们返回的 <code>List</code> 中就应该有两个 <code>TreeNode</code>，值分别为 4 和 2（具体是哪个节点都无所谓）。</p><p>🌟</p><hr><p>🌟</p><p>这题咋做呢？<strong>还是老套路，先思考，对于某一个节点，它应该做什么</strong>。</p><p>比如说，你站在图中这个节点 2 上：</p><p><img src="https://labuladong.online/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%913/4.png" alt="img"></p><p>如果你想知道以自己为根的子树是不是重复的，是否应该被加入结果列表中，你需要知道什么信息？</p><p><strong>你需要知道以下两点</strong>：</p><p><strong>1、以我为根的这棵二叉树（子树）长啥样</strong>？</p><p><strong>2、以其他节点为根的子树都长啥样</strong>？</p><p>这就叫知己知彼嘛，我得知道自己长啥样，还得知道别人长啥样，然后才能知道有没有人跟我重复，对不对？好，那我们一个一个来看。</p><p><strong>首先来思考，我如何才能知道以自己为根的这棵二叉树长啥样</strong>？</p><p>其实想到这里，就可以判断本题需要在二叉树的后序位置写代码了。</p><p>为什么？很简单呀，我要知道以自己为根的子树长啥样，是不是得先知道我的左右子树长啥样，再加上自己，就构成了整棵子树的样子？左右子树的样子，可不就得在后序位置通过递归函数的返回值传递回来吗？</p><p>如果你还绕不过来，我再来举个非常简单的例子：计算一棵二叉树有多少个节点。这个代码应该会写吧：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先算出左右子树有多少节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> count(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> count(root.right);</span><br><span class="line">    <span class="comment">// 后序位置，子树加上自己，就是整棵二叉树的节点数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> left + right + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这不就是标准的后序遍历框架嘛，和我们本题在本质上没啥区别对吧。</p><p>现在，明确了要用后序遍历，那应该怎么描述一棵二叉树的模样呢？我们后文 <a href="https://labuladong.online/algo/data-structure/serialize-and-deserialize-binary-tree/">序列化和反序列化二叉树</a> 其实写过了，二叉树的前序&#x2F;中序&#x2F;后序&#x2F;层序遍历结果可以描述二叉树的结构。</p><p>那么，我就以后序遍历结果作为序列化结果吧，可以通过拼接字符串的方式把二叉树序列化，看下代码：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：输入以 root 为根的二叉树，返回这棵树的序列化字符串</span></span><br><span class="line">String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// 对于空节点，可以用一个特殊字符表示</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将左右子树序列化成字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">left</span> <span class="operator">=</span> serialize(root.left);</span><br><span class="line">    <span class="type">String</span> <span class="variable">right</span> <span class="operator">=</span> serialize(root.right);</span><br><span class="line">    <span class="comment">/* 后序遍历代码位置 */</span></span><br><span class="line">    <span class="comment">// 左右子树加上自己，就是以自己为根的二叉树序列化结果</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">myself</span> <span class="operator">=</span> left + <span class="string">&quot;,&quot;</span> + right + <span class="string">&quot;,&quot;</span> + root.val;</span><br><span class="line">    <span class="keyword">return</span> myself;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用非数字的特殊符 <code>#</code> 表示空指针，并且用字符 <code>,</code> 分隔每个二叉树节点值，这属于序列化二叉树的套路了，不多说。</p><p>注意我们 <code>myself</code> 是按照左子树、右子树、根节点这样的顺序拼接字符串，也就是后序遍历顺序。因为我们这里的目的是通过序列化唯一描述一棵二叉树的结构，所以你也可以用前序顺序来拼接字符串，但是注意不能用中序顺序，具体原因参见后文 <a href="https://labuladong.online/algo/data-structure/serialize-and-deserialize-binary-tree/">序列化和反序列化二叉树</a> 的总结。</p><p>这样，我们第一个问题就解决了，对于每个节点，递归函数中的 <code>myself</code> 变量就可以描述以该节点为根的二叉树。</p><p><strong>现在我们解决第二个问题，我知道了自己长啥样，怎么知道别人长啥样</strong>？这样我才能知道有没有其他子树跟我重复对吧。</p><p>这很简单呀，我们借助一个外部数据结构，让每个节点把自己子树的序列化结果存进去，这样，对于每个节点，不就可以知道有没有其他节点的子树和自己重复了么？</p><p>初步思路可以使用 <code>HashSet</code> 记录所有子树的序列化结果，代码如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录所有子树</span></span><br><span class="line">HashSet&lt;String&gt; subTrees = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 记录重复的子树根节点</span></span><br><span class="line">LinkedList&lt;TreeNode&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右子树的序列化结果</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">left</span> <span class="operator">=</span> serialize(root.left);</span><br><span class="line">    <span class="type">String</span> <span class="variable">right</span> <span class="operator">=</span> serialize(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序位置，计算以自己为根的二叉树序列化结果</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">myself</span> <span class="operator">=</span> left + <span class="string">&quot;,&quot;</span> + right+ <span class="string">&quot;,&quot;</span> + root.val;</span><br><span class="line">    <span class="keyword">if</span> (subTrees.contains(myself)) &#123;</span><br><span class="line">        <span class="comment">// 有人和我重复，把自己加入结果列表</span></span><br><span class="line">        res.add(root);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 暂时没人跟我重复，把自己加入子树集合</span></span><br><span class="line">        subTrees.add(myself);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> myself;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是呢，这有个问题，如果出现多棵重复的子树，结果集 <code>res</code> 中必然出现重复，而题目要求不希望出现重复。</p><p>为了解决这个问题，可以把 <code>HashSet</code> 升级成 <code>HashMap</code>，额外记录每棵子树的出现次数：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录所有子树以及出现的次数</span></span><br><span class="line">    HashMap&lt;String, Integer&gt; subTrees = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 记录重复的子树根节点</span></span><br><span class="line">    LinkedList&lt;TreeNode&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 主函数 */</span></span><br><span class="line">    List&lt;TreeNode&gt; <span class="title function_">findDuplicateSubtrees</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        serialize(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 辅助函数 */</span></span><br><span class="line">    String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先算左右子树的序列化结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">left</span> <span class="operator">=</span> serialize(root.left);</span><br><span class="line">        <span class="type">String</span> <span class="variable">right</span> <span class="operator">=</span> serialize(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">myself</span> <span class="operator">=</span> left + <span class="string">&quot;,&quot;</span> + right+ <span class="string">&quot;,&quot;</span> + root.val;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">freq</span> <span class="operator">=</span> subTrees.getOrDefault(myself, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 多次重复也只会被加入结果集一次</span></span><br><span class="line">        <span class="keyword">if</span> (freq == <span class="number">1</span>) &#123;</span><br><span class="line">            res.add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 给子树对应的出现次数加一</span></span><br><span class="line">        subTrees.put(myself, freq + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> myself;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details data-v-fb30874b="" id="div_find-duplicate-subtrees" class="hint-container details" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1.6em 0px; padding: 1rem 0px 0px; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary data-v-fb30874b="" style="position: relative; margin: -1.5rem 0px -0.5rem; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer; display: flex; align-items: center; font-size: large;"><strong data-v-fb30874b="" style="font-weight: 600;">🍭 代码可视化动画 🍭</strong><span data-v-fb30874b="" class="font-icon icon iconfont icon-resize" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-left: auto; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-refresh" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-link" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle;"></span></summary><div data-v-fb30874b="" class="resizable" style="width: 774.091px; max-width: 100%; height: 70vh; max-height: 70vh; overflow: auto; resize: both;"><iframe data-v-fb30874b="" id="iframe_find-duplicate-subtrees" src="https://labuladong.online/algo-visualize/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>这样，这道题就完全解决了，题目本身算不上难，最后照应一下开头吧：</p><blockquote><p>前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。</p><p>那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>东哥带你刷二叉树（序列化篇）</title>
      <link href="/posts/9299.html"/>
      <url>/posts/9299.html</url>
      
        <content type="html"><![CDATA[<h1 id="东哥带你刷二叉树（序列化篇）"><a href="#东哥带你刷二叉树（序列化篇）" class="headerlink" title="东哥带你刷二叉树（序列化篇）"></a>东哥带你刷二叉树（序列化篇）</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/">297. Serialize and Deserialize Binary Treeopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化open in new window</a></td><td align="center">🔴</td></tr><tr><td align="center">-</td><td align="center"><a href="https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/">剑指 Offer 37. 序列化二叉树open in new window</a></td><td align="center">🔴</td></tr><tr><td align="center">-</td><td align="center"><a href="https://leetcode.cn/problems/h54YBf/">剑指 Offer II 048. 序列化与反序列化二叉树open in new window</a></td><td align="center">🔴</td></tr></tbody></table><p>Info</p><p>在开头先打个广告，我的 <a href="https://labuladong.online/algo/tree-class/">手把手刷二叉树课程open in new window</a> 按照公式和套路讲解了 150 道二叉树题目，只需一顿饭钱，就能手把手带你刷完二叉树分类的题目，迅速掌握递归思维，让你豁然开朗。我绝对有这个信心，信不信，可以等你看完我的二叉树算法系列文章再做评判。</p><p>本文是承接 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">东哥带你刷二叉树（纲领篇）</a> 的第三篇文章，前文 <a href="https://labuladong.online/algo/data-structure/binary-tree-part2/">东哥带你刷二叉树（构造篇）</a> 带你学习了二叉树构造技巧，本文加大难度，让你对二叉树同时进行「序列化」和「反序列化」。</p><p>要说序列化和反序列化，得先从 JSON 数据格式说起。</p><p>JSON 的运用非常广泛，比如我们经常将变成语言中的结构体序列化成 JSON 字符串，存入缓存或者通过网络发送给远端服务，消费者接受 JSON 字符串然后进行反序列化，就可以得到原始数据了。</p><p>这就是序列化和反序列化的目的，以某种特定格式组织数据，使得数据可以独立于编程语言。</p><p>那么假设现在有一棵用 Java 实现的二叉树，我想把它通过某些方式存储下来，然后用 C++ 读取这棵并还原这棵二叉树的结构，怎么办？这就需要对二叉树进行序列化和反序列化了。</p><h3 id="零、前-中-后序和二叉树的唯一性"><a href="#零、前-中-后序和二叉树的唯一性" class="headerlink" title="#零、前&#x2F;中&#x2F;后序和二叉树的唯一性"></a><a href="https://labuladong.online/algo/data-structure/serialize-and-deserialize-binary-tree/#%E9%9B%B6%E3%80%81%E5%89%8D-%E4%B8%AD-%E5%90%8E%E5%BA%8F%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7">#</a>零、前&#x2F;中&#x2F;后序和二叉树的唯一性</h3><p>谈具体的题目之前，我们先思考一个问题：<strong>什么样的序列化的数据可以反序列化出唯一的一棵二叉树</strong>？</p><p>比如说，如果给你一棵二叉树的前序遍历结果，你是否能够根据这个结果还原出这棵二叉树呢？</p><p>答案是也许可以，也许不可以，具体要看你给的前序遍历结果是否包含空指针的信息。如果包含了空指针，那么就可以唯一确定一棵二叉树，否则就不行。</p><p>举例来说，如果我给你这样一个不包含空指针的前序遍历结果 <code>[1,2,3,4,5]</code>，那么如下两棵二叉树都是满足这个前序遍历结果的：</p><p><img src="https://labuladong.online/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BA%8F%E5%88%97%E5%8C%96/dup-preorder.jpg" alt="img"></p><p>所以给定不包含空指针信息的前序遍历结果，是不能还原出唯一的一棵二叉树的。</p><p>但如果我的前序遍历结果包含空指针的信息，那么就能还原出唯一的一棵二叉树了。比如说用 <code>#</code> 表示空指针，上图左侧的二叉树的前序遍历结果就是 <code>[1,2,3,#,#,4,#,#,5,#,#]</code>，上图右侧的二叉树的前序遍历结果就是 <code>[1,2,#,3,#,#,4,5,#,#,#]</code>，它俩就区分开了。</p><p>那么估计就有聪明的小伙伴说了：东哥我懂了，甭管是前中后序哪一种遍历顺序，只要序列化的结果中包含了空指针的信息，就能还原出唯一的一棵二叉树了。</p><p>首先要夸一下这种举一反三的思维，但很不幸，正确答案是，即便你包含了空指针的信息，也只有前序和后序的遍历结果才能唯一还原二叉树，中序遍历结果做不到。</p><p>本文后面会具体探讨这个问题，这里只简单说下原因：因为前序&#x2F;后序遍历的结果中，可以确定根节点的位置，而中序遍历的结果中，根节点的位置是无法确定的。</p><p>更直观的，比如如下两棵二叉树显然拥有不同的结构，但它俩的中序遍历结果都是 <code>[#,1,#,1,#]</code>，无法区分：</p><p><img src="https://labuladong.online/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BA%8F%E5%88%97%E5%8C%96/dup-inorder.jpg" alt="img"></p><p>说了这么多，总结下结论，<strong>当二叉树中节点的值不存在重复时</strong>：</p><ol><li><p>如果你的序列化结果中<strong>不包含空指针的信息</strong>，且你只给出<strong>一种</strong>遍历顺序，那么你无法还原出唯一的一棵二叉树。</p></li><li><p>如果你的序列化结果中<strong>不包含空指针的信息</strong>，且你会给出<strong>两种</strong>遍历顺序，那么按照前文 <a href="https://labuladong.online/algo/data-structure/binary-tree-part2/">东哥手把手带你刷二叉树（构造篇）</a> 所说，分两种情况：</p><p>2.1. 如果你给出的是前序和中序，或者后序和中序，那么你可以还原出唯一的一棵二叉树。</p><p>2.2. 如果你给出前序和后序，那么你无法还原出唯一的一棵二叉树。</p></li><li><p>如果你的序列化结果中<strong>包含空指针的信息</strong>，且你只给出<strong>一种</strong>遍历顺序，也要分两种情况：</p><p>3.1. 如果你给出的是前序或者后序，那么你可以还原出唯一的一棵二叉树。</p><p>3.2. 如果你给出的是中序，那么你无法还原出唯一的一棵二叉树。</p></li></ol><p>我在开头提一下这些总结性的认识，可以理解性记忆，之后会遇到一些相关的题目，再回过头来看看这些总结，会有更深的理解，下面看具体的题目吧。</p><h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="#一、题目描述"></a><a href="https://labuladong.online/algo/data-structure/serialize-and-deserialize-binary-tree/#%E4%B8%80%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">#</a>一、题目描述</h3><p>力扣第 297 题「<a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">二叉树的序列化与反序列化open in new window</a>」就是给你输入一棵二叉树的根节点 <code>root</code>，要求你实现如下一个类：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把一棵二叉树序列化成字符串</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把字符串反序列化成二叉树</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以用 <code>serialize</code> 方法将二叉树序列化成字符串，用 <code>deserialize</code> 方法将序列化的字符串反序列化成二叉树，至于以什么格式序列化和反序列化，这个完全由你决定。</p><p>比如说输入如下这样一棵二叉树：</p><p><img src="https://labuladong.online/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BA%8F%E5%88%97%E5%8C%96/1.jpg" alt="img"></p><p><code>serialize</code> 方法也许会把它序列化成字符串 <code>2,1,#,6,#,#,3,#,#</code>，其中 <code>#</code> 表示 <code>null</code> 指针，那么把这个字符串再输入 <code>deserialize</code> 方法，依然可以还原出这棵二叉树。</p><p>也就是说，这两个方法会成对儿使用，你只要保证他俩能够自洽就行了。</p><p>想象一下，二叉树结该是一个二维平面内的结构，而序列化出来的字符串是一个线性的一维结构。<strong>所谓的序列化不过就是把结构化的数据「打平」，本质就是在考察二叉树的遍历方式</strong>。</p><p>二叉树的遍历方式有哪些？递归遍历方式有前序遍历，中序遍历，后序遍历；迭代方式一般是层级遍历。本文就把这些方式都尝试一遍，来实现 <code>serialize</code> 方法和 <code>deserialize</code> 方法。</p><h3 id="二、前序遍历解法"><a href="#二、前序遍历解法" class="headerlink" title="#二、前序遍历解法"></a><a href="https://labuladong.online/algo/data-structure/serialize-and-deserialize-binary-tree/#%E4%BA%8C%E3%80%81%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E8%A7%A3%E6%B3%95">#</a>二、前序遍历解法</h3><p>前文 <a href="https://labuladong.online/algo/essential-technique/abstraction-of-algorithm/">学习数据结构和算法的框架思维</a> 说过了二叉树的几种遍历方式，前序遍历框架如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序位置的代码</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真的很简单，在递归遍历两棵子树之前写的代码就是前序遍历代码，那么请你看一看如下伪码：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; res;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 暂且用数字 -1 代表空指针 null</span></span><br><span class="line">        res.addLast(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/****** 前序位置 ******/</span></span><br><span class="line">    res.addLast(root.val);</span><br><span class="line">    <span class="comment">/***********************/</span></span><br><span class="line"></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>traverse</code> 函数之后，你是否可以立即想出这个 <code>res</code> 列表中元素的顺序是怎样的？比如如下二叉树（<code>#</code> 代表空指针 null），可以直观看出前序遍历做的事情：</p><p><img src="https://labuladong.online/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BA%8F%E5%88%97%E5%8C%96/1.jpeg" alt="img"></p><p>那么 <code>res = [1,2,-1,4,-1,-1,3,-1,-1]</code>，这就是将二叉树「打平」到了一个列表中，其中 -1 代表 null。</p><p>那么，将二叉树打平到一个字符串中也是完全一样的：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代表分隔符的字符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">SEP</span> <span class="operator">=</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line"><span class="comment">// 代表 null 空指针的字符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">NULL</span> <span class="operator">=</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line"><span class="comment">// 用于拼接字符串</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将二叉树打平为字符串 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, StringBuilder sb)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        sb.append(NULL).append(SEP);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/****** 前序位置 ******/</span></span><br><span class="line">    sb.append(root.val).append(SEP);</span><br><span class="line">    <span class="comment">/***********************/</span></span><br><span class="line"></span><br><span class="line">    traverse(root.left, sb);</span><br><span class="line">    traverse(root.right, sb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>StringBuilder</code> 可以用于高效拼接字符串，所以也可以认为是一个列表，用 <code>,</code> 作为分隔符，用 <code>#</code> 表示空指针 null，调用完 <code>traverse</code> 函数后，<code>sb</code> 中的字符串应该是 <code>1,2,#,4,#,#,3,#,#,</code>。</p><p>至此，我们已经可以写出序列化函数 <code>serialize</code> 的代码了：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">SEP</span> <span class="operator">=</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">NULL</span> <span class="operator">=</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主函数，将二叉树序列化为字符串 */</span></span><br><span class="line">String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    serialize(root, sb);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 辅助函数，将二叉树存入 StringBuilder */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(TreeNode root, StringBuilder sb)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        sb.append(NULL).append(SEP);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/****** 前序位置 ******/</span></span><br><span class="line">    sb.append(root.val).append(SEP);</span><br><span class="line">    <span class="comment">/***********************/</span></span><br><span class="line"></span><br><span class="line">    serialize(root.left, sb);</span><br><span class="line">    serialize(root.right, sb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，思考一下如何写 <code>deserialize</code> 函数，将字符串反过来构造二叉树。</p><p>首先我们可以把字符串转化成列表：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;1,2,#,4,#,#,3,#,#,&quot;</span>;</span><br><span class="line">String[] nodes = data.split(<span class="string">&quot;,&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样，<code>nodes</code> 列表就是二叉树的前序遍历结果，问题转化为：如何通过二叉树的前序遍历结果还原一棵二叉树？</p><p>提示</p><p>前文 <a href="https://labuladong.online/algo/data-structure/binary-tree-part2/">东哥带你刷二叉树（构造篇）</a> 说过，至少要得到前、中、后序遍历中的两种互相配合才能还原二叉树。那是因为前文的遍历结果没有记录空指针的信息。这里的 <code>nodes</code> 列表包含了空指针的信息，所以只使用 <code>nodes</code> 列表就可以还原二叉树。</p><p>根据我们刚才的分析，<code>nodes</code> 列表就是一棵打平的二叉树：</p><p><img src="https://labuladong.online/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BA%8F%E5%88%97%E5%8C%96/1.jpeg" alt="img"></p><p>那么，反序列化过程也是一样，<strong>先确定根节点 <code>root</code>，然后遵循前序遍历的规则，递归生成左右子树即可</strong>：</p><p>🌟</p><hr><p>🌟</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 主函数，将字符串反序列化为二叉树结构 */</span></span><br><span class="line">TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">    <span class="comment">// 将字符串转化成列表</span></span><br><span class="line">    LinkedList&lt;String&gt; nodes = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : data.split(SEP)) &#123;</span><br><span class="line">        nodes.addLast(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deserialize(nodes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 辅助函数，通过 nodes 列表构造二叉树 */</span></span><br><span class="line">TreeNode <span class="title function_">deserialize</span><span class="params">(LinkedList&lt;String&gt; nodes)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nodes.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/****** 前序位置 ******/</span></span><br><span class="line">    <span class="comment">// 列表最左侧就是根节点</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> nodes.removeFirst();</span><br><span class="line">    <span class="keyword">if</span> (first.equals(NULL)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(first));</span><br><span class="line">    <span class="comment">/***********************/</span></span><br><span class="line"></span><br><span class="line">    root.left = deserialize(nodes);</span><br><span class="line">    root.right = deserialize(nodes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，根据树的递归性质，<code>nodes</code> 列表的第一个元素就是一棵树的根节点，所以只要将列表的第一个元素取出作为根节点，剩下的交给递归函数去解决即可。</p><h3 id="三、后序遍历解法"><a href="#三、后序遍历解法" class="headerlink" title="#三、后序遍历解法"></a><a href="https://labuladong.online/algo/data-structure/serialize-and-deserialize-binary-tree/#%E4%B8%89%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E8%A7%A3%E6%B3%95">#</a>三、后序遍历解法</h3><p>二叉树的后序遍历框架：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序位置的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明白了前序遍历的解法，后序遍历就比较容易理解了，我们首先实现 <code>serialize</code> 序列化方法，只需要稍微修改辅助方法即可：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 辅助函数，将二叉树存入 StringBuilder */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(TreeNode root, StringBuilder sb)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        sb.append(NULL).append(SEP);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    serialize(root.left, sb);</span><br><span class="line">    serialize(root.right, sb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/****** 后序位置 ******/</span></span><br><span class="line">    sb.append(root.val).append(SEP);</span><br><span class="line">    <span class="comment">/***********************/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把对 <code>StringBuilder</code> 的拼接操作放到了后序遍历的位置，后序遍历导致结果的顺序发生变化：</p><p><img src="https://labuladong.online/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BA%8F%E5%88%97%E5%8C%96/2.jpeg" alt="img"></p><p>关键点在于，如何实现后序遍历的 <code>deserialize</code> 方法呢？是不是也简单地将反序列化的关键代码无脑放到后序遍历的位置就行了呢：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 辅助函数，通过 nodes 列表构造二叉树 */</span></span><br><span class="line">TreeNode <span class="title function_">deserialize</span><span class="params">(LinkedList&lt;String&gt; nodes)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nodes.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    root.left = deserialize(nodes);</span><br><span class="line">    root.right = deserialize(nodes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/****** 后序位置 ******/</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> nodes.removeFirst();</span><br><span class="line">    <span class="keyword">if</span> (first.equals(NULL)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(first));</span><br><span class="line">    <span class="comment">/***********************/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然上述代码是错误的，变量都没声明呢，就开始用了？生搬硬套肯定是行不通的，回想刚才我们前序遍历方法中的 <code>deserialize</code> 方法，第一件事情在做什么？</p><p><strong><code>deserialize</code> 方法首先寻找 <code>root</code> 节点的值，然后递归计算左右子节点</strong>。那么我们这里也应该顺着这个基本思路走，后序遍历中，<code>root</code> 节点的值能不能找到？</p><p>再看一眼刚才的图：</p><p><img src="https://labuladong.online/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BA%8F%E5%88%97%E5%8C%96/2.jpeg" alt="img"></p><p>在后序遍历结果中，<code>root</code> 的值是列表的最后一个元素。我们应该从后往前取出列表元素，先用最后一个元素构造 <code>root</code>，然后递归调用生成 <code>root</code> 的左右子树。</p><p><strong>注意，根据上图，从后往前在 <code>nodes</code> 列表中取元素，一定要先构造 <code>root.right</code> 子树，后构造 <code>root.left</code> 子树</strong>。</p><p>看完整代码：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 主函数，将字符串反序列化为二叉树结构 */</span></span><br><span class="line">TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">    LinkedList&lt;String&gt; nodes = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : data.split(SEP)) &#123;</span><br><span class="line">        nodes.addLast(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deserialize(nodes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 辅助函数，通过 nodes 列表构造二叉树 */</span></span><br><span class="line">TreeNode <span class="title function_">deserialize</span><span class="params">(LinkedList&lt;String&gt; nodes)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nodes.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 从后往前取出元素</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> nodes.removeLast();</span><br><span class="line">    <span class="keyword">if</span> (last.equals(NULL)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(last));</span><br><span class="line">    <span class="comment">// 先构造右子树，后构造左子树</span></span><br><span class="line">    root.right = deserialize(nodes);</span><br><span class="line">    root.left = deserialize(nodes);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，后序遍历实现的序列化、反序列化方法也都实现了。</p><h3 id="四、中序遍历解法"><a href="#四、中序遍历解法" class="headerlink" title="#四、中序遍历解法"></a><a href="https://labuladong.online/algo/data-structure/serialize-and-deserialize-binary-tree/#%E5%9B%9B%E3%80%81%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E8%A7%A3%E6%B3%95">#</a>四、中序遍历解法</h3><p>先说结论，中序遍历的方式行不通，因为无法实现反序列化方法 <code>deserialize</code>。</p><p>序列化方法 <code>serialize</code> 依然容易，只要把字符串的拼接操作放到中序遍历的位置就行了：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 辅助函数，将二叉树存入 StringBuilder */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(TreeNode root, StringBuilder sb)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        sb.append(NULL).append(SEP);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serialize(root.left, sb);</span><br><span class="line">    <span class="comment">/******* 中序位置 *******/</span></span><br><span class="line">    sb.append(root.val).append(SEP);</span><br><span class="line">    <span class="comment">/***********************/</span></span><br><span class="line">    serialize(root.right, sb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，我们刚才说了，要想实现反序列方法，首先要构造 <code>root</code> 节点。前序遍历得到的 <code>nodes</code> 列表中，第一个元素是 <code>root</code> 节点的值；后序遍历得到的 <code>nodes</code> 列表中，最后一个元素是 <code>root</code> 节点的值。</p><p>你看上面这段中序遍历的代码，<code>root</code> 的值被夹在两棵子树的中间，也就是在 <code>nodes</code> 列表的中间，我们不知道确切的索引位置，所以无法找到 <code>root</code> 节点，也就无法进行反序列化。</p><h3 id="五、层级遍历解法"><a href="#五、层级遍历解法" class="headerlink" title="#五、层级遍历解法"></a><a href="https://labuladong.online/algo/data-structure/serialize-and-deserialize-binary-tree/#%E4%BA%94%E3%80%81%E5%B1%82%E7%BA%A7%E9%81%8D%E5%8E%86%E8%A7%A3%E6%B3%95">#</a>五、层级遍历解法</h3><p>首先，先写出层级遍历二叉树的代码框架：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 初始化队列，将 root 加入队列</span></span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="comment">/* 层级遍历代码位置 */</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            System.out.println(cur.val);</span><br><span class="line">            <span class="comment">/*****************/</span></span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                q.offer(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                q.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上述代码是标准的二叉树层级遍历框架</strong>，从上到下，从左到右打印每一层二叉树节点的值，可以看到，队列 <code>q</code> 中不会存在 null 指针。</p><p>不过我们在反序列化的过程中是需要记录空指针 null 的，所以可以把标准的层级遍历框架略作修改：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 初始化队列，将 root 加入队列</span></span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="comment">/* 层级遍历代码位置 */</span></span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            System.out.println(root.val);</span><br><span class="line">            <span class="comment">/*****************/</span></span><br><span class="line">            q.offer(cur.left);</span><br><span class="line">            q.offer(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样也可以完成层级遍历，只不过我们把对空指针的检验从「将元素加入队列」的时候改成了「从队列取出元素」的时候。</p><p>那么我们完全仿照这个框架即可写出序列化方法：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">SEP</span> <span class="operator">=</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">NULL</span> <span class="operator">=</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将二叉树序列化为字符串 */</span></span><br><span class="line">String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="comment">// 初始化队列，将 root 加入队列</span></span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="comment">/* 层级遍历代码位置 */</span></span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="literal">null</span>) &#123;</span><br><span class="line">                sb.append(NULL).append(SEP);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(cur.val).append(SEP);</span><br><span class="line">            <span class="comment">/*****************/</span></span><br><span class="line">            q.offer(cur.left);</span><br><span class="line">            q.offer(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>层级遍历序列化得出的结果如下图：</p><p><img src="https://labuladong.online/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BA%8F%E5%88%97%E5%8C%96/3.jpeg" alt="img"></p><p>可以看到，每一个非空节点都会对应两个子节点，<strong>那么反序列化的思路也是用队列进行层级遍历，同时用索引 <code>index</code> 记录对应子节点的位置</strong>：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 将字符串反序列化为二叉树结构 */</span></span><br><span class="line">TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (data.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    String[] nodes = data.split(SEP);</span><br><span class="line">    <span class="comment">// 第一个元素就是 root 的值</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(nodes[<span class="number">0</span>]));</span><br><span class="line">    <span class="comment">// 队列 q 记录父节点，将 root 加入队列</span></span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// index 变量记录正在序列化的节点在数组中的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">parent</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="comment">// 为父节点构造左侧子节点</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">left</span> <span class="operator">=</span> nodes[index++];</span><br><span class="line">            <span class="keyword">if</span> (!left.equals(NULL)) &#123;</span><br><span class="line">                parent.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(left));</span><br><span class="line">                q.offer(parent.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 为父节点构造右侧子节点</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">right</span> <span class="operator">=</span> nodes[index++];</span><br><span class="line">            <span class="keyword">if</span> (!right.equals(NULL)) &#123;</span><br><span class="line">                parent.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(right));</span><br><span class="line">                q.offer(parent.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现，这个反序列化的代码逻辑也是标准的二叉树层级遍历的代码衍生出来的。我们的函数通过 <code>nodes[index]</code> 来计算左右子节点，接到父节点上并加入队列，一层一层地反序列化出来一棵二叉树。</p><p>到这里，我们对于二叉树的序列化和反序列化的几种方法就全部讲完了。更多经典的二叉树习题以及递归思维的训练，请参见 <a href="https://labuladong.online/algo/tree-class/">手把手带你刷通二叉树open in new window</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序详解及应用</title>
      <link href="/posts/55187.html"/>
      <url>/posts/55187.html</url>
      
        <content type="html"><![CDATA[<h1 id="归并排序详解及应用"><a href="#归并排序详解及应用" class="headerlink" title="归并排序详解及应用"></a>归并排序详解及应用</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/">315. Count of Smaller Numbers After Selfopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数open in new window</a></td><td align="center">🔴</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/count-of-range-sum/">327. Count of Range Sumopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/count-of-range-sum/">327. 区间和的个数open in new window</a></td><td align="center">🔴</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/reverse-pairs/">493. Reverse Pairsopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/reverse-pairs/">493. 翻转对open in new window</a></td><td align="center">🔴</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/sort-an-array/">912. Sort an Arrayopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/sort-an-array/">912. 排序数组open in new window</a></td><td align="center">🟠</td></tr></tbody></table><p>一直都有很多读者说，想让我用 <a href="https://labuladong.online/algo/essential-technique/abstraction-of-algorithm/">框架思维</a> 讲一讲基本的排序算法，我觉得确实得讲讲，毕竟学习任何东西都讲求一个融会贯通，只有对其本质进行比较深刻的理解，才能运用自如。</p><p>本文就先讲归并排序，给一套代码模板，然后讲讲它在算法问题中的应用。阅读本文前我希望你读过前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树（纲领篇）</a>。</p><p>我在 <a href="https://labuladong.online/algo/data-structure/binary-tree-part1/">手把手刷二叉树（第一期）</a> 讲二叉树的时候，提了一嘴归并排序，说归并排序就是二叉树的后序遍历，当时就有很多读者留言说醍醐灌顶。</p><p>知道为什么很多读者遇到递归相关的算法就觉得烧脑吗？因为还处在「看山是山，看水是水」的阶段。</p><p>就说归并排序吧，如果给你看代码，让你脑补一下归并排序的过程，你脑子里会出现什么场景？</p><p>这是一个数组排序算法，所以你脑补一个数组的 GIF，在那一个个交换元素？如果是这样的话，那格局就低了。</p><p>但如果你脑海中浮现出的是一棵二叉树，甚至浮现出二叉树后序遍历的场景，那格局就高了，大概率掌握了我经常强调的 <a href="https://labuladong.online/algo/essential-technique/abstraction-of-algorithm/">框架思维</a>，用这种抽象能力学习算法就省劲多了。</p><p>那么，归并排序明明就是一个数组算法，和二叉树有什么关系？接下来我就具体讲讲。</p><hr><p>🌟</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="#算法思路"></a><a href="https://labuladong.online/algo/practice-in-action/merge-sort/#%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF">#</a>算法思路</h3><p><strong>就这么说吧，所有递归的算法，你甭管它是干什么的，本质上都是在遍历一棵（递归）树，然后在节点（前中后序位置）上执行代码，你要写递归算法，本质上就是要告诉每个节点需要做什么</strong>。</p><p>你看归并排序的代码框架：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：排序 nums[lo..hi]</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lo == hi) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (lo + hi) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 利用定义，排序 nums[lo..mid]</span></span><br><span class="line">    sort(nums, lo, mid);</span><br><span class="line">    <span class="comment">// 利用定义，排序 nums[mid+1..hi]</span></span><br><span class="line">    sort(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/****** 后序位置 ******/</span></span><br><span class="line">    <span class="comment">// 此时两部分子数组已经被排好序</span></span><br><span class="line">    <span class="comment">// 合并两个有序数组，使 nums[lo..hi] 有序</span></span><br><span class="line">    merge(nums, lo, mid, hi);</span><br><span class="line">    <span class="comment">/*********************/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将有序数组 nums[lo..mid] 和有序数组 nums[mid+1..hi]</span></span><br><span class="line"><span class="comment">// 合并为有序数组 nums[lo..hi]</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> mid, <span class="type">int</span> hi)</span>;</span><br></pre></td></tr></table></figure><p>看这个框架，也就明白那句经典的总结：归并排序就是先把左半边数组排好序，再把右半边数组排好序，然后把两半数组合并。</p><p>上述代码和二叉树的后序遍历很像：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 二叉树遍历框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">    <span class="comment">/****** 后序位置 ******/</span></span><br><span class="line">    print(root.val);</span><br><span class="line">    <span class="comment">/*********************/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再进一步，你联想一下求二叉树的最大深度的算法代码：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：输入根节点，返回这棵二叉树的最大深度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用定义，计算左右子树的最大深度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line"><span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line"><span class="comment">// 整棵树的最大深度等于左右子树的最大深度取最大值，</span></span><br><span class="line">    <span class="comment">// 然后再加上根节点自己</span></span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(leftMax, rightMax) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是更像了？</p><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树（纲领篇）</a> 说二叉树问题可以分为两类思路，一类是遍历一遍二叉树的思路，另一类是分解问题的思路，根据上述类比，显然归并排序利用的是分解问题的思路（<a href="https://labuladong.online/algo/practice-in-action/divide-and-conquer/">分治算法</a>）。</p><p><strong>归并排序的过程可以在逻辑上抽象成一棵二叉树，树上的每个节点的值可以认为是 <code>nums[lo..hi]</code>，叶子节点的值就是数组中的单个元素</strong>：</p><p><img src="https://labuladong.online/algo/images/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/1.jpeg" alt="img"></p><p>然后，在每个节点的后序位置（左右子节点已经被排好序）的时候执行 <code>merge</code> 函数，合并两个子节点上的子数组：</p><p><img src="https://labuladong.online/algo/images/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/2.jpeg" alt="img"></p><p>这个 <code>merge</code> 操作会在二叉树的每个节点上都执行一遍，执行顺序是二叉树后序遍历的顺序。</p><p>后序遍历二叉树大家应该已经烂熟于心了，就是下图这个遍历顺序：</p><p><img src="https://labuladong.online/algo/images/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/3.jpeg" alt="img"></p><p>结合上述基本分析，我们把 <code>nums[lo..hi]</code> 理解成二叉树的节点，<code>sort</code> 函数理解成二叉树的遍历函数，整个归并排序的执行过程就是以下 GIF 描述的这样：</p><p><img src="https://labuladong.online/algo/images/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/4.gif" alt="img"></p><p>这样，归并排序的核心思路就分析完了，接下来只要把思路翻译成代码就行。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="#代码实现"></a><a href="https://labuladong.online/algo/practice-in-action/merge-sort/#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">#</a>代码实现</h3><p><strong>只要拥有了正确的思维方式，理解算法思路是不困难的，但把思路实现成代码，也很考验一个人的编程能力</strong>。</p><p>毕竟算法的时间复杂度只是一个理论上的衡量标准，而算法的实际运行效率要考虑的因素更多，比如应该避免内存的频繁分配释放，代码逻辑应尽可能简洁等等。</p><p>经过对比，《算法 4》中给出的归并排序代码兼具了简洁和高效的特点，所以我们可以参考书中给出的代码作为归并算法模板：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Merge</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于辅助合并有序数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 先给辅助数组开辟内存空间</span></span><br><span class="line">        temp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="comment">// 排序整个数组（原地修改）</span></span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：将子数组 nums[lo..hi] 进行排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lo == hi) &#123;</span><br><span class="line">            <span class="comment">// 单个元素不用排序</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这样写是为了防止溢出，效果等同于 (hi + lo) / 2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 先对左半部分数组 nums[lo..mid] 排序</span></span><br><span class="line">        sort(nums, lo, mid);</span><br><span class="line">        <span class="comment">// 再对右半部分数组 nums[mid+1..hi] 排序</span></span><br><span class="line">        sort(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="comment">// 将两部分有序数组合并成一个有序数组</span></span><br><span class="line">        merge(nums, lo, mid, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 nums[lo..mid] 和 nums[mid+1..hi] 这两个有序数组合并成一个有序数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> mid, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="comment">// 先把 nums[lo..hi] 复制到辅助数组中</span></span><br><span class="line">        <span class="comment">// 以便合并后的结果能够直接存入 nums</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) &#123;</span><br><span class="line">            temp[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组双指针技巧，合并两个有序数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> lo; p &lt;= hi; p++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == mid + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 左半边数组已全部被合并</span></span><br><span class="line">                nums[p] = temp[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == hi + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 右半边数组已全部被合并</span></span><br><span class="line">                nums[p] = temp[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp[i] &gt; temp[j]) &#123;</span><br><span class="line">                nums[p] = temp[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[p] = temp[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了之前的铺垫，这里只需要着重讲一下这个 <code>merge</code> 函数。</p><p><code>sort</code> 函数对 <code>nums[lo..mid]</code> 和 <code>nums[mid+1..hi]</code> 递归排序完成之后，我们没有办法原地把它俩合并，所以需要 copy 到 <code>temp</code> 数组里面，然后通过类似于前文 <a href="https://labuladong.online/algo/essential-technique/linked-list-skills-summary/">单链表的六大技巧</a> 中合并有序链表的双指针技巧将 <code>nums[lo..hi]</code> 合并成一个有序数组：</p><p><img src="https://labuladong.online/algo/images/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/5.jpeg" alt="img"></p><p>注意我们不是在 <code>merge</code> 函数执行的时候 new 辅助数组，而是提前把 <code>temp</code> 辅助数组 new 出来了，这样就避免了在递归中频繁分配和释放内存可能产生的性能问题。</p><p>贴一个归并排序过程的可视化动画，方便大家理解算法运行的过程：</p><details data-v-fb30874b="" id="div_mydata-merge-sort" class="hint-container details" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1.6em 0px; padding: 1rem 0px 0px; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary data-v-fb30874b="" style="position: relative; margin: -1.5rem 0px -0.5rem; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer; display: flex; align-items: center; font-size: large;"><strong data-v-fb30874b="" style="font-weight: 600;">🌈 代码可视化动画 🌈</strong><span data-v-fb30874b="" class="font-icon icon iconfont icon-resize" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-left: auto; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-refresh" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-link" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle;"></span></summary><div data-v-fb30874b="" class="resizable" style="width: 774.091px; max-width: 100%; height: 70vh; max-height: 70vh; overflow: auto; resize: both;"><iframe data-v-fb30874b="" id="iframe_mydata-merge-sort" src="https://labuladong.online/algo-visualize/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="#复杂度分析"></a><a href="https://labuladong.online/algo/practice-in-action/merge-sort/#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90">#</a>复杂度分析</h3><p>再说一下归并排序的时间复杂度，虽然大伙儿应该都知道是 <code>O(NlogN)</code>，但不见得所有人都知道这个复杂度怎么算出来的。</p><p>前文 <a href="https://labuladong.online/algo/essential-technique/dynamic-programming-framework/">动态规划详解</a> 说过递归算法的复杂度计算，就是子问题个数 x 解决一个子问题的复杂度。对于归并排序来说，时间复杂度显然集中在 <code>merge</code> 函数遍历 <code>nums[lo..hi]</code> 的过程，但每次 <code>merge</code> 输入的 <code>lo</code> 和 <code>hi</code> 都不同，所以不容易直观地看出时间复杂度。</p><p><code>merge</code> 函数到底执行了多少次？每次执行的时间复杂度是多少？总的时间复杂度是多少？这就要结合之前画的这幅图来看：</p><p><img src="https://labuladong.online/algo/images/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/1.jpeg" alt="img"></p><p><strong>执行的次数是二叉树节点的个数，每次执行的复杂度就是每个节点代表的子数组的长度，所以总的时间复杂度就是整棵树中「数组元素」的个数</strong>。</p><p>所以从整体上看，这个二叉树的高度是 <code>logN</code>，其中每一层的元素个数就是原数组的长度 <code>N</code>，所以总的时间复杂度就是 <code>O(NlogN)</code>。</p><p>力扣第 912 题「<a href="https://leetcode.cn/problems/sort-an-array/">排序数组open in new window</a>」就是让你对数组进行排序，我们可以直接套用归并排序代码模板：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 归并排序对数组进行原地排序</span></span><br><span class="line">        Merge.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Merge</span> &#123;</span><br><span class="line">    <span class="comment">// 见上文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他应用"><a href="#其他应用" class="headerlink" title="#其他应用"></a><a href="https://labuladong.online/algo/practice-in-action/merge-sort/#%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8">#</a>其他应用</h3><p>除了最基本的排序问题，归并排序还可以用来解决力扣第 315 题「<a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/">计算右侧小于当前元素的个数open in new window</a>」：</p><details class="hint-container details" open="" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1rem 0px; padding: 1.5rem; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary style="position: relative; margin: -1.5rem -1.5rem 0.5em; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer;"><strong style="font-weight: 600;">315. 计算右侧小于当前元素的个数</strong>&nbsp;|<span>&nbsp;</span><a target="_blank" href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|<span>&nbsp;</span><a target="_blank" href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个整数数组<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">nums</code><em><span>&nbsp;</span></em>，按要求返回一个新数组&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">counts</code><em><span>&nbsp;</span></em>。数组<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">counts</code><span>&nbsp;</span>有该性质：<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">counts[i]</code><span>&nbsp;</span>的值是&nbsp;<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">nums[i]</code><span>&nbsp;</span>右侧小于&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">nums[i]</code><span>&nbsp;</span>的元素的数量。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>nums = [5,2,6,1]<strong style="font-weight: 600;">输出：</strong><code style="margin: 0px; padding: 0px; border-radius: 0px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: unset; font-family: var(--font-family-mono); transition: color var(--color-transition); color: var(--code-color); text-align: left; white-space: pre; word-spacing: normal; word-break: normal; hyphens: none; -webkit-font-smoothing: auto;">[2,1,1,0] <strong style="font-weight: 600;">解释：</strong></code>5 的右侧有 <strong style="font-weight: 600;">2 </strong>个更小的元素 (2 和 1)2 的右侧仅有 <strong style="font-weight: 600;">1 </strong>个更小的元素 (1)6 的右侧有 <strong style="font-weight: 600;">1 </strong>个更小的元素 (1)1 的右侧有 <strong style="font-weight: 600;">0 </strong>个更小的元素</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>nums = [-1]<strong style="font-weight: 600;">输出：</strong>[0]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>nums = [-1,-1]<strong style="font-weight: 600;">输出：</strong>[0,0]</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">-10<sup>4</sup><span>&nbsp;</span>&lt;= nums[i] &lt;= 10<sup>4</sup></code></li></ul></div></details><p>我用比较数学的语言来描述一下（方便和后续类似题目进行对比），题目让你求出一个 <code>count</code> 数组，使得：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">count[i] <span class="operator">=</span> <span class="built_in">COUNT</span>(j) <span class="keyword">where</span> j <span class="operator">&gt;</span> i <span class="keyword">and</span> nums[j] <span class="operator">&lt;</span> nums[i]</span><br></pre></td></tr></table></figure><p>拍脑袋的暴力解法就不说了，嵌套 for 循环，平方级别的复杂度。</p><p>这题和归并排序什么关系呢，主要在 <code>merge</code> 函数，<strong>我们在使用 <code>merge</code> 函数合并两个有序数组的时候，其实是可以知道一个元素 <code>nums[i]</code> 后边有多少个元素比 <code>nums[i]</code> 小的</strong>。</p><p>具体来说，比如这个场景：</p><p><img src="https://labuladong.online/algo/images/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/6.jpeg" alt="img"></p><p>这时候我们应该把 <code>temp[i]</code> 放到 <code>nums[p]</code> 上，因为 <code>temp[i] &lt; temp[j]</code>。</p><p>但就在这个场景下，我们还可以知道一个信息：5 后面比 5 小的元素个数就是 左闭右开区间 <code>[mid + 1, j)</code> 中的元素个数，即 2 和 4 这两个元素：</p><p><img src="https://labuladong.online/algo/images/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/7.jpeg" alt="img"></p><p>**换句话说，在对 <code>nums[lo..hi]</code> 合并的过程中，每当执行 <code>nums[p] = temp[i]</code> 时，就可以确定 <code>temp[i]</code> 这个元素后面比它小的元素个数为 <code>j - mid - 1</code>**。</p><p>当然，<code>nums[lo..hi]</code> 本身也只是一个子数组，这个子数组之后还会被执行 <code>merge</code>，其中元素的位置还是会改变。但这是其他递归节点需要考虑的问题，我们只要在 <code>merge</code> 函数中做一些手脚，叠加每次 <code>merge</code> 时记录的结果即可。</p><p>发现了这个规律后，我们只要在 <code>merge</code> 中添加两行代码即可解决这个问题，看解法代码：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">        <span class="type">int</span> val, id;</span><br><span class="line">        Pair(<span class="type">int</span> val, <span class="type">int</span> id) &#123;</span><br><span class="line">            <span class="comment">// 记录数组的元素值</span></span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="comment">// 记录元素在数组中的原始索引</span></span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 归并排序所用的辅助数组</span></span><br><span class="line">    <span class="keyword">private</span> Pair[] temp;</span><br><span class="line">    <span class="comment">// 记录每个元素后面比自己小的元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主函数</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">countSmaller</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        count = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        temp = <span class="keyword">new</span> <span class="title class_">Pair</span>[n];</span><br><span class="line">        Pair[] arr = <span class="keyword">new</span> <span class="title class_">Pair</span>[n];</span><br><span class="line">        <span class="comment">// 记录元素原始的索引位置，以便在 count 数组中更新结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            arr[i] = <span class="keyword">new</span> <span class="title class_">Pair</span>(nums[i], i);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行归并排序，本题结果被记录在 count 数组中</span></span><br><span class="line">        sort(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c : count) res.add(c);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 归并排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Pair[] arr, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lo == hi) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        sort(arr, lo, mid);</span><br><span class="line">        sort(arr, mid + <span class="number">1</span>, hi);</span><br><span class="line">        merge(arr, lo, mid, hi);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 合并两个有序数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(Pair[] arr, <span class="type">int</span> lo, <span class="type">int</span> mid, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) &#123;</span><br><span class="line">            temp[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> lo; p &lt;= hi; p++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == mid + <span class="number">1</span>) &#123;</span><br><span class="line">                arr[p] = temp[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == hi + <span class="number">1</span>) &#123;</span><br><span class="line">                arr[p] = temp[i++];</span><br><span class="line">                <span class="comment">// 更新 count 数组</span></span><br><span class="line">                count[arr[p].id] += j - mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp[i].val &gt; temp[j].val) &#123;</span><br><span class="line">                arr[p] = temp[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[p] = temp[i++];</span><br><span class="line">                <span class="comment">// 更新 count 数组</span></span><br><span class="line">                count[arr[p].id] += j - mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在排序过程中，每个元素的索引位置会不断改变，所以我们用一个 <code>Pair</code> 类封装每个元素及其在原始数组 <code>nums</code> 中的索引，以便 <code>count</code> 数组记录每个元素之后小于它的元素个数。</p><p>接下来我们再看几道原理类似的题目，都是通过给归并排序的 <code>merge</code> 函数加一些私货完成目标。</p><p>看一下力扣第 493 题「<a href="https://leetcode.cn/problems/reverse-pairs/">翻转对open in new window</a>」：</p><details class="hint-container details" open="" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1rem 0px; padding: 1.5rem; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary style="position: relative; margin: -1.5rem -1.5rem 0.5em; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer;"><strong style="font-weight: 600;">493. 翻转对</strong>&nbsp;|<span>&nbsp;</span><a target="_blank" href="https://leetcode.cn/problems/reverse-pairs/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|<span>&nbsp;</span><a target="_blank" href="https://leetcode.com/problems/reverse-pairs/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个数组&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">nums</code>&nbsp;，如果&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">i &lt; j</code>&nbsp;且&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">nums[i] &gt; 2*nums[j]</code>&nbsp;我们就将&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">(i, j)</code>&nbsp;称作一个<strong style="font-weight: 600;"><em>重要翻转对</em></strong>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">你需要返回给定数组中的重要翻转对的数量。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1:</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入</strong>: [1,3,2,3,1]<strong style="font-weight: 600;">输出</strong>: 2</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2:</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入</strong>: [2,4,3,5,1]<strong style="font-weight: 600;">输出</strong>: 3</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">注意:</strong></p><ol style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>给定数组的长度不会超过<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">50000</code>。</li><li>输入数组中的所有数字都在32位整数的表示范围内。</li></ol></div></details><p>我把这道题换个表述方式，你注意和上一道题目对比：</p><p>请你先求出一个 <code>count</code> 数组，其中：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">count[i] <span class="operator">=</span> <span class="built_in">COUNT</span>(j) <span class="keyword">where</span> j <span class="operator">&gt;</span> i <span class="keyword">and</span> nums[i] <span class="operator">&gt;</span> <span class="number">2</span><span class="operator">*</span>nums[j]</span><br></pre></td></tr></table></figure><p>然后请你求出这个 <code>count</code> 数组中所有元素的和。</p><p>你看，这样说其实和题目是一个意思，而且和上一道题非常类似，只不过上一题求的是 <code>nums[i] &gt; nums[j]</code>，这里求的是 <code>nums[i] &gt; 2*nums[j]</code> 罢了。</p><p>所以解题的思路当然还是要在 <code>merge</code> 函数中做点手脚，当 <code>nums[lo..mid]</code> 和 <code>nums[mid+1..hi]</code> 两个子数组完成排序后，对于 <code>nums[lo..mid]</code> 中的每个元素 <code>nums[i]</code>，去 <code>nums[mid+1..hi]</code> 中寻找符合条件的 <code>nums[j]</code> 就行了。</p><p>看一下我们对 <code>merge</code> 函数的改造：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录「翻转对」的个数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 nums[lo..mid] 和 nums[mid+1..hi] 这两个有序数组合并成一个有序数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> mid, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) &#123;</span><br><span class="line">        temp[i] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在合并有序数组之前，加点私货</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= mid; i++) &#123;</span><br><span class="line">        <span class="comment">// 对于左半边的每个 nums[i]，都去右半边寻找符合条件的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>; j &lt;= hi; j++) &#123;</span><br><span class="line">            <span class="comment">// nums 中的元素可能较大，乘 2 可能溢出，所以转化成 long</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span>)nums[i] &gt; (<span class="type">long</span>)nums[j] * <span class="number">2</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组双指针技巧，合并两个有序数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> lo; p &lt;= hi; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == mid + <span class="number">1</span>) &#123;</span><br><span class="line">            nums[p] = temp[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == hi + <span class="number">1</span>) &#123;</span><br><span class="line">            nums[p] = temp[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp[i] &gt; temp[j]) &#123;</span><br><span class="line">            nums[p] = temp[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[p] = temp[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过呢，这段代码提交会超时，毕竟额外添加了一个嵌套 for 循环。怎么进行优化呢，注意子数组 <code>nums[lo..mid]</code> 是排好序的，也就是 <code>nums[i] &lt;= nums[i+1]</code>。</p><p>所以，对于 <code>nums[i], lo &lt;= i &lt;= mid</code>，我们在找到的符合 <code>nums[i] &gt; 2*nums[j]</code> 的 <code>nums[j], mid+1 &lt;= j &lt;= hi</code>，也必然也符合 <code>nums[i+1] &gt; 2*nums[j]</code>。</p><p><strong>换句话说，我们不用每次都傻乎乎地去遍历整个 <code>nums[mid+1..hi]</code>，只要维护一个开区间边界 <code>end</code>，维护 <code>nums[mid+1..end-1]</code> 是符合条件的元素即可</strong>。</p><p>看最终的解法代码：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reversePairs</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 执行归并排序</span></span><br><span class="line">        sort(nums);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        temp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归并排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lo == hi) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        sort(nums, lo, mid);</span><br><span class="line">        sort(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">        merge(nums, lo, mid, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录「翻转对」的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> mid, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) &#123;</span><br><span class="line">            temp[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 进行效率优化，维护左闭右开区间 [mid+1, end) 中的元素乘 2 小于 nums[i]</span></span><br><span class="line">        <span class="comment">// 为什么 end 是开区间？因为这样的话可以保证初始区间 [mid+1, mid+1) 是一个空区间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= mid; i++) &#123;</span><br><span class="line">            <span class="comment">// nums 中的元素可能较大，乘 2 可能溢出，所以转化成 long</span></span><br><span class="line">            <span class="keyword">while</span> (end &lt;= hi &amp;&amp; (<span class="type">long</span>)nums[i] &gt; (<span class="type">long</span>)nums[end] * <span class="number">2</span>) &#123;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            count += end - (mid + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组双指针技巧，合并两个有序数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> lo; p &lt;= hi; p++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == mid + <span class="number">1</span>) &#123;</span><br><span class="line">                nums[p] = temp[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == hi + <span class="number">1</span>) &#123;</span><br><span class="line">                nums[p] = temp[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp[i] &gt; temp[j]) &#123;</span><br><span class="line">                nums[p] = temp[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[p] = temp[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你能够理解这道题目，我们最后来看一道难度更大的题目，力扣第 327 题「<a href="https://leetcode.cn/problems/count-of-range-sum/">区间和的个数open in new window</a>」：</p><details class="hint-container details" open="" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1rem 0px; padding: 1.5rem; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary style="position: relative; margin: -1.5rem -1.5rem 0.5em; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer;"><strong style="font-weight: 600;">327. 区间和的个数</strong>&nbsp;|<span>&nbsp;</span><a target="_blank" href="https://leetcode.cn/problems/count-of-range-sum/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|<span>&nbsp;</span><a target="_blank" href="https://leetcode.com/problems/count-of-range-sum/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个整数数组<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">nums</code><span>&nbsp;</span>以及两个整数<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">lower</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">upper</code><span>&nbsp;</span>。求数组中，值位于范围<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">[lower, upper]</code><span>&nbsp;</span>（包含<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">lower</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">upper</code>）之内的<span>&nbsp;</span><strong style="font-weight: 600;">区间和的个数</strong><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">区间和</strong><span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">S(i, j)</code><span>&nbsp;</span>表示在<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">nums</code><span>&nbsp;</span>中，位置从<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">i</code><span>&nbsp;</span>到<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">j</code><span>&nbsp;</span>的元素之和，包含<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">i</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">j</code><span>&nbsp;</span>(<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">i</code><span>&nbsp;</span>≤<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">j</code>)。</p><strong style="font-weight: 600;">示例 1：</strong><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>nums = [-2,5,-1], lower = -2, upper = 2<strong style="font-weight: 600;">输出：</strong>3<strong style="font-weight: 600;">解释：</strong>存在三个区间：[0,0]、[2,2] 和 [0,2] ，对应的区间和分别是：-2 、-1 、2 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>nums = [0], lower = 0, upper = 0<strong style="font-weight: 600;">输出：</strong>1</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">-2<sup>31</sup><span>&nbsp;</span>&lt;= nums[i] &lt;= 2<sup>31</sup><span>&nbsp;</span>- 1</code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">-10<sup>5</sup><span>&nbsp;</span>&lt;= lower &lt;= upper &lt;= 10<sup>5</sup></code></li><li>题目数据保证答案是一个<span>&nbsp;</span><strong style="font-weight: 600;">32 位</strong><span>&nbsp;</span>的整数</li></ul></div></details><p>简单说，题目让你计算元素和落在 <code>[lower, upper]</code> 中的所有子数组的个数。</p><p>拍脑袋的暴力解法我就不说了，依然是嵌套 for 循环，这里还是说利用归并排序实现的高效算法。</p><p>首先，解决这道题需要快速计算子数组的和，所以你需要阅读前文 <a href="https://labuladong.online/algo/data-structure/prefix-sum/">前缀和数组技巧</a>，创建一个前缀和数组 <code>preSum</code> 来辅助我们迅速计算区间和。</p><p>我继续用比较数学的语言来表述下这道题，题目让你通过 <code>preSum</code> 数组求一个 <code>count</code> 数组，使得：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">count[i] <span class="operator">=</span> <span class="built_in">COUNT</span>(j) <span class="keyword">where</span> lower <span class="operator">&lt;=</span> preSum[j] <span class="operator">-</span> preSum[i] <span class="operator">&lt;=</span> upper</span><br></pre></td></tr></table></figure><p>然后请你求出这个 <code>count</code> 数组中所有元素的和。</p><p>你看，这是不是和题目描述一样？<code>preSum</code> 中的两个元素之差其实就是区间和。</p><p>有了之前两道题的铺垫，我直接给出这道题的解法代码吧，思路见注释：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> lower, upper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countRangeSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lower, <span class="type">int</span> upper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lower = lower;</span><br><span class="line">        <span class="built_in">this</span>.upper = upper;</span><br><span class="line">        <span class="comment">// 构建前缀和数组，注意 int 可能溢出，用 long 存储</span></span><br><span class="line">        <span class="type">long</span>[] preSum = <span class="keyword">new</span> <span class="title class_">long</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            preSum[i + <span class="number">1</span>] = (<span class="type">long</span>)nums[i] + preSum[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对前缀和数组进行归并排序</span></span><br><span class="line">        sort(preSum);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span>[] temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">long</span>[] nums)</span> &#123;</span><br><span class="line">        temp = <span class="keyword">new</span> <span class="title class_">long</span>[nums.length];</span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">long</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lo == hi) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        sort(nums, lo, mid);</span><br><span class="line">        sort(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">        merge(nums, lo, mid, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">long</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> mid, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) &#123;</span><br><span class="line">            temp[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在合并有序数组之前加点私货（这段代码会超时）</span></span><br><span class="line">        <span class="comment">// for (int i = lo; i &lt;= mid; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     for (int j = mid + 1; j &lt;= hi; k++) &#123;</span></span><br><span class="line">        <span class="comment">//         // 寻找符合条件的 nums[j]</span></span><br><span class="line">        <span class="comment">//         long delta = nums[j] - nums[i];</span></span><br><span class="line">        <span class="comment">//         if (delta &lt;= upper &amp;&amp; delta &gt;= lower) &#123;</span></span><br><span class="line">        <span class="comment">//             count++;</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 进行效率优化</span></span><br><span class="line">        <span class="comment">// 维护左闭右开区间 [start, end) 中的元素和 nums[i] 的差在 [lower, upper] 中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> mid + <span class="number">1</span>, end = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= mid; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果 nums[i] 对应的区间是 [start, end)，</span></span><br><span class="line">            <span class="comment">// 那么 nums[i+1] 对应的区间一定会整体右移，类似滑动窗口</span></span><br><span class="line">            <span class="keyword">while</span> (start &lt;= hi &amp;&amp; nums[start] - nums[i] &lt; lower) &#123;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (end &lt;= hi &amp;&amp; nums[end] - nums[i] &lt;= upper) &#123;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            count += end - start;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组双指针技巧，合并两个有序数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> lo; p &lt;= hi; p++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == mid + <span class="number">1</span>) &#123;</span><br><span class="line">                nums[p] = temp[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == hi + <span class="number">1</span>) &#123;</span><br><span class="line">                nums[p] = temp[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp[i] &gt; temp[j]) &#123;</span><br><span class="line">                nums[p] = temp[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[p] = temp[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们依然在 <code>merge</code> 函数合并有序数组之前加了一些逻辑，如果看过前文 <a href="https://labuladong.online/algo/essential-technique/sliding-window-framework/">滑动窗口核心框架</a>，这个效率优化有点类似维护一个滑动窗口，让窗口中的元素和 <code>nums[i]</code> 的差落在 <code>[lower, upper]</code> 中。</p><p>归并排序相关的题目到这里就讲完了，你现在回头体会下我在本文开头说那句话：</p><p><strong>所有递归的算法，本质上都是在遍历一棵（递归）树，然后在节点（前中后序位置）上执行代码。你要写递归算法，本质上就是要告诉每个节点需要做什么</strong>。</p><p>比如本文讲的归并排序算法，递归的 <code>sort</code> 函数就是二叉树的遍历函数，而 <code>merge</code> 函数就是在每个节点上做的事情，有没有品出点味道？</p><p>最后总结一下吧，本文从二叉树的角度讲了归并排序的核心思路和代码实现，同时讲了几道归并排序相关的算法题。这些算法题其实就是归并排序算法逻辑中夹杂一点私货，但仍然属于比较难的，你可能需要亲自做一遍才能理解。</p><p>那我最后留一个思考题吧，下一篇文章我会讲快速排序，你是否能够尝试着从二叉树的角度去理解快速排序？如果让你用一句话总结快速排序的逻辑，你怎么描述？</p><p>好了，答案在下篇文章 <a href="https://labuladong.online/algo/practice-in-action/quick-sort/">快速排序详解及应用</a> 揭晓。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序详解及应用</title>
      <link href="/posts/17520.html"/>
      <url>/posts/17520.html</url>
      
        <content type="html"><![CDATA[<h1 id="快速排序详解及应用"><a href="#快速排序详解及应用" class="headerlink" title="快速排序详解及应用"></a>快速排序详解及应用</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/">215. Kth Largest Element in an Arrayopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素open in new window</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/sort-an-array/">912. Sort an Arrayopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/sort-an-array/">912. 排序数组open in new window</a></td><td align="center">🟠</td></tr><tr><td align="center">-</td><td align="center"><a href="https://leetcode.cn/problems/xx4gT2/">剑指 Offer II 076. 数组中的第 k 大的数字open in new window</a></td><td align="center">🟠</td></tr></tbody></table><p>前文 <a href="https://labuladong.online/algo/practice-in-action/merge-sort/">归并排序算法详解</a> 通过二叉树的视角描述了归并排序的算法原理以及应用，很多读者大呼精妙，那我就趁热打铁，<strong>今天继续用二叉树的视角讲一讲快速排序算法的原理以及运用</strong>。</p><h3 id="快速排序算法思路"><a href="#快速排序算法思路" class="headerlink" title="#快速排序算法思路"></a><a href="https://labuladong.online/algo/practice-in-action/quick-sort/#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF">#</a>快速排序算法思路</h3><p>首先我们看一下快速排序的代码框架：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对 nums[lo..hi] 进行切分</span></span><br><span class="line">    <span class="comment">// 使得 nums[lo..p-1] &lt;= nums[p] &lt; nums[p+1..hi]</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(nums, lo, hi);</span><br><span class="line">    <span class="comment">// 去左右子数组进行切分</span></span><br><span class="line">    sort(nums, lo, p - <span class="number">1</span>);</span><br><span class="line">    sort(nums, p + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实你对比之后可以发现，快速排序就是一个二叉树的前序遍历：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 二叉树遍历框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/****** 前序位置 ******/</span></span><br><span class="line">    print(root.val);</span><br><span class="line">    <span class="comment">/*********************/</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，前文 <a href="https://labuladong.online/algo/practice-in-action/merge-sort/">归并排序详解</a> 用一句话总结了归并排序：先把左半边数组排好序，再把右半边数组排好序，然后把两半数组合并。</p><p>同时我提了一个问题，让你一句话总结快速排序，这里说一下我的答案：</p><p><strong>快速排序是先将一个元素排好序，然后再将剩下的元素排好序</strong>。</p><p>为什么这么说呢，且听我慢慢道来。</p><p>快速排序的核心无疑是 <code>partition</code> 函数， <code>partition</code> 函数的作用是在 <code>nums[lo..hi]</code> 中寻找一个切分点 <code>p</code>，通过交换元素使得 <code>nums[lo..p-1]</code> 都小于等于 <code>nums[p]</code>，且 <code>nums[p+1..hi]</code> 都大于 <code>nums[p]</code>：</p><p><img src="https://labuladong.online/algo/images/%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9/1.jpeg" alt="img"></p><p>一个元素左边的元素都比它小，右边的元素都比它大，啥意思？不就是它自己已经被放到正确的位置上了吗？</p><p>所以 <code>partition</code> 函数干的事情，其实就是把 <code>nums[p]</code> 这个元素排好序了。</p><p>一个元素被排好序了，然后呢？你再把剩下的元素排好序不就得了。</p><p>剩下的元素有哪些？左边一坨，右边一坨，去吧，对子数组进行递归，用 <code>partition</code> 函数把剩下的元素也排好序。</p><p><strong>从二叉树的视角，我们可以把子数组 <code>nums[lo..hi]</code> 理解成二叉树节点上的值，<code>sort</code> 函数理解成二叉树的遍历函数</strong>。</p><p>参照二叉树的前序遍历顺序，快速排序的运行过程如下 GIF：</p><p>🌟</p><hr><p>🌟</p><p><img src="https://labuladong.online/algo/images/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/1.gif" alt="img"></p><p>你注意最后形成的这棵二叉树是什么？是一棵二叉搜索树：</p><p><img src="https://labuladong.online/algo/images/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2.jpeg" alt="img"></p><p>这应该不难理解吧，因为 <code>partition</code> 函数每次都将数组切分成左小右大两部分，恰好和二叉搜索树左小右大的特性吻合。</p><p><strong>你甚至可以这样理解：快速排序的过程是一个构造二叉搜索树的过程</strong>。</p><p>但谈到二叉搜索树的构造，那就不得不说二叉搜索树不平衡的极端情况，极端情况下二叉搜索树会退化成一个链表，导致操作效率大幅降低。</p><p>快速排序的过程中也有类似的情况，比如我画的图中每次 <code>partition</code> 函数选出的切分点都能把 <code>nums[lo..hi]</code> 平分成两半，但现实中你不见得运气这么好。</p><p>如果你每次运气都特别背，有一边的元素特别少的话，这样会导致二叉树生长不平衡：</p><p><img src="https://labuladong.online/algo/images/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/3.jpeg" alt="img"></p><p>这样的话，时间复杂度会大幅上升，后面分析时间复杂度的时候再细说。</p><p><strong>我们为了避免出现这种极端情况，需要引入随机性</strong>。</p><p>常见的方式是在进行排序之前对整个数组执行 <a href="https://labuladong.online/algo/frequency-interview/random-algorithm/">洗牌算法</a> 进行打乱，或者在 <code>partition</code> 函数中随机选择数组元素作为切分点，本文会使用前者。</p><h3 id="快速排序代码实现"><a href="#快速排序代码实现" class="headerlink" title="#快速排序代码实现"></a><a href="https://labuladong.online/algo/practice-in-action/quick-sort/#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">#</a>快速排序代码实现</h3><p>明白了上述概念，直接看快速排序的代码实现：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quick</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 为了避免出现耗时的极端情况，先随机打乱</span></span><br><span class="line">        shuffle(nums);</span><br><span class="line">        <span class="comment">// 排序整个数组（原地修改）</span></span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt;= hi) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对 nums[lo..hi] 进行切分</span></span><br><span class="line">        <span class="comment">// 使得 nums[lo..p-1] &lt;= nums[p] &lt; nums[p+1..hi]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(nums, lo, hi);</span><br><span class="line"></span><br><span class="line">        sort(nums, lo, p - <span class="number">1</span>);</span><br><span class="line">        sort(nums, p + <span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 nums[lo..hi] 进行切分</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[lo];</span><br><span class="line">        <span class="comment">// 关于区间的边界控制需格外小心，稍有不慎就会出错</span></span><br><span class="line">        <span class="comment">// 我这里把 i, j 定义为开区间，同时定义：</span></span><br><span class="line">        <span class="comment">// [lo, i) &lt;= pivot；(j, hi] &gt; pivot</span></span><br><span class="line">        <span class="comment">// 之后都要正确维护这个边界区间的定义</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo + <span class="number">1</span>, j = hi;</span><br><span class="line">        <span class="comment">// 当 i &gt; j 时结束循环，以保证区间 [lo, hi] 都被覆盖</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; hi &amp;&amp; nums[i] &lt;= pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="comment">// 此 while 结束时恰好 nums[i] &gt; pivot</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; lo &amp;&amp; nums[j] &gt; pivot) &#123;</span><br><span class="line">                j--;</span><br><span class="line">                <span class="comment">// 此 while 结束时恰好 nums[j] &lt;= pivot</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时 [lo, i) &lt;= pivot &amp;&amp; (j, hi] &gt; pivot</span></span><br><span class="line">            <span class="comment">// 交换 nums[j] 和 nums[i]</span></span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">            <span class="comment">// 此时 [lo, i] &lt;= pivot &amp;&amp; [j, hi] &gt; pivot</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后将 pivot 放到合适的位置，即 pivot 左边元素较小，右边元素较大</span></span><br><span class="line">        swap(nums, lo, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 洗牌算法，将输入的数组随机打乱</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 生成 [i, n - 1] 的随机数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> i + rand.nextInt(n - i);</span><br><span class="line">            swap(nums, i, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原地交换数组中的两个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里啰嗦一下核心函数 <code>partition</code> 的实现，正如前文 <a href="https://labuladong.online/algo/essential-technique/binary-search-framework/">二分搜索框架详解</a> 所说，想要正确寻找切分点非常考验你对边界条件的控制，稍有差错就会产生错误的结果。</p><p><strong>处理边界细节的一个技巧就是，你要明确每个变量的定义以及区间的开闭情况</strong>。具体的细节看代码注释，建议自己动手实践。</p><p>贴一个快速排序过程的可视化动画，方便大家理解算法运行的过程：</p><details data-v-fb30874b="" id="div_mydata-quick-sort" class="hint-container details" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1.6em 0px; padding: 1rem 0px 0px; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary data-v-fb30874b="" style="position: relative; margin: -1.5rem 0px -0.5rem; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer; display: flex; align-items: center; font-size: large;"><strong data-v-fb30874b="" style="font-weight: 600;">🎃 代码可视化动画 🎃</strong><span data-v-fb30874b="" class="font-icon icon iconfont icon-resize" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-left: auto; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-refresh" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-link" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle;"></span></summary><div data-v-fb30874b="" class="resizable" style="width: 774.091px; max-width: 100%; height: 70vh; max-height: 70vh; overflow: auto; resize: both;"><iframe data-v-fb30874b="" id="iframe_mydata-quick-sort" src="https://labuladong.online/algo-visualize/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h3 id="复杂度分析及其他要点"><a href="#复杂度分析及其他要点" class="headerlink" title="#复杂度分析及其他要点"></a><a href="https://labuladong.online/algo/practice-in-action/quick-sort/#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E5%8F%8A%E5%85%B6%E4%BB%96%E8%A6%81%E7%82%B9">#</a>复杂度分析及其他要点</h3><p>接下来分析一下快速排序的时间复杂度。</p><p>显然，快速排序的时间复杂度主要消耗在 <code>partition</code> 函数上，因为这个函数中存在循环。</p><p>所以 <code>partition</code> 函数到底执行了多少次？每次执行的时间复杂度是多少？总的时间复杂度是多少？</p><p>和归并排序类似，需要结合之前画的这幅图来从整体上分析：</p><p><img src="https://labuladong.online/algo/images/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/4.jpeg" alt="img"></p><p><strong><code>partition</code> 执行的次数是二叉树节点的个数，每次执行的复杂度就是每个节点代表的子数组 <code>nums[lo..hi]</code> 的长度，所以总的时间复杂度就是整棵树中「数组元素」的个数</strong>。</p><p>假设数组元素个数为 <code>N</code>，那么二叉树每一层的元素个数之和就是 <code>O(N)</code>；切分点 <code>p</code> 每次都落在数组正中间的理想情况下，树的层数为 <code>O(logN)</code>，所以理想的总时间复杂度为 <code>O(NlogN)</code>。</p><p>由于快速排序没有使用任何辅助数组，所以空间复杂度就是递归堆栈的深度，也就是树高 <code>O(logN)</code>。</p><p>当然，我们之前说过快速排序的效率存在一定随机性，如果每次 <code>partition</code> 切分的结果都极不均匀：</p><p><img src="https://labuladong.online/algo/images/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/3.jpeg" alt="img"></p><p>快速排序就退化成选择排序了，树高为 <code>O(N)</code>，每层节点的元素个数从 <code>N</code> 开始递减，总的时间复杂度为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N + (N - <span class="number">1</span>) + (N - <span class="number">2</span>) + ... + <span class="number">1</span> = O(N^<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>所以我们说，快速排序理想情况的时间复杂度是 <code>O(NlogN)</code>，空间复杂度 <code>O(logN)</code>，极端情况下的最坏时间复杂度是 <code>O(N^2)</code>，空间复杂度是 <code>O(N)</code>。</p><p>不过大家放心，经过随机化的 <code>partition</code> 函数很难出现极端情况，所以快速排序的效率还是非常高的。</p><p><strong>还有一点需要注意的是，快速排序是「不稳定排序」，与之相对的，前文讲的 <a href="https://labuladong.online/algo/practice-in-action/merge-sort/">归并排序</a> 是「稳定排序」</strong>。</p><p>对于序列中的相同元素，如果排序之后它们的相对位置没有发生改变，则称该排序算法为「稳定排序」，反之则为「不稳定排序」。</p><p>如果单单排序 int 数组，那么稳定性没有什么意义。但如果排序一些结构比较复杂的数据，那么稳定性排序就有更大的优势了。</p><p>比如说你有若干订单数据，已经按照订单号排好序了，现在你想对订单的交易日期再进行排序：</p><p>如果用稳定排序算法（比如归并排序），那么这些订单不仅按照交易日期排好了序，而且相同交易日期的订单的订单号依然是有序的。</p><p>但如果你用不稳定排序算法（比如快速排序），那么虽然排序结果会按照交易日期排好序，但相同交易日期的订单的订单号会丧失有序性。</p><p><strong>在实际工程中我们经常会将一个复杂对象的某一个字段作为排序的 <code>key</code>，所以应该关注编程语言提供的 API 底层使用的到底是什么排序算法，是稳定的还是不稳定的，这很可能影响到代码执行的效率甚至正确性</strong>。</p><p>说了这么多，快速排序算法应该算是讲明白了，力扣第 912 题「<a href="https://leetcode.cn/problems/sort-an-array/">排序数组open in new window</a>」就是让你对数组进行排序，我们可以直接套用快速排序的代码模板：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 归并排序对数组进行原地排序</span></span><br><span class="line">        Quick.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Quick</span> &#123;</span><br><span class="line">    <span class="comment">// 见上文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速选择算法"><a href="#快速选择算法" class="headerlink" title="#快速选择算法"></a><a href="https://labuladong.online/algo/practice-in-action/quick-sort/#%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95">#</a>快速选择算法</h3><p>不仅快速排序算法本身很有意思，而且它还有一些有趣的变体，最有名的就是快速选择算法（Quick Select）。</p><p>力扣第 215 题「<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">数组中的第 K 个最大元素open in new window</a>」就是一道类似的题目，函数签名如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span>;</span><br></pre></td></tr></table></figure><p>题目要求我们寻找<strong>第 <code>k</code> 个最大的元素</strong>，稍微有点绕，意思是去寻找 <code>nums</code> 数组降序排列后排名第 <code>k</code> 的那个元素。</p><p>比如输入 <code>nums = [2,1,5,4], k = 2</code>，算法应该返回 4，因为 4 是 <code>nums</code> 中第 2 个<strong>最大</strong>的元素。</p><p>这种问题有两种解法，一种是二叉堆（优先队列）的解法，另一种就是快速选择算法，我们分别来看。</p><p><strong>二叉堆的解法比较简单，但时间复杂度稍高</strong>，直接看代码好了：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// 小顶堆，堆顶是最小元素</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt;  pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> e : nums) &#123;</span><br><span class="line">        <span class="comment">// 每个元素都要过一遍二叉堆</span></span><br><span class="line">        pq.offer(e);</span><br><span class="line">        <span class="comment">// 堆中元素多于 k 个时，删除堆顶元素</span></span><br><span class="line">        <span class="keyword">if</span> (pq.size() &gt; k) &#123;</span><br><span class="line">            pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pq 中剩下的是 nums 中 k 个最大元素，</span></span><br><span class="line">    <span class="comment">// 堆顶是最小的那个，即第 k 个最大元素</span></span><br><span class="line">    <span class="keyword">return</span> pq.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉堆（优先队列）是一种能够自动排序的数据结构，我们后文 <a href="https://labuladong.online/algo/data-structure/binary-heap-priority-queue/">手把手实现二叉堆数据结构</a> 实现过这种结构，我就默认大家熟悉它的特性了。</p><p>核心思路就是把小顶堆 <code>pq</code> 理解成一个筛子，较大的元素会沉淀下去，较小的元素会浮上来；当堆大小超过 <code>k</code> 的时候，我们就删掉堆顶的元素，因为这些元素比较小，而我们想要的是前 <code>k</code> 个最大元素嘛。</p><p>当 <code>nums</code> 中的所有元素都过了一遍之后，筛子里面留下的就是最大的 <code>k</code> 个元素，而堆顶元素是堆中最小的元素，也就是「第 <code>k</code> 个最大的元素」。</p><p>思路很简单吧，唯一注意的是，Java 的 <code>PriorityQueue</code> 默认实现是小顶堆，有的语言的优先队列可能默认是大顶堆，可能需要做一些调整。</p><p>二叉堆插入和删除的时间复杂度和堆中的元素个数有关，在这里我们堆的大小不会超过 <code>k</code>，所以插入和删除元素的复杂度是 <code>O(logk)</code>，再套一层 for 循环，假设数组元素总数为 <code>N</code>，总的时间复杂度就是 <code>O(Nlogk)</code>。</p><p>这个解法的空间复杂度很显然就是二叉堆的大小，为 <code>O(k)</code>。</p><p><strong>快速选择算法是快速排序的变体，效率更高</strong>，面试中如果能够写出快速选择算法，肯定是加分项。</p><p>首先，题目问「第 <code>k</code> 个最大的元素」，相当于数组升序排序后「排名第 <code>n - k</code> 的元素」，为了方便表述，后文另 <code>k&#39; = n - k</code>。</p><p>如何知道「排名第 <code>k&#39;</code> 的元素」呢？其实在快速排序算法 <code>partition</code> 函数执行的过程中就可以略见一二。</p><p>我们刚说了，<code>partition</code> 函数会将 <code>nums[p]</code> 排到正确的位置，使得 <code>nums[lo..p-1] &lt; nums[p] &lt; nums[p+1..hi]</code>：</p><p>这时候，虽然还没有把整个数组排好序，但我们已经让 <code>nums[p]</code> 左边的元素都比 <code>nums[p]</code> 小了，也就知道 <code>nums[p]</code> 的排名了。</p><p><strong>那么我们可以把 <code>p</code> 和 <code>k&#39;</code> 进行比较，如果 <code>p &lt; k&#39;</code> 说明第 <code>k&#39;</code> 大的元素在 <code>nums[p+1..hi]</code> 中，如果 <code>p &gt; k&#39;</code> 说明第 <code>k&#39;</code> 大的元素在 <code>nums[lo..p-1]</code> 中</strong>。</p><p>进一步，去 <code>nums[p+1..hi]</code> 或者 <code>nums[lo..p-1]</code> 这两个子数组中执行 <code>partition</code> 函数，就可以进一步缩小排在第 <code>k&#39;</code> 的元素的范围，最终找到目标元素。</p><p>这样就可以写出解法代码：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// 首先随机打乱数组</span></span><br><span class="line">    shuffle(nums);</span><br><span class="line">    <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 转化成「排名第 k 的元素」</span></span><br><span class="line">    k = nums.length - k;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="comment">// 在 nums[lo..hi] 中选一个切分点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(nums, lo, hi);</span><br><span class="line">        <span class="keyword">if</span> (p &lt; k) &#123;</span><br><span class="line">            <span class="comment">// 第 k 大的元素在 nums[p+1..hi] 中</span></span><br><span class="line">            lo = p + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p &gt; k) &#123;</span><br><span class="line">            <span class="comment">// 第 k 大的元素在 nums[lo..p-1] 中</span></span><br><span class="line">            hi = p - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 找到第 k 大元素</span></span><br><span class="line">            <span class="keyword">return</span> nums[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 nums[lo..hi] 进行切分</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    <span class="comment">// 见前文</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 洗牌算法，将输入的数组随机打乱</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">// 见前文</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原地交换数组中的两个元素</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="comment">// 见前文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码框架其实非常像我们前文 <a href="https://labuladong.online/algo/essential-technique/binary-search-framework/">二分搜索框架</a> 的代码，这也是这个算法高效的原因，但是时间复杂度为什么是 <code>O(N)</code> 呢？</p><p>显然，这个算法的时间复杂度也主要集中在 <code>partition</code> 函数上，我们需要估算 <code>partition</code> 函数执行了多少次，每次执行的时间复杂度是多少。</p><p>最好情况下，每次 <code>partition</code> 函数切分出的 <code>p</code> 都恰好是正中间索引 <code>(lo + hi) / 2</code>（二分），且每次切分之后会到左边或者右边的子数组继续进行切分，那么 <code>partition</code> 函数执行的次数是 logN，每次输入的数组大小缩短一半。</p><p>所以总的时间复杂度为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 等比数列</span></span><br><span class="line">N + N/<span class="number">2</span> + N/<span class="number">4</span> + N/<span class="number">8</span> + ... + <span class="number">1</span> = 2N = O(N)</span><br></pre></td></tr></table></figure><p>当然，类似快速排序，快速选择算法中的 <code>partition</code> 函数也可能出现极端情况，最坏情况下 <code>p</code> 一直都是 <code>lo + 1</code> 或者一直都是 <code>hi - 1</code>，这样的话时间复杂度就退化为 <code>O(N^2)</code> 了：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N + (N - <span class="number">1</span>) + (N - <span class="number">2</span>) + ... + <span class="number">1</span> = O(N^<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>这也是我们在代码中使用 <code>shuffle</code> 函数的原因，通过引入随机性来避免极端情况的出现，让算法的效率保持在比较高的水平。随机化之后的快速选择算法的复杂度可以认为是 O(N)。</p><p>到这里，快速排序算法和快速选择算法就讲完了，从二叉树的视角来理解思路应该是不难的，但 <code>partition</code> 函数对细节的把控需要你多花心思去理解和记忆。</p><p>最后你可以比较一下快速排序和前文讲的 <a href="https://labuladong.online/algo/practice-in-action/merge-sort/">归并排序</a> 并且可以说说你的理解：为什么快速排序是不稳定排序，而归并排序是稳定排序？</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题目不让我干什么，我偏要干什么</title>
      <link href="/posts/20519.html"/>
      <url>/posts/20519.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目不让我干什么，我偏要干什么"><a href="#题目不让我干什么，我偏要干什么" class="headerlink" title="题目不让我干什么，我偏要干什么"></a>题目不让我干什么，我偏要干什么</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/flatten-nested-list-iterator/">341. Flatten Nested List Iteratoropen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/flatten-nested-list-iterator/">341. 扁平化嵌套列表迭代器open in new window</a></td><td align="center">🟠</td></tr></tbody></table><p>提示</p><p><a href="https://mp.weixin.qq.com/s/OE1zPVPj0V2o82N4HtLQbw">刷题插件open in new window</a> 集成了手把手刷二叉树功能，按照公式和套路讲解了 150 道二叉树题目，可手把手带你刷完二叉树分类的题目，迅速掌握递归思维。</p><p>今天来讲一道非常有启发性的设计题目，为什么说它有启发性，我们后面再说。</p><h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="#一、题目描述"></a><a href="https://labuladong.online/algo/data-structure/flatten-nested-list-iterator/#%E4%B8%80%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">#</a>一、题目描述</h3><p>这是力扣第 341 题「<a href="https://leetcode.cn/problems/flatten-nested-list-iterator/">扁平化嵌套列表迭代器open in new window</a>」，我来描述一下题目：</p><p>首先，现在有一种数据结构 <code>NestedInteger</code>，<strong>这个结构中存的数据可能是一个 <code>Integer</code> 整数，也可能是一个 <code>NestedInteger</code> 列表</strong>。注意，这个列表里面装着的是 <code>NestedInteger</code>，也就是说这个列表中的每一个元素可能是个整数，可能又是个列表，这样无限递归嵌套下去……</p><p><code>NestedInteger</code> 有如下 API：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NestedInteger</span> &#123;</span><br><span class="line">    <span class="comment">// 如果其中存的是一个整数，则返回 true，否则返回 false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInteger</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果其中存的是一个整数，则返回这个整数，否则返回 null</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getInteger</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果其中存的是一个列表，则返回这个列表，否则返回 null</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;NestedInteger&gt; <span class="title function_">getList</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的算法会被输入一个 <code>NestedInteger</code> 列表，我们需要做的就是写一个迭代器类，将这个带有嵌套结构 <code>NestedInteger</code> 的列表「拍平」：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NestedIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="comment">// 构造器输入一个 NestedInteger 列表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NestedIterator</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回下一个整数</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否还有下一个元素？</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们写的这个类会被这样调用，<strong>先调用 <code>hasNext</code> 方法，后调用 <code>next</code> 方法</strong>：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">NestedIterator</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NestedIterator</span>(nestedList);</span><br><span class="line"><span class="keyword">while</span> (i.hasNext())</span><br><span class="line">    print(i.next());</span><br></pre></td></tr></table></figure><p>题目给的几个示例如下：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nestedList = [[1,1],2,[1,1]]</span><br><span class="line">输出：[1,1,2,1,1]</span><br><span class="line">解释：通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,1,2,1,1]。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nestedList = [1,[4,[6]]]</span><br><span class="line">输出：[1,4,6]</span><br><span class="line">解释：通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,4,6]。</span><br></pre></td></tr></table></figure><p>比如示例 1，输入的列表里有三个 <code>NestedInteger</code>，两个列表型的 <code>NestedInteger</code> 和一个整数型的 <code>NestedInteger</code>。</p><p>学过设计模式的朋友应该知道，迭代器也是设计模式的一种，目的就是为调用者屏蔽底层数据结构的细节，简单地通过 <code>hasNext</code> 和 <code>next</code> 方法有序地进行遍历。</p><p>为什么说这个题目很有启发性呢？因为我最近在用一款类似印象笔记的软件，叫做 Notion（挺有名的）。这个软件的一个亮点就是「万物皆 block」，比如说标题、页面、表格都是 block。有的 block 甚至可以无限嵌套，这就打破了传统笔记本「文件夹」-&gt;「笔记本」-&gt;「笔记」的三层结构。</p><p>回想这个算法问题，<code>NestedInteger</code> 结构实际上也是一种支持无限嵌套的结构，而且可以同时表示整数和列表两种不同类型，我想 Notion 的核心数据结构 block 估计也是这样的一种设计思路。</p><p>那么话说回来，对于这个算法问题，我们怎么解决呢？<code>NestedInteger</code> 结构可以无限嵌套，怎么把这个结构「打平」，为迭代器的调用者屏蔽底层细节，得到扁平化的输出呢？</p><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="#二、解题思路"></a><a href="https://labuladong.online/algo/data-structure/flatten-nested-list-iterator/#%E4%BA%8C%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF">#</a>二、解题思路</h3><p>🌟</p><hr><p>🌟</p><p>显然，<code>NestedInteger</code> 这个神奇的数据结构是问题的关键，不过题目专门提醒我们：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">You should not implement it, or speculate about its implementation.</span><br></pre></td></tr></table></figure><p>我不应该去尝试实现 <code>NestedInteger</code> 这个结构，也不应该去猜测它的实现？<strong>为什么？凭什么？是不是题目在误导我？是不是我进行推测之后，这道题就不攻自破</strong>了？</p><p>你不让推测，我就偏偏要去推测！我反手就把 <code>NestedInteger</code> 这个结构给实现出来：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NestedInteger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer val;</span><br><span class="line">    <span class="keyword">private</span> List&lt;NestedInteger&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NestedInteger</span><span class="params">(Integer val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.list = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NestedInteger</span><span class="params">(List&lt;NestedInteger&gt; list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">        <span class="built_in">this</span>.val = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果其中存的是一个整数，则返回 true，否则返回 false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInteger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> val != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果其中存的是一个整数，则返回这个整数，否则返回 null</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getInteger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果其中存的是一个列表，则返回这个列表，否则返回 null</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;NestedInteger&gt; <span class="title function_">getList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，其实这个实现也不难嘛，写出来之后，我不禁翻出前文 <a href="https://labuladong.online/algo/essential-technique/abstraction-of-algorithm/">学习数据结构和算法的框架思维</a>，发现这玩意儿竟然……</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NestedInteger</span> &#123;</span><br><span class="line">    Integer val;</span><br><span class="line">    List&lt;NestedInteger&gt; list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基本的 N 叉树节点 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode[] children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这玩意儿不就是棵 N 叉树吗？叶子节点是 <code>Integer</code> 类型，其 <code>val</code> 字段非空；其他节点都是 <code>List&lt;NestedInteger&gt;</code> 类型，其 <code>val</code> 字段为空，但是 <code>list</code> 字段非空，装着孩子节点</strong>。</p><p>比如说输入是 <code>[[1,1],2,[1,1]]</code>，其实就是如下树状结构：</p><p><img src="https://labuladong.online/algo/images/nestedList/1.jpeg" alt="img"></p><p>好的，刚才题目说什么来着？把一个 <code>NestedInteger</code> 扁平化对吧？<strong>这不就等价于遍历一棵 N 叉树的所有「叶子节点」吗</strong>？我把所有叶子节点都拿出来，不就可以作为迭代器进行遍历了吗？</p><p>N 叉树的遍历怎么整？我又不禁翻出前文 <a href="https://labuladong.online/algo/essential-technique/abstraction-of-algorithm/">学习数据结构和算法的框架思维</a> 找出框架：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode child : root.children)</span><br><span class="line">        traverse(child);</span><br></pre></td></tr></table></figure><p>这个框架可以遍历所有节点，而我们只对整数型的 <code>NestedInteger</code> 感兴趣，也就是我们只想要「叶子节点」，所以 <code>traverse</code> 函数只要在到达叶子节点的时候把 <code>val</code> 加入结果列表即可：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NestedIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Iterator&lt;Integer&gt; it;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NestedIterator</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> &#123;</span><br><span class="line">        <span class="comment">// 存放将 nestedList 打平的结果</span></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (NestedInteger node : nestedList) &#123;</span><br><span class="line">            <span class="comment">// 以每个节点为根遍历</span></span><br><span class="line">            traverse(node, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 得到 result 列表的迭代器</span></span><br><span class="line">        <span class="built_in">this</span>.it = result.iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> it.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> it.hasNext();</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历以 root 为根的多叉树，将叶子节点的值加入 result 列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(NestedInteger root, List&lt;Integer&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.isInteger()) &#123;</span><br><span class="line">            <span class="comment">// 到达叶子节点</span></span><br><span class="line">            result.add(root.getInteger());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历框架</span></span><br><span class="line">        <span class="keyword">for</span> (NestedInteger child : root.getList()) &#123;</span><br><span class="line">            traverse(child, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就把原问题巧妙转化成了一个 N 叉树的遍历问题，并且得到了解法。</p><h3 id="三、进阶思路"><a href="#三、进阶思路" class="headerlink" title="#三、进阶思路"></a><a href="https://labuladong.online/algo/data-structure/flatten-nested-list-iterator/#%E4%B8%89%E3%80%81%E8%BF%9B%E9%98%B6%E6%80%9D%E8%B7%AF">#</a>三、进阶思路</h3><p>以上解法虽然可以通过，但是在面试中，也许是有瑕疵的。</p><p>我们的解法中，一次性算出了所有叶子节点的值，全部装到 <code>result</code> 列表，也就是内存中，<code>next</code> 和 <code>hasNext</code> 方法只是在对 <code>result</code> 列表做迭代。如果输入的规模非常大，构造函数中的计算就会很慢，而且很占用内存。</p><p>一般的迭代器求值应该是「惰性的」，也就是说，如果你要一个结果，我就算一个（或是一小部分）结果出来，而不是一次把所有结果都算出来。</p><p>如果想做到这一点，使用递归函数进行 DFS 遍历肯定是不行的，而且我们其实只关心「叶子节点」，所以传统的 BFS 算法也不行。实际的思路很简单：</p><p><strong>调用 <code>hasNext</code> 时，如果 <code>nestedList</code> 的第一个元素是列表类型，则不断展开这个元素，直到第一个元素是整数类型</strong>。</p><p>由于调用 <code>next</code> 方法之前一定会调用 <code>hasNext</code> 方法，这就可以保证每次调用 <code>next</code> 方法的时候第一个元素是整数型，直接返回并删除第一个元素即可。</p><p>看一下代码：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NestedIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;NestedInteger&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NestedIterator</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> &#123;</span><br><span class="line">        <span class="comment">// 不直接用 nestedList 的引用，是因为不能确定它的底层实现</span></span><br><span class="line">        <span class="comment">// 必须保证是 LinkedList，否则下面的 addFirst 会很低效</span></span><br><span class="line">        list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(nestedList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// hasNext 方法保证了第一个元素一定是整数类型</span></span><br><span class="line">        <span class="keyword">return</span> list.remove(<span class="number">0</span>).getInteger();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 循环拆分列表元素，直到列表第一个元素是整数类型</span></span><br><span class="line">        <span class="keyword">while</span> (!list.isEmpty() &amp;&amp; !list.get(<span class="number">0</span>).isInteger()) &#123;</span><br><span class="line">            <span class="comment">// 当列表开头第一个元素是列表类型时，进入循环</span></span><br><span class="line">            List&lt;NestedInteger&gt; first = list.remove(<span class="number">0</span>).getList();</span><br><span class="line">            <span class="comment">// 将第一个列表打平并按顺序添加到开头</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> first.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                list.addFirst(first.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !list.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以这种方法，符合迭代器惰性求值的特性，是比较好的解法。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一道求中位数的算法题把我整不会了</title>
      <link href="/posts/3749.html"/>
      <url>/posts/3749.html</url>
      
        <content type="html"><![CDATA[<h1 id="一道求中位数的算法题把我整不会了"><a href="#一道求中位数的算法题把我整不会了" class="headerlink" title="一道求中位数的算法题把我整不会了"></a>一道求中位数的算法题把我整不会了</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/find-median-from-data-stream/">295. Find Median from Data Streamopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/find-median-from-data-stream/">295. 数据流的中位数open in new window</a></td><td align="center">🔴</td></tr><tr><td align="center">-</td><td align="center"><a href="https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">剑指 Offer 41. 数据流中的中位数open in new window</a></td><td align="center">🔴</td></tr></tbody></table><p>如果输入一个数组，让你求中位数，这个好办，排个序，如果数组长度是奇数，最中间的一个元素就是中位数，如果数组长度是偶数，最中间两个元素的平均数作为中位数。</p><p>如果数据规模非常巨大，排序不太现实，那么也可以使用概率算法，随机抽取一部分数据，排序，求中位数，作为所有数据的中位数。</p><p>本文说的中位数算法比较困难，也比较精妙，是力扣第 295 题「<a href="https://leetcode.cn/problems/find-median-from-data-stream/">数据流的中位数open in new window</a>」：</p><details class="hint-container details" open="" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1rem 0px; padding: 1.5rem; border-radius: 0.5rem; background: var(--detail-bg-color); color: rgb(44, 62, 80); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, STHeiti, &quot;Microsoft YaHei&quot;, SimSun, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1.5rem -1.5rem 0.5em; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer;"><strong style="font-weight: 600;">295. 数据流的中位数</strong>&nbsp;|<span>&nbsp;</span><a target="_blank" href="https://leetcode.cn/problems/find-median-from-data-stream/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|<span>&nbsp;</span><a target="_blank" href="https://leetcode.com/problems/find-median-from-data-stream/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">中位数</strong>是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>例如<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">arr = [2,3,4]</code>&nbsp;的中位数是<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">3</code>&nbsp;。</li><li>例如&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">arr = [2,3]</code><span>&nbsp;</span>的中位数是<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">(2 + 3) / 2 = 2.5</code><span>&nbsp;</span>。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">实现 MedianFinder 类:</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><p style="line-height: 1.6; overflow-wrap: break-word; margin-bottom: 0px; padding-bottom: 0px;"><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">MedianFinder()<span>&nbsp;</span></code>初始化<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">MedianFinder</code>&nbsp;对象。</p></li><li><p style="line-height: 1.6; overflow-wrap: break-word; margin-bottom: 0px; padding-bottom: 0px;"><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">void addNum(int num)</code><span>&nbsp;</span>将数据流中的整数<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">num</code><span>&nbsp;</span>添加到数据结构中。</p></li><li><p style="line-height: 1.6; overflow-wrap: break-word; margin-bottom: 0px; padding-bottom: 0px;"><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">double findMedian()</code><span>&nbsp;</span>返回到目前为止所有元素的中位数。与实际答案相差&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">10<sup>-5</sup></code>&nbsp;以内的答案将被接受。</p></li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入</strong>["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"][[], [1], [2], [], [3], []]<strong style="font-weight: 600;">输出</strong>[null, null, null, 1.5, null, 2.0]<p><strong style="font-weight: 600;">解释</strong><br>MedianFinder medianFinder &#x3D; new MedianFinder();<br>medianFinder.addNum(1);    &#x2F;&#x2F; arr &#x3D; [1]<br>medianFinder.addNum(2);    &#x2F;&#x2F; arr &#x3D; [1, 2]<br>medianFinder.findMedian(); &#x2F;&#x2F; 返回 1.5 ((1 + 2) &#x2F; 2)<br>medianFinder.addNum(3);    &#x2F;&#x2F; arr[1, 2, 3]<br>medianFinder.findMedian(); &#x2F;&#x2F; return 2.0</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示:</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">-10<sup>5</sup>&nbsp;&lt;= num &lt;= 10<sup>5</sup></code></li><li>在调用<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">findMedian</code>&nbsp;之前，数据结构中至少有一个元素</li><li>最多&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">5 * 10<sup>4</sup></code>&nbsp;次调用&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">addNum</code>&nbsp;和&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">findMedian</code></li></ul></div></details></p><p>就是让你设计这样一个类：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个数字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算当前添加的所有数字的中位数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其实，所有关于「流」的算法都比较难</strong>，比如我在后文 <a href="https://labuladong.online/algo/frequency-interview/random-algorithm/">谈谈游戏中的随机算法</a> 写过如何从数据流中等概率随机抽取一个元素，如果说你没有接触过这个问题的话，还是很难想到解法的。</p><p>这道题要求在数据流中计算平均数，我们先想一想常规思路。</p><h3 id="尝试分析"><a href="#尝试分析" class="headerlink" title="#尝试分析"></a><a href="https://labuladong.online/algo/practice-in-action/find-median-from-data-stream/#%E5%B0%9D%E8%AF%95%E5%88%86%E6%9E%90">#</a>尝试分析</h3><p>一个直接的解法可以用一个数组记录所有 <code>addNum</code> 添加进来的数字，通过插入排序的逻辑保证数组中的元素有序，当调用 <code>findMedian</code> 方法时，可以通过数组索引直接计算中位数。</p><p>但是用数组作为底层容器的问题也很明显，<code>addNum</code> 搜索插入位置的时候可以用二分搜索算法，但是插入操作需要搬移数据，所以最坏时间复杂度为 O(N)。</p><p>那换链表？链表插入元素很快，但是查找插入位置的时候只能线性遍历，最坏时间复杂度还是 O(N)，而且 <code>findMedian</code> 方法也需要遍历寻找中间索引，最坏时间复杂度也是 O(N)。</p><p>那么就用平衡二叉树呗，增删查改复杂度都是 O(logN)，这样总行了吧？</p><p>比如用 Java 提供的 <code>TreeSet</code> 容器，底层是红黑树，<code>addNum</code> 直接插入，<code>findMedian</code> 可以通过当前元素的个数推出计算中位数的元素的排名。</p><p>很遗憾，依然不行，这里有两个问题：</p><p>第一，<code>TreeSet</code> 是一种 <code>Set</code>，其中不存在重复元素的元素，但是我们的数据流可能输入重复数据的，而且计算中位数也是需要算上重复元素的。</p><p>第二，<code>TreeSet</code> 并没有实现一个通过排名快速计算元素的 API。假设我想找到 <code>TreeSet</code> 中第 5 大的元素，并没有一个现成可用的方法实现这个需求。</p><p>相关信息</p><p>如果让你实现一个在二叉搜索树中通过排名计算对应元素的方法 <code>select(int index)</code>，你会怎么设计？你可以思考一下，我会把答案写在留言区置顶。</p><p>除了平衡二叉树，还有没有什么常用的数据结构是动态有序的？优先级队列（二叉堆）行不行？</p><p>好像也不太行，因为优先级队列是一种受限的数据结构，只能从堆顶添加&#x2F;删除元素，我们的 <code>addNum</code> 方法可以从堆顶插入元素，但是 <code>findMedian</code> 函数需要从数据中间取，这个功能优先级队列是没办法提供的。</p><p>可以看到，求个中位数还是挺难的，我们使尽浑身解数都没有一个高效地思路，下面直接来看解法吧，比较巧妙。</p><p>🌟</p><hr><p>🌟</p><h3 id="解法思路"><a href="#解法思路" class="headerlink" title="#解法思路"></a><a href="https://labuladong.online/algo/practice-in-action/find-median-from-data-stream/#%E8%A7%A3%E6%B3%95%E6%80%9D%E8%B7%AF">#</a>解法思路</h3><p><strong>我们必然需要有序数据结构，本题的核心思路是使用两个优先级队列</strong>。</p><p>中位数是有序数组最中间的元素算出来的对吧，我们可以把「有序数组」抽象成一个倒三角形，宽度可以视为元素的大小，那么这个倒三角的中部就是计算中位数的元素对吧：</p><p><img src="https://labuladong.online/algo/images/%E4%B8%AD%E4%BD%8D%E6%95%B0/1.jpeg" alt="img"></p><p>然后我把这个大的倒三角形从正中间切成两半，变成一个小倒三角和一个梯形，这个小倒三角形相当于一个从小到大的有序数组，这个梯形相当于一个从大到小的有序数组。</p><p>中位数就可以通过小倒三角和梯形顶部的元素算出来对吧？嗯，你联想到什么了没有？它们能不能用优先级队列表示？</p><p><strong>小倒三角不就是个大顶堆嘛，梯形不就是个小顶堆嘛，中位数可以通过它们的堆顶元素算出来</strong>：</p><p><img src="https://labuladong.online/algo/images/%E4%B8%AD%E4%BD%8D%E6%95%B0/2.jpeg" alt="img"></p><p>梯形虽然是小顶堆，但其中的元素是较大的，我们称其为 <code>large</code>，倒三角虽然是大顶堆，但是其中元素较小，我们称其为 <code>small</code>。</p><p>当然，这两个堆需要算法逻辑正确维护，才能保证堆顶元素是可以算出正确的中位数，<strong>我们很容易看出来，两个堆中的元素之差不能超过 1</strong>。</p><p>因为我们要求中位数嘛，假设元素总数是 <code>n</code>，如果 <code>n</code> 是偶数，我们希望两个堆的元素个数是一样的，这样把两个堆的堆顶元素拿出来求个平均数就是中位数；如果 <code>n</code> 是奇数，那么我们希望两个堆的元素个数分别是 <code>n/2 + 1</code> 和 <code>n/2</code>，这样元素多的那个堆的堆顶元素就是中位数。</p><p>根据这个逻辑，我们可以直接写出 <code>findMedian</code> 函数的代码：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; large;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; small;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MedianFinder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 小顶堆</span></span><br><span class="line">        large = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 大顶堆</span></span><br><span class="line">        small = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> b - a;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果元素不一样多，多的那个堆的堆顶元素就是中位数</span></span><br><span class="line">        <span class="keyword">if</span> (large.size() &lt; small.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> small.peek();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (large.size() &gt; small.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> large.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果元素一样多，两个堆堆顶元素的平均数是中位数</span></span><br><span class="line">        <span class="keyword">return</span> (large.peek() + small.peek()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="comment">// 后文实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在的问题是，如何实现 <code>addNum</code> 方法，维护「两个堆中的元素之差不能超过 1」这个条件呢？</p><p>这样行不行？每次调用 <code>addNum</code> 函数的时候，我们比较一下 <code>large</code> 和 <code>small</code> 的元素个数，谁的元素少我们就加到谁那里，如果它们的元素一样多，我们默认加到 <code>large</code> 里面：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">    <span class="comment">// 为了节约篇幅，省略上文给出的代码部分...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有缺陷的代码实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (small.size() &gt;= large.size()) &#123;</span><br><span class="line">            large.offer(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            small.offer(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来好像没问题，但是跑一下就发现问题了，比如说我们这样调用：</p><p><code>addNum(1)</code>，现在两个堆元素数量相同，都是 0，所以默认把 1 添加进 <code>large</code> 堆。</p><p><code>addNum(2)</code>，现在 <code>large</code> 的元素比 <code>small</code> 的元素多，所以把 2 添加进 <code>small</code> 堆中。</p><p><code>addNum(3)</code>，现在两个堆都有一个元素，所以默认把 3 添加进 <code>large</code> 中。</p><p>调用 <code>findMedian</code>，预期的结果应该是 2，但是实际得到的结果是 1。</p><p>问题很容易发现，看下当前两个堆中的数据：</p><p><img src="https://labuladong.online/algo/images/%E4%B8%AD%E4%BD%8D%E6%95%B0/3.jpeg" alt="img"></p><p>抽象点说，我们的梯形和小倒三角都是由原始的大倒三角从中间切开得到的，那么梯形中的最小宽度要大于等于小倒三角的最大宽度，这样它俩才能拼成一个大的倒三角对吧？</p><p><strong>也就是说，不仅要维护 <code>large</code> 和 <code>small</code> 的元素个数之差不超过 1，还要维护 <code>large</code> 堆的堆顶元素要大于等于 <code>small</code> 堆的堆顶元素</strong>。</p><p>维护 <code>large</code> 堆的元素大小整体大于 <code>small</code> 堆的元素是本题的难点，不是一两个 if 语句能够正确维护的，而是需要如下技巧：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">    <span class="comment">// 为了节约篇幅，省略上文给出的代码部分...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确的代码实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (small.size() &gt;= large.size()) &#123;</span><br><span class="line">            small.offer(num);</span><br><span class="line">            large.offer(small.poll());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            large.offer(num);</span><br><span class="line">            small.offer(large.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>简单说，想要往 <code>large</code> 里添加元素，不能直接添加，而是要先往 <code>small</code> 里添加，然后再把 <code>small</code> 的堆顶元素加到 <code>large</code> 中；向 <code>small</code> 中添加元素同理</strong>。</p><p>为什么呢，稍加思考可以想明白，假设我们准备向 <code>large</code> 中插入元素：</p><p>如果插入的 <code>num</code> 小于 <code>small</code> 的堆顶元素，那么 <code>num</code> 就会留在 <code>small</code> 堆里，为了保证两个堆的元素数量之差不大于 1，作为交换，把 <code>small</code> 堆顶部的元素再插到 <code>large</code> 堆里。</p><p>如果插入的 <code>num</code> 大于 <code>small</code> 的堆顶元素，那么 <code>num</code> 就会成为 <code>samll</code> 的堆顶元素，最后还是会被插入 <code>large</code> 堆中。</p><p>反之，向 <code>small</code> 中插入元素是一个道理，这样就巧妙地保证了 <code>large</code> 堆整体大于 <code>small</code> 堆，且两个堆的元素之差不超过 1，那么中位数就可以通过两个堆的堆顶元素快速计算了。</p><p>至此，整个算法就结束了，<code>addNum</code> 方法时间复杂度 O(logN)，<code>findMedian</code> 方法时间复杂度 O(1)。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀树算法模板秒杀五道算法题</title>
      <link href="/posts/42761.html"/>
      <url>/posts/42761.html</url>
      
        <content type="html"><![CDATA[<h1 id="前缀树算法模板秒杀五道算法题"><a href="#前缀树算法模板秒杀五道算法题" class="headerlink" title="前缀树算法模板秒杀五道算法题"></a>前缀树算法模板秒杀五道算法题</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/implement-trie-ii-prefix-tree/">1804. Implement Trie II (Prefix Tree)open in new window</a>🔒</td><td align="center"><a href="https://leetcode.cn/problems/implement-trie-ii-prefix-tree/">1804. 实现 Trie （前缀树） IIopen in new window</a>🔒</td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/implement-trie-prefix-tree/">208. Implement Trie (Prefix Tree)open in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)open in new window</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/design-add-and-search-words-data-structure/">211. Design Add and Search Words Data Structureopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/">211. 添加与搜索单词 - 数据结构设计open in new window</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/replace-words/">648. Replace Wordsopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/replace-words/">648. 单词替换open in new window</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/map-sum-pairs/">677. Map Sum Pairsopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/map-sum-pairs/">677. 键值映射open in new window</a></td><td align="center">🟠</td></tr><tr><td align="center">-</td><td align="center"><a href="https://leetcode.cn/problems/QC3q1f/">剑指 Offer II 062. 实现前缀树open in new window</a></td><td align="center">🟠</td></tr><tr><td align="center">-</td><td align="center"><a href="https://leetcode.cn/problems/UhWRSj/">剑指 Offer II 063. 替换单词open in new window</a></td><td align="center">🟠</td></tr><tr><td align="center">-</td><td align="center"><a href="https://leetcode.cn/problems/z1R5dt/">剑指 Offer II 066. 单词之和open in new window</a></td><td align="center">🟠</td></tr></tbody></table><p>Tip</p><p>本文有视频版：<a href="https://labuladong.online/algo/ds-class/dong-shou--995bb/trie-shu-j-33917/">动手实现字典树open in new window</a>。</p><p>Trie 树又叫字典树、前缀树、单词查找树，是一种二叉树衍生出来的高级数据结构，主要应用场景是处理字符串前缀相关的操作。</p><p>我是在《算法 4》第一次学到这种数据结构，不过书中的讲解不是特别通俗易懂，所以本文按照我的逻辑帮大家重新梳理一遍 Trie 树的原理，并基于《算法 4》的代码实现一套更通用易懂的代码模板，用于处理力扣上一系列字符串前缀问题。</p><p>阅读本文之前希望你读过我旧文讲过的 <a href="https://labuladong.online/algo/essential-technique/backtrack-framework/">回溯算法代码模板</a> 和 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树（总结篇）</a>。</p><p>本文主要分三部分：</p><p><strong>1、讲解 Trie 树的工作原理</strong>。</p><p><strong>2、给出一套 <code>TrieMap</code> 和 <code>TrieSet</code> 的代码模板，实现几个常用 API</strong>。</p><p><strong>3、实践环节，直接套代码模板秒杀 5 道算法题</strong>。本来可以秒杀七八道题，篇幅考虑，剩下的我集成到 <a href="https://labuladong.online/algo/intro/chrome/">刷题插件</a> 中。</p><p>关于 <code>Map</code> 和 <code>Set</code>，是两个抽象数据结构（接口），<code>Map</code> 存储一个键值对集合，其中键不重复，<code>Set</code> 存储一个不重复的元素集合。</p><p>常见的 <code>Map</code> 和 <code>Set</code> 的底层实现原理有哈希表和二叉搜索树两种，比如 Java 的 HashMap&#x2F;HashSet 和 C++ 的 unorderd_map&#x2F;unordered_set 底层就是用哈希表实现，而 Java 的 TreeMap&#x2F;TreeSet 和 C++ 的 map&#x2F;set 底层使用红黑树这种自平衡 BST 实现的。</p><p>而本文实现的 TrieSet&#x2F;TrieMap 底层则用 Trie 树这种结构来实现。</p><p>了解数据结构的读者应该知道，本质上 <code>Set</code> 可以视为一种特殊的 <code>Map</code>，<code>Set</code> 其实就是 <code>Map</code> 中的键。</p><p>**所以本文先实现 <code>TrieMap</code>，然后在 <code>TrieMap</code> 的基础上封装出 <code>TrieSet</code>**。</p><p>注</p><p>为了模板通用性的考虑，后文会用到 Java 的泛型，也就是用尖括号 <code>&lt;&gt;</code> 指定的类型变量。这些类型变量的作用是指定我们实现的容器中存储的数据类型，类比 Java 标准库的那些容器的用法应该不难理解。</p><p>前文 <a href="https://labuladong.online/algo/essential-technique/abstraction-of-algorithm/">学习数据结构的框架思维</a> 说过，各种乱七八糟的结构都是为了在「特定场景」下尽可能高效地进行增删查改。</p><p>你比如 <code>HashMap&lt;K, V&gt;</code> 的优势是能够在 O(1) 时间通过键查找对应的值，但要求键的类型 <code>K</code> 必须是「可哈希」的；而 <code>TreeMap&lt;K, V&gt;</code> 的特点是方便根据键的大小进行操作，但要求键的类型 <code>K</code> 必须是「可比较」的。</p><p>本文要实现的 <code>TrieMap</code> 也是类似的，由于 Trie 树原理，我们要求 <code>TrieMap&lt;V&gt;</code> 的键必须是字符串类型，值的类型 <code>V</code> 可以随意。</p><p>接下来我们了解一下 Trie 树的原理，看看为什么这种数据结构能够高效操作字符串。</p><p>🌟</p><hr><p>🌟</p><h3 id="Trie-树原理"><a href="#Trie-树原理" class="headerlink" title="#Trie 树原理"></a><a href="https://labuladong.online/algo/data-structure/trie/#trie-%E6%A0%91%E5%8E%9F%E7%90%86">#</a>Trie 树原理</h3><p><strong>Trie 树本质上就是一棵从二叉树衍生出来的多叉树</strong>。</p><p>二叉树节点的代码实现是这样：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基本的二叉树节点 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left, right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>left, right</code> 存储左右子节点的指针，所以二叉树的结构是这样：</p><p><img src="https://labuladong.online/algo/images/trie/1.jpeg" alt="img"></p><p>多叉树节点的代码实现是这样：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基本的多叉树节点 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode[] children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>children</code> 数组中存储指向孩子节点的指针，所以多叉树的结构是这样：</p><p><img src="https://labuladong.online/algo/images/trie/2.jpeg" alt="img"></p><p>而 <code>TrieMap</code> 中的树节点 <code>TrieNode</code> 的代码实现是这样：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Trie 树节点实现 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="type">V</span> <span class="variable">val</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    TrieNode&lt;V&gt;[] children = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">256</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>val</code> 字段存储键对应的值，<code>children</code> 数组存储指向子节点的指针。</p><p><strong>但是和之前的普通多叉树节点不同，<code>TrieNode</code> 中 <code>children</code> 数组的索引是有意义的，代表键中的一个字符</strong>。</p><p>比如说 <code>children[97]</code> 如果非空，说明这里存储了一个字符 <code>&#39;a&#39;</code>，因为 <code>&#39;a&#39;</code> 的 ASCII 码为 97。</p><p>我们的模板只考虑处理 ASCII 字符，所以 <code>children</code> 数组的大小设置为 256。不过这个可以根据具体问题修改，比如改成更小的数组或者 <code>HashMap&lt;Character, TrieNode&gt;</code> 都是一样的效果。</p><p>有了以上铺垫，Trie 树的结构是这样的：</p><p><img src="https://labuladong.online/algo/images/trie/3.jpeg" alt="img"></p><p>一个节点有 256 个子节点指针，但大多数时候都是空的，可以省略掉不画，<strong>所以一般你看到的 Trie 树长这样</strong>：</p><p><img src="https://labuladong.online/algo/images/trie/9.jpeg" alt="img"></p><p>这是在 <code>TrieMap&lt;Integer&gt;</code> 中插入一些键值对后的样子，白色节点代表 <code>val</code> 字段为空，橙色节点代表 <code>val</code> 字段非空。</p><p><strong>这里要特别注意，<code>TrieNode</code> 节点本身只存储 <code>val</code> 字段，并没有一个字段来存储字符，字符是通过子节点在父节点的 <code>children</code> 数组中的索引确定的</strong>。</p><p><strong>形象理解就是，Trie 树用「树枝」存储字符串（键），用「节点」存储字符串（键）对应的数据（值）。所以我在图中把字符标在树枝，键对应的值 <code>val</code> 标在节点上</strong>：</p><p><img src="https://labuladong.online/algo/images/trie/10.jpeg" alt="img"></p><p>明白这一点很重要，有助于之后你理解代码实现。</p><p>注</p><p>《算法 4》以及网上讲 Trie 树的文章中都是把字符标在节点上，我认为这样很容易让初学者产生误解，所以建议大家按照我的这种理解来记忆 Trie 树结构。</p><p>现在你应该知道为啥 Trie 树也叫前缀树了，因为其中的字符串共享前缀，相同前缀的字符串集中在 Trie 树中的一个子树上，给字符串的处理带来很大的便利。</p><h3 id="TrieMap-TrieSet-API-及实现"><a href="#TrieMap-TrieSet-API-及实现" class="headerlink" title="#TrieMap&#x2F;TrieSet API 及实现"></a><a href="https://labuladong.online/algo/data-structure/trie/#triemap-trieset-api-%E5%8F%8A%E5%AE%9E%E7%8E%B0">#</a>TrieMap&#x2F;TrieSet API 及实现</h3><p>首先我们看一下本文实现的 <code>TrieMap</code> 的 API，为了举例 API 的功能，假设 TrieMap 中已经存储了如下键值对：</p><p><img src="https://labuladong.online/algo/images/trie/9.jpeg" alt="img"></p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 底层用 Trie 树实现的键值映射</span></span><br><span class="line"><span class="comment">// 键为 String 类型，值为类型 V</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieMap</span>&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 增/改 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 Map 中添加 key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, V val)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 删 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除键 key 以及对应的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(String key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 查 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索 key 对应的值，不存在则返回 null</span></span><br><span class="line">    <span class="comment">// get(&quot;the&quot;) -&gt; 4</span></span><br><span class="line">    <span class="comment">// get(&quot;tha&quot;) -&gt; null</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(String key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 key 是否存在在 Map 中</span></span><br><span class="line">    <span class="comment">// containsKey(&quot;tea&quot;) -&gt; false</span></span><br><span class="line">    <span class="comment">// containsKey(&quot;team&quot;) -&gt; true</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(String key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 Map 的所有键中搜索 query 的最短前缀</span></span><br><span class="line">    <span class="comment">// shortestPrefixOf(&quot;themxyz&quot;) -&gt; &quot;the&quot;</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">shortestPrefixOf</span><span class="params">(String query)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 Map 的所有键中搜索 query 的最长前缀</span></span><br><span class="line">    <span class="comment">// longestPrefixOf(&quot;themxyz&quot;) -&gt; &quot;them&quot;</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPrefixOf</span><span class="params">(String query)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索所有前缀为 prefix 的键</span></span><br><span class="line">    <span class="comment">// keysWithPrefix(&quot;th&quot;) -&gt; [&quot;that&quot;, &quot;the&quot;, &quot;them&quot;]</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysWithPrefix</span><span class="params">(String prefix)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是和否存在前缀为 prefix 的键</span></span><br><span class="line">    <span class="comment">// hasKeyWithPrefix(&quot;tha&quot;) -&gt; true</span></span><br><span class="line">    <span class="comment">// hasKeyWithPrefix(&quot;apple&quot;) -&gt; false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPrefix</span><span class="params">(String prefix)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通配符 . 匹配任意字符，搜索所有匹配的键</span></span><br><span class="line">    <span class="comment">// keysWithPattern(&quot;t.a.&quot;) -&gt; [&quot;team&quot;, &quot;that&quot;]</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysWithPattern</span><span class="params">(String pattern)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通配符 . 匹配任意字符，判断是否存在匹配的键</span></span><br><span class="line">    <span class="comment">// hasKeyWithPattern(&quot;.ip&quot;) -&gt; true</span></span><br><span class="line">    <span class="comment">// hasKeyWithPattern(&quot;.i&quot;) -&gt; false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPattern</span><span class="params">(String pattern)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 Map 中键值对的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于 <code>TrieSet</code> 的 API 大同小异，所以这里不重复列举，后文直接给出实现。</p><p><strong>接下来是重头戏，我们一个一个实现 <code>TrieMap</code> 的上述 API 函数</strong>。</p><p>首先，<code>TrieMap</code> 类中一定需要记录 Trie 的根节点 <code>root</code>，以及 Trie 树中的所有节点数量用于实现 <code>size()</code> 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieMap</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">// ASCII 码个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">256</span>;</span><br><span class="line">    <span class="comment">// 当前存在 Map 中的键值对个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span>&lt;V&gt; &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">val</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        TrieNode&lt;V&gt;[] children = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[R];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trie 树的根节点</span></span><br><span class="line">    <span class="keyword">private</span> TrieNode&lt;V&gt; root = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 其他 API 的实现... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，我们再实现一个工具函数 <code>getNode</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从节点 node 开始搜索 key，如果存在返回对应节点，否则返回 null</span></span><br><span class="line"><span class="keyword">private</span> TrieNode&lt;V&gt; <span class="title function_">getNode</span><span class="params">(TrieNode&lt;V&gt; node, String key)</span> &#123;</span><br><span class="line">    TrieNode&lt;V&gt; p = node;</span><br><span class="line">    <span class="comment">// 从节点 node 开始搜索 key</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; key.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 无法向下搜索</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向下搜索</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> key.charAt(i);</span><br><span class="line">        p = p.children[c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://labuladong.online/algo/images/trie/11.jpeg" alt="img"></p><p>有了这个 <code>getNode</code> 函数，就能实现 <code>containsKey</code> 方法和 <code>get</code> 方法了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 搜索 key 对应的值，不存在则返回 null</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="comment">// 从 root 开始搜索 key</span></span><br><span class="line">    TrieNode&lt;V&gt; x = getNode(root, key);</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span> || x.val == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// x 为空或 x 的 val 字段为空都说明 key 没有对应的值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 key 是否存在在 Map 中</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get(key) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里需要注意，就算 <code>getNode(key)</code> 的返回值 <code>x</code> 非空，也只能说字符串 <code>key</code> 是一个「前缀」；除非 <code>x.val</code> 同时非空，才能判断键 <code>key</code> 存在</strong>。</p><p>不过，这个特性恰好能够帮我们实现 <code>hasKeyWithPrefix</code> 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是和否存在前缀为 prefix 的键</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">    <span class="comment">// 只要能找到一个节点，就是存在前缀</span></span><br><span class="line">    <span class="keyword">return</span> getNode(root, prefix) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似 <code>getNode</code> 方法的逻辑，我们可以实现 <code>shortestPrefixOf</code> 方法，只要在第一次遇到存有 <code>val</code> 的节点的时候返回就行了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在所有键中寻找 query 的最短前缀</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">shortestPrefixOf</span><span class="params">(String query)</span> &#123;</span><br><span class="line">    TrieNode&lt;V&gt; p = root;</span><br><span class="line">    <span class="comment">// 从节点 node 开始搜索 key</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; query.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 无法向下搜索</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.val != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到一个键是 query 的前缀</span></span><br><span class="line">            <span class="keyword">return</span> query.substring(<span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向下搜索</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> query.charAt(i);</span><br><span class="line">        p = p.children[c];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; p.val != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 query 本身就是一个键</span></span><br><span class="line">        <span class="keyword">return</span> query;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里需要注意的是 for 循环结束之后我们还需要额外检查一下</strong>。</p><p>因为之前说了 Trie 树中「树枝」存储字符串，「节点」存储字符串对应的值，for 循环相当于只遍历了「树枝」，但漏掉了最后一个「节点」，即 <code>query</code> 本身就是 <code>TrieMap</code> 中的一个键的情况。</p><p>如果你理解了 <code>shortestPrefixOf</code> 的实现，那么 <code>longestPrefixOf</code> 也是非常类似的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在所有键中寻找 query 的最长前缀</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPrefixOf</span><span class="params">(String query)</span> &#123;</span><br><span class="line">    TrieNode&lt;V&gt; p = root;</span><br><span class="line">    <span class="comment">// 记录前缀的最大长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max_len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从节点 node 开始搜索 key</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; query.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 无法向下搜索</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.val != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到一个键是 query 的前缀，更新前缀的最大长度</span></span><br><span class="line">            max_len = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向下搜索</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> query.charAt(i);</span><br><span class="line">        p = p.children[c];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; p.val != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 query 本身就是一个键</span></span><br><span class="line">        <span class="keyword">return</span> query;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> query.substring(<span class="number">0</span>, max_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次遇到 <code>p.val</code> 非空的时候说明找到一个键，但是我们不急着返回，而是更新 <code>max_len</code> 变量，记录最长前缀的长度。</p><p>同样的，在 for 循环结束时还是要特殊判断一下，处理 <code>query</code> 本身就是键的情况。</p><p>接下来，我们来实现 <code>keysWithPrefix</code> 方法，得到所有前缀为 <code>prefix</code> 的键。</p><p>看过前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树（总结篇）</a> 的读者应该可以想到，先利用 <code>getNode</code> 函数在 Trie 树中找到 <code>prefix</code> 对应的节点 <code>x</code>，然施展多叉树的遍历算法，遍历以 <code>x</code> 为根的这棵 Trie 树，找到所有键值对：</p><p><img src="https://labuladong.online/algo/images/trie/12.jpeg" alt="img"></p><p>代码实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 搜索前缀为 prefix 的所有键</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysWithPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 找到匹配 prefix 在 Trie 树中的那个节点</span></span><br><span class="line">    TrieNode&lt;V&gt; x = getNode(root, prefix);</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// DFS 遍历以 x 为根的这棵 Trie 树</span></span><br><span class="line">    traverse(x, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(prefix), res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历以 node 节点为根的 Trie 树，找到所有键</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TrieNode&lt;V&gt; node, StringBuilder path, List&lt;String&gt; res)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 到达 Trie 树底部叶子结点</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.val != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到一个 key，添加到结果列表中</span></span><br><span class="line">        res.add(path.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯算法遍历框架</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; R; c++) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        path.append(c);</span><br><span class="line">        traverse(node.children[c], path, res);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中 <code>traverse</code> 函数你可能看起来特别熟悉，就是 <a href="https://labuladong.online/algo/essential-technique/backtrack-framework/">回溯算法核心套路</a> 中讲的回溯算法代码框架。</p><p>关于回溯算法框架和标准多叉树框架的区别我在 <a href="https://labuladong.online/algo/data-structure/graph-traverse/">图论算法基础</a> 中探讨过，关键在于遍历「节点」和遍历「树枝」的区别。由于 Trie 树将字符存储在「树枝」上，<code>traverse</code> 函数是在遍历树枝上的字符，所以采用的是回溯算法框架。</p><p>另外，再注意一下这段逻辑：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回溯算法遍历框架</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; R; c++) &#123;</span><br><span class="line">    <span class="comment">// 做选择</span></span><br><span class="line">    path.append(c);</span><br><span class="line">    traverse(node.children[c], path, res);</span><br><span class="line">    <span class="comment">// 撤销选择</span></span><br><span class="line">    path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回顾一下我们 Trie 树的图：</p><p><img src="https://labuladong.online/algo/images/trie/9.jpeg" alt="img"></p><p>你是否会有疑问：代码中 for 循环会执行 256 次，但是图中的一个节点只有几个子节点，也就是说每个节点的 <code>children</code> 数组中大部分都是空指针，这不会有问题吗？</p><p>是不是应该把代码改成这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回溯算法遍历框架</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; R; c++) &#123;</span><br><span class="line">    <span class="comment">// 做选择</span></span><br><span class="line">    path.append(c);</span><br><span class="line">    <span class="keyword">if</span> (node.children[c] != <span class="literal">null</span>) &#123;</span><br><span class="line">        traverse(node.children[c], path, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 撤销选择</span></span><br><span class="line">    path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是，改不改都行，这两种写法从逻辑上讲完全相同，因为 <code>traverse</code> 函数开始的时候如果发现 <code>node == null</code> 也会直接返回。</p><p>我为了保持框架的一致性，就没有在 for 循环中判断子节点是否为空，而是依赖递归函数的 base case。当然你完全可以按照自己的喜好来实现。</p><p>下面来实现 <code>keysWithPattern</code> 方法，使用通配符来匹配多个键，其关键就在于通配符 <code>.</code> 可以匹配所有字符。</p><p>在代码实现上，用 <code>path</code> 变量记录匹配键的路径，遇到通配符时使用类似回溯算法的框架就行了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通配符 . 匹配任意字符</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysWithPattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    traverse(root, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(), pattern, <span class="number">0</span>, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历函数，尝试在「以 node 为根的 Trie 树中」匹配 pattern[i..]</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TrieNode&lt;V&gt; node, StringBuilder path, String pattern, <span class="type">int</span> i, List&lt;String&gt; res)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 树枝不存在，即字符 pattern[i-1] 匹配失败</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == pattern.length()) &#123;</span><br><span class="line">        <span class="comment">// pattern 匹配完成</span></span><br><span class="line">        <span class="keyword">if</span> (node.val != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果这个节点存储着 val，则找到一个匹配的键</span></span><br><span class="line">            res.add(path.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> pattern.charAt(i);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// pattern[i] 是通配符，可以变化成任意字符</span></span><br><span class="line">        <span class="comment">// 多叉树（回溯算法）遍历框架</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; R; j++) &#123;</span><br><span class="line">            path.append(j);</span><br><span class="line">            traverse(node.children[j], path, pattern, i + <span class="number">1</span>, res);</span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// pattern[i] 是普通字符 c</span></span><br><span class="line">        path.append(c);</span><br><span class="line">        traverse(node.children[c], path, pattern, i + <span class="number">1</span>, res);</span><br><span class="line">        path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个 GIF 画了匹配 <code>&quot;t.a.&quot;</code> 的过程，应该就容易理解上述代码的逻辑了：</p><p><img src="https://labuladong.online/algo/images/trie/1.gif" alt="img"></p><p>可以看到，<code>keysWithPattern</code> 和 <code>keysWithPrefix</code> 的实现是有些类似的，而且这两个函数还有一个潜在的特性：<strong>它们返回的结果列表一定是符合「字典序」的</strong>。</p><p>原因应该不难理解，每一个节点的 <code>children</code> 数组都是从左到右进行遍历，即按照 ASCII 码从小到大的顺序递归遍历，得到的结果自然是符合字典序的。</p><p>好，现在我们实现了 <code>keysWithPattern</code> 方法得到模式串匹配的所有键，那你是否可以实现 <code>hasKeyWithPattern</code> 方法，仅仅判断是否存在键匹配模式串？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个偷懒的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !keysWithPattern(pattern).isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个偷懒的实现，因为它的复杂度比较高。我们的目的仅仅是判断是否存在匹配模式串的键，你却把所有匹配的键都算出来了，这显然是没有必要的。</p><p>我们只需稍微改写一下 <code>keysWithPattern</code> 方法就可以高效实现 <code>hasKeyWithPattern</code> 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是和否存在前缀为 prefix 的键</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">    <span class="comment">// 从 root 节点开始匹配 pattern[0..]</span></span><br><span class="line">    <span class="keyword">return</span> hasKeyWithPattern(root, pattern, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义：从 node 节点开始匹配 pattern[i..]，返回是否成功匹配</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPattern</span><span class="params">(TrieNode&lt;V&gt; node, String pattern, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 树枝不存在，即匹配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == pattern.length()) &#123;</span><br><span class="line">        <span class="comment">// 模式串走到头了，看看匹配到的是否是一个键</span></span><br><span class="line">        <span class="keyword">return</span> node.val != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> pattern.charAt(i);</span><br><span class="line">    <span class="comment">// 没有遇到通配符</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 从 node.children[c] 节点开始匹配 pattern[i+1..]</span></span><br><span class="line">        <span class="keyword">return</span> hasKeyWithPattern(node.children[c], pattern, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遇到通配符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; R; j++) &#123;</span><br><span class="line">        <span class="comment">// pattern[i] 可以变化成任意字符，尝试所有可能，只要遇到一个匹配成功就返回</span></span><br><span class="line">        <span class="keyword">if</span> (hasKeyWithPattern(node.children[j], pattern, i + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 都没有匹配</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有之前的铺垫，这个实现应该是不难理解的，类似于 <a href="https://labuladong.online/algo/practice-in-action/sudoku/">回溯算法解数独游戏</a> 中找到一个可行解就提前结束递归的做法。</p><p>到这里，<code>TrieMap</code> 的所有和前缀相关的方法都实现完了，还剩下 <code>put</code> 和 <code>remove</code> 这两个基本方法了，其实它们的难度不大，就是递归修改数据结构的那一套，如果不熟悉的话可以参见 <a href="https://labuladong.online/algo/data-structure/bst-part2/">二叉搜索树基本操作</a>。</p><p>先说 <code>put</code> 方法的实现吧，直接看代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 map 中添加或修改键值对</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, V val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!containsKey(key)) &#123;</span><br><span class="line">        <span class="comment">// 新增键值对</span></span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要一个额外的辅助函数，并接收其返回值</span></span><br><span class="line">    root = put(root, key, val, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义：向以 node 为根的 Trie 树中插入 key[i..]，返回插入完成后的根节点</span></span><br><span class="line"><span class="keyword">private</span> TrieNode&lt;V&gt; <span class="title function_">put</span><span class="params">(TrieNode&lt;V&gt; node, String key, V val, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果树枝不存在，新建</span></span><br><span class="line">        node = <span class="keyword">new</span> <span class="title class_">TrieNode</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == key.length()) &#123;</span><br><span class="line">        <span class="comment">// key 的路径已插入完成，将值 val 存入节点</span></span><br><span class="line">        node.val = val;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> key.charAt(i);</span><br><span class="line">    <span class="comment">// 递归插入子节点，并接收返回值</span></span><br><span class="line">    node.children[c] = put(node.children[c], key, val, i + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是递归修改数据结构，所以我们必须额外创建一个返回类型为 <code>TrieNode</code> 的辅助函数，并且在递归调用的时候接收其返回值，拼接到父节点上。</p><p>**前文说了，Trie 树中的键就是「树枝」，值就是「节点」，所以插入的逻辑就是沿路新建「树枝」，把 <code>key</code> 的整条「树枝」构建出来之后，在树枝末端的「节点」中存储 <code>val</code>**：</p><p><img src="https://labuladong.online/algo/images/trie/2.gif" alt="img"></p><p>最后，我们说一下 <code>remove</code> 函数，似乎所有数据结构的删除操作相对其他操作都会更复杂一些。</p><p>比如说下图这个场景，如果你想删除键 <code>&quot;team&quot;</code>，那么需要删掉 <code>&quot;eam&quot;</code> 这条树枝才是符合逻辑的：</p><p><img src="https://labuladong.online/algo/images/trie/13.jpeg" alt="img"></p><p>删多了肯定不行，但删少了也不行，否则前文实现的 <code>hasKeyWithPrefix</code> 就会出错。</p><p>那么如何控制算法来正确地进行删除呢？</p><p>首先，递归修改数据结构的时候，如果一个节点想删掉自己，直接返回空指针就行了。</p><p><strong>其次，一个节点如何知道自己是否需要被删除呢？主要看自己的 <code>val</code> 字段是否为空以及自己的 <code>children</code> 数组是否全都是空指针</strong>。</p><p>这里就要利用前文 <a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">手把手刷二叉树（总结篇）</a> 中说到的后序位置的特点了：</p><p>一个节点要先递归处理子树，然后在后序位置检查自己的 <code>val</code> 字段和 <code>children</code> 列表，判断自己是否需要被删除。</p><p>如果自己的 <code>val</code> 字段为空，说明自己没有存储值，如果同时自己的 <code>children</code> 数组全是空指针，说明自己下面也没有接树枝，即不是任何一个键的前缀。这种情况下这个节点就没有存在的意义了，应该删掉自己。</p><p>直接看代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 Map 中删除 key</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!containsKey(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归修改数据结构要接收函数的返回值</span></span><br><span class="line">    root = remove(root, key, <span class="number">0</span>);</span><br><span class="line">    size--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义：在以 node 为根的 Trie 树中删除 key[i..]，返回删除后的根节点</span></span><br><span class="line"><span class="keyword">private</span> TrieNode&lt;V&gt; <span class="title function_">remove</span><span class="params">(TrieNode&lt;V&gt; node, String key, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == key.length()) &#123;</span><br><span class="line">        <span class="comment">// 找到了 key 对应的 TrieNode，删除 val</span></span><br><span class="line">        node.val = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> key.charAt(i);</span><br><span class="line">        <span class="comment">// 递归去子树进行删除</span></span><br><span class="line">        node.children[c] = remove(node.children[c], key, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序位置，递归路径上的节点可能需要被清理</span></span><br><span class="line">    <span class="keyword">if</span> (node.val != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果该 TireNode 存储着 val，不需要被清理</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查该 TrieNode 是否还有后缀</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; R; c++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.children[c] != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 只要存在一个子节点（后缀树枝），就不需要被清理</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 既没有存储 val，也没有后缀树枝，则该节点需要被清理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，<code>TrieMap</code> 的所有 API 就实现完了，完整代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieMap</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">// ASCII 码个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">256</span>;</span><br><span class="line">    <span class="comment">// 当前存在 Map 中的键值对个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Trie 树的根节点</span></span><br><span class="line">    <span class="keyword">private</span> TrieNode&lt;V&gt; root = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span>&lt;V&gt; &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">val</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        TrieNode&lt;V&gt;[] children = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[R];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 增/改 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 map 中添加或修改键值对</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, V val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 新增键值对</span></span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 需要一个额外的辅助函数，并接收其返回值</span></span><br><span class="line">        root = put(root, key, val, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：向以 node 为根的 Trie 树中插入 key[i..]，返回插入完成后的根节点</span></span><br><span class="line">    <span class="keyword">private</span> TrieNode&lt;V&gt; <span class="title function_">put</span><span class="params">(TrieNode&lt;V&gt; node, String key, V val, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果树枝不存在，新建</span></span><br><span class="line">            node = <span class="keyword">new</span> <span class="title class_">TrieNode</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == key.length()) &#123;</span><br><span class="line">            <span class="comment">// key 的路径已插入完成，将值 val 存入节点</span></span><br><span class="line">            node.val = val;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> key.charAt(i);</span><br><span class="line">        <span class="comment">// 递归插入子节点，并接收返回值</span></span><br><span class="line">        node.children[c] = put(node.children[c], key, val, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 删 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 Map 中删除 key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归修改数据结构要接收函数的返回值</span></span><br><span class="line">        root = remove(root, key, <span class="number">0</span>);</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：在以 node 为根的 Trie 树中删除 key[i..]，返回删除后的根节点</span></span><br><span class="line">    <span class="keyword">private</span> TrieNode&lt;V&gt; <span class="title function_">remove</span><span class="params">(TrieNode&lt;V&gt; node, String key, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == key.length()) &#123;</span><br><span class="line">            <span class="comment">// 找到了 key 对应的 TrieNode，删除 val</span></span><br><span class="line">            node.val = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> key.charAt(i);</span><br><span class="line">            <span class="comment">// 递归去子树进行删除</span></span><br><span class="line">            node.children[c] = remove(node.children[c], key, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后序位置，递归路径上的节点可能需要被清理</span></span><br><span class="line">        <span class="keyword">if</span> (node.val != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果该 TireNode 存储着 val，不需要被清理</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查该 TrieNode 是否还有后缀</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; R; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.children[c] != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 只要存在一个子节点（后缀树枝），就不需要被清理</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 既没有存储 val，也没有后缀树枝，则该节点需要被清理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 查 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索 key 对应的值，不存在则返回 null</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">// 从 root 开始搜索 key</span></span><br><span class="line">        TrieNode&lt;V&gt; x = getNode(root, key);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span> || x.val == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// x 为空或 x 的 val 字段为空都说明 key 没有对应的值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 key 是否存在在 Map 中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> get(key) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是和否存在前缀为 prefix 的键</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="comment">// 只要能找到一个节点，就是存在前缀</span></span><br><span class="line">        <span class="keyword">return</span> getNode(root, prefix) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在所有键中寻找 query 的最短前缀</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">shortestPrefixOf</span><span class="params">(String query)</span> &#123;</span><br><span class="line">        TrieNode&lt;V&gt; p = root;</span><br><span class="line">        <span class="comment">// 从节点 node 开始搜索 key</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; query.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 无法向下搜索</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p.val != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 找到一个键是 query 的前缀</span></span><br><span class="line">                <span class="keyword">return</span> query.substring(<span class="number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向下搜索</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> query.charAt(i);</span><br><span class="line">            p = p.children[c];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; p.val != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 query 本身就是一个键</span></span><br><span class="line">            <span class="keyword">return</span> query;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在所有键中寻找 query 的最长前缀</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPrefixOf</span><span class="params">(String query)</span> &#123;</span><br><span class="line">        TrieNode&lt;V&gt; p = root;</span><br><span class="line">        <span class="comment">// 记录前缀的最大长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max_len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从节点 node 开始搜索 key</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; query.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 无法向下搜索</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p.val != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 找到一个键是 query 的前缀，更新前缀的最大长度</span></span><br><span class="line">                max_len = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向下搜索</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> query.charAt(i);</span><br><span class="line">            p = p.children[c];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; p.val != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 query 本身就是一个键</span></span><br><span class="line">            <span class="keyword">return</span> query;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> query.substring(<span class="number">0</span>, max_len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索前缀为 prefix 的所有键</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysWithPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 找到匹配 prefix 在 Trie 树中的那个节点</span></span><br><span class="line">        TrieNode&lt;V&gt; x = getNode(root, prefix);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// DFS 遍历以 x 为根的这棵 Trie 树</span></span><br><span class="line">        traverse(x, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(prefix), res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历以 node 节点为根的 Trie 树，找到所有键</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TrieNode&lt;V&gt; node, StringBuilder path, List&lt;String&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 到达 Trie 树底部叶子结点</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.val != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到一个 key，添加到结果列表中</span></span><br><span class="line">            res.add(path.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回溯算法遍历框架</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; R; c++) &#123;</span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            path.append(c);</span><br><span class="line">            traverse(node.children[c], path, res);</span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通配符 . 匹配任意字符</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysWithPattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        traverse(root, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(), pattern, <span class="number">0</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历函数，尝试在「以 node 为根的 Trie 树中」匹配 pattern[i..]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TrieNode&lt;V&gt; node, StringBuilder path, String pattern, <span class="type">int</span> i, List&lt;String&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 树枝不存在，即匹配失败</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == pattern.length()) &#123;</span><br><span class="line">            <span class="comment">// pattern 匹配完成</span></span><br><span class="line">            <span class="keyword">if</span> (node.val != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果这个节点存储着 val，则找到一个匹配的键</span></span><br><span class="line">                res.add(path.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> pattern.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// pattern[i] 是通配符，可以变化成任意字符</span></span><br><span class="line">            <span class="comment">// 多叉树（回溯算法）遍历框架</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; R; j++) &#123;</span><br><span class="line">                path.append(j);</span><br><span class="line">                traverse(node.children[j], path, pattern, i + <span class="number">1</span>, res);</span><br><span class="line">                path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// pattern[i] 是普通字符 c</span></span><br><span class="line">            path.append(c);</span><br><span class="line">            traverse(node.children[c], path, pattern, i + <span class="number">1</span>, res);</span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是和否存在前缀为 prefix 的键</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">        <span class="comment">// 从 root 节点开始匹配 pattern[0..]</span></span><br><span class="line">        <span class="keyword">return</span> hasKeyWithPattern(root, pattern, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数定义：从 node 节点开始匹配 pattern[i..]，返回是否成功匹配</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPattern</span><span class="params">(TrieNode&lt;V&gt; node, String pattern, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 树枝不存在，即匹配失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == pattern.length()) &#123;</span><br><span class="line">            <span class="comment">// 模式串走到头了，看看匹配到的是否是一个键</span></span><br><span class="line">            <span class="keyword">return</span> node.val != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> pattern.charAt(i);</span><br><span class="line">        <span class="comment">// 没有遇到通配符</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 从 node.children[c] 节点开始匹配 pattern[i+1..]</span></span><br><span class="line">            <span class="keyword">return</span> hasKeyWithPattern(node.children[c], pattern, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遇到通配符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; R; j++) &#123;</span><br><span class="line">            <span class="comment">// pattern[i] 可以变化成任意字符，尝试所有可能，只要遇到一个匹配成功就返回</span></span><br><span class="line">            <span class="keyword">if</span> (hasKeyWithPattern(node.children[j], pattern, i + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 都没有匹配</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从节点 node 开始搜索 key，如果存在返回对应节点，否则返回 null</span></span><br><span class="line">    <span class="keyword">private</span> TrieNode&lt;V&gt; <span class="title function_">getNode</span><span class="params">(TrieNode&lt;V&gt; node, String key)</span> &#123;</span><br><span class="line">        TrieNode&lt;V&gt; p = node;</span><br><span class="line">        <span class="comment">// 从节点 node 开始搜索 key</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; key.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 无法向下搜索</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向下搜索</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> key.charAt(i);</span><br><span class="line">            p = p.children[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们只要对 <code>TrieMap</code> 做简单的封装，即可实现 <code>TrieSet</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieSet</span> &#123;</span><br><span class="line">    <span class="comment">// 底层用一个 TrieMap，键就是 TrieSet，值仅仅起到占位的作用</span></span><br><span class="line">    <span class="comment">// 值的类型可以随便设置，我参考 Java 标准库设置成 Object</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TrieMap&lt;Object&gt; map = <span class="keyword">new</span> <span class="title class_">TrieMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 增 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在集合中添加元素 key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        map.put(key, <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 删 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从集合中删除元素 key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        map.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 查 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断元素 key 是否存在集合中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.containsKey(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在集合中寻找 query 的最短前缀</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">shortestPrefixOf</span><span class="params">(String query)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.shortestPrefixOf(query);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在集合中寻找 query 的最长前缀</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPrefixOf</span><span class="params">(String query)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.longestPrefixOf(query);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在集合中搜索前缀为 prefix 的所有元素</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysWithPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.keysWithPrefix(prefix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断集合中是否存在前缀为 prefix 的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.hasKeyWithPrefix(prefix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通配符 . 匹配任意字符，返回集合中匹配 pattern 的所有元素</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysWithPattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.keysWithPattern(pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通配符 . 匹配任意字符，判断集合中是否存在匹配 pattern 的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.hasKeyWithPattern(pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回集合中元素的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>有了 <code>TrieMap</code> 和 <code>TrieSet</code>，力扣上所有前缀树相关的题目都可以直接套用了</strong>，下面我举几个题目实践一下。</p><h3 id="秒杀题目"><a href="#秒杀题目" class="headerlink" title="#秒杀题目"></a><a href="https://labuladong.online/algo/data-structure/trie/#%E7%A7%92%E6%9D%80%E9%A2%98%E7%9B%AE">#</a>秒杀题目</h3><p><strong>首先需要说明，上文实现的算法模板的执行效率在具体的题目里面肯定是有优化空间的</strong>。</p><p>比如力扣前缀树相关题目的输入都被限制在小写英文字母 <code>a-z</code>，所以 <code>TrieNode</code> 其实不用维护一个大小为 256 的 <code>children</code> 数组，大小设置为 26 就够了，可以减小时间和空间上的复杂度。</p><p>不过本文只考虑模板的通用性，重在思路，所以就直接套用上文给出的算法模板解题，具体实现上的细节优化我集成在 <a href="https://labuladong.online/algo/intro/chrome/">刷题插件</a> 的「思路」按钮中。</p><p>先看下力扣第 208 题「<a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">实现前缀树open in new window</a>」：</p><details class="hint-container details" open="" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1rem 0px; padding: 1.5rem; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary style="position: relative; margin: -1.5rem -1.5rem 0.5em; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer;"><strong style="font-weight: 600;">208. 实现 Trie (前缀树)</strong>&nbsp;|<span>&nbsp;</span><a target="_blank" href="https://leetcode.cn/problems/implement-trie-prefix-tree/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|<span>&nbsp;</span><a target="_blank" href="https://leetcode.com/problems/implement-trie-prefix-tree/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;"><a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin" target="_blank" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">Trie</a></strong>（发音类似 "try"）或者说<span>&nbsp;</span><strong style="font-weight: 600;">前缀树</strong><span>&nbsp;</span>是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p><p style="line-height: 1.6; overflow-wrap: break-word;">请你实现 Trie 类：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">Trie()</code><span>&nbsp;</span>初始化前缀树对象。</li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">void insert(String word)</code><span>&nbsp;</span>向前缀树中插入字符串<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">word</code><span>&nbsp;</span>。</li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">boolean search(String word)</code><span>&nbsp;</span>如果字符串<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">word</code><span>&nbsp;</span>在前缀树中，返回<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">true</code>（即，在检索之前已经插入）；否则，返回<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">false</code><span>&nbsp;</span>。</li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">boolean startsWith(String prefix)</code><span>&nbsp;</span>如果之前已经插入的字符串<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">word</code><span>&nbsp;</span>的前缀之一为<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">prefix</code><span>&nbsp;</span>，返回<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">true</code><span>&nbsp;</span>；否则，返回<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">false</code><span>&nbsp;</span>。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入</strong>["Trie", "insert", "search", "search", "startsWith", "insert", "search"][[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]<strong style="font-weight: 600;">输出</strong>[null, null, true, false, true, null, true]<p><strong style="font-weight: 600;">解释</strong><br>Trie trie &#x3D; new Trie();<br>trie.insert(“apple”);<br>trie.search(“apple”);   &#x2F;&#x2F; 返回 True<br>trie.search(“app”);     &#x2F;&#x2F; 返回 False<br>trie.startsWith(“app”); &#x2F;&#x2F; 返回 True<br>trie.insert(“app”);<br>trie.search(“app”);     &#x2F;&#x2F; 返回 True<br></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 &lt;= word.length, prefix.length &lt;= 2000</code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">word</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">prefix</code><span>&nbsp;</span>仅由小写英文字母组成</li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">insert</code>、<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">search</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">startsWith</code><span>&nbsp;</span>调用次数<span>&nbsp;</span><strong style="font-weight: 600;">总计</strong><span>&nbsp;</span>不超过<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">3 * 10<sup>4</sup></code><span>&nbsp;</span>次</li></ul></div></details></p><p>题目让我们实现的几个函数其实就是 <code>TrieSet</code> 的部分 API，所以直接封装一个 <code>TrieSet</code> 就能解决这道题了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="comment">// 直接封装 TrieSet</span></span><br><span class="line">    <span class="type">TrieSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrieSet</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        set.add(word);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断元素是否在集合中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> set.contains(word);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断集合中是否有前缀为 prefix 的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> set.hasKeyWithPrefix(prefix);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieSet</span> &#123; <span class="comment">/* 见上文 */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieMap</span> &#123; <span class="comment">/* 见上文 */</span> &#125;</span><br></pre></td></tr></table></figure><p>接下来看下力扣第 648 题「<a href="https://leetcode.cn/problems/replace-words/">单词替换open in new window</a>」：</p><details class="hint-container details" open="" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1rem 0px; padding: 1.5rem; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary style="position: relative; margin: -1.5rem -1.5rem 0.5em; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer;"><strong style="font-weight: 600;">648. 单词替换</strong>&nbsp;|<span>&nbsp;</span><a target="_blank" href="https://leetcode.cn/problems/replace-words/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|<span>&nbsp;</span><a target="_blank" href="https://leetcode.com/problems/replace-words/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">在英语中，我们有一个叫做&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">词根</code>(root) 的概念，可以词根<strong style="font-weight: 600;">后面</strong>添加其他一些词组成另一个较长的单词——我们称这个词为&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">继承词</code>(successor)。例如，词根<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">an</code>，跟随着单词&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">other</code>(其他)，可以形成新的单词&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">another</code>(另一个)。</p><p style="line-height: 1.6; overflow-wrap: break-word;">现在，给定一个由许多<strong style="font-weight: 600;">词根</strong>组成的词典<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">dictionary</code><span>&nbsp;</span>和一个用空格分隔单词形成的句子<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">sentence</code>。你需要将句子中的所有<strong style="font-weight: 600;">继承词</strong>用<strong style="font-weight: 600;">词根</strong>替换掉。如果<strong style="font-weight: 600;">继承词</strong>有许多可以形成它的<strong style="font-weight: 600;">词根</strong>，则用<strong style="font-weight: 600;">最短</strong>的词根替换它。</p><p style="line-height: 1.6; overflow-wrap: break-word;">你需要输出替换之后的句子。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>dictionary = ["cat","bat","rat"], sentence = "the cattle was rattled by the battery"<strong style="font-weight: 600;">输出：</strong>"the cat was rat by the bat"</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>dictionary = ["a","b","c"], sentence = "aadsfasf absbs bbab cadsfafs"<strong style="font-weight: 600;">输出：</strong>"a a b c"</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 &lt;= dictionary.length&nbsp;&lt;= 1000</code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 &lt;= dictionary[i].length &lt;= 100</code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">dictionary[i]</code>&nbsp;仅由小写字母组成。</li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 &lt;= sentence.length &lt;= 10^6</code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">sentence</code>&nbsp;仅由小写字母和空格组成。</li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">sentence</code><span>&nbsp;</span>中单词的总量在范围<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">[1, 1000]</code><span>&nbsp;</span>内。</li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">sentence</code><span>&nbsp;</span>中每个单词的长度在范围<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">[1, 1000]</code><span>&nbsp;</span>内。</li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">sentence</code><span>&nbsp;</span>中单词之间由一个空格隔开。</li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">sentence</code>&nbsp;没有前导或尾随空格。</li></ul></div></details><p>现在你学过 Trie 树结构，应该可以看出来这题就在考察最短前缀问题。</p><p>所以可以把输入的词根列表 <code>dict</code> 存入 <code>TrieSet</code>，然后直接复用我们实现的 <code>shortestPrefixOf</code> 函数就行了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">replaceWords</span><span class="params">(List&lt;String&gt; dict, String sentence)</span> &#123;</span><br><span class="line">    <span class="comment">// 先将词根都存入 TrieSet</span></span><br><span class="line">    <span class="type">TrieSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrieSet</span>();</span><br><span class="line">    <span class="keyword">for</span> (String key : dict) &#123;</span><br><span class="line">        set.add(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    String[] words = sentence.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="comment">// 处理句子中的单词</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 在 Trie 树中搜索最短词根（最短前缀）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> set.shortestPrefixOf(words[i]);</span><br><span class="line">        <span class="keyword">if</span> (!prefix.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 如果搜索到了，改写为词根</span></span><br><span class="line">            sb.append(prefix);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，原样放回</span></span><br><span class="line">            sb.append(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i != words.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 添加单词之间的空格</span></span><br><span class="line">            sb.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieSet</span> &#123; <span class="comment">/* 见上文 */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieMap</span> &#123; <span class="comment">/* 见上文 */</span> &#125;</span><br></pre></td></tr></table></figure><p>继续看力扣第 211 题「<a href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/">添加与搜索单词 - 数据结构设计open in new window</a>」：</p><details class="hint-container details" open="" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1rem 0px; padding: 1.5rem; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary style="position: relative; margin: -1.5rem -1.5rem 0.5em; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer;"><strong style="font-weight: 600;">211. 添加与搜索单词 - 数据结构设计</strong>&nbsp;|<span>&nbsp;</span><a target="_blank" href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|<span>&nbsp;</span><a target="_blank" href="https://leetcode.com/problems/design-add-and-search-words-data-structure/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。</p><p style="line-height: 1.6; overflow-wrap: break-word;">实现词典类<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">WordDictionary</code><span>&nbsp;</span>：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">WordDictionary()</code><span>&nbsp;</span>初始化词典对象</li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">void addWord(word)</code><span>&nbsp;</span>将<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">word</code><span>&nbsp;</span>添加到数据结构中，之后可以对它进行匹配</li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">bool search(word)</code><span>&nbsp;</span>如果数据结构中存在字符串与&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">word</code><span>&nbsp;</span>匹配，则返回<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">true</code><span>&nbsp;</span>；否则，返回&nbsp;<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">false</code><span>&nbsp;</span>。<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">word</code><span>&nbsp;</span>中可能包含一些<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">'.'</code><span>&nbsp;</span>，每个&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">.</code><span>&nbsp;</span>都可以表示任何一个字母。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>["WordDictionary","addWord","addWord","addWord","search","search","search","search"][[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]<strong style="font-weight: 600;">输出：</strong>[null,null,null,null,false,true,true,true]<p><strong style="font-weight: 600;">解释：</strong><br>WordDictionary wordDictionary &#x3D; new WordDictionary();<br>wordDictionary.addWord(“bad”);<br>wordDictionary.addWord(“dad”);<br>wordDictionary.addWord(“mad”);<br>wordDictionary.search(“pad”); &#x2F;&#x2F; 返回 False<br>wordDictionary.search(“bad”); &#x2F;&#x2F; 返回 True<br>wordDictionary.search(“.ad”); &#x2F;&#x2F; 返回 True<br>wordDictionary.search(“b..”); &#x2F;&#x2F; 返回 True<br></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 &lt;= word.length &lt;= 25</code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">addWord</code><span>&nbsp;</span>中的<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">word</code><span>&nbsp;</span>由小写英文字母组成</li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">search</code><span>&nbsp;</span>中的<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">word</code><span>&nbsp;</span>由 ‘.’ 或小写英文字母组成</li><li>最多调用<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">10<sup>4</sup></code><span>&nbsp;</span>次<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">addWord</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">search</code></li></ul></div></details></p><p>这道题的考点就在于这个 <code>search</code> 函数进行通配符匹配，其实就是我们给 <code>TrieSet</code> 实现的 <code>hasKeyWithPattern</code> 方法，直接套就行了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span> &#123;</span><br><span class="line">    <span class="type">TrieSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrieSet</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在 TrieSet 中添加元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addWord</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        set.add(word);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通配符匹配元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> set.hasKeyWithPattern(word);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieSet</span> &#123; <span class="comment">/* 见上文 */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieMap</span> &#123; <span class="comment">/* 见上文 */</span> &#125;</span><br></pre></td></tr></table></figure><p>上面列举的这几道题用的都是 <code>TrieSet</code>，下面来看看 <code>TrieMap</code> 的题目。</p><p>先看力扣第 1804 题「<a href="https://leetcode.cn/problems/implement-trie-ii-prefix-tree/">实现前缀树 IIopen in new window</a>」：</p><details class="hint-container details" open="" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1rem 0px; padding: 1.5rem; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary style="position: relative; margin: -1.5rem -1.5rem 0.5em; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer;"><strong style="font-weight: 600;">1804. 实现 Trie （前缀树） II</strong>&nbsp;|<span>&nbsp;</span><a target="_blank" href="https://leetcode.cn/problems/implement-trie-ii-prefix-tree/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|<span>&nbsp;</span><a target="_blank" href="https://leetcode.com/problems/implement-trie-ii-prefix-tree/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">前缀树（<strong style="font-weight: 600;"><a href="https://en.wikipedia.org/wiki/Trie" target="_blank" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">trie</a></strong><span>&nbsp;</span>，发音为 "try"）是一个树状的数据结构，用于高效地存储和检索一系列字符串的前缀。前缀树有许多应用，如自动补全和拼写检查。</p><p style="line-height: 1.6; overflow-wrap: break-word;">实现前缀树 Trie 类：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">Trie()</code><span>&nbsp;</span>初始化前缀树对象。</li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">void insert(String word)</code><span>&nbsp;</span>将字符串<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">word</code><span>&nbsp;</span>插入前缀树中。</li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">int countWordsEqualTo(String word)</code><span>&nbsp;</span>返回前缀树中字符串<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">word</code><span>&nbsp;</span>的实例个数。</li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">int countWordsStartingWith(String prefix)</code><span>&nbsp;</span>返回前缀树中以<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">prefix</code><span>&nbsp;</span>为前缀的字符串个数。</li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">void erase(String word)</code><span>&nbsp;</span>从前缀树中移除字符串<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">word</code><span>&nbsp;</span>。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1:</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><b>输入</b>["Trie", "insert", "insert", "countWordsEqualTo", "countWordsStartingWith", "erase", "countWordsEqualTo", "countWordsStartingWith", "erase", "countWordsStartingWith"][[], ["apple"], ["apple"], ["apple"], ["app"], ["apple"], ["apple"], ["app"], ["apple"], ["app"]]<b>输出</b>[null, null, null, 2, 2, null, 1, 1, null, 0]<p><b>解释</b><br>Trie trie &#x3D; new Trie();<br>trie.insert(“apple”);               &#x2F;&#x2F; 插入 “apple”。<br>trie.insert(“apple”);               &#x2F;&#x2F; 插入另一个 “apple”。<br>trie.countWordsEqualTo(“apple”);    &#x2F;&#x2F; 有两个 “apple” 实例，所以返回 2。<br>trie.countWordsStartingWith(“app”); &#x2F;&#x2F; “app” 是 “apple” 的前缀，所以返回 2。<br>trie.erase(“apple”);                &#x2F;&#x2F; 移除一个 “apple”。<br>trie.countWordsEqualTo(“apple”);    &#x2F;&#x2F; 现在只有一个 “apple” 实例，所以返回 1。<br>trie.countWordsStartingWith(“app”); &#x2F;&#x2F; 返回 1<br>trie.erase(“apple”);                &#x2F;&#x2F; 移除 “apple”。现在前缀树是空的。<br>trie.countWordsStartingWith(“app”); &#x2F;&#x2F; 返回 0<br></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><b>提示：</b></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 &lt;= word.length, prefix.length &lt;= 2000</code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">word</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">prefix</code><span>&nbsp;</span>只包含小写英文字母。</li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">insert</code>、<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">countWordsEqualTo</code>、<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">countWordsStartingWith</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">erase</code><span>&nbsp;</span><strong style="font-weight: 600;">总共</strong>调用最多<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">3 * 10<sup>4</sup></code><span>&nbsp;</span>次。</li><li>保证每次调用<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">erase</code><span>&nbsp;</span>时，字符串<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">word</code><span>&nbsp;</span>总是存在于前缀树中。</li></ul></div></details></p><p>这题就可以用到 <code>TrieMap</code>，每个插入的 <code>word</code> 就是键，插入的次数就是对应的值，然后复用 <code>TrieMap</code> 的 API 就能实现题目要求的这些函数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="comment">// 封装我们实现的 TrieMap</span></span><br><span class="line">    TrieMap&lt;Integer&gt; map = <span class="keyword">new</span> <span class="title class_">TrieMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入 word 并记录插入次数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(word)) &#123;</span><br><span class="line">            map.put(word, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(word, map.get(word) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查询 word 插入的次数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWordsEqualTo</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(word)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(word);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 累加前缀为 prefix 的键的插入次数总和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWordsStartingWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keysWithPrefix(prefix)) &#123;</span><br><span class="line">            res += map.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// word 的插入次数减一</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">erase</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">freq</span> <span class="operator">=</span> map.get(word);</span><br><span class="line">        <span class="keyword">if</span> (freq - <span class="number">1</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            map.remove(word);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(word, freq - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieMap</span> &#123; <span class="comment">/* 见上文 */</span> &#125;</span><br></pre></td></tr></table></figure><p>反正都是直接套模板，也没什么意思，再看最后一道题目吧，这是力扣第 677 题「<a href="https://leetcode.cn/problems/map-sum-pairs/">键值映射open in new window</a>」：</p><details class="hint-container details" open="" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1rem 0px; padding: 1.5rem; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary style="position: relative; margin: -1.5rem -1.5rem 0.5em; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer;"><strong style="font-weight: 600;">677. 键值映射</strong>&nbsp;|<span>&nbsp;</span><a target="_blank" href="https://leetcode.cn/problems/map-sum-pairs/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|<span>&nbsp;</span><a target="_blank" href="https://leetcode.com/problems/map-sum-pairs/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">设计一个 map ，满足以下几点:</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>字符串表示键，整数表示值</li><li>返回具有前缀等于给定字符串的键的值的总和</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">实现一个<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">MapSum</code><span>&nbsp;</span>类：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">MapSum()</code><span>&nbsp;</span>初始化<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">MapSum</code><span>&nbsp;</span>对象</li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">void insert(String key, int val)</code><span>&nbsp;</span>插入<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">key-val</code><span>&nbsp;</span>键值对，字符串表示键<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">key</code><span>&nbsp;</span>，整数表示值<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">val</code><span>&nbsp;</span>。如果键<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">key</code><span>&nbsp;</span>已经存在，那么原来的键值对&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">key-value</code>&nbsp;将被替代成新的键值对。</li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">int sum(string prefix)</code><span>&nbsp;</span>返回所有以该前缀<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">prefix</code><span>&nbsp;</span>开头的键<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">key</code><span>&nbsp;</span>的值的总和。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>["MapSum", "insert", "sum", "insert", "sum"][[], ["apple", 3], ["ap"], ["app", 2], ["ap"]]<strong style="font-weight: 600;">输出：</strong>[null, null, 3, null, 5]<p><strong style="font-weight: 600;">解释：</strong><br>MapSum mapSum &#x3D; new MapSum();<br>mapSum.insert(“apple”, 3);<br>mapSum.sum(“ap”);           &#x2F;&#x2F; 返回 3 (<u>ap</u>ple &#x3D; 3)<br>mapSum.insert(“app”, 2);<br>mapSum.sum(“ap”);           &#x2F;&#x2F; 返回 5 (<u>ap</u>ple + <u>ap</u>p &#x3D; 3 + 2 &#x3D; 5)<br></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 &lt;= key.length, prefix.length &lt;= 50</code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">key</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">prefix</code><span>&nbsp;</span>仅由小写英文字母组成</li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 &lt;= val &lt;= 1000</code></li><li>最多调用<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">50</code><span>&nbsp;</span>次<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">insert</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">sum</code></li></ul></div></details></p><p>这道题还是标准的 <code>TrieMap</code> 的应用，直接看代码吧：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MapSum</span> &#123;</span><br><span class="line">    <span class="comment">// 封装我们实现的 TrieMap</span></span><br><span class="line">    TrieMap&lt;Integer&gt; map = <span class="keyword">new</span> <span class="title class_">TrieMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        map.put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 累加所有前缀为 prefix 的键的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        List&lt;String&gt; keys = map.keysWithPrefix(prefix);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            res += map.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieMap</span> &#123; <span class="comment">/* 见上文 */</span> &#125;</span><br></pre></td></tr></table></figure><p>Trie 树这种数据结构的实现原理和题目实践就讲完了，如果你能够看到这里，真得给你鼓掌。</p><p>可以看到，我最近写的图论算法以及本文讲的 Trie 树算法，都和「树」这种基本数据结构相关，所以我才会在刷题插件中集成 <a href="https://mp.weixin.qq.com/s/OE1zPVPj0V2o82N4HtLQbw">手把手刷 100 道二叉树题目open in new window</a> 的功能。</p><p>最后，纸上得来终觉浅，绝知此事要躬行，我建议最好亲手实现一遍上面的代码，去把题目刷一遍，才能对 Trie 树有更深入的理解。</p><p>之后我准备继续讲解一些基本数据结构在高级数据结构或实际算法题中的应用，大家期待就好。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一道数组去重的算法题把我整不会了</title>
      <link href="/posts/38502.html"/>
      <url>/posts/38502.html</url>
      
        <content type="html"><![CDATA[<h1 id="一道数组去重的算法题把我整不会了"><a href="#一道数组去重的算法题把我整不会了" class="headerlink" title="一道数组去重的算法题把我整不会了"></a>一道数组去重的算法题把我整不会了</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/">1081. Smallest Subsequence of Distinct Charactersopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/smallest-subsequence-of-distinct-characters/">1081. 不同字符的最小子序列open in new window</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/remove-duplicate-letters/">316. Remove Duplicate Lettersopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/remove-duplicate-letters/">316. 去除重复字母open in new window</a></td><td align="center">🟠</td></tr></tbody></table><p>关于去重算法，应该没什么难度，往哈希集合里面塞不就行了么？</p><p>最多给你加点限制，问你怎么给有序数组原地去重，这个我们前文 <a href="https://labuladong.online/algo/essential-technique/array-two-pointers-summary/">双指针技巧秒杀七道数组题目</a> 讲过。</p><p>本文讲的问题应该是去重相关算法中难度最大的了，把这个问题搞懂，就再也不用怕数组去重问题了。</p><p>这是力扣第 316 题「<a href="https://leetcode.cn/problems/remove-duplicate-letters/">去除重复字母open in new window</a>」，题目如下：</p><details class="hint-container details" open="" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1rem 0px; padding: 1.5rem; border-radius: 0.5rem; background: var(--detail-bg-color); color: rgb(44, 62, 80); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, STHeiti, &quot;Microsoft YaHei&quot;, SimSun, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1.5rem -1.5rem 0.5em; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer;"><strong style="font-weight: 600;">316. 去除重复字母</strong>&nbsp;|<span>&nbsp;</span><a target="_blank" href="https://leetcode.cn/problems/remove-duplicate-letters/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|<span>&nbsp;</span><a target="_blank" href="https://leetcode.com/problems/remove-duplicate-letters/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个字符串<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">s</code><span>&nbsp;</span>，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证<span>&nbsp;</span><strong style="font-weight: 600;">返回结果的字典序最小</strong>（要求不能打乱其他字符的相对位置）。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong><code style="margin: 0px; padding: 0px; border-radius: 0px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: unset; font-family: var(--font-family-mono); transition: color var(--color-transition); color: var(--code-color); text-align: left; white-space: pre; word-spacing: normal; word-break: normal; hyphens: none; -webkit-font-smoothing: auto;">s = "bcabc"</code><strong style="font-weight: 600;">输出<code style="margin: 0px; padding: 0px; border-radius: 0px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: unset; font-family: var(--font-family-mono); transition: color var(--color-transition); color: var(--code-color); text-align: left; white-space: pre; word-spacing: normal; word-break: normal; hyphens: none; -webkit-font-smoothing: auto;">：</code></strong><code style="margin: 0px; padding: 0px; border-radius: 0px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: unset; font-family: var(--font-family-mono); transition: color var(--color-transition); color: var(--code-color); text-align: left; white-space: pre; word-spacing: normal; word-break: normal; hyphens: none; -webkit-font-smoothing: auto;">"abc"</code></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong><code style="margin: 0px; padding: 0px; border-radius: 0px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: unset; font-family: var(--font-family-mono); transition: color var(--color-transition); color: var(--code-color); text-align: left; white-space: pre; word-spacing: normal; word-break: normal; hyphens: none; -webkit-font-smoothing: auto;">s = "cbacdcbc"</code><strong style="font-weight: 600;">输出：</strong><code style="margin: 0px; padding: 0px; border-radius: 0px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: unset; font-family: var(--font-family-mono); transition: color var(--color-transition); color: var(--code-color); text-align: left; white-space: pre; word-spacing: normal; word-break: normal; hyphens: none; -webkit-font-smoothing: auto;">"acdb"</code></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 &lt;= s.length &lt;= 10<sup>4</sup></code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">s</code><span>&nbsp;</span>由小写英文字母组成</li></ul><p style="line-height: 1.6; overflow-wrap: break-word; margin-bottom: 0px; padding-bottom: 0px;"><strong style="font-weight: 600;">注意：</strong>该题与 1081<span>&nbsp;</span><a href="https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters</a><span>&nbsp;</span>相同</p></div></details><p>这道题和第 1081 题「不同字符的最小子序列」的解法是完全相同的，你可以把这道题的解法代码直接粘过去把 1081 题也干掉。</p><p>题目的要求总结出来有三点：</p><p>要求一、<strong>要去重</strong>。</p><p>要求二、去重字符串中的字符顺序<strong>不能打乱 <code>s</code> 中字符出现的相对顺序</strong>。</p><p>要求三、在所有符合上一条要求的去重字符串中，<strong>字典序最小</strong>的作为最终结果。</p><p>上述三条要求中，要求三可能有点难理解，举个例子。</p><p>比如说输入字符串 <code>s = &quot;babc&quot;</code>，去重且符合相对位置的字符串有两个，分别是 <code>&quot;bac&quot;</code> 和 <code>&quot;abc&quot;</code>，但是我们的算法得返回 <code>&quot;abc&quot;</code>，因为它的字典序更小。</p><p>按理说，如果我们想要有序的结果，那就得对原字符串排序对吧，但是排序后就不能保证符合 <code>s</code> 中字符出现顺序了，这似乎是矛盾的。</p><p>其实这里会借鉴后文 <a href="https://labuladong.online/algo/data-structure/monotonic-stack/">单调栈解题框架</a> 中讲到的「单调栈」的思路，没看过也无妨，等会你就明白了。</p><p>🌟</p><hr><p>🌟</p><p><strong>我们先暂时忽略要求三，用「栈」来实现一下要求一和要求二</strong>，至于为什么用栈来实现，后面你就知道了：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">removeDuplicateLetters</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">// 存放去重的结果</span></span><br><span class="line">    Stack&lt;Character&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 布尔数组初始值为 false，记录栈中是否存在某个字符</span></span><br><span class="line">    <span class="comment">// 输入字符均为 ASCII 字符，所以大小 256 够用了</span></span><br><span class="line">    <span class="type">boolean</span>[] inStack = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        <span class="comment">// 如果字符 c 存在栈中，直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (inStack[c]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 若不存在，则插入栈顶并标记为存在</span></span><br><span class="line">        stk.push(c);</span><br><span class="line">        inStack[c] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span> (!stk.empty()) &#123;</span><br><span class="line">        sb.append(stk.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 栈中元素插入顺序是反的，需要 reverse 一下</span></span><br><span class="line">    <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的逻辑很简单吧，就是用布尔数组 <code>inStack</code> 记录栈中元素，达到去重的目的，<strong>此时栈中的元素都是没有重复的</strong>。</p><p>如果输入 <code>s = &quot;bcabc&quot;</code>，这个算法会返回 <code>&quot;bca&quot;</code>，已经符合要求一和要求二了，但是题目希望要的答案是 <code>&quot;abc&quot;</code> 对吧。</p><p>那我们想一想，如果想满足要求三，保证字典序，需要做些什么修改？</p><p>在向栈 <code>stk</code> 中插入字符 <code>&#39;a&#39;</code> 的这一刻，我们的算法需要知道，字符 <code>&#39;a&#39;</code> 的字典序和之前的两个字符 <code>&#39;b&#39;</code> 和 <code>&#39;c&#39;</code> 相比，谁大谁小？</p><p><strong>如果当前字符 <code>&#39;a&#39;</code> 比之前的字符字典序小，就有可能需要把前面的字符 pop 出栈，让 <code>&#39;a&#39;</code> 排在前面，对吧</strong>？</p><p>那么，我们先改一版代码：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">removeDuplicateLetters</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    Stack&lt;Character&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span>[] inStack = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inStack[c]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入之前，和之前的元素比较一下大小</span></span><br><span class="line">        <span class="comment">// 如果字典序比前面的小，pop 前面的元素</span></span><br><span class="line">        <span class="keyword">while</span> (!stk.isEmpty() &amp;&amp; stk.peek() &gt; c) &#123;</span><br><span class="line">            <span class="comment">// 弹出栈顶元素，并把该元素标记为不在栈中</span></span><br><span class="line">            inStack[stk.pop()] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stk.push(c);</span><br><span class="line">        inStack[c] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span> (!stk.empty()) &#123;</span><br><span class="line">        sb.append(stk.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码也好理解，就是插入了一个 while 循环，连续 pop 出比当前字符小的栈顶字符，直到栈顶元素比当前元素的字典序还小为止。只是不是有点「单调栈」的意思了？</p><p>这样，对于输入 <code>s = &quot;bcabc&quot;</code>，我们可以得出正确结果 <code>&quot;abc&quot;</code> 了。</p><p>但是，如果我改一下输入，假设 <code>s = &quot;bcac&quot;</code>，按照刚才的算法逻辑，返回的结果是 <code>&quot;ac&quot;</code>，而正确答案应该是 <code>&quot;bac&quot;</code>，分析一下这是怎么回事？</p><p>很容易发现，因为 <code>s</code> 中只有唯一一个 <code>&#39;b&#39;</code>，即便字符 <code>&#39;a&#39;</code> 的字典序比字符 <code>&#39;b&#39;</code> 要小，字符 <code>&#39;b&#39;</code> 也不应该被 pop 出去。</p><p>那问题出在哪里？</p><p><strong>我们的算法在 <code>stk.peek() &gt; c</code> 时才会 pop 元素，其实这时候应该分两种情况</strong>：</p><p>情况一、如果 <code>stk.peek()</code> 这个字符之后还会出现，那么可以把它 pop 出去，反正后面还有嘛，后面再 push 到栈里，刚好符合字典序的要求。</p><p>情况二、如果 <code>stk.peek()</code> 这个字符之后不会出现了，前面也说了栈中不会存在重复的元素，那么就不能把它 pop 出去，否则你就永远失去了这个字符。</p><p>回到 <code>s = &quot;bcac&quot;</code> 的例子，插入字符 <code>&#39;a&#39;</code> 的时候，发现前面的字符 <code>&#39;c&#39;</code> 的字典序比 <code>&#39;a&#39;</code> 大，且在 <code>&#39;a&#39;</code> 之后还存在字符 <code>&#39;c&#39;</code>，那么栈顶的这个 <code>&#39;c&#39;</code> 就会被 pop 掉。</p><p>while 循环继续判断，发现前面的字符 <code>&#39;b&#39;</code> 的字典序还是比 <code>&#39;a&#39;</code> 大，但是在 <code>&#39;a&#39;</code> 之后再没有字符 <code>&#39;b&#39;</code> 了，所以不应该把 <code>&#39;b&#39;</code> pop 出去。</p><p><strong>那么关键就在于，如何让算法知道字符 <code>&#39;a&#39;</code> 之后有几个 <code>&#39;b&#39;</code> 有几个 <code>&#39;c&#39;</code> 呢</strong>？</p><p>也不难，只要再改一版代码：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">removeDuplicateLetters</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    Stack&lt;Character&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护一个计数器记录字符串中字符的数量</span></span><br><span class="line">    <span class="comment">// 因为输入为 ASCII 字符，大小 256 够用了</span></span><br><span class="line">    <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        count[s.charAt(i)]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span>[] inStack = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        <span class="comment">// 每遍历过一个字符，都将对应的计数减一</span></span><br><span class="line">        count[c]--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inStack[c]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stk.isEmpty() &amp;&amp; stk.peek() &gt; c) &#123;</span><br><span class="line">            <span class="comment">// 若之后不存在栈顶元素了，则停止 pop</span></span><br><span class="line">            <span class="keyword">if</span> (count[stk.peek()] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若之后还有，则可以 pop</span></span><br><span class="line">            inStack[stk.pop()] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stk.push(c);</span><br><span class="line">        inStack[c] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span> (!stk.empty()) &#123;</span><br><span class="line">        sb.append(stk.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details data-v-fb30874b="" id="div_remove-duplicate-letters" class="hint-container details" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1.6em 0px; padding: 1rem 0px 0px; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary data-v-fb30874b="" style="position: relative; margin: -1.5rem 0px -0.5rem; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer; display: flex; align-items: center; font-size: large;"><strong data-v-fb30874b="" style="font-weight: 600;">🍭 代码可视化动画 🍭</strong><span data-v-fb30874b="" class="font-icon icon iconfont icon-resize" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-left: auto; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-refresh" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-link" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle;"></span></summary><div data-v-fb30874b="" class="resizable" style="width: 774.091px; max-width: 100%; height: 70vh; max-height: 70vh; overflow: auto; resize: both;"><iframe data-v-fb30874b="" id="iframe_remove-duplicate-letters" src="https://labuladong.online/algo-visualize/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>我们用了一个计数器 <code>count</code>，当字典序较小的字符试图「挤掉」栈顶元素的时候，在 <code>count</code> 中检查栈顶元素是否是唯一的，只有当后面还存在栈顶元素的时候才能挤掉，否则不能挤掉。</p><p>至此，这个算法就结束了，时间空间复杂度都是 O(N)。</p><p><strong>你还记得我们开头提到的三个要求吗？我们是怎么达成这三个要求的</strong>？</p><p>要求一、通过 <code>inStack</code> 这个布尔数组做到栈 <code>stk</code> 中不存在重复元素。</p><p>要求二、我们顺序遍历字符串 <code>s</code>，通过「栈」这种顺序结构的 push&#x2F;pop 操作记录结果字符串，保证了字符出现的顺序和 <code>s</code> 中出现的顺序一致。</p><p>这里也可以想到为什么要用「栈」这种数据结构，因为先进后出的结构允许我们立即操作刚插入的字符，如果用「队列」的话肯定是做不到的。</p><p>要求三、我们用类似单调栈的思路，配合计数器 <code>count</code> 不断 pop 掉不符合最小字典序的字符，保证了最终得到的结果字典序最小。</p><p>当然，由于栈的结构特点，我们最后需要把栈中元素取出后再反转一次才是最终结果。</p><p>说实话，这应该是数组去重的最高境界了，没做过还真不容易想出来。你学会了吗？学会了点个「在看」？</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉堆详解实现优先级队列</title>
      <link href="/posts/37248.html"/>
      <url>/posts/37248.html</url>
      
        <content type="html"><![CDATA[<h1 id="二叉堆详解实现优先级队列"><a href="#二叉堆详解实现优先级队列" class="headerlink" title="二叉堆详解实现优先级队列"></a>二叉堆详解实现优先级队列</h1><p>二叉堆（Binary Heap）没什么神秘，性质比二叉搜索树 BST 还简单。</p><p>其主要操作就两个，<code>sink</code>（下沉）和 <code>swim</code>（上浮），用以维护二叉堆的性质。其主要应用有两个，首先是一种排序方法「堆排序」，第二是一种很有用的数据结构「优先级队列」。</p><p>那么本文以实现优先级队列（Priority Queue）为例，来讲讲一下二叉堆怎么运作的。</p><h3 id="一、二叉堆概览"><a href="#一、二叉堆概览" class="headerlink" title="#一、二叉堆概览"></a><a href="https://labuladong.online/algo/data-structure/binary-heap-priority-queue/#%E4%B8%80%E3%80%81%E4%BA%8C%E5%8F%89%E5%A0%86%E6%A6%82%E8%A7%88">#</a>一、二叉堆概览</h3><p>首先，二叉堆和二叉树有啥关系呢，为什么人们总是把二叉堆画成一棵二叉树？</p><p>因为，二叉堆在逻辑上其实是一种特殊的二叉树（完全二叉树），只不过存储在数组里。一般的链表二叉树，我们操作节点的指针，而在数组里，我们把数组索引作为指针：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父节点的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parent</span><span class="params">(<span class="type">int</span> root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> root / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左孩子的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">left</span><span class="params">(<span class="type">int</span> root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> root * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右孩子的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span> root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> root * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>画个图你立即就能理解了，比如 <code>arr</code> 是一个字符数组，注意数组的第一个索引 0 空着不用：</p><p><img src="https://labuladong.online/algo/images/heap/1.png" alt="img"></p><p>你看到了，因为这棵二叉树是「完全二叉树」，所以把 <code>arr[1]</code> 作为整棵树的根的话，每个节点的父节点和左右孩子的索引都可以通过简单的运算得到，这就是二叉堆设计的一个巧妙之处。</p><p>为了方便讲解，下面都会画的图都是二叉树结构，相信你能把树和数组对应起来。</p><p>二叉堆还分为最大堆和最小堆。<strong>最大堆的性质是：每个节点都大于等于它的两个子节点</strong>。类似的，最小堆的性质是：每个节点都小于等于它的子节点。</p><p>两种堆核心思路都是一样的，本文以最大堆为例讲解。</p><p>对于一个最大堆，根据其性质，显然堆顶，也就是 <code>arr[1]</code> 一定是所有元素中最大的元素。</p><h3 id="二、优先级队列概览"><a href="#二、优先级队列概览" class="headerlink" title="#二、优先级队列概览"></a><a href="https://labuladong.online/algo/data-structure/binary-heap-priority-queue/#%E4%BA%8C%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E6%A6%82%E8%A7%88">#</a>二、优先级队列概览</h3><p>优先级队列这种数据结构有一个很有用的功能，你插入或者删除元素的时候，元素会自动排序，这底层的原理就是二叉堆的操作。</p><p>数据结构的功能无非增删查改，优先级队列有两个主要 API，分别是 <code>insert</code> 插入一个元素和 <code>delMax</code> 删除最大元素（如果底层用最小堆，那么就是 <code>delMin</code>，删除最小元素）。</p><p>注</p><p>刚才说到二叉堆本质上是一棵二叉树，而优先级队列这种数据结构底层是二叉堆，那么为啥它的名字又和「队列」扯上了关系呢？</p><p>因为优先级队列的操作和队列比较像。普通队列有个从队尾插入元素，从队头移出元素，出队顺序就是入队的时间顺序；你也可以认为优先级队列是一种特殊的队列，从队尾插入元素，从队头移出元素，只不过出队顺序是按照元素的大小顺序。</p><p>这么一看，是不是觉得这种数据结构有队列内味儿了？</p><p>下面我们实现一个简化的优先级队列，先看下代码框架：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxPQ</span></span><br><span class="line">    &lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// 存储元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> Key[] pq;</span><br><span class="line">    <span class="comment">// 当前 Priority Queue 中的元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxPQ</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">        <span class="comment">// 索引 0 不用，所以多分配一个空间</span></span><br><span class="line">        pq = (Key[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[cap + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回当前队列中最大元素 */</span></span><br><span class="line">    <span class="keyword">public</span> Key <span class="title function_">max</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pq[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 插入元素 e */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Key e)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除并返回当前队列中最大元素 */</span></span><br><span class="line">    <span class="keyword">public</span> Key <span class="title function_">delMax</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 上浮第 x 个元素，以维护最大堆性质 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> x)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 下沉第 x 个元素，以维护最大堆性质 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> x)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 交换数组的两个元素 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">Key</span> <span class="variable">temp</span> <span class="operator">=</span> pq[i];</span><br><span class="line">        pq[i] = pq[j];</span><br><span class="line">        pq[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pq[i] 是否比 pq[j] 小？ */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 还有 left, right, parent 三个方法 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提示</p><p>这里用到 Java 的泛型，<code>Key</code> 可以是任何一种可比较大小的数据类型（实现了 <code>compareTo</code> 方法），比如 Integer 等类型。</p><p>当然，你自己练习时可以适度变通，比如说在构造函数中传入一个比较函数，这样就可以实现自定义排序逻辑了。</p><p>我这里为了简化，就实现一个最大堆 <code>MaxPQ</code>，即每次删除都是队列中最大的元素。</p><p>空出来的四个方法是二叉堆和优先级队列的奥妙所在，下面用图文来逐个理解。</p><h3 id="三、实现-swim-和-sink"><a href="#三、实现-swim-和-sink" class="headerlink" title="#三、实现 swim 和 sink"></a><a href="https://labuladong.online/algo/data-structure/binary-heap-priority-queue/#%E4%B8%89%E3%80%81%E5%AE%9E%E7%8E%B0-swim-%E5%92%8C-sink">#</a>三、实现 swim 和 sink</h3><p>为什么要有上浮 <code>swim</code> 和下沉 <code>sink</code> 的操作呢？为了维护二叉堆结构。</p><p>我们要讲的是最大堆，每个节点都比它的两个子节点大，但是在插入元素和删除元素时，难免破坏堆的性质，这就需要通过这两个操作来恢复堆的性质了。</p><p>对于最大堆，会破坏堆性质的有两种情况：</p><p>1、如果某个节点 A 比它的子节点（中的一个）小，那么 A 就不配做父节点，应该下去，下面那个更大的节点上来做父节点，这就是对 A 进行<strong>下沉</strong>。</p><p>2、如果某个节点 A 比它的父节点大，那么 A 不应该做子节点，应该把父节点换下来，自己去做父节点，这就是对 A 的<strong>上浮</strong>。</p><p>当然，错位的节点 A 可能要上浮（或下沉）很多次，才能到达正确的位置，恢复堆的性质。所以代码中肯定有一个 <code>while</code> 循环。</p><p>细心的读者也许会问，这两个操作不是互逆吗，所以上浮的操作一定能用下沉来完成，为什么我还要费劲写两个方法？</p><p>是的，操作是互逆等价的，但是最终我们的操作只会在堆底和堆顶进行（等会讲原因），显然堆底的「错位」元素需要上浮，堆顶的「错位」元素需要下沉。</p><p><strong>上浮的代码实现：</strong></p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxPQ</span> &lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// 为了节约篇幅，省略上文给出的代码部分...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果浮到堆顶，就不能再上浮了</span></span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">1</span> &amp;&amp; less(parent(x), x)) &#123;</span><br><span class="line">            <span class="comment">// 如果第 x 个元素比上层大</span></span><br><span class="line">            <span class="comment">// 将 x 换上去</span></span><br><span class="line">            swap(parent(x), x);</span><br><span class="line">            x = parent(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>画个 GIF 看一眼就明白了：</p><p><img src="https://labuladong.online/algo/images/heap/swim.gif" alt="img"></p><p><strong>下沉的代码实现：</strong></p><p>下沉比上浮略微复杂一点，因为上浮某个节点 A，只需要 A 和其父节点比较大小即可；但是下沉某个节点 A，需要 A 和其<strong>两个子节点</strong>比较大小，如果 A 不是最大的就需要调整位置，要把较大的那个子节点和 A 交换。</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxPQ</span> &lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// 为了节约篇幅，省略上文给出的代码部分...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果沉到堆底，就沉不下去了</span></span><br><span class="line">        <span class="keyword">while</span> (left(x) &lt;= size) &#123;</span><br><span class="line">            <span class="comment">// 先假设左边节点较大</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> left(x);</span><br><span class="line">            <span class="comment">// 如果右边节点存在，比一下大小</span></span><br><span class="line">            <span class="keyword">if</span> (right(x) &lt;= size &amp;&amp; less(max, right(x)))</span><br><span class="line">                max = right(x);</span><br><span class="line">            <span class="comment">// 结点 x 比俩孩子都大，就不必下沉了</span></span><br><span class="line">            <span class="keyword">if</span> (less(max, x)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 否则，不符合最大堆的结构，下沉 x 结点</span></span><br><span class="line">            swap(x, max);</span><br><span class="line">            x = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>画个 GIF 看下就明白了：</p><p><img src="https://labuladong.online/algo/images/heap/sink.gif" alt="img"></p><p>至此，二叉堆的主要操作就讲完了，一点都不难吧，代码加起来也就十行。明白了 <code>sink</code> 和 <code>swim</code> 的行为，下面就可以实现优先级队列了。</p><h3 id="四、实现-delMax-和-insert"><a href="#四、实现-delMax-和-insert" class="headerlink" title="#四、实现 delMax 和 insert"></a><a href="https://labuladong.online/algo/data-structure/binary-heap-priority-queue/#%E5%9B%9B%E3%80%81%E5%AE%9E%E7%8E%B0-delmax-%E5%92%8C-insert">#</a>四、实现 delMax 和 insert</h3><p>这两个方法就是建立在 <code>swim</code> 和 <code>sink</code> 上的。</p><p><strong><code>insert</code> 方法先把要插入的元素添加到堆底的最后，然后让其上浮到正确位置</strong>。</p><p><img src="https://labuladong.online/algo/images/heap/insert.gif" alt="img"></p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxPQ</span> &lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// 为了节约篇幅，省略上文给出的代码部分...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Key e)</span> &#123;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="comment">// 先把新元素加到最后</span></span><br><span class="line">        pq[size] = e;</span><br><span class="line">        <span class="comment">// 然后让它上浮到正确的位置</span></span><br><span class="line">        swim(size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>delMax</code> 方法先把堆顶元素 <code>A</code> 和堆底最后的元素 <code>B</code> 对调，然后删除 <code>A</code>，最后让 <code>B</code> 下沉到正确位置</strong>。</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxPQ</span> &lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// 为了节约篇幅，省略上文给出的代码部分...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Key <span class="title function_">delMax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 最大堆的堆顶就是最大元素</span></span><br><span class="line">        <span class="type">Key</span> <span class="variable">max</span> <span class="operator">=</span> pq[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 把这个最大元素换到最后，删除之</span></span><br><span class="line">        swap(<span class="number">1</span>, size);</span><br><span class="line">        pq[size] = <span class="literal">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="comment">// 让 pq[1] 下沉到正确位置</span></span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://labuladong.online/algo/images/heap/delete.gif" alt="img"></p><p>至此，一个优先级队列就实现了，插入和删除元素的时间复杂度为 <code>O(logK)</code>，<code>K</code> 为当前二叉堆（优先级队列）中的元素总数。因为我们时间复杂度主要花费在 <code>sink</code> 或者 <code>swim</code> 上，而不管上浮还是下沉，最多也就树（堆）的高度，也就是 log 级别。</p><h3 id="五、最后总结"><a href="#五、最后总结" class="headerlink" title="#五、最后总结"></a><a href="https://labuladong.online/algo/data-structure/binary-heap-priority-queue/#%E4%BA%94%E3%80%81%E6%9C%80%E5%90%8E%E6%80%BB%E7%BB%93">#</a>五、最后总结</h3><p>二叉堆就是一种完全二叉树，所以适合存储在数组中，而且二叉堆拥有一些特殊性质。</p><p>二叉堆的操作很简单，主要就是上浮和下沉，来维护堆的性质（堆有序），核心代码也就十行。</p><p>优先级队列是基于二叉堆实现的，主要操作是插入和删除。插入是先插到最后，然后上浮到正确位置；删除是调换位置后再删除，然后下沉到正确位置。核心代码也就十行。</p><p>也许这就是数据结构的威力，简单的操作就能实现巧妙的功能，真心佩服发明二叉堆算法的人！</p><p>最后，更多二叉堆&#x2F;优先级队列相关的题目练习见 <a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e">二叉堆（优先级队列）的经典习题open in new window</a>。</p><h1 id="经典练习题"><a href="#经典练习题" class="headerlink" title="经典练习题"></a>经典练习题</h1><p>二叉堆的主要应用是优先级队列，而优先级队列的特色是<strong>动态排序</strong>，插入的元素可以自动维护正确的顺序。当然，后文讲的 <a href="https://labuladong.online/algo/ds-class/dong-shou--60928/treemap-yu-a003e/">二叉搜索树open in new window</a> 也可以做到动态排序，优先级队列的限制是只能从队头和队尾操作元素。</p><p>一般来说，用到优先级队列的题目主要分两类，一类是合并多个有序链表这类题，另一类是寻找第 <code>k</code> 个最大元素这类题，我们分别来看。</p><hr><p>先来看第一类，合并有序链表这样的题目：</p><hr><h2 id="23-合并-K-个升序链表open-in-new-window"><a href="#23-合并-K-个升序链表open-in-new-window" class="headerlink" title="#23. 合并 K 个升序链表open in new window"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#_23-%E5%90%88%E5%B9%B6-k-%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8">#</a><a href="https://leetcode.cn/problems/merge-k-sorted-lists">23. 合并 K 个升序链表open in new window</a></h2><ul><li><strong>标签：二叉堆，数据结构，链表，链表双指针</strong></li></ul><p>给你一个链表数组，每个链表都已经按升序排列，请你将这些链表合并成一个升序链表，返回合并后的链表。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：lists = [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="#基本思路"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF">#</a>基本思路</h3><blockquote><p>本文有视频版：<a href="https://www.bilibili.com/video/BV1q94y1X7vy">链表双指针技巧全面汇总open in new window</a></p></blockquote><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists">21. 合并两个有序链表open in new window</a> 的延伸，利用 <a href="https://labuladong.gitee.io/article/fname.html?fname=%E4%BA%8C%E5%8F%89%E5%A0%86%E8%AF%A6%E8%A7%A3%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97">优先级队列（二叉堆）open in new window</a> 进行节点排序即可。</p><ul><li><strong>详细题解：<a href="https://labuladong.gitee.io/article/fname.html?fname=%E9%93%BE%E8%A1%A8%E6%8A%80%E5%B7%A7">双指针技巧秒杀七道链表题目open in new window</a></strong></li></ul><h3 id="解法代码"><a href="#解法代码" class="headerlink" title="#解法代码"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81">#</a>解法代码</h3><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 虚拟头结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">// 优先级队列，最小堆</span></span><br><span class="line">        PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">            lists.length, (a, b)-&gt;(a.val - b.val));</span><br><span class="line">        <span class="comment">// 将 k 个链表的头结点加入最小堆</span></span><br><span class="line">        <span class="keyword">for</span> (ListNode head : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head != <span class="literal">null</span>)</span><br><span class="line">                pq.add(head);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 获取最小节点，接到结果链表中</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            p.next = node;</span><br><span class="line">            <span class="keyword">if</span> (node.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                pq.add(node.next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// p 指针不断前进</span></span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>类似题目</p><p>：</p><ul><li><a href="https://leetcode.cn/problems/linked-list-cycle">141. 环形链表 🟢open in new window</a></li><li><a href="https://leetcode.cn/problems/linked-list-cycle-ii">142. 环形链表 II 🟠open in new window</a></li><li><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists">160. 相交链表 🟢open in new window</a></li><li><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list">19. 删除链表的倒数第 N 个结点 🟠open in new window</a></li><li><a href="https://leetcode.cn/problems/merge-two-sorted-lists">21. 合并两个有序链表 🟢open in new window</a></li><li><a href="https://leetcode.cn/problems/super-ugly-number">313. 超级丑数 🟠open in new window</a></li><li><a href="https://leetcode.cn/problems/design-twitter">355. 设计推特 🟠open in new window</a></li><li><a href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums">373. 查找和最小的 K 对数字 🟠open in new window</a></li><li><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix">378. 有序矩阵中第 K 小的元素 🟠open in new window</a></li><li><a href="https://leetcode.cn/problems/partition-list">86. 分隔链表 🟠open in new window</a></li><li><a href="https://leetcode.cn/problems/middle-of-the-linked-list">876. 链表的中间结点 🟢open in new window</a></li><li><a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof">剑指 Offer 22. 链表中倒数第k个节点 🟢open in new window</a></li><li><a href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof">剑指 Offer 25. 合并两个排序的链表 🟢open in new window</a></li><li><a href="https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof">剑指 Offer 52. 两个链表的第一个公共节点 🟢open in new window</a></li><li><a href="https://leetcode.cn/problems/SLwz0R">剑指 Offer II 021. 删除链表的倒数第 n 个结点 🟠open in new window</a></li><li><a href="https://leetcode.cn/problems/c32eOV">剑指 Offer II 022. 链表中环的入口节点 🟠open in new window</a></li><li><a href="https://leetcode.cn/problems/3u1WK4">剑指 Offer II 023. 两个链表的第一个重合节点 🟢open in new window</a></li><li><a href="https://leetcode.cn/problems/qn8gGX">剑指 Offer II 061. 和最小的 k 个数对 🟠open in new window</a></li><li><a href="https://leetcode.cn/problems/vvXgSW">剑指 Offer II 078. 合并排序链表 🔴open in new window</a></li></ul></li></ul><h2 id="373-查找和最小的-K-对数字open-in-new-window"><a href="#373-查找和最小的-K-对数字open-in-new-window" class="headerlink" title="#373. 查找和最小的 K 对数字open in new window"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#_373-%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84-k-%E5%AF%B9%E6%95%B0%E5%AD%97">#</a><a href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums">373. 查找和最小的 K 对数字open in new window</a></h2><ul><li><strong>标签：二叉堆，链表双指针</strong></li></ul><p>给定两个以 <strong>升序排列</strong> 的整数数组 <code>nums1</code> 和 <code>nums2</code>, 以及一个整数 <code>k</code>。</p><p>定义一对值 <code>(u,v)</code>，其中第一个元素来自 <code>nums1</code>，第二个元素来自 <code>nums2</code>。</p><p>请找到<strong>和</strong>最小的 <code>k</code> 个数对 <code>(u1,v1)</code>, <code>(u2,v2)</code> … <code>(uk,vk)</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,7,11], nums2 = [2,4,6], k = 3</span><br><span class="line">输出：[1,2],[1,4],[1,6]</span><br><span class="line">解释：返回序列中的前 3 对数：</span><br><span class="line">     [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]</span><br></pre></td></tr></table></figure><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="#基本思路"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1">#</a>基本思路</h3><p>这道题其实是前文 <a href="https://labuladong.gitee.io/article/fname.html?fname=%E9%93%BE%E8%A1%A8%E6%8A%80%E5%B7%A7">单链表的六大解题套路open in new window</a> 中讲过的 <a href="https://leetcode.cn/problems/merge-k-sorted-lists">23. 合并K个升序链表open in new window</a> 的变体。</p><p>怎么把这道题变成合并多个有序链表呢？就比如说题目输入的用例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>,<span class="number">7</span>,<span class="number">11</span>], nums2 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>组合出的所有数对儿这就可以抽象成三个有序链表：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>] -&gt; [<span class="number">1</span>, <span class="number">4</span>] -&gt; [<span class="number">1</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">7</span>, <span class="number">2</span>] -&gt; [<span class="number">7</span>, <span class="number">4</span>] -&gt; [<span class="number">7</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">11</span>, <span class="number">2</span>] -&gt; [<span class="number">11</span>, <span class="number">4</span>] -&gt; [<span class="number">11</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>这三个链表中每个元素（数对之和）是递增的，所以就可以按照 <a href="https://leetcode.cn/problems/merge-k-sorted-lists">23. 合并K个升序链表open in new window</a> 的思路来合并，取出前 <code>k</code> 个作为答案即可。</p><h3 id="解法代码-1"><a href="#解法代码-1" class="headerlink" title="#解法代码"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-1">#</a>解法代码</h3><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">kSmallestPairs</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 存储三元组 (num1[i], nums2[i], i)</span></span><br><span class="line">        <span class="comment">// i 记录 nums2 元素的索引位置，用于生成下一个节点</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 按照数对的元素和升序排序</span></span><br><span class="line">            <span class="keyword">return</span> (a[<span class="number">0</span>] + a[<span class="number">1</span>]) - (b[<span class="number">0</span>] + b[<span class="number">1</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 按照 23 题的逻辑初始化优先级队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nums1[i], nums2[<span class="number">0</span>], <span class="number">0</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 执行合并多个有序链表的逻辑</span></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span>[] cur = pq.poll();</span><br><span class="line">            k--;</span><br><span class="line">            <span class="comment">// 链表中的下一个节点加入优先级队列</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">next_index</span> <span class="operator">=</span> cur[<span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (next_index &lt; nums2.length) &#123;</span><br><span class="line">                pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;cur[<span class="number">0</span>], nums2[next_index], next_index&#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List&lt;Integer&gt; pair = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            pair.add(cur[<span class="number">0</span>]);</span><br><span class="line">            pair.add(cur[<span class="number">1</span>]);</span><br><span class="line">            res.add(pair);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>类似题目</p><p>：</p><ul><li><a href="https://leetcode.cn/problems/qn8gGX">剑指 Offer II 061. 和最小的 k 个数对 🟠open in new window</a></li></ul></li></ul><h2 id="378-有序矩阵中第-K-小的元素open-in-new-window"><a href="#378-有序矩阵中第-K-小的元素open-in-new-window" class="headerlink" title="#378. 有序矩阵中第 K 小的元素open in new window"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#_378-%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%AC-k-%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0">#</a><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix">378. 有序矩阵中第 K 小的元素open in new window</a></h2><ul><li><strong>标签：二叉堆，链表双指针</strong></li></ul><p>给你一个 <code>n x n</code> 矩阵 <code>matrix</code>，其中每行和每列元素均按升序排序，找到矩阵中第 <code>k</code> 小的元素。<br>请注意，它是 <strong>排序后</strong> 的第 <code>k</code> 小元素，而不是第 <code>k</code> 个 <strong>不同</strong>的元素。</p><p>你必须找到一个内存复杂度优于 <code>O(n2)</code> 的解决方案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8</span><br><span class="line">输出：13</span><br><span class="line">解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13</span><br></pre></td></tr></table></figure><h3 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="#基本思路"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-2">#</a>基本思路</h3><p>这道题其实是前文 <a href="https://labuladong.gitee.io/article/fname.html?fname=%E9%93%BE%E8%A1%A8%E6%8A%80%E5%B7%A7">单链表的六大解题套路open in new window</a> 中讲过的 <a href="https://leetcode.cn/problems/merge-k-sorted-lists">23. 合并K个升序链表open in new window</a> 的变体。</p><p>矩阵中的每一行都是排好序的，就好比多条有序链表，你用优先级队列施展合并多条有序链表的逻辑就能找到第 <code>k</code> 小的元素了。</p><h3 id="解法代码-2"><a href="#解法代码-2" class="headerlink" title="#解法代码"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-2">#</a>解法代码</h3><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 存储二元组 (matrix[i][j], i, j)</span></span><br><span class="line">        <span class="comment">// i, j 记录当前元素的索引位置，用于生成下一个节点</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 按照元素大小升序排序</span></span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化优先级队列，把每一行的第一个元素装进去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;matrix[i][<span class="number">0</span>], i, <span class="number">0</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 执行合并多个有序链表的逻辑，找到第 k 小的元素</span></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span>[] cur = pq.poll();</span><br><span class="line">            res = cur[<span class="number">0</span>];</span><br><span class="line">            k--;</span><br><span class="line">            <span class="comment">// 链表中的下一个节点加入优先级队列</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cur[<span class="number">1</span>], j = cur[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; matrix[i].length) &#123;</span><br><span class="line">                pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;matrix[i][j + <span class="number">1</span>], i, j + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="313-超级丑数open-in-new-window"><a href="#313-超级丑数open-in-new-window" class="headerlink" title="#313. 超级丑数open in new window"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#_313-%E8%B6%85%E7%BA%A7%E4%B8%91%E6%95%B0">#</a><a href="https://leetcode.cn/problems/super-ugly-number">313. 超级丑数open in new window</a></h2><ul><li><strong>标签：二叉堆，链表双指针</strong></li></ul><p><strong>超级丑数</strong> 是一个正整数，并满足其所有质因数都出现在质数数组 <code>primes</code> 中。给你一个整数 <code>n</code> 和一个整数数组 <code>primes</code>，返回第 <code>n</code> 个 <strong>超级丑数</strong>。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 12, primes = [2,7,13,19]</span><br><span class="line">输出：32 </span><br><span class="line">解释：给定长度为 4 的质数数组 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32]。</span><br></pre></td></tr></table></figure><h3 id="基本思路-3"><a href="#基本思路-3" class="headerlink" title="#基本思路"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-3">#</a>基本思路</h3><p>这题是 <a href="https://leetcode.cn/problems/ugly-number-ii">264. 丑数 IIopen in new window</a> 的进阶版，第 264 题是 <a href="https://leetcode.cn/problems/merge-two-sorted-lists">21. 合并两个有序链表（简单）open in new window</a> 的变体，而这道题是 <a href="https://leetcode.cn/problems/merge-k-sorted-lists">23. 合并K个升序链表（困难）open in new window</a> 的变体，我在 <a href="https://labuladong.gitee.io/article/fname.html?fname=%E9%93%BE%E8%A1%A8%E6%8A%80%E5%B7%A7">双指针技巧秒杀七道链表题目open in new window</a> 中都讲过。</p><p>你一定要先做下 264 题，注意那里我们抽象出了三条链表，需要 <code>p2, p3, p5</code> 作为三条有序链表上的指针，同时需要 <code>product2, product3, product5</code> 记录指针所指节点的值，用 <code>min</code> 函数计算最小头结点。</p><p>这道题相当于输入了 <code>len(primes)</code> 条有序链表，我们不能用 <code>min</code> 函数计算最小头结点了，而是要用优先级队列来计算最小头结点，同时依然要维护链表指针、指针所指节点的值，我们把这些信息用一个三元组来保存。</p><p>结合第 23 题的解法逻辑，你应该能够看懂这道题的解法代码了。</p><ul><li><strong>详细题解：<a href="https://labuladong.gitee.io/article/fname.html?fname=%E4%B8%91%E6%95%B0">一文秒杀所有丑数系列问题open in new window</a></strong></li></ul><h3 id="解法代码-3"><a href="#解法代码-3" class="headerlink" title="#解法代码"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-3">#</a>解法代码</h3><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthSuperUglyNumber</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] primes)</span> &#123;</span><br><span class="line">        <span class="comment">// 优先队列中装三元组 int[] &#123;product, prime, pi&#125;</span></span><br><span class="line">        <span class="comment">// 其中 product 代表链表节点的值，prime 是计算下一个节点所需的质数因子，pi 代表链表上的指针</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把多条链表的头结点加入优先级队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; primes.length; i++) &#123;</span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123; <span class="number">1</span>, primes[i], <span class="number">1</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以理解为最终合并的有序链表（结果链表）</span></span><br><span class="line">        <span class="type">int</span>[] ugly = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 可以理解为结果链表上的指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p &lt;= n) &#123;</span><br><span class="line">            <span class="comment">// 取三个链表的最小结点</span></span><br><span class="line">            <span class="type">int</span>[] pair = pq.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> pair[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">prime</span> <span class="operator">=</span> pair[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> pair[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 避免结果链表出现重复元素</span></span><br><span class="line">            <span class="keyword">if</span> (product != ugly[p - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 接到结果链表上</span></span><br><span class="line">                ugly[p] = product;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生成下一个节点加入优先级队列</span></span><br><span class="line">            <span class="type">int</span>[] nextPair = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;ugly[index] * prime, prime, index + <span class="number">1</span>&#125;;</span><br><span class="line">            pq.offer(nextPair);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ugly[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>类似题目</p><p>：</p><ul><li><a href="https://leetcode.cn/problems/ugly-number-iii">1201. 丑数 III 🟠open in new window</a></li><li><a href="https://leetcode.cn/problems/ugly-number">263. 丑数 🟢open in new window</a></li><li><a href="https://leetcode.cn/problems/ugly-number-ii">264. 丑数 II 🟠open in new window</a></li><li><a href="https://leetcode.cn/problems/chou-shu-lcof">剑指 Offer 49. 丑数 🟠open in new window</a></li></ul></li></ul><h2 id="355-设计推特open-in-new-window"><a href="#355-设计推特open-in-new-window" class="headerlink" title="#355. 设计推特open in new window"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#_355-%E8%AE%BE%E8%AE%A1%E6%8E%A8%E7%89%B9">#</a><a href="https://leetcode.cn/problems/design-twitter">355. 设计推特open in new window</a></h2><ul><li><strong>标签：数据结构，设计</strong></li></ul><p>设计一个简化版的推特 (Twitter)，可以让用户实现发送推文，关注&#x2F;取消关注其他用户，能够看见关注人（包括自己）的最近 <code>10</code> 条推文。</p><p>实现 <code>Twitter</code> 类：</p><ul><li><code>void postTweet(int userId, int tweetId)</code> 根据给定的 <code>tweetId</code> 和 <code>userId</code> 创建一条新推文。每次调用此函数都会使用一个不同的 <code>tweetId</code>。</li><li><code>List&lt;Integer&gt; getNewsFeed(int userId)</code> 检索当前用户新闻推送中最近 <code>10</code> 条推文的 ID。新闻推送中的每一项都必须是由用户关注的人或者是用户自己发布的推文。推文必须<strong>按照时间顺序由最近到最远排序</strong>。</li><li><code>void follow(int followerId, int followeeId)</code> ID 为 <code>followerId</code> 的用户开始关注 ID 为 <code>followeeId</code> 的用户。</li><li><code>void unfollow(int followerId, int followeeId)</code> ID 为 <code>followerId</code> 的用户不再关注 ID 为 <code>followeeId</code> 的用户。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;Twitter&quot;, &quot;postTweet&quot;, &quot;getNewsFeed&quot;, &quot;follow&quot;, &quot;postTweet&quot;, &quot;getNewsFeed&quot;, &quot;unfollow&quot;, &quot;getNewsFeed&quot;]</span><br><span class="line">[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]</span><br><span class="line">输出</span><br><span class="line">[null, null, [5], null, null, [6, 5], null, [5]]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">Twitter twitter = new Twitter();</span><br><span class="line">twitter.postTweet(1, 5); // 用户 1 发送了一条新推文 (用户 id = 1, 推文 id = 5)</span><br><span class="line">twitter.getNewsFeed(1);  // 用户 1 的获取推文应当返回一个列表，其中包含一个 id 为 5 的推文</span><br><span class="line">twitter.follow(1, 2);    // 用户 1 关注了用户 2</span><br><span class="line">twitter.postTweet(2, 6); // 用户 2 发送了一个新推文 (推文 id = 6)</span><br><span class="line">twitter.getNewsFeed(1);  // 用户 1 的获取推文应当返回一个列表，其中包含两个推文，id 分别为 -&gt; [6, 5]。推文 id 6 应当在推文 id 5 之前，因为它是在 5 之后发送的</span><br><span class="line">twitter.unfollow(1, 2);  // 用户 1 取消关注了用户 2</span><br><span class="line">twitter.getNewsFeed(1);  // 用户 1 获取推文应当返回一个列表，其中包含一个 id 为 5 的推文。因为用户 1 已经不再关注用户 2</span><br></pre></td></tr></table></figure><h3 id="基本思路-4"><a href="#基本思路-4" class="headerlink" title="#基本思路"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-4">#</a>基本思路</h3><p>这道题比较经典，在特定场景下让你设计算法。其难点在于 <code>getNewsFeed</code> 方法，要按照时间线顺序展示所有关注用户的推文，这个方法要用到我在 <a href="https://labuladong.gitee.io/article/fname.html?fname=%E9%93%BE%E8%A1%A8%E6%8A%80%E5%B7%A7">单链表的六大解题套路open in new window</a> 解决 <a href="https://leetcode.cn/problems/merge-k-sorted-lists">23. 合并K个升序链表open in new window</a> 的合并多个有序链表的技巧：</p><p>你把一个用户发布的所有推文做成一条有序链表（靠近头部的推文是最近发布的），那么只要合并关注用户的推文链表，即可获得按照时间线顺序排序的信息流。</p><p>具体看代码吧，我注释比较详细。</p><ul><li><strong>详细题解：<a href="https://labuladong.gitee.io/article/fname.html?fname=%E8%AE%BE%E8%AE%A1Twitter">设计朋友圈时间线功能open in new window</a></strong></li></ul><h3 id="解法代码-4"><a href="#解法代码-4" class="headerlink" title="#解法代码"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-4">#</a>解法代码</h3><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Twitter</span> &#123;</span><br><span class="line">    <span class="comment">// 全局时间戳</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">globalTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录用户 ID 到用户示例的映射</span></span><br><span class="line">    HashMap&lt;Integer, User&gt; idToUser = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tweet 类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="comment">// 时间戳用于对信息流按照时间排序</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> timestamp;</span><br><span class="line">        <span class="comment">// 指向下一条 tweet，类似单链表结构</span></span><br><span class="line">        <span class="keyword">private</span> Tweet next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Tweet</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="comment">// 新建一条 tweet 时记录并更新时间戳 </span></span><br><span class="line">            <span class="built_in">this</span>.timestamp = globalTime++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTimestamp</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> timestamp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Tweet <span class="title function_">getNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Tweet next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="comment">// 记录该用户的 id 以及发布的 tweet</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">private</span> Tweet tweetHead;</span><br><span class="line">        <span class="comment">// 记录该用户的关注者</span></span><br><span class="line">        <span class="keyword">private</span> HashSet&lt;User&gt; followedUserSet;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="built_in">this</span>.tweetHead = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.followedUserSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Tweet <span class="title function_">getTweetHead</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> tweetHead;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> HashSet&lt;User&gt; <span class="title function_">getFollowedUserSet</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> followedUserSet;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(User other)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.id == other.id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关注其他人</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">follow</span><span class="params">(User other)</span> &#123;</span><br><span class="line">            followedUserSet.add(other);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取关其他人</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unfollow</span><span class="params">(User other)</span> &#123;</span><br><span class="line">            followedUserSet.remove(other);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布一条 tweet</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">post</span><span class="params">(Tweet tweet)</span> &#123;</span><br><span class="line">            <span class="comment">// 把新发布的 tweet 作为链表头节点</span></span><br><span class="line">            tweet.setNext(tweetHead);</span><br><span class="line">            tweetHead = tweet;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postTweet</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> tweetId)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果这个用户还不存在，新建用户</span></span><br><span class="line">        <span class="keyword">if</span> (!idToUser.containsKey(userId)) &#123;</span><br><span class="line">            idToUser.put(userId, <span class="keyword">new</span> <span class="title class_">User</span>(userId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> idToUser.get(userId);</span><br><span class="line">        user.post(<span class="keyword">new</span> <span class="title class_">Tweet</span>(tweetId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getNewsFeed</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (!idToUser.containsKey(userId)) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取该用户关注的用户列表</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> idToUser.get(userId);</span><br><span class="line">        Set&lt;User&gt; followedUserSet = user.getFollowedUserSet();</span><br><span class="line">        <span class="comment">// 每个用户的 tweet 是一条按时间排序的链表</span></span><br><span class="line">        <span class="comment">// 现在执行合并多条有序链表的逻辑，找出时间线中的最近 10 条动态</span></span><br><span class="line">        PriorityQueue&lt;Tweet&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 按照每条 tweet 的发布时间降序排序（最近发布的排在事件流前面）</span></span><br><span class="line">            <span class="keyword">return</span> b.timestamp - a.timestamp;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 该用户自己的 tweet 也在时间线内</span></span><br><span class="line">        <span class="keyword">if</span> (user.getTweetHead() != <span class="literal">null</span>) &#123;</span><br><span class="line">            pq.offer(user.getTweetHead());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (User other : followedUserSet) &#123;</span><br><span class="line">            <span class="keyword">if</span> (other.getTweetHead() != <span class="literal">null</span>) &#123;</span><br><span class="line">                pq.offer(other.tweetHead);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 合并多条有序链表</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="type">Tweet</span> <span class="variable">tweet</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            res.add(tweet.getId());</span><br><span class="line">            <span class="keyword">if</span> (tweet.getNext() != <span class="literal">null</span>) &#123;</span><br><span class="line">                pq.offer(tweet.getNext());</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">follow</span><span class="params">(<span class="type">int</span> followerId, <span class="type">int</span> followeeId)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果用户还不存在，则新建用户</span></span><br><span class="line">        <span class="keyword">if</span> (!idToUser.containsKey(followerId)) &#123;</span><br><span class="line">            idToUser.put(followerId, <span class="keyword">new</span> <span class="title class_">User</span>(followerId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!idToUser.containsKey(followeeId)) &#123;</span><br><span class="line">            idToUser.put(followeeId, <span class="keyword">new</span> <span class="title class_">User</span>(followeeId));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">follower</span> <span class="operator">=</span> idToUser.get(followerId);</span><br><span class="line">        <span class="type">User</span> <span class="variable">followee</span> <span class="operator">=</span> idToUser.get(followeeId);</span><br><span class="line">        <span class="comment">// 关注者关注被关注者</span></span><br><span class="line">        follower.follow(followee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unfollow</span><span class="params">(<span class="type">int</span> followerId, <span class="type">int</span> followeeId)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!idToUser.containsKey(followerId) || !idToUser.containsKey(followeeId)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">User</span> <span class="variable">follower</span> <span class="operator">=</span> idToUser.get(followerId);</span><br><span class="line">        <span class="type">User</span> <span class="variable">followee</span> <span class="operator">=</span> idToUser.get(followeeId);</span><br><span class="line">        <span class="comment">// 关注者取关被关注者</span></span><br><span class="line">        follower.unfollow(followee);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>再来看第二类，寻找第 <code>k</code> 个最大元素这类题：</p><hr><h2 id="215-数组中的第-K-个最大元素open-in-new-window"><a href="#215-数组中的第-K-个最大元素open-in-new-window" class="headerlink" title="#215. 数组中的第 K 个最大元素open in new window"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#_215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%AC-k-%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0">#</a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array">215. 数组中的第 K 个最大元素open in new window</a></h2><ul><li><strong>标签：二叉堆，快速选择算法，数组</strong></li></ul><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[3,2,1,5,6,4] 和 k = 2</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[3,2,3,1,2,4,5,5,6] 和 k = 4</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><h3 id="基本思路-5"><a href="#基本思路-5" class="headerlink" title="#基本思路"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-5">#</a>基本思路</h3><p>二叉堆的解法比较简单，实际写算法题的时候，推荐大家写这种解法。</p><p>可以把小顶堆 <code>pq</code> 理解成一个筛子，较大的元素会沉淀下去，较小的元素会浮上来；当堆大小超过 <code>k</code> 的时候，我们就删掉堆顶的元素，因为这些元素比较小，而我们想要的是前 <code>k</code> 个最大元素嘛。</p><p>当 <code>nums</code> 中的所有元素都过了一遍之后，筛子里面留下的就是最大的 <code>k</code> 个元素，而堆顶元素是堆中最小的元素，也就是「第 <code>k</code> 个最大的元素」。</p><p>二叉堆插入和删除的时间复杂度和堆中的元素个数有关，在这里我们堆的大小不会超过 <code>k</code>，所以插入和删除元素的复杂度是 <code>O(logK)</code>，再套一层 for 循环，总的时间复杂度就是 <code>O(NlogK)</code>。</p><p>当然，这道题可以有效率更高的解法叫「快速选择算法」，只需要 <code>O(N)</code> 的时间复杂度。</p><p>快速选择算法不用借助二叉堆结构，而是稍微改造了快速排序的算法思路，有兴趣的读者可以看详细题解。</p><ul><li><strong>详细题解：<a href="https://labuladong.gitee.io/article/fname.html?fname=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序详解及应用open in new window</a></strong></li></ul><h3 id="解法代码-5"><a href="#解法代码-5" class="headerlink" title="#解法代码"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-5">#</a>解法代码</h3><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 小顶堆，堆顶是最小元素</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e : nums) &#123;</span><br><span class="line">            <span class="comment">// 每个元素都要过一遍二叉堆</span></span><br><span class="line">            pq.offer(e);</span><br><span class="line">            <span class="comment">// 堆中元素多于 k 个时，删除堆顶元素</span></span><br><span class="line">            <span class="keyword">if</span> (pq.size() &gt; k) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pq 中剩下的是 nums 中 k 个最大元素，</span></span><br><span class="line">        <span class="comment">// 堆顶是最小的那个，即第 k 个最大元素</span></span><br><span class="line">        <span class="keyword">return</span> pq.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>类似题目</p><p>：</p><ul><li><a href="https://leetcode.cn/problems/top-k-frequent-elements">347. 前 K 个高频元素 🟠open in new window</a></li><li><a href="https://leetcode.cn/problems/kth-largest-element-in-a-stream">703. 数据流中的第 K 大元素 🟢open in new window</a></li><li><a href="https://leetcode.cn/problems/sort-an-array">912. 排序数组 🟠open in new window</a></li><li><a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof">剑指 Offer 40. 最小的k个数 🟢open in new window</a></li><li><a href="https://leetcode.cn/problems/jBjn9C">剑指 Offer II 059. 数据流的第 K 大数值 🟢open in new window</a></li><li><a href="https://leetcode.cn/problems/g5c51o">剑指 Offer II 060. 出现频率最高的 k 个数字 🟠open in new window</a></li><li><a href="https://leetcode.cn/problems/xx4gT2">剑指 Offer II 076. 数组中的第 k 大的数字 🟠open in new window</a></li></ul></li></ul><h2 id="451-根据字符出现频率排序open-in-new-window"><a href="#451-根据字符出现频率排序open-in-new-window" class="headerlink" title="#451. 根据字符出现频率排序open in new window"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#_451-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F">#</a><a href="https://leetcode.cn/problems/sort-characters-by-frequency">451. 根据字符出现频率排序open in new window</a></h2><ul><li><strong>标签：二叉堆，排序</strong></li></ul><p>给定一个字符串 <code>s</code>，根据字符出现的 <strong>频率</strong> 对其进行 <strong>降序排序</strong>。一个字符出现的 <strong>频率</strong> 是它出现在字符串中的次数，<strong>返回已排序的字符串</strong>。如果有多个答案，返回其中任何一个。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;tree&quot;</span><br><span class="line">输出：&quot;eert&quot;</span><br><span class="line">解释：&#x27;e&#x27; 出现两次，&#x27;r&#x27; 和 &#x27;t&#x27; 都只出现一次。</span><br><span class="line">因此 &#x27;e&#x27; 必须出现在 &#x27;r&#x27; 和 &#x27;t&#x27; 之前。此外，&quot;eetr&quot; 也是一个有效的答案。</span><br></pre></td></tr></table></figure><h3 id="基本思路-6"><a href="#基本思路-6" class="headerlink" title="#基本思路"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-6">#</a>基本思路</h3><p>做这道题肯定需要计算每个字符出现的频率，然后你可以用很多种其他方法把字符按照频率排序。我这里用 <a href="https://labuladong.gitee.io/article/fname.html?fname=%E4%BA%8C%E5%8F%89%E5%A0%86%E8%AF%A6%E8%A7%A3%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97">优先级队列open in new window</a> 来实现排序的效果，详细看代码。</p><h3 id="解法代码-6"><a href="#解法代码-6" class="headerlink" title="#解法代码"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-6">#</a>解法代码</h3><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">frequencySort</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="comment">// s 中的字符 -&gt; 该字符出现的频率</span></span><br><span class="line">        HashMap&lt;Character, Integer&gt; charToFreq = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : chars) &#123;</span><br><span class="line">            charToFreq.put(ch, charToFreq.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;Character, Integer&gt;&gt;</span><br><span class="line">                pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((entry1, entry2) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 队列按照键值对中的值（字符出现频率）从大到小排序</span></span><br><span class="line">            <span class="keyword">return</span> entry2.getValue().compareTo(entry1.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照字符频率排序</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : charToFreq.entrySet()) &#123;</span><br><span class="line">            pq.offer(entry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 把频率最高的字符排在前面</span></span><br><span class="line">            Map.Entry&lt;Character, Integer&gt; entry = pq.poll();</span><br><span class="line">            <span class="type">String</span> <span class="variable">part</span> <span class="operator">=</span> String.valueOf(entry.getKey()).repeat(entry.getValue());</span><br><span class="line">            sb.append(part);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="703-数据流中的第-K-大元素open-in-new-window"><a href="#703-数据流中的第-K-大元素open-in-new-window" class="headerlink" title="#703. 数据流中的第 K 大元素open in new window"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#_703-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%AC-k-%E5%A4%A7%E5%85%83%E7%B4%A0">#</a><a href="https://leetcode.cn/problems/kth-largest-element-in-a-stream">703. 数据流中的第 K 大元素open in new window</a></h2><ul><li><strong>标签：二叉堆，数据结构</strong></li></ul><p>设计一个找到数据流中第 <code>k</code> 大元素的类（class）。注意是排序后的第 <code>k</code> 大元素，不是第 <code>k</code> 个不同的元素。</p><p>请实现 <code>KthLargest</code> 类：</p><p>1、<code>KthLargest(int k, int[] nums)</code> 使用整数 <code>k</code> 和整数流 <code>nums</code> 初始化对象。</p><p>2、<code>int add(int val)</code> 将 <code>val</code> 插入数据流 <code>nums</code> 后，返回当前数据流中第 <code>k</code> 大的元素。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;KthLargest&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;]</span><br><span class="line">[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]</span><br><span class="line">输出：</span><br><span class="line">[null, 4, 5, 5, 8, 8]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);</span><br><span class="line">kthLargest.add(3);   // return 4</span><br><span class="line">kthLargest.add(5);   // return 5</span><br><span class="line">kthLargest.add(10);  // return 5</span><br><span class="line">kthLargest.add(9);   // return 8</span><br><span class="line">kthLargest.add(4);   // return 8</span><br></pre></td></tr></table></figure><h3 id="基本思路-7"><a href="#基本思路-7" class="headerlink" title="#基本思路"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-7">#</a>基本思路</h3><p>这题考察优先级队列的使用，可以先做下这道类似的题目 <a href="https://leetcode.cn/problems/kth-largest-element-in-an-array">215. 数组中的第 K 个最大元素open in new window</a>。</p><p>优先级队列的实现原理详见 <a href="https://labuladong.gitee.io/article/fname.html?fname=%E4%BA%8C%E5%8F%89%E5%A0%86%E8%AF%A6%E8%A7%A3%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97">图文详解二叉堆，实现优先级队列open in new window</a>。</p><h3 id="解法代码-7"><a href="#解法代码-7" class="headerlink" title="#解法代码"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-7">#</a>解法代码</h3><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KthLargest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> k;</span><br><span class="line">    <span class="comment">// 默认是小顶堆</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">KthLargest</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 将 nums 装入小顶堆，保留下前 k 大的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e : nums) &#123;</span><br><span class="line">            pq.offer(e);</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &gt; k) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 维护小顶堆只保留前 k 大的元素</span></span><br><span class="line">        pq.offer(val);</span><br><span class="line">        <span class="keyword">if</span> (pq.size() &gt; k) &#123;</span><br><span class="line">            pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 堆顶就是第 k 大元素（即倒数第 k 小的元素）</span></span><br><span class="line">        <span class="keyword">return</span> pq.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>类似题目</p><p>：</p><ul><li><a href="https://leetcode.cn/problems/jBjn9C">剑指 Offer II 059. 数据流的第 K 大数值 🟢open in new window</a></li></ul></li></ul><h2 id="347-前-K-个高频元素open-in-new-window"><a href="#347-前-K-个高频元素open-in-new-window" class="headerlink" title="#347. 前 K 个高频元素open in new window"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#_347-%E5%89%8D-k-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0">#</a><a href="https://leetcode.cn/problems/top-k-frequent-elements">347. 前 K 个高频元素open in new window</a></h2><ul><li><strong>标签：二叉堆，哈希表，快速选择</strong></li></ul><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><h3 id="基本思路-8"><a href="#基本思路-8" class="headerlink" title="#基本思路"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-8">#</a>基本思路</h3><p>首先，肯定要用一个 <code>valToFreq</code> <a href="https://labuladong.online/algo/ds-class/yong-la-li-3b08e/la-lian-fa-68d24/">哈希表open in new window</a> 把每个元素出现的频率计算出来。</p><p>然后，这道题就变成了 <a href="https://leetcode.cn/problems/kth-largest-element-in-an-array">215. 数组中的第 K 个最大元素open in new window</a>，只不过第 215 题让你求数组中元素值 <code>e</code> 排在第 <code>k</code> 大的那个元素，这道题让你求数组中元素值 <code>valToFreq[e]</code> 排在前 <code>k</code> 个的元素。</p><p>我在 <a href="https://labuladong.gitee.io/article/fname.html?fname=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序详解及运用open in new window</a> 中讲过第 215 题，可以用 <a href="https://labuladong.gitee.io/article/fname.html?fname=%E4%BA%8C%E5%8F%89%E5%A0%86%E8%AF%A6%E8%A7%A3%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97">优先级队列open in new window</a> 或者快速选择算法解决这道题。这里稍微改一下优先级队列的比较函数，或者改一下快速选择算法中的逻辑即可。</p><p>这里我再加一种解法，用计数排序的方式找到前 <code>k</code> 个高频元素，见代码。</p><h3 id="解法代码-8"><a href="#解法代码-8" class="headerlink" title="#解法代码"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-8">#</a>解法代码</h3><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用优先级队列解决这道题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// nums 中的元素 -&gt; 该元素出现的频率</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; valToFreq = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : nums) &#123;</span><br><span class="line">            valToFreq.put(v, valToFreq.getOrDefault(v, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt;</span><br><span class="line">                pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((entry1, entry2) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 队列按照键值对中的值（元素出现频率）从小到大排序</span></span><br><span class="line">            <span class="keyword">return</span> entry1.getValue().compareTo(entry2.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : valToFreq.entrySet()) &#123;</span><br><span class="line">            pq.offer(entry);</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &gt; k) &#123;</span><br><span class="line">                <span class="comment">// 弹出最小元素，维护队列内是 k 个频率最大的元素</span></span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// res 数组中存储前 k 个最大元素</span></span><br><span class="line">            res[i] = pq.poll().getKey();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用计数排序的方法解决这道题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// nums 中的元素 -&gt; 该元素出现的频率</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; valToFreq = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : nums) &#123;</span><br><span class="line">            valToFreq.put(v, valToFreq.getOrDefault(v, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 频率 -&gt; 这个频率有哪些元素</span></span><br><span class="line">        ArrayList&lt;Integer&gt;[] freqToVals = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : valToFreq.keySet()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">freq</span> <span class="operator">=</span> valToFreq.get(val);</span><br><span class="line">            <span class="keyword">if</span> (freqToVals[freq] == <span class="literal">null</span>) &#123;</span><br><span class="line">                freqToVals[freq] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            freqToVals[freq].add(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// freqToVals 从后往前存储着出现最多的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> freqToVals.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; valList = freqToVals[i];</span><br><span class="line">            <span class="keyword">if</span> (valList == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; valList.size(); j++) &#123;</span><br><span class="line">                <span class="comment">// 将出现次数最多的 k 个元素装入 res</span></span><br><span class="line">                res[p] = valList.get(j);</span><br><span class="line">                p++;</span><br><span class="line">                <span class="keyword">if</span> (p == k) &#123;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>类似题目</p><p>：</p><ul><li><a href="https://leetcode.cn/problems/top-k-frequent-words">692. 前K个高频单词 🟠open in new window</a></li><li><a href="https://leetcode.cn/problems/g5c51o">剑指 Offer II 060. 出现频率最高的 k 个数字 🟠open in new window</a></li></ul></li></ul><h2 id="692-前K个高频单词open-in-new-window"><a href="#692-前K个高频单词open-in-new-window" class="headerlink" title="#692. 前K个高频单词open in new window"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#_692-%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D">#</a><a href="https://leetcode.cn/problems/top-k-frequent-words">692. 前K个高频单词open in new window</a></h2><ul><li><strong>标签：二叉堆，哈希表</strong></li></ul><p>给定一个单词列表 <code>words</code> 和一个整数 <code>k</code>，返回前 <code>k</code> 个出现次数最多的单词。返回的答案应该按单词出现频率由高到低排序，如果不同的单词有相同出现频率，<strong>按字典顺序</strong> 排序。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：words = [&quot;i&quot;, &quot;love&quot;, &quot;leetcode&quot;, &quot;i&quot;, &quot;love&quot;, &quot;coding&quot;], k = 2</span><br><span class="line">输出：[&quot;i&quot;, &quot;love&quot;]</span><br><span class="line">解析：&quot;i&quot; 和 &quot;love&quot; 为出现次数最多的两个单词，均为 2 次。</span><br><span class="line">    注意，按字母顺序 &quot;i&quot; 在 &quot;love&quot; 之前。</span><br></pre></td></tr></table></figure><h3 id="基本思路-9"><a href="#基本思路-9" class="headerlink" title="#基本思路"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-9">#</a>基本思路</h3><p>这道题可以认为是 <a href="https://leetcode.cn/problems/top-k-frequent-elements">347. 前 K 个高频元素open in new window</a> 的进阶版。整体思路还哈希表计数，然后用 <a href="https://labuladong.gitee.io/article/fname.html?fname=%E4%BA%8C%E5%8F%89%E5%A0%86%E8%AF%A6%E8%A7%A3%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97">优先级队列open in new window</a> 维护出现频率最高的 <code>k</code> 个单词。</p><p>只是我们需要注意题目要求，在 <code>PriorityQueue</code> 的比较器中正确处理频率相同的单词的字典序。</p><h3 id="解法代码-9"><a href="#解法代码-9" class="headerlink" title="#解法代码"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-9">#</a>解法代码</h3><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">topKFrequent</span><span class="params">(String[] words, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 字符串 -&gt; 该字符串出现的频率</span></span><br><span class="line">        HashMap&lt;String, Integer&gt; wordToFreq = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            wordToFreq.put(word, wordToFreq.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;String, Integer&gt;&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">                (entry1, entry2) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (entry1.getValue().equals(entry2.getValue())) &#123;</span><br><span class="line">                        <span class="comment">// 如果出现频率相同，按照字符串字典序排序</span></span><br><span class="line">                        <span class="keyword">return</span> entry2.getKey().compareTo(entry1.getKey());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 队列按照字符串出现频率从小到大排序</span></span><br><span class="line">                    <span class="keyword">return</span> entry1.getValue().compareTo(entry2.getValue());</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照字符串频率升序排序</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : wordToFreq.entrySet()) &#123;</span><br><span class="line">            pq.offer(entry);</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &gt; k) &#123;</span><br><span class="line">                <span class="comment">// 维护出现频率最多的 k 个单词</span></span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把出现次数最多的 k 个字符串返回</span></span><br><span class="line">        LinkedList&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            res.addFirst(pq.poll().getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>最后，再看一看优先级队列的其他运用吧：</p><hr><h2 id="1845-座位预约管理系统open-in-new-window"><a href="#1845-座位预约管理系统open-in-new-window" class="headerlink" title="#1845. 座位预约管理系统open in new window"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#_1845-%E5%BA%A7%E4%BD%8D%E9%A2%84%E7%BA%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">#</a><a href="https://leetcode.cn/problems/seat-reservation-manager">1845. 座位预约管理系统open in new window</a></h2><ul><li><strong>标签：二叉堆，数据结构，设计</strong></li></ul><p>请你设计一个管理 <code>n</code> 个座位预约的系统，座位编号从 <code>1</code> 到 <code>n</code>。</p><p>请你实现 <code>SeatManager</code> 类：</p><ul><li><code>SeatManager(int n)</code> 初始化一个 <code>SeatManager</code> 对象，它管理从 <code>1</code> 到 <code>n</code> 编号的 <code>n</code> 个座位。所有座位初始都是可预约的。</li><li><code>int reserve()</code> 返回可以预约座位的<strong>最小编号</strong>，此座位变为不可预约。</li><li><code>void unreserve(int seatNumber)</code> 将给定编号 <code>seatNumber</code> 对应的座位变成可以预约。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;SeatManager&quot;, &quot;reserve&quot;, &quot;reserve&quot;, &quot;unreserve&quot;, &quot;reserve&quot;, &quot;reserve&quot;, &quot;reserve&quot;, &quot;reserve&quot;, &quot;unreserve&quot;]</span><br><span class="line">[[5], [], [], [2], [], [], [], [], [5]]</span><br><span class="line">输出：</span><br><span class="line">[null, 1, 2, null, 2, 3, 4, 5, null]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">SeatManager seatManager = new SeatManager(5); // 初始化 SeatManager，有 5 个座位。</span><br><span class="line">seatManager.reserve();    // 所有座位都可以预约，所以返回最小编号的座位，也就是 1。</span><br><span class="line">seatManager.reserve();    // 可以预约的座位为 [2,3,4,5]，返回最小编号的座位，也就是 2。</span><br><span class="line">seatManager.unreserve(2); // 将座位 2 变为可以预约，现在可预约的座位为 [2,3,4,5]。</span><br><span class="line">seatManager.reserve();    // 可以预约的座位为 [2,3,4,5]，返回最小编号的座位，也就是 2。</span><br><span class="line">seatManager.reserve();    // 可以预约的座位为 [3,4,5]，返回最小编号的座位，也就是 3。</span><br><span class="line">seatManager.reserve();    // 可以预约的座位为 [4,5]，返回最小编号的座位，也就是 4。</span><br><span class="line">seatManager.reserve();    // 唯一可以预约的是座位 5，所以返回 5。</span><br><span class="line">seatManager.unreserve(5); // 将座位 5 变为可以预约，现在可预约的座位为 [5]。</span><br></pre></td></tr></table></figure><h3 id="基本思路-10"><a href="#基本思路-10" class="headerlink" title="#基本思路"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-10">#</a>基本思路</h3><p>这题是 <a href="https://leetcode.cn/problems/design-phone-directory">379. 电话目录管理系统open in new window</a> 的进阶版，那一道题返回的空闲号码可以随意，而这道题要求返回<strong>最小</strong>的座位编号。</p><p>其实很思路是一样的，只是这里需要用到能够按照元素大小自动排序的数据结构 <a href="https://labuladong.gitee.io/article/fname.html?fname=%E4%BA%8C%E5%8F%89%E5%A0%86%E8%AF%A6%E8%A7%A3%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97">优先级队列（二叉堆）open in new window</a>，直接看代码吧。</p><h3 id="解法代码-10"><a href="#解法代码-10" class="headerlink" title="#解法代码"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-10">#</a>解法代码</h3><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SeatManager</span> &#123;</span><br><span class="line">    <span class="comment">// 利用优先级队列自动排序，队头的元素就是最小的</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SeatManager</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化所有空闲座位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            pq.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reserve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 拿出队头元素（最小）</span></span><br><span class="line">        <span class="keyword">return</span> pq.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unreserve</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        pq.offer(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="295-数据流的中位数open-in-new-window"><a href="#295-数据流的中位数open-in-new-window" class="headerlink" title="#295. 数据流的中位数open in new window"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#_295-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0">#</a><a href="https://leetcode.cn/problems/find-median-from-data-stream">295. 数据流的中位数open in new window</a></h2><ul><li><strong>标签：二叉堆，数学</strong></li></ul><p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p><p>设计一个支持以下两种操作的数据结构：</p><p>1、<code>void addNum(int num)</code> 从数据流中添加一个整数到数据结构中。</p><p>2、<code>double findMedian()</code> 返回目前所有元素的中位数。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">addNum(1)</span><br><span class="line">addNum(2)</span><br><span class="line">findMedian() -&gt; 1.5</span><br><span class="line">addNum(3) </span><br><span class="line">findMedian() -&gt; 2</span><br></pre></td></tr></table></figure><h3 id="基本思路-11"><a href="#基本思路-11" class="headerlink" title="#基本思路"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-11">#</a>基本思路</h3><p>本题的核心思路是使用两个优先级队列。</p><p><img src="/%E4%BA%8C%E5%8F%89%E5%A0%86%E8%AF%A6%E8%A7%A3%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/1.jpeg" alt="img"></p><p>小的倒三角就是个大顶堆，梯形就是个小顶堆，中位数可以通过它们的堆顶元素算出来：</p><p><img src="/%E4%BA%8C%E5%8F%89%E5%A0%86%E8%AF%A6%E8%A7%A3%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/2.jpeg" alt="img"></p><ul><li><strong>详细题解：<a href="https://labuladong.gitee.io/article/fname.html?fname=%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E4%BD%8D%E6%95%B0">一道求中位数的算法题把我整不会了open in new window</a></strong></li></ul><h3 id="解法代码-11"><a href="#解法代码-11" class="headerlink" title="#解法代码"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-11">#</a>解法代码</h3><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; large;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; small;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MedianFinder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 小顶堆</span></span><br><span class="line">        large = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 大顶堆</span></span><br><span class="line">        small = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> b - a;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果元素不一样多，多的那个堆的堆顶元素就是中位数</span></span><br><span class="line">        <span class="keyword">if</span> (large.size() &lt; small.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> small.peek();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (large.size() &gt; small.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> large.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果元素一样多，两个堆堆顶元素的平均数是中位数</span></span><br><span class="line">        <span class="keyword">return</span> (large.peek() + small.peek()) / <span class="number">2.0</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (small.size() &gt;= large.size()) &#123;</span><br><span class="line">            small.offer(num);</span><br><span class="line">            large.offer(small.poll());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            large.offer(num);</span><br><span class="line">            small.offer(large.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>类似题目</p><p>：</p><ul><li><a href="https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof">剑指 Offer 41. 数据流中的中位数 🔴open in new window</a></li></ul></li></ul><h2 id="870-优势洗牌open-in-new-window"><a href="#870-优势洗牌open-in-new-window" class="headerlink" title="#870. 优势洗牌open in new window"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#_870-%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C">#</a><a href="https://leetcode.cn/problems/advantage-shuffle">870. 优势洗牌open in new window</a></h2><ul><li><strong>标签：数组，数组双指针</strong></li></ul><p>给定两个大小相等的数组 <code>A</code> 和 <code>B</code>，<code>A</code> 相对于 <code>B</code> 的<strong>优势</strong>可以用满足 <code>A[i] &gt; B[i]</code> 的索引 <code>i</code> 的数目来描述。</p><p>请你返回 <code>A</code> 的<strong>任意</strong>排列，使其相对于 <code>B</code> 的优势最大化。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：A = [2,7,11,15], B = [1,10,4,11]</span><br><span class="line">输出：[2,11,7,15]</span><br></pre></td></tr></table></figure><h3 id="基本思路-12"><a href="#基本思路-12" class="headerlink" title="#基本思路"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-12">#</a>基本思路</h3><p>这题就像田忌赛马的情景，<code>nums1</code> 就是田忌的马，<code>nums2</code> 就是齐王的马，数组中的元素就是马的战斗力，你就是谋士孙膑，请你帮田忌安排赛马顺序，使胜场最多。</p><p>最优策略是将齐王和田忌的马按照战斗力排序，然后按照战斗力排名一一对比：</p><p>如果田忌的马能赢，那就比赛，如果赢不了，那就换个垫底的来送人头，保存实力。</p><p>具体分析见详细题解。</p><ul><li><strong>详细题解：<a href="https://labuladong.gitee.io/article/fname.html?fname=%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC">田忌赛马背后的算法决策open in new window</a></strong></li></ul><h3 id="解法代码-12"><a href="#解法代码-12" class="headerlink" title="#解法代码"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-12">#</a>解法代码</h3><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] advantageCount(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="comment">// 给 nums2 降序排序</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; maxpq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">                (<span class="type">int</span>[] pair1, <span class="type">int</span>[] pair2) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> pair2[<span class="number">1</span>] - pair1[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            maxpq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, nums2[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 给 nums1 升序排序</span></span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// nums1[left] 是最小值，nums1[right] 是最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!maxpq.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] pair = maxpq.poll();</span><br><span class="line">            <span class="comment">// maxval 是 nums2 中的最大值，i 是对应索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> pair[<span class="number">0</span>], maxval = pair[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (maxval &lt; nums1[right]) &#123;</span><br><span class="line">                <span class="comment">// 如果 nums1[right] 能胜过 maxval，那就自己上</span></span><br><span class="line">                res[i] = nums1[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则用最小值混一下，养精蓄锐</span></span><br><span class="line">                res[i] = nums1[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1834-单线程-CPUopen-in-new-window"><a href="#1834-单线程-CPUopen-in-new-window" class="headerlink" title="#1834. 单线程 CPUopen in new window"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#_1834-%E5%8D%95%E7%BA%BF%E7%A8%8B-cpu">#</a><a href="https://leetcode.cn/problems/single-threaded-cpu">1834. 单线程 CPUopen in new window</a></h2><ul><li><strong>标签：二叉堆，排序</strong></li></ul><p>给你一个二维数组 <code>tasks</code>，用于表示 <code>n</code> 项从 <code>0</code> 到 <code>n - 1</code> 编号的任务。其中 <code>tasks[i] = [enqueueTime_i, processingTime_i]</code> 意味着第 <code>i</code> 项任务将会于 <code>enqueueTime_i</code> 时进入任务队列，需要 <code>processingTime_i</code> 的时长完成执行。</p><p>现有一个单线程 CPU，同一时间只能执行 <strong>最多一项</strong> 任务，该 CPU 将会按照下述方式运行：</p><ul><li>如果 CPU 空闲，且任务队列中没有需要执行的任务，则 CPU 保持空闲状态。</li><li>如果 CPU 空闲，但任务队列中有需要执行的任务，则 CPU 将会选择<strong>执行时间最短</strong>的任务开始执行。如果多个任务具有同样的最短执行时间，则选择下标最小的任务开始执行。</li><li>一旦某项任务开始执行，CPU 在 <strong>执行完整个任务</strong> 前都不会停止。</li><li>CPU 可以在完成一项任务后，立即开始执行一项新任务。</li></ul><p>返回 CPU 处理任务的顺序。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：tasks = [[1,2],[2,4],[3,2],[4,1]]</span><br><span class="line">输出：[0,2,3,1]</span><br><span class="line">解释：事件按下述流程运行： </span><br><span class="line">- time = 1，任务 0 进入任务队列，可执行任务项 = &#123;0&#125;</span><br><span class="line">- 同样在 time = 1，空闲状态的 CPU 开始执行任务 0，可执行任务项 = &#123;&#125;</span><br><span class="line">- time = 2，任务 1 进入任务队列，可执行任务项 = &#123;1&#125;</span><br><span class="line">- time = 3，任务 2 进入任务队列，可执行任务项 = &#123;1, 2&#125;</span><br><span class="line">- 同样在 time = 3，CPU 完成任务 0 并开始执行队列中用时最短的任务 2，可执行任务项 = &#123;1&#125;</span><br><span class="line">- time = 4，任务 3 进入任务队列，可执行任务项 = &#123;1, 3&#125;</span><br><span class="line">- time = 5，CPU 完成任务 2 并开始执行队列中用时最短的任务 3，可执行任务项 = &#123;1&#125;</span><br><span class="line">- time = 6，CPU 完成任务 3 并开始执行任务 1，可执行任务项 = &#123;&#125;</span><br><span class="line">- time = 10，CPU 完成任务 1 并进入空闲状态</span><br></pre></td></tr></table></figure><h3 id="基本思路-13"><a href="#基本思路-13" class="headerlink" title="#基本思路"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-13">#</a>基本思路</h3><p>这题的难度不算大，就是有些复杂，<strong>难点在于你要同时控制三个变量（开始时间、处理时间、索引）的有序性，而且这三个变量还有优先级</strong>：</p><p>首先应该考虑开始时间，因为只要到了开始时间，任务才进入可执行状态；</p><p>其次应该考虑任务的处理时间，在所有可以执行的任务中优先选择处理时间最短的；</p><p>如果存在处理时间相同的任务，那么优先选择索引最小的。</p><p>所以这道题的思路是：</p><p><strong>先根据任务「开始时间」排序，维护一个时间线变量 <code>now</code> 来判断哪些任务到了可执行状态，然后借助一个优先级队列 <code>pq</code> 对「处理时间」和「索引」进行动态排序</strong>。</p><p>利用优先级队列动态排序是有必要的，因为每完成一个任务，时间线 <code>now</code> 就要更新，进而产生新的可执行任务。</p><h3 id="解法代码-13"><a href="#解法代码-13" class="headerlink" title="#解法代码"></a><a href="https://labuladong.online/algo/ds-class/dong-shou--b9ca2/qiang-hua--b046e/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81-13">#</a>解法代码</h3><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getOrder(<span class="type">int</span>[][] tasks) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tasks.length;</span><br><span class="line">        <span class="comment">// 把原始索引也添加上，方便后面排序用</span></span><br><span class="line">        ArrayList&lt;<span class="type">int</span>[]&gt; triples = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tasks.length; i++) &#123;</span><br><span class="line">            triples.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;tasks[i][<span class="number">0</span>], tasks[i][<span class="number">1</span>], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数组先按照任务的开始时间排序</span></span><br><span class="line">        triples.sort((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照任务的处理时间排序，如果处理时间相同，按照原始索引排序</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">1</span>] != b[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 比较处理时间</span></span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 比较原始索引</span></span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">2</span>] - b[<span class="number">2</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 记录完成任务的时间线</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (res.size() &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pq.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 完成队列中的一个任务</span></span><br><span class="line">                <span class="type">int</span>[] triple = pq.poll();</span><br><span class="line">                res.add(triple[<span class="number">2</span>]);</span><br><span class="line">                <span class="comment">// 每完成一个任务，就要推进时间线</span></span><br><span class="line">                now += triple[<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; n &amp;&amp; triples.get(i)[<span class="number">0</span>] &gt; now) &#123;</span><br><span class="line">                <span class="comment">// 队列为空可能因为还没到开始时间，</span></span><br><span class="line">                <span class="comment">// 直接把时间线推进到最近任务的开始时间</span></span><br><span class="line">                now = triples.get(i)[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 由于时间线的推进，会产生可以开始执行的任务</span></span><br><span class="line">            <span class="keyword">for</span> (; i &lt; n &amp;&amp; triples.get(i)[<span class="number">0</span>] &lt;= now; i++) &#123;</span><br><span class="line">                pq.offer(triples.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Java 语言特性，将 List 转化成 int[] 格式</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            arr[j] = res.get(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法就像搭乐高：带你手撸 LFU 算法</title>
      <link href="/posts/30751.html"/>
      <url>/posts/30751.html</url>
      
        <content type="html"><![CDATA[<h1 id="算法就像搭乐高：带你手撸-LFU-算法"><a href="#算法就像搭乐高：带你手撸-LFU-算法" class="headerlink" title="算法就像搭乐高：带你手撸 LFU 算法"></a>算法就像搭乐高：带你手撸 LFU 算法</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/lfu-cache/">460. LFU Cacheopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/lfu-cache/">460. LFU 缓存open in new window</a></td><td align="center">🔴</td></tr></tbody></table><p>上篇文章 <a href="https://labuladong.online/algo/data-structure/lru-cache/">带你手写LRU算法</a> 写了 LRU 缓存淘汰算法的实现方法，本文来写另一个著名的缓存淘汰算法：LFU 算法。</p><p>LRU 算法的淘汰策略是 Least Recently Used，也就是每次淘汰那些最久没被使用的数据；而 LFU 算法的淘汰策略是 Least Frequently Used，也就是每次淘汰那些使用次数最少的数据。</p><p>LRU 算法的核心数据结构是使用哈希链表 <code>LinkedHashMap</code>，首先借助链表的有序性使得链表元素维持插入顺序，同时借助哈希映射的快速访问能力使得我们可以在 O(1) 时间访问链表的任意元素。</p><p>从实现难度上来说，LFU 算法的难度大于 LRU 算法，因为 LRU 算法相当于把数据按照时间排序，这个需求借助链表很自然就能实现，你一直从链表头部加入元素的话，越靠近头部的元素就是新的数据，越靠近尾部的元素就是旧的数据，我们进行缓存淘汰的时候只要简单地将尾部的元素淘汰掉就行了。</p><p>而 LFU 算法相当于是把数据按照访问频次进行排序，这个需求恐怕没有那么简单，而且还有一种情况，如果多个数据拥有相同的访问频次，我们就得删除最早插入的那个数据。也就是说 LFU 算法是淘汰访问频次最低的数据，如果访问频次最低的数据有多条，需要淘汰最旧的数据。</p><p>所以说 LFU 算法是要复杂很多的，而且经常出现在面试中，因为 LFU 缓存淘汰算法在工程实践中经常使用，也有可能是因为 LRU 算法太简单了。<strong>不过话说回来，这种著名的算法的套路都是固定的，关键是由于逻辑较复杂，不容易写出漂亮且没有 bug 的代码</strong>。</p><p>那么本文我就带你拆解 LFU 算法，自顶向下，逐步求精，就是解决复杂问题的不二法门。</p><h3 id="一、算法描述"><a href="#一、算法描述" class="headerlink" title="#一、算法描述"></a><a href="https://labuladong.online/algo/frequency-interview/lfu/#%E4%B8%80%E3%80%81%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0">#</a>一、算法描述</h3><p>要求你写一个类，接受一个 <code>capacity</code> 参数，实现 <code>get</code> 和 <code>put</code> 方法：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LFUCache</span> &#123;</span><br><span class="line">    <span class="comment">// 构造容量为 capacity 的缓存</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LFUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 在缓存中查询 key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 将 key 和 val 存入缓存</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>get(key)</code> 方法会去缓存中查询键 <code>key</code>，如果 <code>key</code> 存在，则返回 <code>key</code> 对应的 <code>val</code>，否则返回 -1。</p><p><code>put(key, value)</code> 方法插入或修改缓存。如果 <code>key</code> 已存在，则将它对应的值改为 <code>val</code>；如果 <code>key</code> 不存在，则插入键值对 <code>(key, val)</code>。</p><p>当缓存达到容量 <code>capacity</code> 时，则应该在插入新的键值对之前，删除使用频次（后文用 <code>freq</code> 表示）最低的键值对。如果 <code>freq</code> 最低的键值对有多个，则删除其中最旧的那个。</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造一个容量为 2 的 LFU 缓存</span></span><br><span class="line"><span class="type">LFUCache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LFUCache</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入两对 (key, val)，对应的 freq 为 1</span></span><br><span class="line">cache.put(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">cache.put(<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询 key 为 1 对应的 val</span></span><br><span class="line"><span class="comment">// 返回 10，同时键 1 对应的 freq 变为 2</span></span><br><span class="line">cache.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容量已满，淘汰 freq 最小的键 2</span></span><br><span class="line"><span class="comment">// 插入键值对 (3, 30)，对应的 freq 为 1</span></span><br><span class="line">cache.put(<span class="number">3</span>, <span class="number">30</span>);   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 键 2 已经被淘汰删除，返回 -1</span></span><br><span class="line">cache.get(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="二、思路分析"><a href="#二、思路分析" class="headerlink" title="#二、思路分析"></a><a href="https://labuladong.online/algo/frequency-interview/lfu/#%E4%BA%8C%E3%80%81%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90">#</a>二、思路分析</h3><p>一定先从最简单的开始，根据 LFU 算法的逻辑，我们先列举出算法执行过程中的几个显而易见的事实：</p><p>1、调用 <code>get(key)</code> 方法时，要返回该 <code>key</code> 对应的 <code>val</code>。</p><p>2、只要用 <code>get</code> 或者 <code>put</code> 方法访问一次某个 <code>key</code>，该 <code>key</code> 的 <code>freq</code> 就要加一。</p><p>3、如果在容量满了的时候进行插入，则需要将 <code>freq</code> 最小的 <code>key</code> 删除，如果最小的 <code>freq</code> 对应多个 <code>key</code>，则删除其中最旧的那一个。</p><p>好的，我们希望能够在 O(1) 的时间内解决这些需求，可以使用基本数据结构来逐个击破：</p><p>1、使用一个 <code>HashMap</code> 存储 <code>key</code> 到 <code>val</code> 的映射，就可以快速计算 <code>get(key)</code>。</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; keyToVal;</span><br></pre></td></tr></table></figure><p>2、使用一个 <code>HashMap</code> 存储 <code>key</code> 到 <code>freq</code> 的映射，就可以快速操作 <code>key</code> 对应的 <code>freq</code>。</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; keyToFreq;</span><br></pre></td></tr></table></figure><p>3、这个需求应该是 LFU 算法的核心，所以我们分开说：</p><p>🌟</p><hr><p>🌟</p><p>3.1、首先，肯定是需要 <code>freq</code> 到 <code>key</code> 的映射，用来找到 <code>freq</code> 最小的 <code>key</code>。</p><p>3.2、将 <code>freq</code> 最小的 <code>key</code> 删除，那你就得快速得到当前所有 <code>key</code> 最小的 <code>freq</code> 是多少。想要时间复杂度 O(1) 的话，肯定不能遍历一遍去找，那就用一个变量 <code>minFreq</code> 来记录当前最小的 <code>freq</code> 吧。</p><p>3.3、可能有多个 <code>key</code> 拥有相同的 <code>freq</code>，所以 <strong><code>freq</code> 对 <code>key</code> 是一对多的关系</strong>，即一个 <code>freq</code> 对应一个 <code>key</code> 的列表。</p><p>3.4、希望 <code>freq</code> 对应的 <code>key</code> 的列表是<strong>存在时序</strong>的，便于快速查找并删除最旧的 <code>key</code>。</p><p>3.5、希望**能够快速删除 <code>key</code> 列表中的任何一个 <code>key</code>**，因为如果频次为 <code>freq</code> 的某个 <code>key</code> 被访问，那么它的频次就会变成 <code>freq+1</code>，就应该从 <code>freq</code> 对应的 <code>key</code> 列表中删除，加到 <code>freq+1</code> 对应的 <code>key</code> 的列表中。</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqToKeys;</span><br><span class="line"><span class="type">int</span> <span class="variable">minFreq</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>介绍一下这个 <code>LinkedHashSet</code>，它满足我们 3.3，3.4，3.5 这几个要求。你会发现普通的链表 <code>LinkedList</code> 能够满足 3.3，3.4 这两个要求，但是由于普通链表不能快速访问链表中的某一个节点，所以无法满足 3.5 的要求。</p><p><code>LinkedHashSet</code> 顾名思义，是链表和哈希集合的结合体。链表不能快速访问链表节点，但是插入元素具有时序；哈希集合中的元素无序，但是可以对元素进行快速的访问和删除。</p><p>那么，它俩结合起来就兼具了哈希集合和链表的特性，既可以在 O(1) 时间内访问或删除其中的元素，又可以保持插入的时序，高效实现 3.5 这个需求。</p><p>综上，我们可以写出 LFU 算法的基本数据结构：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LFUCache</span> &#123;</span><br><span class="line">    <span class="comment">// key 到 val 的映射，我们后文称为 KV 表</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; keyToVal;</span><br><span class="line">    <span class="comment">// key 到 freq 的映射，我们后文称为 KF 表</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; keyToFreq;</span><br><span class="line">    <span class="comment">// freq 到 key 列表的映射，我们后文称为 FK 表</span></span><br><span class="line">    HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqToKeys;</span><br><span class="line">    <span class="comment">// 记录最小的频次</span></span><br><span class="line">    <span class="type">int</span> minFreq;</span><br><span class="line">    <span class="comment">// 记录 LFU 缓存的最大容量</span></span><br><span class="line">    <span class="type">int</span> cap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LFUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        keyToVal = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        keyToFreq = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        freqToKeys = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.cap = capacity;</span><br><span class="line">        <span class="built_in">this</span>.minFreq = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、代码框架"><a href="#三、代码框架" class="headerlink" title="#三、代码框架"></a><a href="https://labuladong.online/algo/frequency-interview/lfu/#%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6">#</a>三、代码框架</h3><p>LFU 的逻辑不难理解，但是写代码实现并不容易，因为你看我们要维护 <code>KV</code> 表，<code>KF</code> 表，<code>FK</code> 表三个映射，特别容易出错。对于这种情况，我教你三个技巧：</p><p>1、不要企图上来就实现算法的所有细节，而应该自顶向下，逐步求精，先写清楚主函数的逻辑框架，然后再一步步实现细节。</p><p>2、搞清楚映射关系，如果我们更新了某个 <code>key</code> 对应的 <code>freq</code>，那么就要同步修改 <code>KF</code> 表和 <code>FK</code> 表，这样才不会出问题。</p><p>3、画图，画图，画图，重要的话说三遍，把逻辑比较复杂的部分用流程图画出来，然后根据图来写代码，可以极大减少出错的概率。</p><p>下面我们先来实现 <code>get(key)</code> 方法，逻辑很简单，返回 <code>key</code> 对应的 <code>val</code>，然后增加 <code>key</code> 对应的 <code>freq</code>：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LFUCache</span> &#123;</span><br><span class="line">    <span class="comment">// 为了节约篇幅，省略上文给出的代码部分...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!keyToVal.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 增加 key 对应的 freq</span></span><br><span class="line">        increaseFreq(key);</span><br><span class="line">        <span class="keyword">return</span> keyToVal.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加 <code>key</code> 对应的 <code>freq</code> 是 LFU 算法的核心，所以我们干脆直接抽象成一个函数 <code>increaseFreq</code>，这样 <code>get</code> 方法看起来就简洁清晰了对吧。</p><p>下面来实现 <code>put(key, val)</code> 方法，逻辑略微复杂，我们直接画个图来看：</p><p><img src="https://labuladong.online/algo/images/lfu/1.jpg" alt="img"></p><p>这图就是随手画的，不是什么正规的程序流程图，但是算法逻辑一目了然，看图可以直接写出 <code>put</code> 方法的逻辑：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LFUCache</span> &#123;</span><br><span class="line">    <span class="comment">// 为了节约篇幅，省略上文给出的代码部分...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.cap &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 若 key 已存在，修改对应的 val 即可 */</span></span><br><span class="line">        <span class="keyword">if</span> (keyToVal.containsKey(key)) &#123;</span><br><span class="line">            keyToVal.put(key, val);</span><br><span class="line">            <span class="comment">// key 对应的 freq 加一</span></span><br><span class="line">            increaseFreq(key);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* key 不存在，需要插入 */</span></span><br><span class="line">        <span class="comment">/* 容量已满的话需要淘汰一个 freq 最小的 key */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.cap &lt;= keyToVal.size()) &#123;</span><br><span class="line">            removeMinFreqKey();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 插入 key 和 val，对应的 freq 为 1 */</span></span><br><span class="line">        <span class="comment">// 插入 KV 表</span></span><br><span class="line">        keyToVal.put(key, val);</span><br><span class="line">        <span class="comment">// 插入 KF 表</span></span><br><span class="line">        keyToFreq.put(key, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 插入 FK 表</span></span><br><span class="line">        freqToKeys.putIfAbsent(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;());</span><br><span class="line">        freqToKeys.get(<span class="number">1</span>).add(key);</span><br><span class="line">        <span class="comment">// 插入新 key 后最小的 freq 肯定是 1</span></span><br><span class="line">        <span class="built_in">this</span>.minFreq = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>increaseFreq</code> 和 <code>removeMinFreqKey</code> 方法是 LFU 算法的核心，我们下面来看看怎么借助 <code>KV</code> 表，<code>KF</code> 表，<code>FK</code> 表这三个映射巧妙完成这两个函数。</p><h3 id="四、LFU-核心逻辑"><a href="#四、LFU-核心逻辑" class="headerlink" title="#四、LFU 核心逻辑"></a><a href="https://labuladong.online/algo/frequency-interview/lfu/#%E5%9B%9B%E3%80%81lfu-%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91">#</a>四、LFU 核心逻辑</h3><p>首先来实现 <code>removeMinFreqKey</code> 函数：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LFUCache</span> &#123;</span><br><span class="line">    <span class="comment">// 为了节约篇幅，省略上文给出的代码部分...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeMinFreqKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// freq 最小的 key 列表</span></span><br><span class="line">        LinkedHashSet&lt;Integer&gt; keyList = freqToKeys.get(<span class="built_in">this</span>.minFreq);</span><br><span class="line">        <span class="comment">// 其中最先被插入的那个 key 就是该被淘汰的 key</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">deletedKey</span> <span class="operator">=</span> keyList.iterator().next();</span><br><span class="line">        <span class="comment">/* 更新 FK 表 */</span></span><br><span class="line">        keyList.remove(deletedKey);</span><br><span class="line">        <span class="keyword">if</span> (keyList.isEmpty()) &#123;</span><br><span class="line">            freqToKeys.remove(<span class="built_in">this</span>.minFreq);</span><br><span class="line">            <span class="comment">// 问：这里需要更新 minFreq 的值吗？</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 更新 KV 表 */</span></span><br><span class="line">        keyToVal.remove(deletedKey);</span><br><span class="line">        <span class="comment">/* 更新 KF 表 */</span></span><br><span class="line">        keyToFreq.remove(deletedKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除某个键 <code>key</code> 肯定是要同时修改三个映射表的，借助 <code>minFreq</code> 参数可以从 <code>FK</code> 表中找到 <code>freq</code> 最小的 <code>keyList</code>，根据时序，其中第一个元素就是要被淘汰的 <code>deletedKey</code>，操作三个映射表删除这个 <code>key</code> 即可。</p><p>但是有个细节问题，如果 <code>keyList</code> 中只有一个元素，那么删除之后 <code>minFreq</code> 对应的 <code>key</code> 列表就为空了，也就是 <code>minFreq</code> 变量需要被更新。如何计算当前的 <code>minFreq</code> 是多少呢？</p><p>实际上没办法快速计算 <code>minFreq</code>，只能线性遍历 <code>FK</code> 表或者 <code>KF</code> 表来计算，这样肯定不能保证 O(1) 的时间复杂度。</p><p><strong>但是，其实这里没必要更新 <code>minFreq</code> 变量</strong>，因为你想想 <code>removeMinFreqKey</code> 这个函数是在什么时候调用？在 <code>put</code> 方法中插入新 <code>key</code> 时可能调用。而你回头看 <code>put</code> 的代码，插入新 <code>key</code> 时一定会把 <code>minFreq</code> 更新成 1，所以说即便这里 <code>minFreq</code> 变了，我们也不需要管它。</p><p>下面来实现 <code>increaseFreq</code> 函数：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LFUCache</span> &#123;</span><br><span class="line">    <span class="comment">// 为了节约篇幅，省略上文给出的代码部分...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">increaseFreq</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">freq</span> <span class="operator">=</span> keyToFreq.get(key);</span><br><span class="line">        <span class="comment">/* 更新 KF 表 */</span></span><br><span class="line">        keyToFreq.put(key, freq + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* 更新 FK 表 */</span></span><br><span class="line">        <span class="comment">// 将 key 从 freq 对应的列表中删除</span></span><br><span class="line">        freqToKeys.get(freq).remove(key);</span><br><span class="line">        <span class="comment">// 将 key 加入 freq + 1 对应的列表中</span></span><br><span class="line">        freqToKeys.putIfAbsent(freq + <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;());</span><br><span class="line">        freqToKeys.get(freq + <span class="number">1</span>).add(key);</span><br><span class="line">        <span class="comment">// 如果 freq 对应的列表空了，移除这个 freq</span></span><br><span class="line">        <span class="keyword">if</span> (freqToKeys.get(freq).isEmpty()) &#123;</span><br><span class="line">            freqToKeys.remove(freq);</span><br><span class="line">            <span class="comment">// 如果这个 freq 恰好是 minFreq，更新 minFreq</span></span><br><span class="line">            <span class="keyword">if</span> (freq == <span class="built_in">this</span>.minFreq) &#123;</span><br><span class="line">                <span class="built_in">this</span>.minFreq++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新某个 <code>key</code> 的 <code>freq</code> 肯定会涉及 <code>FK</code> 表和 <code>KF</code> 表，所以我们分别更新这两个表就行了。</p><p>和之前类似，当 <code>FK</code> 表中 <code>freq</code> 对应的列表被删空后，需要删除 <code>FK</code> 表中 <code>freq</code> 这个映射。如果这个 <code>freq</code> 恰好是 <code>minFreq</code>，说明 <code>minFreq</code> 变量需要更新。</p><p>能不能快速找到当前的 <code>minFreq</code> 呢？这里是可以的，因为之前修改的那个 <code>key</code> 依然是目前出现频率最小的 <code>key</code>，所以 <code>minFreq</code> 也加 1 就行了。</p><p>至此，经过层层拆解，LFU 算法就完成了。更多数据结构设计相关的题目参见 <a href="https://labuladong.gitee.io/article/fname.html?fname=%E8%AE%BE%E8%AE%A1%E9%A2%98%E7%9B%AE">数据结构设计经典习题open in new window</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划穷举的两种视角</title>
      <link href="/posts/5236.html"/>
      <url>/posts/5236.html</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划穷举的两种视角"><a href="#动态规划穷举的两种视角" class="headerlink" title="动态规划穷举的两种视角"></a>动态规划穷举的两种视角</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/distinct-subsequences/">115. Distinct Subsequencesopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/distinct-subsequences/">115. 不同的子序列open in new window</a></td><td align="center">🔴</td></tr><tr><td align="center">-</td><td align="center"><a href="https://leetcode.cn/problems/21dk04/">剑指 Offer II 097. 子序列的数目open in new window</a></td><td align="center">🔴</td></tr></tbody></table><p>挺久没写动态规划相关的题目了，本文我带大家复习一下动态规划相关问题的一系列解题套路，然后着重讨论一下动态规划穷举时不同视角的问题。</p><h3 id="动态规划解题组合拳"><a href="#动态规划解题组合拳" class="headerlink" title="#动态规划解题组合拳"></a><a href="https://labuladong.online/algo/dynamic-programming/two-views-of-dp/#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E7%BB%84%E5%90%88%E6%8B%B3">#</a>动态规划解题组合拳</h3><p>首先，前文 <a href="https://labuladong.online/algo/essential-technique/algorithm-summary/">我的刷题心得</a> 讲了，我们刷的算法问题的本质是「穷举」，动态规划问题也不例外，你必须想办法穷举所有可能的解，然后从中筛选出符合题目要求的解。</p><p>另外，动态规划问题穷举的过程中会出现重叠子问题导致的冗余计算，所以前文 <a href="https://labuladong.online/algo/essential-technique/dynamic-programming-framework/">动态规划核心套路框架</a> 中告诉你如何一步一步把暴力穷举解法优化成效率更高的动态规划解法。</p><p>然而，想要写出暴力解需要依据状态转移方程，状态转移方程是动态规划的解题核心，可不是那么容易想出来的。不过，前文 <a href="https://labuladong.online/algo/dynamic-programming/longest-increasing-subsequence/">动态规划设计：数学归纳法</a> 告诉你，思考状态转移方程的一个基本方法是数学归纳法，即明确 <code>dp</code> 函数或数组的定义，然后使用这个定义，从已知的「状态」中推导出未知的「状态」。</p><p>还没完，比如 <a href="https://labuladong.online/algo/dynamic-programming/egg-drop/">高楼扔鸡蛋问题</a> 中对 <code>dp</code> 函数&#x2F;数组的定义不见得是唯一的，不同的定义会导致状态转移方程发生变化，解题效率也有高低之分，所以我们应该给 <code>dp</code> 函数尽可能想出更合适的定义来解题。</p><p><strong>接下来就是本文要着重探讨的问题了：就算 <code>dp</code> 函数&#x2F;数组的定义相同，如果你使用不同的「视角」进行穷举，效率也不见得是相同的</strong>。</p><p>关于穷举「视角」的问题，后文 <a href="https://labuladong.online/algo/practice-in-action/partition-to-k-equal-sum-subsets/">回溯算法穷举视角：子集划分问题</a> 讲了回溯算法中不同的穷举视角导致的不同解法，其实这种视角的切换在动态规划类型问题中依然存在。前文对排列的举例非常有助于你理解穷举视角的问题，这里再简单提一下。</p><p>🌟</p><hr><p>🌟</p><h3 id="排列问题的两种视角"><a href="#排列问题的两种视角" class="headerlink" title="#排列问题的两种视角"></a><a href="https://labuladong.online/algo/dynamic-programming/two-views-of-dp/#%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%A7%86%E8%A7%92">#</a>排列问题的两种视角</h3><p>我们先回顾一下以前学过的排列组合知识：</p><p>1、<code>P(n, k)</code>（也有很多书写成 <code>A(n, k)</code>）表示从 <code>n</code> 个不同元素中拿出 <code>k</code> 个元素的排列（Permutation&#x2F;Arrangement）；<code>C(n, k)</code> 表示从 <code>n</code> 个不同元素中拿出 <code>k</code> 个元素的组合（Combination）总数。</p><p>2、「排列」和「组合」的主要区别在于是否考虑顺序的差异。</p><p>3、排列和组合总数的计算公式如下：</p><p><img src="https://labuladong.online/algo/images/%E9%9B%86%E5%90%88%E5%88%92%E5%88%86/math.png" alt="img"></p><p>好，现在我问一个问题，这个排列公式 <code>P(n, k)</code> 是如何推导出来的？为了搞清楚这个问题，我需要讲一点组合数学的知识。</p><p>排列组合问题的各种变体都可以抽象成「球盒模型」，<code>P(n, k)</code> 就可以抽象成下面这个场景：</p><p><img src="https://labuladong.online/algo/images/%E9%9B%86%E5%90%88%E5%88%92%E5%88%86/7.jpeg" alt="img"></p><p>即，将 <code>n</code> 个标记了不同序号的球（标号为了体现顺序的差异），放入 <code>k</code> 个标记了不同序号的盒子中（其中 <code>n &gt;= k</code>，每个盒子最终都装有恰好一个球），共有 <code>P(n, k)</code> 种不同的方法。</p><p>现在你来，往盒子里放球，你怎么放？其实有两种视角。</p><p><strong>首先，你可以站在盒子的视角</strong>，每个盒子必然要选择一个球。</p><p>这样，第一个盒子可以选择 <code>n</code> 个球中的任意一个，然后你需要让剩下 <code>k - 1</code> 个盒子在 <code>n - 1</code> 个球中选择：</p><p><img src="https://labuladong.online/algo/images/%E9%9B%86%E5%90%88%E5%88%92%E5%88%86/8.jpeg" alt="img"></p><p><strong>另外，你也可以站在球的视角</strong>，因为并不是每个球都会被装进盒子，所以球的视角分两种情况：</p><p>1、第一个球可以不装进任何一个盒子，这样的话你就需要将剩下 <code>n - 1</code> 个球放入 <code>k</code> 个盒子。</p><p>2、第一个球可以装进 <code>k</code> 个盒子中的任意一个，这样的话你就需要将剩下 <code>n - 1</code> 个球放入 <code>k - 1</code> 个盒子。</p><p>结合上述两种情况，可以得到：</p><p><img src="https://labuladong.online/algo/images/%E9%9B%86%E5%90%88%E5%88%92%E5%88%86/9.jpeg" alt="img"></p><p>你看，两种视角得到两个不同的递归式，但这两个递归式解开的结果都是我们熟知的阶乘形式：</p><p><img src="https://labuladong.online/algo/images/%E9%9B%86%E5%90%88%E5%88%92%E5%88%86/math1.png" alt="img"></p><p>至于如何解递归式，涉及数学的内容比较多，这里就不做深入探讨了，有兴趣的读者可以自行学习组合数学相关知识。</p><p>当然，以上只是纯数学的推导，<code>P(n, k)</code> 的计算结果也仅仅是一个数字，所以以上两种穷举视角从数学上讲没什么差异。但从编程的角度来看，如果让你计算出来所有排列结果，那么两种穷举思路的代码实现可能会产生性能上的差异，因为有的穷举思路难免会使用额外的 for 循环拖慢效率，这也是后文 <a href="https://labuladong.online/algo/practice-in-action/partition-to-k-equal-sum-subsets/">回溯算法穷举视角：子集划分问题</a> 主要探讨的。</p><p>本文不讲回溯算法和排列组合，不过请你记住这个例子，待会会把这种穷举视角的差异运用到动态规划题目当中。</p><h3 id="例题分析"><a href="#例题分析" class="headerlink" title="#例题分析"></a><a href="https://labuladong.online/algo/dynamic-programming/two-views-of-dp/#%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90">#</a>例题分析</h3><p>看一下力扣第 115 题「<a href="https://leetcode.cn/problems/distinct-subsequences/">不同的子序列open in new window</a>」：给你输入一个字符串 <code>s</code> 和一个字符串 <code>t</code>，请你计算在 <code>s</code> 的子序列中 <code>t</code> 出现的次数。比如题目给的例子，输入 <code>s = &quot;babgbag&quot;, t = &quot;bag&quot;</code>，算法返回 5：</p><p><img src="https://labuladong.online/algo/images/%E5%8A%A8%E5%BD%92%E4%B8%A4%E7%A7%8D%E8%A7%86%E8%A7%92/example.jpg" alt="img"></p><p>函数签名如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span>;</span><br></pre></td></tr></table></figure><p>你要数一数 <code>s</code> 的子序列中有多少个 <code>t</code>，说白了就是穷举嘛，那么首先想到的就是能不能把原问题分解成规模更小的子问题，然后通过子问题的答案推导出原问题的答案。</p><p>首先，我们可以这样定义一个 <code>dp</code> 函数：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：s[i..] 的子序列中 t[j..] 出现的次数为 dp(s, i, t, j)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(String s, <span class="type">int</span> i, String t, <span class="type">int</span> j)</span></span><br></pre></td></tr></table></figure><p>这道题对 <code>dp</code> 函数的定义很简单直接，题目让你求出现次数，那你就定义函数返回值为出现次数就可以。</p><p>有了这个 <code>dp</code> 函数，题目想要的结果是 <code>dp(s, 0, t, 0)</code>，base case 也很容易写出来，解法框架如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dp(s, <span class="number">0</span>, t, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义：s[i..] 的子序列中 t[j..] 出现的次数为 dp(s, i, t, j)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(String s, <span class="type">int</span> i, String t, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="comment">// base case 1</span></span><br><span class="line">    <span class="keyword">if</span> (j == t.length()) &#123;</span><br><span class="line">        <span class="comment">// t 已经全部匹配完成</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// base case 2</span></span><br><span class="line">    <span class="keyword">if</span> (s.length() - i &lt; t.length() - j) &#123;</span><br><span class="line">        <span class="comment">// s[i..] 比 t[j..] 还短，必然没有匹配的子序列</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好，接下来开始思考如何利用这个 <code>dp</code> 函数将大问题分解成小问题，即如何写出状态转移方程进行穷举。</p><p><strong>回顾一下之前讲的排列组合的「球盒模型」，这里是不是很类似？<code>t</code> 中的若干字符就好像若干盒子，<code>s</code> 中的若干字符就好像若干小球，你需要做的就是给所有盒子都装一个小球。所以这里就有两种穷举思路了，分别是站在 <code>t</code> 的视角（盒子选择小球）和站在 <code>s</code> 的视角（小球选择盒子）</strong>。</p><p><strong>视角一，站在 <code>t</code> 的角度进行穷举</strong>：</p><p>我们的原问题是求 <code>s[0..]</code> 的所有子序列中 <code>t[0..]</code> 出现的次数，那么可以先看 <code>t[0]</code> 在 <code>s</code> 中的什么位置，假设 <code>s[2], s[6]</code> 是字符 <code>t[0]</code>，那么原问题转化成了在 <code>s[3..]</code> 和 <code>s[7..]</code> 的所有子序列中计算 <code>t[1..]</code> 出现的次数。</p><p>写成比较偏数学的形式就是状态转移方程：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 定义：s[i..] 的子序列中 t[j..] 出现的次数为 dp(s, i, t, j)</span></span><br><span class="line">dp(s, i, t, j) <span class="operator">=</span> <span class="built_in">SUM</span>( dp(s, k <span class="operator">+</span> <span class="number">1</span>, t, j <span class="operator">+</span> <span class="number">1</span>) <span class="keyword">where</span> k <span class="operator">&gt;=</span> i <span class="keyword">and</span> s[k] <span class="operator">=</span><span class="operator">=</span> t[j] )</span><br></pre></td></tr></table></figure><p>翻译成代码大致就是这个思路：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：s[i..] 的子序列中 t[j..] 出现的次数为 dp(s, i, t, j)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(String s, <span class="type">int</span> i, String t, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 在 s[i..] 中寻找 k，使得 s[k] == t[j]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i; k &lt; s.length(); k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(k) == t.charAt(j)) &#123;</span><br><span class="line">            <span class="comment">// 累加结果</span></span><br><span class="line">            res += dp(s, k + <span class="number">1</span>, t, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个思路应该不难理解吧，当然还可以加上备忘录消除重叠子问题，最终解法如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 备忘录</span></span><br><span class="line">    <span class="type">int</span>[][] memo;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化备忘录为特殊值 -1</span></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()][t.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : memo) &#123;</span><br><span class="line">            Arrays.fill(row, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp(s, <span class="number">0</span>, t, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：s[i..] 的子序列中 t[j..] 出现的次数为 dp(s, i, t, j)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">dp</span><span class="params">(String s, <span class="type">int</span> i, String t, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="comment">// base case 1</span></span><br><span class="line">        <span class="keyword">if</span> (j == t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// base case 2</span></span><br><span class="line">        <span class="keyword">if</span> (s.length() - i &lt; t.length() - j) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查备忘录防止冗余计算</span></span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 执行状态转移方程</span></span><br><span class="line">        <span class="comment">// 在 s[i..] 中寻找 k，使得 s[k] == t[j]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i; k &lt; s.length(); k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(k) == t.charAt(j)) &#123;</span><br><span class="line">                <span class="comment">// 累加结果</span></span><br><span class="line">                res += dp(s, k + <span class="number">1</span>, t, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存入备忘录</span></span><br><span class="line">        memo[i][j] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题就解决了，不过效率不算很高，我们可以粗略估算一下这个算法的时间复杂度上界，其中 <code>M, N</code> 分别代表 <code>s, t</code> 的长度，算法的「状态」就是 <code>dp</code> 函数参数 <code>i, j</code> 的组合：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  带备忘录的动态规划算法的时间复杂度 </span><br><span class="line">= 子问题的个数 x 函数本身的时间复杂度 </span><br><span class="line">= 「状态」的个数 x 函数本身的时间复杂度 </span><br><span class="line">= O(MN) * O(M)</span><br><span class="line">= O(N * M^<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>当然，因为 for 循环的复杂度不总是 O(M) 且子问题个数肯定小于 O(MN)，所以这是复杂度的粗略上界。不过根据前文 <a href="https://labuladong.online/algo/essential-technique/complexity-analysis/">算法时空复杂度使用指南</a> 的描述，这个上界还是说明这个算法的复杂度有些偏高。主要高在哪里呢？对「状态」的穷举已经有了 <code>memo</code> 备忘录的优化，所以 O(MN) 的复杂度是必不可少的，关键问题出在 <code>dp</code> 函数中的 for 循环。</p><p>是否可以优化掉 <code>dp</code> 函数中的 for 循环呢？可以的，这就需要另一种穷举视角来解决这个问题。</p><p><strong>视角二，站在 <code>s</code> 的角度进行穷举</strong>：</p><p>我们的原问题是计算 <code>s[0..]</code> 的所有子序列中 <code>t[0..]</code> 出现的次数，可以先看看 <code>s[0]</code> 是否能匹配 <code>t[0]</code>，如果不匹配，那没得说，原问题就可以转化为计算 <code>s[1..]</code> 的所有子序列中 <code>t[0..]</code> 出现的次数；</p><p>但如果 <code>s[0]</code> 可以匹配 <code>t[0]</code>，那么又有两种情况，这两种情况是累加的关系：</p><p>1、让 <code>s[0]</code> 匹配 <code>t[0]</code>，那么原问题转化为在 <code>s[1..]</code> 的所有子序列中计算 <code>t[1..]</code> 出现的次数。</p><p>2、不让 <code>s[0]</code> 匹配 <code>t[0]</code>，那么原问题转化为在 <code>s[1..]</code> 的所有子序列中计算 <code>t[0..]</code> 出现的次数。</p><p>为啥明明 <code>s[0]</code> 可以匹配 <code>t[0]</code>，还不让它俩匹配呢？主要是为了给 <code>s[0]</code> 之后的元素匹配的机会，比如 <code>s = &quot;aab&quot;, t = &quot;ab&quot;</code>，就有两种匹配方式：<code>a_b</code> 和 <code>_ab</code>。</p><p>把以上思路写成状态转移方程：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：s[i..] 的子序列中 t[j..] 出现的次数为 dp(s, i, t, j)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(String s, <span class="type">int</span> i, String t, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">        <span class="comment">// 匹配，两种情况，累加关系</span></span><br><span class="line">        <span class="keyword">return</span> dp(s, i + <span class="number">1</span>, t, j + <span class="number">1</span>) + dp(s, i + <span class="number">1</span>, t, j);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不匹配，在 s[i+1..] 的子序列中计算 t[j..] 的出现次数</span></span><br><span class="line">        <span class="keyword">return</span> dp(s, i + <span class="number">1</span>, t, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依照这个思路，再加个备忘录消除重叠子问题，可以写出如下解法：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] memo;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化备忘录为特殊值 -1</span></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()][t.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : memo) &#123;</span><br><span class="line">            Arrays.fill(row, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp(s, <span class="number">0</span>, t, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：s[i..] 的子序列中 t[j..] 出现的次数为 dp(s, i, t, j)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">dp</span><span class="params">(String s, <span class="type">int</span> i, String t, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="comment">// base case 1</span></span><br><span class="line">        <span class="keyword">if</span> (j == t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// base case 2</span></span><br><span class="line">        <span class="keyword">if</span> (s.length() - i &lt; t.length() - j) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查备忘录防止冗余计算</span></span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 执行状态转移方程</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == t.charAt(j)) &#123;</span><br><span class="line">            <span class="comment">// 匹配，两种情况，累加关系</span></span><br><span class="line">            res += dp(s, i + <span class="number">1</span>, t, j + <span class="number">1</span>) + dp(s, i + <span class="number">1</span>, t, j);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不匹配，在 s[i+1..] 的子序列中计算 t[j..] 的出现次数</span></span><br><span class="line">            res += dp(s, i + <span class="number">1</span>, t, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结果存入备忘录</span></span><br><span class="line">        memo[i][j] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details data-v-fb30874b="" id="div_distinct-subsequences" class="hint-container details" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1.6em 0px; padding: 1rem 0px 0px; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary data-v-fb30874b="" style="position: relative; margin: -1.5rem 0px -0.5rem; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer; display: flex; align-items: center; font-size: large;"><strong data-v-fb30874b="" style="font-weight: 600;">🎃 代码可视化动画 🎃</strong><span data-v-fb30874b="" class="font-icon icon iconfont icon-resize" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-left: auto; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-refresh" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-link" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle;"></span></summary><div data-v-fb30874b="" class="resizable" style="width: 774.091px; max-width: 100%; height: 70vh; max-height: 70vh; overflow: auto; resize: both;"><iframe data-v-fb30874b="" id="iframe_distinct-subsequences" src="https://labuladong.online/algo-visualize/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>这个解法中 <code>dp</code> 函数递归的次数，即状态 <code>i, j</code> 的不同组合的个数为 O(MN)，而 <code>dp</code> 函数本身没有 for 循环，即时间复杂度为 O(1)，所以算法总的时间复杂度就是 O(MN)，比刚才的解法要好一些，你提交这个解法代码，耗时明显比刚才的解法少一些。</p><p>至此，这道题就分析完了。我们分别站在 <code>t</code> 的视角和 <code>s</code> 的视角运用 <code>dp</code> 函数的定义进行穷举，得出两种完全不同但都是正确的状态转移逻辑，不过两种逻辑在代码实现上有效率的差异。</p><p>那么不妨进一步思考一下，什么样的动态规划题目可能产生「穷举视角」上的差异？换句话说，什么样的动态规划问题能够抽象成经典的「球盒模型」呢？如果你有思考，欢迎留言和我探讨。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分搜索怎么用？我又总结了套路</title>
      <link href="/posts/64908.html"/>
      <url>/posts/64908.html</url>
      
        <content type="html"><![CDATA[<h1 id="二分搜索怎么用？我又总结了套路"><a href="#二分搜索怎么用？我又总结了套路" class="headerlink" title="二分搜索怎么用？我又总结了套路"></a>二分搜索怎么用？我又总结了套路</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/">1011. Capacity To Ship Packages Within D Daysopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/">1011. 在 D 天内送达包裹的能力open in new window</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/split-array-largest-sum/">410. Split Array Largest Sumopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/split-array-largest-sum/">410. 分割数组的最大值open in new window</a></td><td align="center">🔴</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/koko-eating-bananas/">875. Koko Eating Bananasopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/koko-eating-bananas/">875. 爱吃香蕉的珂珂open in new window</a></td><td align="center">🟠</td></tr><tr><td align="center">-</td><td align="center"><a href="https://leetcode.cn/problems/nZZqjQ/">剑指 Offer II 073. 狒狒吃香蕉open in new window</a></td><td align="center">🟠</td></tr></tbody></table><p>我们前文 <a href="https://labuladong.online/algo/essential-technique/binary-search-framework/">我写了首诗，把二分搜索变成了默写题</a> 详细介绍了二分搜索的细节问题，探讨了「搜索一个元素」，「搜索左侧边界」，「搜索右侧边界」这三个情况，教你如何写出正确无 bug 的二分搜索算法。</p><p><strong>但是前文总结的二分搜索代码框架仅仅局限于「在有序数组中搜索指定元素」这个基本场景，具体的算法问题没有这么直接，可能你都很难看出这个问题能够用到二分搜索</strong>。</p><p>所以本文就来总结一套二分搜索算法运用的框架套路，帮你在遇到二分搜索算法相关的实际问题时，能够有条理地思考分析，步步为营，写出答案。</p><h3 id="原始的二分搜索代码"><a href="#原始的二分搜索代码" class="headerlink" title="#原始的二分搜索代码"></a><a href="https://labuladong.online/algo/frequency-interview/binary-search-in-action/#%E5%8E%9F%E5%A7%8B%E7%9A%84%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E4%BB%A3%E7%A0%81">#</a>原始的二分搜索代码</h3><p>二分搜索的原型就是在「<strong>有序数组</strong>」中搜索一个元素 <code>target</code>，返回该元素对应的索引。</p><p>如果该元素不存在，那可以返回一个什么特殊值，这种细节问题只要微调算法实现就可实现。</p><p>还有一个重要的问题，如果「<strong>有序数组</strong>」中存在多个 <code>target</code> 元素，那么这些元素肯定挨在一起，这里就涉及到算法应该返回最左侧的那个 <code>target</code> 元素的索引还是最右侧的那个 <code>target</code> 元素的索引，也就是所谓的「搜索左侧边界」和「搜索右侧边界」，这个也可以通过微调算法的代码来实现。</p><p><strong>我们前文 <a href="https://labuladong.online/algo/essential-technique/binary-search-framework/">我写了首诗，把二分搜索变成了默写题</a> 详细探讨了上述问题，对这块还不清楚的读者建议复习前文</strong>，已经搞清楚基本二分搜索算法的读者可以继续看下去。</p><p><strong>在具体的算法问题中，常用到的是「搜索左侧边界」和「搜索右侧边界」这两种场景</strong>，很少有让你单独「搜索一个元素」。</p><p>因为算法题一般都让你求最值，比如让你求吃香蕉的「最小速度」，让你求轮船的「最低运载能力」，求最值的过程，必然是搜索一个边界的过程，所以后面我们就详细分析一下这两种搜索边界的二分算法代码。</p><p>注</p><p>注意，本文我写的都是左闭右开的二分搜索写法，如果你习惯两端都闭的写法，可以自行改写代码。</p><p>「搜索左侧边界」的二分搜索算法的具体代码实现如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 搜索左侧边界</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">left_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 当找到 target 时，收缩右侧边界</span></span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设输入的数组 <code>nums = [1,2,3,3,3,5,7]</code>，想搜索的元素 <code>target = 3</code>，那么算法就会返回索引 2。</p><p>如果画一个图，就是这样：</p><p><img src="https://labuladong.online/algo/images/%E4%BA%8C%E5%88%86%E8%BF%90%E7%94%A8/1.jpeg" alt="img"></p><p>「搜索右侧边界」的二分搜索算法的具体代码实现如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 搜索右侧边界</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">right_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 当找到 target 时，收缩左侧边界</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入同上，那么算法就会返回索引 4，如果画一个图，就是这样：</p><p><img src="https://labuladong.online/algo/images/%E4%BA%8C%E5%88%86%E8%BF%90%E7%94%A8/2.jpeg" alt="img"></p><p>好，上述内容都属于复习，我想读到这里的读者应该都能理解。记住上述的图像，所有能够抽象出上述图像的问题，都可以使用二分搜索解决。</p><p>🌟</p><hr><p>🌟</p><h3 id="二分搜索问题的泛化"><a href="#二分搜索问题的泛化" class="headerlink" title="#二分搜索问题的泛化"></a><a href="https://labuladong.online/algo/frequency-interview/binary-search-in-action/#%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E9%97%AE%E9%A2%98%E7%9A%84%E6%B3%9B%E5%8C%96">#</a>二分搜索问题的泛化</h3><p>什么问题可以运用二分搜索算法技巧？</p><p>**首先，你要从题目中抽象出一个自变量 <code>x</code>，一个关于 <code>x</code> 的函数 <code>f(x)</code>，以及一个目标值 <code>target</code>**。</p><p>同时，<code>x, f(x), target</code> 还要满足以下条件：</p><p><strong>1、<code>f(x)</code> 必须是在 <code>x</code> 上的单调函数（单调增单调减都可以）</strong>。</p><p><strong>2、题目是让你计算满足约束条件 <code>f(x) == target</code> 时的 <code>x</code> 的值</strong>。</p><p>上述规则听起来有点抽象，来举个具体的例子：</p><p>给你一个升序排列的有序数组 <code>nums</code> 以及一个目标元素 <code>target</code>，请你计算 <code>target</code> 在数组中的索引位置，如果有多个目标元素，返回最小的索引。</p><p>这就是「搜索左侧边界」这个基本题型，解法代码之前都写了，但这里面 <code>x, f(x), target</code> 分别是什么呢？</p><p>我们可以把数组中元素的索引认为是自变量 <code>x</code>，函数关系 <code>f(x)</code> 就可以这样设定：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数 f(x) 是关于自变量 x 的单调递增函数</span></span><br><span class="line"><span class="comment">// 入参 nums 是不会改变的，所以可以忽略，不算自变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nums[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这个函数 <code>f</code> 就是在访问数组 <code>nums</code>，因为题目给我们的数组 <code>nums</code> 是升序排列的，所以函数 <code>f(x)</code> 就是在 <code>x</code> 上单调递增的函数。</p><p>最后，题目让我们求什么来着？是不是让我们计算元素 <code>target</code> 的最左侧索引？</p><p>是不是就相当于在问我们「满足 <code>f(x) == target</code> 的 <code>x</code> 的最小值是多少」？</p><p>画个图，如下：</p><p><img src="https://labuladong.online/algo/images/%E4%BA%8C%E5%88%86%E8%BF%90%E7%94%A8/3.jpeg" alt="img"></p><p><strong>如果遇到一个算法问题，能够把它抽象成这幅图，就可以对它运用二分搜索算法</strong>。</p><p>算法代码如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数 f 是关于自变量 x 的单调递增函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nums[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">left_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (f(mid, nums) == target) &#123;</span><br><span class="line">            <span class="comment">// 当找到 target 时，收缩右侧边界</span></span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f(mid, nums) &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f(mid, nums) &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码把之前的代码微调了一下，把直接访问 <code>nums[mid]</code> 套了一层函数 <code>f</code>，其实就是多此一举，但是，这样能抽象出二分搜索思想在具体算法问题中的框架。</p><h3 id="运用二分搜索的套路框架"><a href="#运用二分搜索的套路框架" class="headerlink" title="#运用二分搜索的套路框架"></a><a href="https://labuladong.online/algo/frequency-interview/binary-search-in-action/#%E8%BF%90%E7%94%A8%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%9A%84%E5%A5%97%E8%B7%AF%E6%A1%86%E6%9E%B6">#</a>运用二分搜索的套路框架</h3><p>想要运用二分搜索解决具体的算法问题，可以从以下代码框架着手思考：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数 f 是关于自变量 x 的单调函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数，在 f(x) == target 的约束下求 x 的最值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 问自己：自变量 x 的最小值是多少？</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> ...;</span><br><span class="line">    <span class="comment">// 问自己：自变量 x 的最大值是多少？</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> ... + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (f(mid) == target) &#123;</span><br><span class="line">            <span class="comment">// 问自己：题目是求左边界还是右边界？</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f(mid) &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 问自己：怎么让 f(x) 大一点？</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f(mid) &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 问自己：怎么让 f(x) 小一点？</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体来说，想要用二分搜索算法解决问题，分为以下几步：</p><p><strong>1、确定 <code>x, f(x), target</code> 分别是什么，并写出函数 <code>f</code> 的代码</strong>。</p><p><strong>2、找到 <code>x</code> 的取值范围作为二分搜索的搜索区间，初始化 <code>left</code> 和 <code>right</code> 变量</strong>。</p><p><strong>3、根据题目的要求，确定应该使用搜索左侧还是搜索右侧的二分搜索算法，写出解法代码</strong>。</p><p>下面用几道例题来讲解这个流程。</p><h3 id="例题一、珂珂吃香蕉"><a href="#例题一、珂珂吃香蕉" class="headerlink" title="#例题一、珂珂吃香蕉"></a><a href="https://labuladong.online/algo/frequency-interview/binary-search-in-action/#%E4%BE%8B%E9%A2%98%E4%B8%80%E3%80%81%E7%8F%82%E7%8F%82%E5%90%83%E9%A6%99%E8%95%89">#</a>例题一、珂珂吃香蕉</h3><p>这是力扣第 875 题「<a href="https://leetcode.cn/problems/koko-eating-bananas/">爱吃香蕉的珂珂open in new window</a>」：</p><details class="hint-container details" open="" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1rem 0px; padding: 1.5rem; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary style="position: relative; margin: -1.5rem -1.5rem 0.5em; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer;"><strong style="font-weight: 600;">875. 爱吃香蕉的珂珂</strong>&nbsp;|<span>&nbsp;</span><a target="_blank" href="https://leetcode.cn/problems/koko-eating-bananas/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|<span>&nbsp;</span><a target="_blank" href="https://leetcode.com/problems/koko-eating-bananas/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">珂珂喜欢吃香蕉。这里有<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">n</code><span>&nbsp;</span>堆香蕉，第<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">i</code><span>&nbsp;</span>堆中有&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">piles[i]</code>&nbsp;根香蕉。警卫已经离开了，将在<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">h</code><span>&nbsp;</span>小时后回来。</p><p style="line-height: 1.6; overflow-wrap: break-word;">珂珂可以决定她吃香蕉的速度<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">k</code><span>&nbsp;</span>（单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">k</code><span>&nbsp;</span>根。如果这堆香蕉少于<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">k</code><span>&nbsp;</span>根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。&nbsp;&nbsp;</p><p style="line-height: 1.6; overflow-wrap: break-word;">珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p style="line-height: 1.6; overflow-wrap: break-word;">返回她可以在<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">h</code><span>&nbsp;</span>小时内吃掉所有香蕉的最小速度<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">k</code>（<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">k</code><span>&nbsp;</span>为整数）。</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>piles = [3,6,7,11], h = 8<strong style="font-weight: 600;">输出：</strong>4</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>piles = [30,11,23,4,20], h = 5<strong style="font-weight: 600;">输出：</strong>30</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>piles = [30,11,23,4,20], h = 6<strong style="font-weight: 600;">输出：</strong>23</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 &lt;= piles.length &lt;= 10<sup>4</sup></code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">piles.length &lt;= h &lt;= 10<sup>9</sup></code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 &lt;= piles[i] &lt;= 10<sup>9</sup></code></li></ul></div></details><p>珂珂每小时最多只能吃一堆香蕉，如果吃不完的话留到下一小时再吃；如果吃完了这一堆还有胃口，也只会等到下一小时才会吃下一堆。</p><p>他想在警卫回来之前吃完所有香蕉，让我们确定吃香蕉的**最小速度 <code>K</code>**。函数签名如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minEatingSpeed</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> H)</span>;</span><br></pre></td></tr></table></figure><p>那么，对于这道题，如何运用刚才总结的套路，写出二分搜索解法代码？</p><p>按步骤思考即可：</p><p><strong>1、确定 <code>x, f(x), target</code> 分别是什么，并写出函数 <code>f</code> 的代码</strong>。</p><p>自变量 <code>x</code> 是什么呢？回忆之前的函数图像，二分搜索的本质就是在搜索自变量。</p><p>所以，题目让求什么，就把什么设为自变量，珂珂吃香蕉的速度就是自变量 <code>x</code>。</p><p>那么，在 <code>x</code> 上单调的函数关系 <code>f(x)</code> 是什么？</p><p>显然，吃香蕉的速度越快，吃完所有香蕉堆所需的时间就越少，速度和时间就是一个单调函数关系。</p><p>所以，<code>f(x)</code> 函数就可以这样定义：</p><p>若吃香蕉的速度为 <code>x</code> 根&#x2F;小时，则需要 <code>f(x)</code> 小时吃完所有香蕉。</p><p>代码实现如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：速度为 x 时，需要 f(x) 小时吃完所有香蕉</span></span><br><span class="line"><span class="comment">// f(x) 随着 x 的增加单调递减</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">hours</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; piles.length; i++) &#123;</span><br><span class="line">        hours += piles[i] / x;</span><br><span class="line">        <span class="keyword">if</span> (piles[i] % x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            hours++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hours;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关信息</p><p>为什么 <code>f(x)</code> 的返回值是 <code>long</code> 类型？因为你注意题目给的数据范围和 <code>f</code> 函数的逻辑。<code>piles</code> 数组中元素的最大值是 10^9，最多有 10^4 个元素；那么当 <code>x</code> 取值为 1 时，<code>hours</code> 变量就会被加到 10^13 这个数量级，超过了 <code>int</code> 类型的最大值（大概 2x10^9 这个量级），所以这里用 <code>long</code> 类型避免可能出现的整型溢出。</p><p><code>target</code> 就很明显了，吃香蕉的时间限制 <code>H</code> 自然就是 <code>target</code>，是对 <code>f(x)</code> 返回值的最大约束。</p><p><strong>2、找到 <code>x</code> 的取值范围作为二分搜索的搜索区间，初始化 <code>left</code> 和 <code>right</code> 变量</strong>。</p><p>珂珂吃香蕉的速度最小是多少？多大是多少？</p><p>显然，最小速度应该是 1，最大速度是 <code>piles</code> 数组中元素的最大值，因为每小时最多吃一堆香蕉，胃口再大也白搭嘛。</p><p>这里可以有两种选择，要么你用一个 for 循环去遍历 <code>piles</code> 数组，计算最大值，要么你看题目给的约束，<code>piles</code> 中的元素取值范围是多少，然后给 <code>right</code> 初始化一个取值范围之外的值。</p><p>我选择第二种，题目说了 <code>1 &lt;= piles[i] &lt;= 10^9</code>，那么我就可以确定二分搜索的区间边界：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minEatingSpeed</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> H)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 注意，我选择左闭右开的二分搜索写法，right 是开区间，所以再加一</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1000000000</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们二分搜索是对数级别的复杂度，所以 <code>right</code> 就算是个很大的值，算法的效率依然很高。</p><p><strong>3、根据题目的要求，确定应该使用搜索左侧还是搜索右侧的二分搜索算法，写出解法代码</strong>。</p><p>现在我们确定了自变量 <code>x</code> 是吃香蕉的速度，<code>f(x)</code> 是单调递减的函数，<code>target</code> 就是吃香蕉的时间限制 <code>H</code>，题目要我们计算最小速度，也就是 <code>x</code> 要尽可能小：</p><p><img src="https://labuladong.online/algo/images/%E4%BA%8C%E5%88%86%E8%BF%90%E7%94%A8/4.jpeg" alt="img"></p><p>这就是搜索左侧边界的二分搜索嘛，不过注意 <code>f(x)</code> 是单调递减的，不要闭眼睛套框架，需要结合上图进行思考，写出代码：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minEatingSpeed</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> H)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1000000000</span> + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (f(piles, mid) == H) &#123;</span><br><span class="line">            <span class="comment">// 搜索左侧边界，则需要收缩右侧边界</span></span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f(piles, mid) &lt; H) &#123;</span><br><span class="line">            <span class="comment">// 需要让 f(x) 的返回值大一些</span></span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f(piles, mid) &gt; H) &#123;</span><br><span class="line">            <span class="comment">// 需要让 f(x) 的返回值小一些</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details data-v-fb30874b="" id="div_koko-eating-bananas" class="hint-container details" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1.6em 0px; padding: 1rem 0px 0px; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary data-v-fb30874b="" style="position: relative; margin: -1.5rem 0px -0.5rem; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer; display: flex; align-items: center; font-size: large;"><strong data-v-fb30874b="" style="font-weight: 600;">🌈 代码可视化动画 🌈</strong><span data-v-fb30874b="" class="font-icon icon iconfont icon-resize" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-left: auto; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-refresh" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-link" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle;"></span></summary><div data-v-fb30874b="" class="resizable" style="width: 774.091px; max-width: 100%; height: 70vh; max-height: 70vh; overflow: auto; resize: both;"><iframe data-v-fb30874b="" id="iframe_koko-eating-bananas" src="https://labuladong.online/algo-visualize/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>提示</p><p>我这里采用的是左闭右开的二分搜索写法，关于这个算法中的细节问题，前文 <a href="https://labuladong.online/algo/essential-technique/binary-search-framework/">二分搜索算法详解</a> 进行了详细分析，这里不展开了。</p><p>至此，这道题就解决了。我们代码框架中多余的 if 分支主要是帮助理解的，写出正确解法后建议合并多余的分支，可以提高算法运行的效率：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minEatingSpeed</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> H)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1000000000</span> + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (f(piles, mid) &lt;= H) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f(x) 随着 x 的增加单调递减</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// 见上文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>肯定有读者会尝试使用前文 <a href="https://labuladong.online/algo/essential-technique/binary-search-framework/">二分搜索算法详解</a> 介绍的两端都闭的二分搜索框架来写解法，其实简单，只要修改 <code>right</code> 的初始值和 <code>right</code> 更新的逻辑即可：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两端都闭的二分搜索写法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">minEatingSpeed</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> H)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// right 是闭区间，所以这里改成最大取值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// right 是闭区间，所以这里改成 &lt;=</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (f(piles, mid) &lt;= H) &#123;</span><br><span class="line">            <span class="comment">// right 是闭区间，所以这里用 mid - 1</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f(x) 随着 x 的增加单调递减</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// 见上文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题二、运送货物"><a href="#例题二、运送货物" class="headerlink" title="#例题二、运送货物"></a><a href="https://labuladong.online/algo/frequency-interview/binary-search-in-action/#%E4%BE%8B%E9%A2%98%E4%BA%8C%E3%80%81%E8%BF%90%E9%80%81%E8%B4%A7%E7%89%A9">#</a>例题二、运送货物</h3><p>再看看力扣第 1011 题「<a href="https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/">在 D 天内送达包裹的能力open in new window</a>」：</p><details class="hint-container details" open="" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1rem 0px; padding: 1.5rem; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary style="position: relative; margin: -1.5rem -1.5rem 0.5em; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer;"><strong style="font-weight: 600;">1011. 在 D 天内送达包裹的能力</strong>&nbsp;|<span>&nbsp;</span><a target="_blank" href="https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|<span>&nbsp;</span><a target="_blank" href="https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">传送带上的包裹必须在<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">days</code><span>&nbsp;</span>天内从一个港口运送到另一个港口。</p><p style="line-height: 1.6; overflow-wrap: break-word;">传送带上的第<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">i</code>&nbsp;个包裹的重量为&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">weights[i]</code>。每一天，我们都会按给出重量（<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">weights</code>）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</p><p style="line-height: 1.6; overflow-wrap: break-word;">返回能在<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">days</code><span>&nbsp;</span>天内将传送带上的所有包裹送达的船的最低运载能力。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>weights = [1,2,3,4,5,6,7,8,9,10], days = 5<strong style="font-weight: 600;">输出：</strong>15<strong style="font-weight: 600;">解释：</strong>船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：第 1 天：1, 2, 3, 4, 5第 2 天：6, 7第 3 天：8第 4 天：9第 5 天：10<p>请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。<br></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>weights = [3,2,2,4,1,4], days = 3<br><strong style="font-weight: 600;">输出：</strong>6<br><strong style="font-weight: 600;">解释：</strong><br>船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：<br>第 1 天：3, 2<br>第 2 天：2, 4<br>第 3 天：1, 4<br></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>weights = [1,2,3,1,1], days = 4<br><strong style="font-weight: 600;">输出：</strong>3<br><strong style="font-weight: 600;">解释：</strong><br>第 1 天：1<br>第 2 天：2<br>第 3 天：3<br>第 4 天：1, 1<br></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 &lt;= days &lt;= weights.length &lt;= 5 * 10<sup>4</sup></code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 &lt;= weights[i] &lt;= 500</code></li></ul></div></details></p><p>要在 <code>D</code> 天内按顺序运输完所有货物，货物不可分割，如何确定运输的最小载重呢？</p><p>函数签名如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shipWithinDays</span><span class="params">(<span class="type">int</span>[] weights, <span class="type">int</span> days)</span>;</span><br></pre></td></tr></table></figure><p>和上一道题一样的，我们按照流程来就行：</p><p><strong>1、确定 <code>x, f(x), target</code> 分别是什么，并写出函数 <code>f</code> 的代码</strong>。</p><p>题目问什么，什么就是自变量，也就是说船的运载能力就是自变量 <code>x</code>。</p><p>运输天数和运载能力成反比，所以可以让 <code>f(x)</code> 计算 <code>x</code> 的运载能力下需要的运输天数，那么 <code>f(x)</code> 是单调递减的。</p><p>函数 <code>f(x)</code> 的实现如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：当运载能力为 x 时，需要 f(x) 天运完所有货物</span></span><br><span class="line"><span class="comment">// f(x) 随着 x 的增加单调递减</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] weights, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; weights.length; ) &#123;</span><br><span class="line">        <span class="comment">// 尽可能多装货物</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; weights.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cap &lt; weights[i]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> cap -= weights[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        days++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> days;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这道题，<code>target</code> 显然就是运输天数 <code>D</code>，我们要在 <code>f(x) == D</code> 的约束下，算出船的最小载重。</p><p><strong>2、找到 <code>x</code> 的取值范围作为二分搜索的搜索区间，初始化 <code>left</code> 和 <code>right</code> 变量</strong>。</p><p>船的最小载重是多少？最大载重是多少？</p><p>显然，船的最小载重应该是 <code>weights</code> 数组中元素的最大值，因为每次至少得装一件货物走，不能说装不下嘛。</p><p>最大载重显然就是<code>weights</code> 数组所有元素之和，也就是一次把所有货物都装走。</p><p>这样就确定了搜索区间 <code>[left, right)</code>：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shipWithinDays</span><span class="params">(<span class="type">int</span>[] weights, <span class="type">int</span> days)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 注意，right 是开区间，所以额外加一</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w : weights) &#123;</span><br><span class="line">        left = Math.max(left, w);</span><br><span class="line">        right += w;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、需要根据题目的要求，确定应该使用搜索左侧还是搜索右侧的二分搜索算法，写出解法代码</strong>。</p><p>现在我们确定了自变量 <code>x</code> 是船的载重能力，<code>f(x)</code> 是单调递减的函数，<code>target</code> 就是运输总天数限制 <code>D</code>，题目要我们计算船的最小载重，也就是 <code>x</code> 要尽可能小：</p><p><img src="https://labuladong.online/algo/images/%E4%BA%8C%E5%88%86%E8%BF%90%E7%94%A8/5.jpeg" alt="img"></p><p>这就是搜索左侧边界的二分搜索嘛，结合上图就可写出二分搜索代码：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shipWithinDays</span><span class="params">(<span class="type">int</span>[] weights, <span class="type">int</span> days)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 注意，right 是开区间，所以额外加一</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w : weights) &#123;</span><br><span class="line">        left = Math.max(left, w);</span><br><span class="line">        right += w;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (f(weights, mid) == days) &#123;</span><br><span class="line">            <span class="comment">// 搜索左侧边界，则需要收缩右侧边界</span></span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f(weights, mid) &lt; days) &#123;</span><br><span class="line">            <span class="comment">// 需要让 f(x) 的返回值大一些</span></span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f(weights, mid) &gt; days) &#123;</span><br><span class="line">            <span class="comment">// 需要让 f(x) 的返回值小一些</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，这道题的解法也写出来了，我们合并一下多余的 if 分支，提高代码运行速度，最终代码如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shipWithinDays</span><span class="params">(<span class="type">int</span>[] weights, <span class="type">int</span> days)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w : weights) &#123;</span><br><span class="line">        left = Math.max(left, w);</span><br><span class="line">        right += w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (f(weights, mid) &lt;= days) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] weights, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// 见上文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details data-v-fb30874b="" id="div_capacity-to-ship-packages-within-d-days" class="hint-container details" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1.6em 0px; padding: 1rem 0px 0px; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary data-v-fb30874b="" style="position: relative; margin: -1.5rem 0px -0.5rem; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer; display: flex; align-items: center; font-size: large;"><strong data-v-fb30874b="" style="font-weight: 600;">🍭 代码可视化动画 🍭</strong><span data-v-fb30874b="" class="font-icon icon iconfont icon-resize" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-left: auto; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-refresh" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-link" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle;"></span></summary><div data-v-fb30874b="" class="resizable" style="width: 774.091px; max-width: 100%; height: 70vh; max-height: 70vh; overflow: auto; resize: both;"><iframe data-v-fb30874b="" id="iframe_capacity-to-ship-packages-within-d-days" src="https://labuladong.online/algo-visualize/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><h3 id="例题三、分割数组"><a href="#例题三、分割数组" class="headerlink" title="#例题三、分割数组"></a><a href="https://labuladong.online/algo/frequency-interview/binary-search-in-action/#%E4%BE%8B%E9%A2%98%E4%B8%89%E3%80%81%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84">#</a>例题三、分割数组</h3><p>我们实操一下力扣第 410 题「<a href="https://leetcode.cn/problems/split-array-largest-sum/">分割数组的最大值open in new window</a>」，难度为困难：</p><details class="hint-container details" open="" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1rem 0px; padding: 1.5rem; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary style="position: relative; margin: -1.5rem -1.5rem 0.5em; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer;"><strong style="font-weight: 600;">410. 分割数组的最大值</strong>&nbsp;|<span>&nbsp;</span><a target="_blank" href="https://leetcode.cn/problems/split-array-largest-sum/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|<span>&nbsp;</span><a target="_blank" href="https://leetcode.com/problems/split-array-largest-sum/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个非负整数数组<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">nums</code><span>&nbsp;</span>和一个整数&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">m</code><span>&nbsp;</span>，你需要将这个数组分成&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">m</code><em>&nbsp;</em>个非空的连续子数组。</p><p style="line-height: 1.6; overflow-wrap: break-word;">设计一个算法使得这&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">m</code><em>&nbsp;</em>个子数组各自和的最大值最小。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>nums = [7,2,5,10,8], m = 2<strong style="font-weight: 600;">输出：</strong>18<strong style="font-weight: 600;">解释：</strong>一共有四种方法将 nums 分割为 2 个子数组。 其中最好的方式是将其分为 [7,2,5] 和 [10,8] 。因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>nums = [1,2,3,4,5], m = 2<strong style="font-weight: 600;">输出：</strong>9</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>nums = [1,4,4], m = 3<strong style="font-weight: 600;">输出：</strong>4</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 &lt;= nums.length &lt;= 1000</code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 &lt;= m &lt;= min(50, nums.length)</code></li></ul></div></details><p>函数签名如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">splitArray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> m)</span>;</span><br></pre></td></tr></table></figure><p>这个题目有点类似前文一道经典动态规划题目 <a href="https://labuladong.online/algo/dynamic-programming/egg-drop/">高楼扔鸡蛋</a>，题目比较绕，又是最大值又是最小值的。</p><p>简单说，给你输入一个数组 <code>nums</code> 和数字 <code>m</code>，你要把 <code>nums</code> 分割成 <code>m</code> 个子数组。</p><p>肯定有不止一种分割方法，每种分割方法都会把 <code>nums</code> 分成 <code>m</code> 个子数组，这 <code>m</code> 个子数组中肯定有一个和最大的子数组对吧。</p><p>我们想要找一个分割方法，该方法分割出的最大子数组和是所有方法中最大子数组和最小的。</p><p>请你的算法返回这个分割方法对应的最大子数组和。</p><p>我滴妈呀，这个题目看了就觉得难的不行，完全没思路，这题怎么运用我们之前说套路，转化成二分搜索呢？</p><p><strong>其实，这道题和上面讲的运输问题是一模一样的，不相信的话我给你改写一下题目</strong>：</p><p>你只有一艘货船，现在有若干货物，每个货物的重量是 <code>nums[i]</code>，现在你需要在 <code>m</code> 天内将这些货物运走，请问你的货船的最小载重是多少？</p><p>这不就是刚才我们解决的力扣第 1011 题「<a href="https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/">在 D 天内送达包裹的能力open in new window</a>」吗？</p><p>货船每天运走的货物就是 <code>nums</code> 的一个子数组；在 <code>m</code> 天内运完就是将 <code>nums</code> 划分成 <code>m</code> 个子数组；让货船的载重尽可能小，就是让所有子数组中最大的那个子数组元素之和尽可能小。</p><p>所以这道题的解法直接复制粘贴运输问题的解法代码即可：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">splitArray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> shipWithinDays(nums, m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shipWithinDays</span><span class="params">(<span class="type">int</span>[] weights, <span class="type">int</span> days)</span> &#123;</span><br><span class="line">    <span class="comment">// 见上文</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] weights, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// 见上文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文就到这里，总结来说，如果发现题目中存在单调关系，就可以尝试使用二分搜索的思路来解决。搞清楚单调性和二分搜索的种类，通过分析和画图，就能够写出最终的代码。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划之子序列问题解题模板</title>
      <link href="/posts/43963.html"/>
      <url>/posts/43963.html</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划之子序列问题解题模板"><a href="#动态规划之子序列问题解题模板" class="headerlink" title="动态规划之子序列问题解题模板"></a>动态规划之子序列问题解题模板</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/">1312. Minimum Insertion Steps to Make a String Palindromeopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/">1312. 让字符串成为回文串的最少插入次数open in new window</a></td><td align="center">🔴</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/longest-palindromic-subsequence/">516. Longest Palindromic Subsequenceopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516. 最长回文子序列open in new window</a></td><td align="center">🟠</td></tr></tbody></table><p>子序列问题是常见的算法问题，而且并不好解决。</p><p>首先，子序列问题本身就相对子串、子数组更困难一些，因为前者是不连续的序列，而后两者是连续的，就算穷举你都不一定会，更别说求解相关的算法问题了。</p><p>而且，子序列问题很可能涉及到两个字符串，比如前文 <a href="https://labuladong.online/algo/dynamic-programming/longest-common-subsequence/">最长公共子序列</a>，如果没有一定的处理经验，真的不容易想出来。所以本文就来扒一扒子序列问题的套路，其实就有两种模板，相关问题只要往这两种思路上想，十拿九稳。</p><p>一般来说，这类问题都是让你求一个<strong>最长子序列</strong>，因为最短子序列就是一个字符嘛，没啥可问的。一旦涉及到子序列和最值，那几乎可以肯定，**考察的是动态规划技巧，时间复杂度一般都是 O(n^2)**。</p><p>原因很简单，你想想一个字符串，它的子序列有多少种可能？起码是指数级的吧，这种情况下，不用动态规划技巧，还想怎么着？</p><p>既然要用动态规划，那就要定义 <code>dp</code> 数组，找状态转移关系。我们说的两种思路模板，就是 <code>dp</code> 数组的定义思路。不同的问题可能需要不同的 <code>dp</code> 数组定义来解决。</p><h3 id="一、两种思路"><a href="#一、两种思路" class="headerlink" title="#一、两种思路"></a><a href="https://labuladong.online/algo/dynamic-programming/subsequence-problem/#%E4%B8%80%E3%80%81%E4%B8%A4%E7%A7%8D%E6%80%9D%E8%B7%AF">#</a>一、两种思路</h3><p>🌟</p><hr><p>🌟</p><p><strong>1、第一种思路模板是一个一维的 <code>dp</code> 数组</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> array.length;</span><br><span class="line"><span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        dp[i] = 最值(dp[i], dp[j] + ...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们写过的 <a href="https://labuladong.online/algo/dynamic-programming/longest-increasing-subsequence/">最长递增子序列</a> 和 <a href="https://labuladong.online/algo/dynamic-programming/maximum-subarray/">最大子数组和</a> 都是这个思路。</p><p>在这个思路中 <code>dp</code> 数组的定义是：</p><p>**在子数组 <code>arr[0..i]</code> 中，以 <code>arr[i]</code> 结尾的子序列的长度是 <code>dp[i]</code>**。</p><p>为啥最长递增子序列需要这种思路呢？前文说得很清楚了，因为这样符合归纳法，可以找到状态转移的关系，这里就不具体展开了。</p><p><strong>2、第二种思路模板是一个二维的 <code>dp</code> 数组</strong>：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">dp</span>[n][n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == arr[j]) </span><br><span class="line">            dp[i][j] = dp[i][j] + ...</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[i][j] = 最值(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种思路运用相对更多一些，尤其是涉及两个字符串&#x2F;数组的子序列时，比如前文讲的 <a href="https://labuladong.online/algo/dynamic-programming/longest-common-subsequence/">最长公共子序列</a> 和 <a href="https://labuladong.online/algo/dynamic-programming/edit-distance/">编辑距离</a>；这种思路也可以用于只涉及一个字符串&#x2F;数组的情景，比如本文讲的回文子序列问题。</p><p><strong>2.1 涉及两个字符串&#x2F;数组的场景</strong>，<code>dp</code> 数组的定义如下：</p><p>**在子数组 <code>arr1[0..i]</code> 和子数组 <code>arr2[0..j]</code> 中，我们要求的子序列长度为 <code>dp[i][j]</code>**。</p><p><strong>2.2 只涉及一个字符串&#x2F;数组的场景</strong>，<code>dp</code> 数组的定义如下：</p><p>**在子数组 <code>array[i..j]</code> 中，我们要求的子序列的长度为 <code>dp[i][j]</code>**。</p><p>下面就看看最长回文子序列问题，详解一下第二种情况下如何使用动态规划。</p><h3 id="二、最长回文子序列"><a href="#二、最长回文子序列" class="headerlink" title="#二、最长回文子序列"></a><a href="https://labuladong.online/algo/dynamic-programming/subsequence-problem/#%E4%BA%8C%E3%80%81%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97">#</a>二、最长回文子序列</h3><p>之前解决了 <a href="https://labuladong.online/algo/essential-technique/array-two-pointers-summary/">最长回文子串</a> 的问题，这次提升难度，看看力扣第 516 题「<a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">最长回文子序列open in new window</a>」，求最长回文子序列的长度：</p><p>输入一个字符串 <code>s</code>，请你找出 <code>s</code> 中的最长回文子序列长度，函数签名如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span>;</span><br></pre></td></tr></table></figure><p>比如说输入 <code>s = &quot;aecda&quot;</code>，算法返回 3，因为最长回文子序列是 <code>&quot;aca&quot;</code>，长度为 3。</p><p>我们对 <code>dp</code> 数组的定义是：**在子串 <code>s[i..j]</code> 中，最长回文子序列的长度为 <code>dp[i][j]</code>**。一定要记住这个定义才能理解算法。</p><p>为啥这个问题要这样定义二维的 <code>dp</code> 数组呢？我在 <a href="https://labuladong.online/algo/dynamic-programming/longest-increasing-subsequence/">最长递增子序列</a> 提到，找状态转移需要归纳思维，说白了就是如何从已知的结果推出未知的部分。而这样定义能够进行归纳，容易发现状态转移关系。</p><p>具体来说，如果我们想求 <code>dp[i][j]</code>，假设你知道了子问题 <code>dp[i+1][j-1]</code> 的结果（<code>s[i+1..j-1]</code> 中最长回文子序列的长度），你是否能想办法算出 <code>dp[i][j]</code> 的值（<code>s[i..j]</code> 中，最长回文子序列的长度）呢？</p><p><img src="https://labuladong.online/algo/images/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/1.jpg" alt="img"></p><p>可以！这取决于 <code>s[i]</code> 和 <code>s[j]</code> 的字符：</p><p><strong>如果它俩相等</strong>，那么它俩加上 <code>s[i+1..j-1]</code> 中的最长回文子序列就是 <code>s[i..j]</code> 的最长回文子序列：</p><p><img src="https://labuladong.online/algo/images/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/2.jpg" alt="img"></p><p><strong>如果它俩不相等</strong>，说明它俩<strong>不可能同时</strong>出现在 <code>s[i..j]</code> 的最长回文子序列中，那么把它俩<strong>分别</strong>加入 <code>s[i+1..j-1]</code> 中，看看哪个子串产生的回文子序列更长即可：</p><p><img src="https://labuladong.online/algo/images/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/3.jpg" alt="img"></p><p>以上两种情况写成代码就是这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">    <span class="comment">// 它俩一定在最长回文子序列中</span></span><br><span class="line">    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">// s[i+1..j] 和 s[i..j-1] 谁的回文子序列更长？</span></span><br><span class="line">    dp[i][j] = max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>至此，状态转移方程就写出来了，根据 dp 数组的定义，我们要求的就是 <code>dp[0][n - 1]</code>，也就是整个 <code>s</code> 的最长回文子序列的长度。</p><h3 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="#三、代码实现"></a><a href="https://labuladong.online/algo/dynamic-programming/subsequence-problem/#%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">#</a>三、代码实现</h3><p>首先明确一下 base case，如果只有一个字符，显然最长回文子序列长度是 1，也就是 <code>dp[i][j] = 1 (i == j)</code>。</p><p>因为 <code>i</code> 肯定小于等于 <code>j</code>，所以对于那些 <code>i &gt; j</code> 的位置，根本不存在什么子序列，应该初始化为 0。</p><p>另外，看看刚才写的状态转移方程，想求 <code>dp[i][j]</code> 需要知道 <code>dp[i+1][j-1]</code>，<code>dp[i+1][j]</code>，<code>dp[i][j-1]</code> 这三个位置；再看看我们确定的 base case，填入 <code>dp</code> 数组之后是这样：</p><p><img src="https://labuladong.online/algo/images/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/4.jpg" alt="img"></p><p><strong>为了保证每次计算 <code>dp[i][j]</code>，左下右方向的位置已经被计算出来，只能斜着遍历或者反着遍历</strong>：</p><p><img src="https://labuladong.online/algo/images/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/5.jpg" alt="img"></p><p>提示</p><p>关于 <code>dp</code> 数组的遍历方向，详情见 <a href="https://labuladong.online/algo/dynamic-programming/faq-summary/">动态规划答疑篇</a>。</p><p>我选择反着遍历，代码如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="comment">// dp 数组全部初始化为 0</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反着遍历保证正确的状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// 状态转移方程</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 整个 s 的最长回文子串长度</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details data-v-fb30874b="" id="div_longest-palindromic-subsequence" class="hint-container details" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1.6em 0px; padding: 1rem 0px 0px; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary data-v-fb30874b="" style="position: relative; margin: -1.5rem 0px -0.5rem; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer; display: flex; align-items: center; font-size: large;"><strong data-v-fb30874b="" style="font-weight: 600;">🌟 代码可视化动画 🌟</strong><span data-v-fb30874b="" class="font-icon icon iconfont icon-resize" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-left: auto; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-refresh" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-link" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle;"></span></summary><div data-v-fb30874b="" class="resizable" style="width: 774.091px; max-width: 100%; height: 70vh; max-height: 70vh; overflow: auto; resize: both;"><iframe data-v-fb30874b="" id="iframe_longest-palindromic-subsequence" src="https://labuladong.online/algo-visualize/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>至此，最长回文子序列的问题就解决了。</p><h3 id="四、拓展延伸"><a href="#四、拓展延伸" class="headerlink" title="#四、拓展延伸"></a><a href="https://labuladong.online/algo/dynamic-programming/subsequence-problem/#%E5%9B%9B%E3%80%81%E6%8B%93%E5%B1%95%E5%BB%B6%E4%BC%B8">#</a>四、拓展延伸</h3><p>虽然回文相关的问题没有什么特别广泛的使用场景，但是你会算最长回文子序列之后，一些类似的题目也可以顺手做掉。</p><p>比如力扣第 1312 题「<a href="https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/">计算让字符串成为回文串的最少插入次数open in new window</a>」：</p><p>输入一个字符串 <code>s</code>，你可以在字符串的任意位置插入任意字符。如果要把 <code>s</code> 变成回文串，请你计算最少要进行多少次插入？</p><p>函数签名如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minInsertions</span><span class="params">(String s)</span>;</span><br></pre></td></tr></table></figure><p>比如说输入 <code>s = &quot;abcea&quot;</code>，算法返回 2，因为可以给 <code>s</code> 插入 2 个字符变成回文串 <code>&quot;abeceba&quot;</code> 或者 <code>&quot;aebcbea&quot;</code>。如果输入 <code>s = &quot;aba&quot;</code>，则算法返回 0，因为 <code>s</code> 已经是回文串，不用插入任何字符。</p><p>这也是一道单字符串的子序列问题，所以我们也可以使用一个二维 <code>dp</code> 数组，其中 <code>dp[i][j]</code> 的定义如下：</p><p><strong>对字符串 <code>s[i..j]</code>，最少需要进行 <code>dp[i][j]</code> 次插入才能变成回文串</strong>。</p><p>根据 <code>dp</code> 数组的定义，base case 就是 <code>dp[i][i] = 0</code>，因为单个字符本身就是回文串，不需要插入。</p><p>然后使用数学归纳法，假设已经计算出了子问题 <code>dp[i+1][j-1]</code> 的值了，思考如何推出 <code>dp[i][j]</code> 的值：</p><p><img src="https://labuladong.online/algo/images/%E6%8F%92%E5%85%A5%E5%9B%9E%E6%96%87/1.jpeg" alt="img"></p><p>实际上和最长回文子序列问题的状态转移方程非常类似，这里也分两种情况：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">    <span class="comment">// 不需要插入任何字符</span></span><br><span class="line">    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 把 s[i+1..j] 和 s[i..j-1] 变成回文串，选插入次数较少的</span></span><br><span class="line">    <span class="comment">// 然后还要再插入一个 s[i] 或 s[j]，使 s[i..j] 配成回文串</span></span><br><span class="line">    dp[i][j] = min(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们依然采取倒着遍历 <code>dp</code> 数组的方式，写出代码：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minInsertions</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="comment">// dp[i][j] 表示把字符串 s[i..j] 变成回文串的最少插入次数</span></span><br><span class="line">    <span class="comment">// dp 数组全部初始化为 0</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="comment">// 反着遍历保证正确的状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// 状态转移方程</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 整个 s 的最少插入次数</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，这道题也使用子序列解题模板解决了，整体逻辑和最长回文子序列非常相似，那么这个问题是否可以直接复用回文子序列的解法呢？</p><p>其实是可以的，我们甚至都不用写状态转移方程，你仔细想想：</p><p><strong>我先算出字符串 <code>s</code> 中的最长回文子序列，那些不在最长回文子序列中的字符，不就是需要插入的字符吗</strong>？</p><p>所以这道题可以直接复用之前实现的 <code>longestPalindromeSubseq</code> 函数：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算把 s 变成回文串的最少插入次数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minInsertions</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.length() - longestPalindromeSubseq(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 s 中的最长回文子序列长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">// 见上文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，子序列相关的算法就讲到这里，希望对你有启发。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>带权重的随机选择算法</title>
      <link href="/posts/64793.html"/>
      <url>/posts/64793.html</url>
      
        <content type="html"><![CDATA[<h1 id="带权重的随机选择算法"><a href="#带权重的随机选择算法" class="headerlink" title="带权重的随机选择算法"></a>带权重的随机选择算法</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/random-pick-with-weight/">528. Random Pick with Weightopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/random-pick-with-weight/">528. 按权重随机选择open in new window</a></td><td align="center">🟠</td></tr><tr><td align="center">-</td><td align="center"><a href="https://leetcode.cn/problems/cuyjEf/">剑指 Offer II 071. 按权重生成随机数open in new window</a></td><td align="center">🟠</td></tr></tbody></table><p>写这篇的文章的原因是玩 LOL 手游。</p><p>我有个朋友抱怨说打排位匹配的队友太菜了，我就说我打排位觉得队友都挺行的啊，好像不怎么坑？</p><p>朋友意味深长地说了句：一般隐藏分比较高的玩家，排位如果排不到实力相当的队友，就会排到一些菜狗。</p><p>嗯？我想了几秒钟感觉这小伙子不对劲，他意思是说我隐藏分低，还是说我就是那条菜狗？</p><p>我立马要求和他开黑打一把，证明我不是菜狗，他才是菜狗。开黑结果这里不便透露，大家猜猜吧。</p><p>打完之后我就来发文了，因为我对游戏的匹配机制有了一点思考。</p><p><img src="https://labuladong.online/algo/images/%E9%9A%8F%E6%9C%BA%E6%9D%83%E9%87%8D/images.png" alt="img"></p><p><strong>所谓「隐藏分」我不知道是不是真的，毕竟匹配机制是所有竞技类游戏的核心环节，想必非常复杂，不是简单几个指标就能搞定的</strong>。</p><p>但是如果把这个「隐藏分」机制简化，倒是一个值得思考的算法问题：系统如何以不同的随机概率进行匹配？</p><p>或者简单点说，如何带权重地做随机选择？</p><p>不要觉得这个很容易，如果给你一个长度为 <code>n</code> 的数组，让你从中等概率随机抽取一个元素，你肯定会做，random 一个 <code>[0, n-1]</code> 的数字出来作为索引就行了，每个元素被随机选到的概率都是 <code>1/n</code>。</p><p>但假设每个元素都有不同的权重，权重地大小代表随机选到这个元素的概率大小，你如何写算法去随机获取元素呢？</p><p>力扣第 528 题「<a href="https://leetcode.cn/problems/random-pick-with-weight/">按权重随机选择open in new window</a>」就是这样一个问题：</p><details class="hint-container details" open="" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1rem 0px; padding: 1.5rem; border-radius: 0.5rem; background: var(--detail-bg-color); color: rgb(44, 62, 80); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, STHeiti, &quot;Microsoft YaHei&quot;, SimSun, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1.5rem -1.5rem 0.5em; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer;"><strong style="font-weight: 600;">528. 按权重随机选择</strong>&nbsp;|<span>&nbsp;</span><a target="_blank" href="https://leetcode.cn/problems/random-pick-with-weight/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|<span>&nbsp;</span><a target="_blank" href="https://leetcode.com/problems/random-pick-with-weight/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个<span>&nbsp;</span><strong style="font-weight: 600;">下标从 0 开始</strong><span>&nbsp;</span>的正整数数组&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">w</code><span>&nbsp;</span>，其中&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">w[i]</code><span>&nbsp;</span>代表第<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">i</code><span>&nbsp;</span>个下标的权重。</p><p style="line-height: 1.6; overflow-wrap: break-word;">请你实现一个函数&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">pickIndex</code>&nbsp;，它可以<span>&nbsp;</span><strong style="font-weight: 600;">随机地</strong><span>&nbsp;</span>从范围<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">[0, w.length - 1]</code><span>&nbsp;</span>内（含<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">0</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">w.length - 1</code>）选出并返回一个下标。选取下标<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">i</code>&nbsp;的<span>&nbsp;</span><strong style="font-weight: 600;">概率</strong><span>&nbsp;</span>为<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">w[i] / sum(w)</code><span>&nbsp;</span>。</p><ol style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"></ol><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>例如，对于<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">w = [1, 3]</code>，挑选下标<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">0</code><span>&nbsp;</span>的概率为<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 / (1 + 3)&nbsp;= 0.25</code><span>&nbsp;</span>（即，25%），而选取下标<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1</code><span>&nbsp;</span>的概率为<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">3 / (1 + 3)&nbsp;= 0.75</code>（即，<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">75%</code>）。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>["Solution","pickIndex"][[[1]],[]]<strong style="font-weight: 600;">输出：</strong>[null,0]<strong style="font-weight: 600;">解释：</strong>Solution solution = new Solution([1]);solution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>["Solution","pickIndex","pickIndex","pickIndex","pickIndex","pickIndex"][[[1,3]],[],[],[],[],[]]<strong style="font-weight: 600;">输出：</strong>[null,1,1,1,1,0]<strong style="font-weight: 600;">解释：</strong>Solution solution = new Solution([1, 3]);solution.pickIndex(); // 返回 1，返回下标 1，返回该下标概率为 3/4 。solution.pickIndex(); // 返回 1solution.pickIndex(); // 返回 1solution.pickIndex(); // 返回 1solution.pickIndex(); // 返回 0，返回下标 0，返回该下标概率为 1/4 。<p>由于这是一个随机问题，允许多个答案，因此下列输出都可以被认为是正确的:<br>[null,1,1,1,1,0]<br>[null,1,1,1,1,1]<br>[null,1,1,1,0,0]<br>[null,1,1,1,0,1]<br>[null,1,0,1,0,0]<br>……<br>诸若此类。<br></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 &lt;= w.length &lt;= 10<sup>4</sup></code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 &lt;= w[i] &lt;= 10<sup>5</sup></code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">pickIndex</code>&nbsp;将被调用不超过<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">10<sup>4</sup></code>&nbsp;次</li></ul></div></details></p><p>我们就来思考一下这个问题，解决按照权重随机选择元素的问题。</p><p>🌟</p><hr><p>🌟</p><h3 id="解法思路"><a href="#解法思路" class="headerlink" title="#解法思路"></a><a href="https://labuladong.online/algo/frequency-interview/random-pick-with-weight/#%E8%A7%A3%E6%B3%95%E6%80%9D%E8%B7%AF">#</a>解法思路</h3><p>首先回顾一下我们和随机算法有关的历史文章：</p><p>后文 <a href="https://labuladong.online/algo/data-structure/random-set/">设计随机删除元素的数据结构</a> 主要考察的是数据结构的使用，每次把元素移到数组尾部再删除，可以避免数据搬移。</p><p>后文 <a href="https://labuladong.online/algo/frequency-interview/random-algorithm/">谈谈游戏中的随机算法</a> 讲的是经典的「水塘抽样算法」，运用简单的数学运算，在无限序列中等概率选取元素。</p><p>前文 <a href="https://labuladong.online/algo/other-skills/tips-in-exam/">算法笔试技巧</a> 中我还分享过一个巧用概率最大化测试用例通过率的骗分技巧。</p><p><strong>不过上述旧文并不能解决本文提出的问题，反而是前文 <a href="https://labuladong.online/algo/data-structure/prefix-sum/">前缀和技巧</a> 加上 <a href="https://labuladong.online/algo/essential-technique/binary-search-framework/">二分搜索详解</a> 能够解决带权重的随机选择算法</strong>。</p><p>这个随机算法和前缀和技巧和二分搜索技巧能扯上啥关系？且听我慢慢道来。</p><p>假设给你输入的权重数组是 <code>w = [1,3,2,1]</code>，我们想让概率符合权重，那么可以抽象一下，根据权重画出这么一条彩色的线段：</p><p><img src="https://labuladong.online/algo/images/%E9%9A%8F%E6%9C%BA%E6%9D%83%E9%87%8D/1.jpeg" alt="img"></p><p>如果我在线段上面随机丢一个石子，石子落在哪个颜色上，我就选择该颜色对应的权重索引，那么每个索引被选中的概率是不是就是和权重相关联了？</p><p><strong>所以，你再仔细看看这条彩色的线段像什么？这不就是 <a href="https://labuladong.online/algo/data-structure/prefix-sum/">前缀和数组</a> 嘛</strong>：</p><p><img src="https://labuladong.online/algo/images/%E9%9A%8F%E6%9C%BA%E6%9D%83%E9%87%8D/2.jpeg" alt="img"></p><p>那么接下来，如何模拟在线段上扔石子？</p><p>当然是随机数，比如上述前缀和数组 <code>preSum</code>，取值范围是 <code>[1, 7]</code>，那么我生成一个在这个区间的随机数 <code>target = 5</code>，就好像在这条线段中随机扔了一颗石子：</p><p><img src="https://labuladong.online/algo/images/%E9%9A%8F%E6%9C%BA%E6%9D%83%E9%87%8D/3.jpeg" alt="img"></p><p>还有个问题，<code>preSum</code> 中并没有 5 这个元素，我们应该选择比 5 大的最小元素，也就是 6，即 <code>preSum</code> 数组的索引 3：</p><p><img src="https://labuladong.online/algo/images/%E9%9A%8F%E6%9C%BA%E6%9D%83%E9%87%8D/4.jpeg" alt="img"></p><p><strong>如何快速寻找数组中大于等于目标值的最小元素？<a href="https://labuladong.online/algo/essential-technique/binary-search-framework/">二分搜索算法</a> 就是我们想要的</strong>。</p><p>到这里，这道题的核心思路就说完了，主要分几步：</p><p>1、根据权重数组 <code>w</code> 生成前缀和数组 <code>preSum</code>。</p><p>2、生成一个取值在 <code>preSum</code> 之内的随机数，用二分搜索算法寻找大于等于这个随机数的最小元素索引。</p><p>3、最后对这个索引减一（因为前缀和数组有一位索引偏移），就可以作为权重数组的索引，即最终答案:</p><p><img src="https://labuladong.online/algo/images/%E9%9A%8F%E6%9C%BA%E6%9D%83%E9%87%8D/5.jpeg" alt="img"></p><h3 id="解法代码"><a href="#解法代码" class="headerlink" title="#解法代码"></a><a href="https://labuladong.online/algo/frequency-interview/random-pick-with-weight/#%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81">#</a>解法代码</h3><p>上述思路应该不难理解，但是写代码的时候坑可就多了。</p><p>要知道涉及开闭区间、索引偏移和二分搜索的题目，需要你对算法的细节把控非常精确，否则会出各种难以排查的 bug。</p><p>下面来抠细节，继续前面的例子：</p><p><img src="https://labuladong.online/algo/images/%E9%9A%8F%E6%9C%BA%E6%9D%83%E9%87%8D/3.jpeg" alt="img"></p><p>就比如这个 <code>preSum</code> 数组，你觉得随机数 <code>target</code> 应该在什么范围取值？闭区间 <code>[0, 7]</code> 还是左闭右开 <code>[0, 7)</code>？</p><p>都不是，应该在闭区间 <code>[1, 7]</code> 中选择，<strong>因为前缀和数组中 0 本质上是个占位符</strong>，仔细体会一下：</p><p><img src="https://labuladong.online/algo/images/%E9%9A%8F%E6%9C%BA%E6%9D%83%E9%87%8D/6.jpeg" alt="img"></p><p>所以要这样写代码：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> preSum.length;</span><br><span class="line"><span class="comment">// target 取值范围是闭区间 [1, preSum[n - 1]]</span></span><br><span class="line"><span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> rand.nextInt(preSum[n - <span class="number">1</span>]) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>接下来，在 <code>preSum</code> 中寻找大于等于 <code>target</code> 的最小元素索引，应该用什么品种的二分搜索？搜索左侧边界的还是搜索右侧边界的？</p><p>实际上应该使用搜索左侧边界的二分搜索：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 搜索左侧边界的二分搜索</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">left_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前文 <a href="https://labuladong.online/algo/essential-technique/binary-search-framework/">二分搜索详解</a> 着重讲了数组中存在目标元素重复的情况，没仔细讲目标元素不存在的情况，这里补充一下。</p><p><strong>当目标元素 <code>target</code> 不存在数组 <code>nums</code> 中时，搜索左侧边界的二分搜索的返回值可以做以下几种解读</strong>：</p><p>1、返回的这个值是 <code>nums</code> 中大于等于 <code>target</code> 的最小元素索引。</p><p>2、返回的这个值是 <code>target</code> 应该插入在 <code>nums</code> 中的索引位置。</p><p>3、返回的这个值是 <code>nums</code> 中小于 <code>target</code> 的元素个数。</p><p>比如在有序数组 <code>nums = [2,3,5,7]</code> 中搜索 <code>target = 4</code>，搜索左边界的二分算法会返回 2，你带入上面的说法，都是对的。</p><p>所以以上三种解读都是等价的，可以根据具体题目场景灵活运用，显然这里我们需要的是第一种。</p><p>综上，我们可以写出最终解法代码：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 前缀和数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] preSum;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Solution</span><span class="params">(<span class="type">int</span>[] w)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> w.length;</span><br><span class="line">        <span class="comment">// 构建前缀和数组，偏移一位留给 preSum[0]</span></span><br><span class="line">        preSum = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        preSum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// preSum[i] = sum(w[0..i-1])</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            preSum[i] = preSum[i - <span class="number">1</span>] + w[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pickIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> preSum.length;</span><br><span class="line">        <span class="comment">// Java 的 nextInt(n) 方法在 [0, n) 中生成一个随机整数</span></span><br><span class="line">        <span class="comment">// 再加一就是在闭区间 [1, preSum[n - 1]] 中随机选择一个数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> rand.nextInt(preSum[n - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 获取 target 在前缀和数组 preSum 中的索引</span></span><br><span class="line">        <span class="comment">// 别忘了前缀和数组 preSum 和原始数组 w 有一位索引偏移</span></span><br><span class="line">        <span class="keyword">return</span> left_bound(preSum, target) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索左侧边界的二分搜索</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">left_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 见上文</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了之前的铺垫，相信你能够完全理解上述代码，这道随机权重的题目就解决了。</p><p>经常有读者留言调侃，每次都是看我的文章「云刷题」，看完就会了，也不用亲自动手刷了。</p><p>但我想说的是，很多题目思路一说就懂，但是深入一些的话很多细节都可能有坑，本文讲的这道题就是一个例子，所以还是建议多实践，多总结。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典动态规划：最长公共子序列</title>
      <link href="/posts/49870.html"/>
      <url>/posts/49870.html</url>
      
        <content type="html"><![CDATA[<h1 id="经典动态规划：最长公共子序列"><a href="#经典动态规划：最长公共子序列" class="headerlink" title="经典动态规划：最长公共子序列"></a>经典动态规划：最长公共子序列</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/longest-common-subsequence/">1143. Longest Common Subsequenceopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列open in new window</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/delete-operation-for-two-strings/">583. Delete Operation for Two Stringsopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作open in new window</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/">712. Minimum ASCII Delete Sum for Two Stringsopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/">712. 两个字符串的最小ASCII删除和open in new window</a></td><td align="center">🟠</td></tr><tr><td align="center">-</td><td align="center"><a href="https://leetcode.cn/problems/qJnOS7/">剑指 Offer II 095. 最长公共子序列open in new window</a></td><td align="center">🟠</td></tr></tbody></table><p>不知道大家做算法题有什么感觉，<strong>我总结出来做算法题的技巧就是，把大的问题细化到一个点，先研究在这个小的点上如何解决问题，然后再通过递归&#x2F;迭代的方式扩展到整个问题</strong>。</p><p>比如说我们前文 <a href="https://labuladong.online/algo/data-structure/binary-tree-part3/">手把手带你刷二叉树第三期</a>，解决二叉树的题目，我们就会把整个问题细化到某一个节点上，想象自己站在某个节点上，需要做什么，然后套二叉树递归框架就行了。</p><p>动态规划系列问题也是一样，尤其是子序列相关的问题。<strong>本文从「最长公共子序列问题」展开，总结三道子序列问题</strong>，解这道题仔细讲讲这种子序列问题的套路，你就能感受到这种思维方式了。</p><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="#最长公共子序列"></a><a href="https://labuladong.online/algo/dynamic-programming/longest-common-subsequence/#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97">#</a>最长公共子序列</h3><p>计算最长公共子序列（Longest Common Subsequence，简称 LCS）是一道经典的动态规划题目，力扣第 1143 题「<a href="https://leetcode.cn/problems/longest-common-subsequence/">最长公共子序列open in new window</a>」就是这个问题：</p><p>给你输入两个字符串 <code>s1</code> 和 <code>s2</code>，请你找出他们俩的最长公共子序列，返回这个子序列的长度。函数签名如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String s1, String s2)</span>;</span><br></pre></td></tr></table></figure><p>比如说输入 <code>s1 = &quot;zabcde&quot;, s2 = &quot;acez&quot;</code>，它俩的最长公共子序列是 <code>lcs = &quot;ace&quot;</code>，长度为 3，所以算法返回 3。</p><p>如果没有做过这道题，一个最简单的暴力算法就是，把 <code>s1</code> 和 <code>s2</code> 的所有子序列都穷举出来，然后看看有没有公共的，然后在所有公共子序列里面再寻找一个长度最大的。</p><p>显然，这种思路的复杂度非常高，你要穷举出所有子序列，这个复杂度就是指数级的，肯定不实际。</p><p>正确的思路是不要考虑整个字符串，而是细化到 <code>s1</code> 和 <code>s2</code> 的每个字符。后文 <a href="https://labuladong.online/algo/dynamic-programming/subsequence-problem/">子序列解题模板</a> 中总结的一个规律：</p><p>🌟</p><hr><p>🌟</p><p><strong>对于两个字符串求子序列的问题，都是用两个指针 <code>i</code> 和 <code>j</code> 分别在两个字符串上移动，大概率是动态规划思路</strong>。</p><p>最长公共子序列的问题也可以遵循这个规律，我们可以先写一个 <code>dp</code> 函数：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：计算 s1[i..] 和 s2[j..] 的最长公共子序列长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(String s1, <span class="type">int</span> i, String s2, <span class="type">int</span> j)</span></span><br></pre></td></tr></table></figure><p>这个 <code>dp</code> 函数的定义是：**<code>dp(s1, i, s2, j)</code> 计算 <code>s1[i..]</code> 和 <code>s2[j..]</code> 的最长公共子序列长度**。</p><p>根据这个定义，那么我们想要的答案就是 <code>dp(s1, 0, s2, 0)</code>，且 base case 就是 <code>i == len(s1)</code> 或 <code>j == len(s2)</code> 时，因为这时候 <code>s1[i..]</code> 或 <code>s2[j..]</code> 就相当于空串了，最长公共子序列的长度显然是 0：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dp(s1, <span class="number">0</span>, s2, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(String s1, <span class="type">int</span> i, String s2, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (i == s1.length() || j == s2.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p><strong>接下来，咱不要看 <code>s1</code> 和 <code>s2</code> 两个字符串，而是要具体到每一个字符，思考每个字符该做什么</strong>。</p><p><img src="https://labuladong.online/algo/images/LCS/1.jpeg" alt="img"></p><p>我们只看 <code>s1[i]</code> 和 <code>s2[j]</code>，<strong>如果 <code>s1[i] == s2[j]</code>，说明这个字符一定在 <code>lcs</code> 中</strong>：</p><p><img src="https://labuladong.online/algo/images/LCS/2.jpeg" alt="img"></p><p>这样，就找到了一个 <code>lcs</code> 中的字符，根据 <code>dp</code> 函数的定义，我们可以完善一下代码：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：计算 s1[i..] 和 s2[j..] 的最长公共子序列长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(String s1, <span class="type">int</span> i, String s2, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.charAt(i) == s2.charAt(j)) &#123;</span><br><span class="line">        <span class="comment">// s1[i] 和 s2[j] 必然在 lcs 中，</span></span><br><span class="line">        <span class="comment">// 加上 s1[i+1..] 和 s2[j+1..] 中的 lcs 长度，就是答案</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dp(s1, i + <span class="number">1</span>, s2, j + <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚才说的 <code>s1[i] == s2[j]</code> 的情况，但如果 <code>s1[i] != s2[j]</code>，应该怎么办呢？</p><p><strong><code>s1[i] != s2[j]</code> 意味着，<code>s1[i]</code> 和 <code>s2[j]</code> 中至少有一个字符不在 <code>lcs</code> 中</strong>：</p><p><img src="https://labuladong.online/algo/images/LCS/3.jpeg" alt="img"></p><p>如上图，总共可能有三种情况，我怎么知道具体是那种情况呢？</p><p>其实我们也不知道，那就把这三种情况的答案都算出来，取其中结果最大的那个呗，因为题目让我们算「最长」公共子序列的长度嘛。</p><p>这三种情况的答案怎么算？回想一下我们的 <code>dp</code> 函数定义，不就是专门为了计算它们而设计的嘛！</p><p>代码可以再进一步：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：计算 s1[i..] 和 s2[j..] 的最长公共子序列长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(String s1, <span class="type">int</span> i, String s2, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.charAt(i) == s2.charAt(j)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dp(s1, i + <span class="number">1</span>, s2, j + <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// s1[i] 和 s2[j] 中至少有一个字符不在 lcs 中，</span></span><br><span class="line">        <span class="comment">// 穷举三种情况的结果，取其中的最大结果</span></span><br><span class="line">        <span class="keyword">return</span> max(</span><br><span class="line">            <span class="comment">// 情况一、s1[i] 不在 lcs 中</span></span><br><span class="line">            dp(s1, i + <span class="number">1</span>, s2, j),</span><br><span class="line">            <span class="comment">// 情况二、s2[j] 不在 lcs 中</span></span><br><span class="line">            dp(s1, i, s2, j + <span class="number">1</span>),</span><br><span class="line">            <span class="comment">// 情况三、都不在 lcs 中</span></span><br><span class="line">            dp(s1, i + <span class="number">1</span>, s2, j + <span class="number">1</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就已经非常接近我们的最终答案了，<strong>还有一个小的优化，情况三「<code>s1[i]</code> 和 <code>s2[j]</code> 都不在 lcs 中」其实可以直接忽略</strong>。</p><p>因为我们在求最大值嘛，情况三在计算 <code>s1[i+1..]</code> 和 <code>s2[j+1..]</code> 的 <code>lcs</code> 长度，这个长度肯定是小于等于情况二 <code>s1[i..]</code> 和 <code>s2[j+1..]</code> 中的 <code>lcs</code> 长度的，因为 <code>s1[i+1..]</code> 比 <code>s1[i..]</code> 短嘛，那从这里面算出的 <code>lcs</code> 当然也不可能更长嘛。</p><p>同理，情况三的结果肯定也小于等于情况一。<strong>说白了，情况三被情况一和情况二包含了</strong>，所以我们可以直接忽略掉情况三，完整代码如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 备忘录，消除重叠子问题</span></span><br><span class="line">    <span class="type">int</span>[][] memo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 主函数 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s1.length(), n = s2.length();</span><br><span class="line">        <span class="comment">// 备忘录值为 -1 代表未曾计算</span></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : memo) </span><br><span class="line">            Arrays.fill(row, -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 计算 s1[0..] 和 s2[0..] 的 lcs 长度</span></span><br><span class="line">        <span class="keyword">return</span> dp(s1, <span class="number">0</span>, s2, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：计算 s1[i..] 和 s2[j..] 的最长公共子序列长度</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">dp</span><span class="params">(String s1, <span class="type">int</span> i, String s2, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (i == s1.length() || j == s2.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果之前计算过，则直接返回备忘录中的答案</span></span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据 s1[i] 和 s2[j] 的情况做选择</span></span><br><span class="line">        <span class="keyword">if</span> (s1.charAt(i) == s2.charAt(j)) &#123;</span><br><span class="line">            <span class="comment">// s1[i] 和 s2[j] 必然在 lcs 中</span></span><br><span class="line">            memo[i][j] = <span class="number">1</span> + dp(s1, i + <span class="number">1</span>, s2, j + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// s1[i] 和 s2[j] 至少有一个不在 lcs 中</span></span><br><span class="line">            memo[i][j] = Math.max(</span><br><span class="line">                dp(s1, i + <span class="number">1</span>, s2, j),</span><br><span class="line">                dp(s1, i, s2, j + <span class="number">1</span>)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上思路完全就是按照我们之前的爆文 <a href="https://labuladong.online/algo/essential-technique/dynamic-programming-framework/">动态规划套路框架</a> 来的，应该是很容易理解的。至于为什么要加 <code>memo</code> 备忘录，我们之前写过很多次，为了照顾新来的读者，这里再简单重复一下，首先抽象出我们核心 <code>dp</code> 函数的递归框架：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    dp(i + <span class="number">1</span>, j + <span class="number">1</span>); <span class="comment">// #1</span></span><br><span class="line">    dp(i, j + <span class="number">1</span>);     <span class="comment">// #2</span></span><br><span class="line">    dp(i + <span class="number">1</span>, j);     <span class="comment">// #3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你看，假设我想从 <code>dp(i, j)</code> 转移到 <code>dp(i+1, j+1)</code>，有不止一种方式，可以直接走 <code>#1</code>，也可以走 <code>#2 -&gt; #3</code>，也可以走 <code>#3 -&gt; #2</code>。</p><p>这就是重叠子问题，如果我们不用 <code>memo</code> 备忘录消除子问题，那么 <code>dp(i+1, j+1)</code> 就会被多次计算，这是没有必要的。</p><p>至此，最长公共子序列问题就完全解决了，用的是自顶向下带备忘录的动态规划思路，我们当然也可以使用自底向上的迭代的动态规划思路，和我们的递归思路一样，关键是如何定义 <code>dp</code> 数组，我这里也写一下自底向上的解法吧：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s1.length(), n = s2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 定义：s1[0..i-1] 和 s2[0..j-1] 的 lcs 长度为 dp[i][j]</span></span><br><span class="line">        <span class="comment">// 目标：s1[0..m-1] 和 s2[0..n-1] 的 lcs 长度，即 dp[m][n]</span></span><br><span class="line">        <span class="comment">// base case: dp[0][..] = dp[..][0] = 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="comment">// 现在 i 和 j 从 1 开始，所以要减一</span></span><br><span class="line">                <span class="keyword">if</span> (s1.charAt(i - <span class="number">1</span>) == s2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="comment">// s1[i-1] 和 s2[j-1] 必然在 lcs 中</span></span><br><span class="line">                    dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// s1[i-1] 和 s2[j-1] 至少有一个不在 lcs 中</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details data-v-fb30874b="" id="div_longest-common-subsequence" class="hint-container details" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1.6em 0px; padding: 1rem 0px 0px; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary data-v-fb30874b="" style="position: relative; margin: -1.5rem 0px -0.5rem; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer; display: flex; align-items: center; font-size: large;"><strong data-v-fb30874b="" style="font-weight: 600;">🌈 代码可视化动画 🌈</strong><span data-v-fb30874b="" class="font-icon icon iconfont icon-resize" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-left: auto; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-refresh" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-link" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle;"></span></summary><div data-v-fb30874b="" class="resizable" style="width: 774.091px; max-width: 100%; height: 70vh; max-height: 70vh; overflow: auto; resize: both;"><iframe data-v-fb30874b="" id="iframe_longest-common-subsequence" src="https://labuladong.online/algo-visualize/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>自底向上的解法中 <code>dp</code> 数组定义的方式和我们的递归解法有一点差异，而且由于数组索引从 0 开始，有索引偏移，不过思路和我们的递归解法完全相同，如果你看懂了递归解法，这个解法应该不难理解。</p><p>另外，自底向上的解法可以通过我们前文讲过的 <a href="https://labuladong.online/algo/dynamic-programming/space-optimization/">动态规划空间压缩技巧</a> 来进行优化，把空间复杂度压缩为 O(N)，这里由于篇幅所限，就不展开了。</p><p>下面，来看两道和最长公共子序列相似的两道题目。</p><h3 id="字符串的删除操作"><a href="#字符串的删除操作" class="headerlink" title="#字符串的删除操作"></a><a href="https://labuladong.online/algo/dynamic-programming/longest-common-subsequence/#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C">#</a>字符串的删除操作</h3><p>这是力扣第 583 题「<a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">两个字符串的删除操作open in new window</a>」，看下题目：</p><p>给定两个单词 <code>s1</code> 和 <code>s2</code> ，返回使得 <code>s1</code> 和 <code>s2</code> 相同所需的最小步数。每步可以删除任意一个字符串中的一个字符。</p><p>函数签名如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String s1, String s2)</span>;</span><br></pre></td></tr></table></figure><p>比如输入 <code>s1 = &quot;sea&quot; s2 = &quot;eat&quot;</code>，算法返回 2，第一步将 <code>&quot;sea&quot;</code> 变为 <code>&quot;ea&quot;</code> ，第二步将 <code>&quot;eat&quot;</code> 变为 <code>&quot;ea&quot;</code>。</p><p>题目让我们计算将两个字符串变得相同的最少删除次数，那我们可以思考一下，最后这两个字符串会被删成什么样子？</p><p>删除的结果不就是它俩的最长公共子序列嘛！</p><p>那么，要计算删除的次数，就可以通过最长公共子序列的长度推导出来：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s1.length(), n = s2.length();</span><br><span class="line">    <span class="comment">// 复用前文计算 lcs 长度的函数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lcs</span> <span class="operator">=</span> longestCommonSubsequence(s1, s2);</span><br><span class="line">    <span class="keyword">return</span> m - lcs + n - lcs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题就解决了！</p><h3 id="最小-ASCII-删除和"><a href="#最小-ASCII-删除和" class="headerlink" title="#最小 ASCII 删除和"></a><a href="https://labuladong.online/algo/dynamic-programming/longest-common-subsequence/#%E6%9C%80%E5%B0%8F-ascii-%E5%88%A0%E9%99%A4%E5%92%8C">#</a>最小 ASCII 删除和</h3><p>这是力扣第 712 题「<a href="https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/">两个字符串的最小 ASCII 删除和open in new window</a>」，题目和上一道题目类似，只不过上道题要求删除次数最小化，这道题要求删掉的字符 ASCII 码之和最小化。</p><p>函数签名如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minimumDeleteSum</span><span class="params">(String s1, String s2)</span></span><br></pre></td></tr></table></figure><p>比如输入 <code>s1 = &quot;sea&quot;, s2 = &quot;eat&quot;</code>，算法返回 231。</p><p>因为在 <code>&quot;sea&quot;</code> 中删除 <code>&quot;s&quot;</code>，在 <code>&quot;eat&quot;</code> 中删除 <code>&quot;t&quot;</code>，可使得两个字符串相等，且删掉字符的 ASCII 码之和最小，即 <code>s(115) + t(116) = 231</code>。</p><p><strong>这道题不能直接复用计算最长公共子序列的函数，但是可以依照之前的思路，稍微修改 base case 和状态转移部分即可直接写出解法代码</strong>：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 备忘录</span></span><br><span class="line">    <span class="type">int</span> memo[][];</span><br><span class="line">    <span class="comment">/* 主函数 */</span>    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumDeleteSum</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s1.length(), n = s2.length();</span><br><span class="line">        <span class="comment">// 备忘录值为 -1 代表未曾计算</span></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : memo) </span><br><span class="line">            Arrays.fill(row, -<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp(s1, <span class="number">0</span>, s2, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：将 s1[i..] 和 s2[j..] 删除成相同字符串，</span></span><br><span class="line">    <span class="comment">// 最小的 ASCII 码之和为 dp(s1, i, s2, j)。</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">dp</span><span class="params">(String s1, <span class="type">int</span> i, String s2, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (i == s1.length()) &#123;</span><br><span class="line">            <span class="comment">// 如果 s1 到头了，那么 s2 剩下的都得删除</span></span><br><span class="line">            <span class="keyword">for</span> (; j &lt; s2.length(); j++)</span><br><span class="line">                res += s2.charAt(j);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == s2.length()) &#123;</span><br><span class="line">            <span class="comment">// 如果 s2 到头了，那么 s1 剩下的都得删除</span></span><br><span class="line">            <span class="keyword">for</span> (; i &lt; s1.length(); i++)</span><br><span class="line">                res += s1.charAt(i);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (s1.charAt(i) == s2.charAt(j)) &#123;</span><br><span class="line">            <span class="comment">// s1[i] 和 s2[j] 都是在 lcs 中的，不用删除</span></span><br><span class="line">            memo[i][j] = dp(s1, i + <span class="number">1</span>, s2, j + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// s1[i] 和 s2[j] 至少有一个不在 lcs 中，删一个</span></span><br><span class="line">            memo[i][j] = Math.min(</span><br><span class="line">                s1.charAt(i) + dp(s1, i + <span class="number">1</span>, s2, j),</span><br><span class="line">                s2.charAt(j) + dp(s1, i, s2, j + <span class="number">1</span>)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details data-v-fb30874b="" id="div_minimum-ascii-delete-sum-for-two-strings" class="hint-container details" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1.6em 0px; padding: 1rem 0px 0px; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary data-v-fb30874b="" style="position: relative; margin: -1.5rem 0px -0.5rem; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer; display: flex; align-items: center; font-size: large;"><strong data-v-fb30874b="" style="font-weight: 600;">🌟 代码可视化动画 🌟</strong><span data-v-fb30874b="" class="font-icon icon iconfont icon-resize" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-left: auto; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-refresh" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-link" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle;"></span></summary><div data-v-fb30874b="" class="resizable" style="width: 774.091px; max-width: 100%; height: 70vh; max-height: 70vh; overflow: auto; resize: both;"><iframe data-v-fb30874b="" id="iframe_minimum-ascii-delete-sum-for-two-strings" src="https://labuladong.online/algo-visualize/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>base case 有一定区别，计算 <code>lcs</code> 长度时，如果一个字符串为空，那么 <code>lcs</code> 长度必然是 0；但是这道题如果一个字符串为空，另一个字符串必然要被全部删除，所以需要计算另一个字符串所有字符的 ASCII 码之和。</p><p>关于状态转移，当 <code>s1[i]</code> 和 <code>s2[j]</code> 相同时不需要删除，不同时需要删除，所以可以利用 <code>dp</code> 函数计算两种情况，得出最优的结果。其他的大同小异，就不具体展开了。</p><p>至此，三道子序列问题就解决完了，关键在于将问题细化到字符，根据每两个字符是否相同来判断他们是否在结果子序列中，从而避免了对所有子序列进行穷举。</p><p>这也算是在两个字符串中求子序列的常用思路吧，建议好好体会，多多练习~</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口算法延伸：Rabin Karp 字符匹配算法</title>
      <link href="/posts/19505.html"/>
      <url>/posts/19505.html</url>
      
        <content type="html"><![CDATA[<h1 id="滑动窗口算法延伸：Rabin-Karp-字符匹配算法"><a href="#滑动窗口算法延伸：Rabin-Karp-字符匹配算法" class="headerlink" title="滑动窗口算法延伸：Rabin Karp 字符匹配算法"></a>滑动窗口算法延伸：Rabin Karp 字符匹配算法</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/repeated-dna-sequences/">187. Repeated DNA Sequencesopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/repeated-dna-sequences/">187. 重复的DNA序列open in new window</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. Find the Index of the First Occurrence in a Stringopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标open in new window</a></td><td align="center">🟠</td></tr></tbody></table><p>经常有读者留言，请我讲讲那些比较经典的算法，我觉得有这个必要，主要有以下原因：</p><p>1、经典算法之所以经典，一定是因为有独特新颖的设计思想，那当然要带大家学习一波。</p><p>2、我会尽量从最简单、最基本的算法切入，带你亲手推导出来这些经典算法的设计思想，自然流畅地写出最终解法。一方面消除大多数人对算法的恐惧，另一方面可以避免很多人对算法死记硬背的错误习惯。</p><p>我之前用状态机的思路讲解了 <a href="https://labuladong.github.io/article/fname.html?fname=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8BKMP%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95">KMP 算法open in new window</a>，说实话 KMP 算法确实不太好理解。不过今天我来讲一讲字符串匹配的另一种经典算法：Rabin-Karp 算法，这是一个很简单优雅的算法。</p><p>本文会由浅入深地讲明白这个算法的核心思路，先从最简单的字符串转数字讲起，然后研究一道力扣题目，到最后你就会发现 Rabin-Karp 算法使用的就是滑动窗口技巧，直接套前文讲的 <a href="https://labuladong.online/algo/essential-technique/sliding-window-framework/">滑动窗口算法框架</a> 就出来了，根本不用死记硬背。</p><p>废话不多说了，直接上干货。</p><p>首先，我问你一个很基础的问题，给你输入一个字符串形式的正整数，如何把它转化成数字的形式？很简单，下面这段代码就可以做到：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;8264&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">    <span class="comment">// 将字符转化成数字</span></span><br><span class="line">    number = <span class="number">10</span> * number + (s.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    System.out.println(number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印输出：</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 82</span></span><br><span class="line"><span class="comment">// 826</span></span><br><span class="line"><span class="comment">// 8264</span></span><br></pre></td></tr></table></figure><p>🌟</p><hr><p>🌟</p><p><strong>可以看到这个算法的核心思路就是不断向最低位（个位）添加数字</strong>，同时把前面的数字整体左移一位（乘以 10）。</p><p>为什么是乘以 10？因为我们默认探讨的是十进制数。这和我们操作二进制数的时候是一个道理，左移一位就是把二进制数乘以 2，右移一位就是除以 2。</p><p>上面这个场景是不断给数字添加最低位，<strong>那如果我想删除数字的最高位，怎么做呢</strong>？比如说我想把 8264 变成 264，应该如何运算？其实也很简单，让 8264 减去 8000 就得到 264 了。</p><p>这个 8000 是怎么来的？是 8 x 10^3 算出来的。8 是最高位的数字，10 是因为我们这里是十进制数，3 是因为 8264 去掉最高位后还剩三位数。</p><p>上述内容主要探讨了如何在数字的最低位添加数字以及如何删除数字的最高位，用 <code>R</code> 表示数字的进制数，用 <code>L</code> 表示数字的位数，就可以总结出如下公式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在最低位添加一个数字 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">8264</span>;</span><br><span class="line"><span class="comment">// number 的进制</span></span><br><span class="line"><span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 想在 number 的最低位添加的数字</span></span><br><span class="line"><span class="type">int</span> <span class="variable">appendVal</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 运算，在最低位添加一位</span></span><br><span class="line">number = R * number + appendVal;</span><br><span class="line"><span class="comment">// 此时 number = 82643</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在最高位删除一个数字 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">8264</span>;</span><br><span class="line"><span class="comment">// number 的进制</span></span><br><span class="line"><span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">// number 最高位的数字</span></span><br><span class="line"><span class="type">int</span> <span class="variable">removeVal</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 此时 number 的位数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 运算，删除最高位数字</span></span><br><span class="line">number = number - removeVal * R^(L-<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 此时 number = 264</span></span><br></pre></td></tr></table></figure><p><strong>如果你能理解这两个公式，那么 Rabin-Karp 算法就没有任何难度</strong>，算法就是这样，再高大上的技巧，都是在最简单最基本的原理之上构建的。不过在讲 Rabin-Karp 算法之前，我们先来看一道简单的力扣题目。</p><h3 id="高效寻找重复子序列"><a href="#高效寻找重复子序列" class="headerlink" title="#高效寻找重复子序列"></a><a href="https://labuladong.online/algo/practice-in-action/rabinkarp/#%E9%AB%98%E6%95%88%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E5%AD%90%E5%BA%8F%E5%88%97">#</a>高效寻找重复子序列</h3><p>看下力扣第 187 题「<a href="https://leetcode.cn/problems/repeated-dna-sequences/">重复的 DNA 序列open in new window</a>」，我简单描述下题目：</p><p>DNA 序列由四种碱基 <code>A, G, C, T</code> 组成，现在给你输入一个只包含 <code>A, G, C, T</code> 四种字符的字符串 <code>s</code> 代表一个 DNA 序列，请你在 <code>s</code> 中找出所有重复出现的长度为 10 的子字符串。</p><p>比如下面的测试用例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;AAAAACCCCC&quot;</span>,<span class="string">&quot;CCCCCAAAAA&quot;</span>]</span><br><span class="line">解释：子串 <span class="string">&quot;AAAAACCCCC&quot;</span> 和 <span class="string">&quot;CCCCCAAAAA&quot;</span> 都重复出现了两次。</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;AAAAAAAAAAAAA&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;AAAAAAAAAA&quot;</span>]</span><br></pre></td></tr></table></figure><p>函数签名如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; <span class="title function_">findRepeatedDnaSequences</span><span class="params">(String s)</span>;</span><br></pre></td></tr></table></figure><p>这道题的拍脑袋解法比较简单粗暴，我直接穷举所有长度为 10 的子串，然后借助哈希集合寻找那些重复的子串就行了，代码如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暴力解法</span></span><br><span class="line">List&lt;String&gt; <span class="title function_">findRepeatedDnaSequences</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="comment">// 记录出现过的子串</span></span><br><span class="line">    HashSet&lt;String&gt; seen = <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">    <span class="comment">// 记录那些重复出现多次的子串</span></span><br><span class="line">    <span class="comment">// 注意要用哈希集合，防止记录重复的结果</span></span><br><span class="line">    HashSet&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i + <span class="number">10</span> &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">subStr</span> <span class="operator">=</span> s.substring(i, i + <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (seen.contains(subStr))&#123;</span><br><span class="line">            <span class="comment">// 之前出现过，找到一个重复的</span></span><br><span class="line">            res.add(subStr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 之前没出现过，加入集合</span></span><br><span class="line">            seen.add(subStr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details data-v-fb30874b="" id="div_repeated-dna-sequences" class="hint-container details" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1.6em 0px; padding: 1rem 0px 0px; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary data-v-fb30874b="" style="position: relative; margin: -1.5rem 0px -0.5rem; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer; display: flex; align-items: center; font-size: large;"><strong data-v-fb30874b="" style="font-weight: 600;">🎃 代码可视化动画 🎃</strong><span data-v-fb30874b="" class="font-icon icon iconfont icon-resize" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-left: auto; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-refresh" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-link" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle;"></span></summary><div data-v-fb30874b="" class="resizable" style="width: 774.091px; max-width: 100%; height: 70vh; max-height: 70vh; overflow: auto; resize: both;"><iframe data-v-fb30874b="" id="iframe_repeated-dna-sequences" src="https://labuladong.online/algo-visualize/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>这个算法肯定是没问题的，只是时间复杂度略高。假设 <code>s</code> 的长度为 <code>N</code>，目标子串的长度为 <code>L</code>（本题 <code>L = 10</code>），for 循环遍历 <code>s</code> 的 <code>O(N)</code> 个字符，对每个字符都要截取长度为 <code>L</code> 的子字符串，所以这个算法的时间复杂是 <code>O(NL)</code>。</p><p><strong>遍历整个 <code>s</code> 肯定是免不了的，问题是我们能不能不要每次都调用 <code>substring</code> 去截取子字符串</strong>？</p><p>你注意我们这个匹配过程实际上就是维护了一个长度为 <code>L = 10</code> 的定长窗口在从左向右滑动，是否可以借鉴前文 <a href="https://labuladong.online/algo/essential-technique/sliding-window-framework/">滑动窗口算法框架</a> 中的做法，只维护 <code>left, right</code> 指针来划定子字符串区间？</p><p>其实可以的，直接套用前文给出的滑动窗口算法框架写出伪码思路：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">HashSet&lt;String&gt; seen;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滑动窗口代码框架</span></span><br><span class="line">CharWindow window;</span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">    <span class="comment">// 扩大窗口，移入字符</span></span><br><span class="line">    window.addRight(s[right]);</span><br><span class="line">    right++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当子串的长度达到要求</span></span><br><span class="line">    <span class="keyword">if</span> (right - left == L) &#123;</span><br><span class="line">        <span class="comment">// 把窗口中的字符变成字符串，还是需要 O(L) 的时间</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">windowStr</span> <span class="operator">=</span> window.toString();</span><br><span class="line">        <span class="keyword">if</span> (seen.contains(windowStr)) &#123;</span><br><span class="line">            print(<span class="string">&quot;找到一个重复子串: &quot;</span>, windowStr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            seen.add(windowHash);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缩小窗口，移出字符</span></span><br><span class="line">        window.removeLeft();</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段伪码直接套用了滑动窗口算法框架，你应该不难理解。但你注意这个解法依然需要将窗口中的字符转化成字符串然后去 <code>seen</code> 集合判断是否存在重复，你一旦想把字符转化成字符串，就难免需要 <code>O(L)</code> 的时间来操作。所以这个算法的时间复杂度还是没有降低，依然是 <code>O(NL)</code>。</p><p><strong>所以优化的关键在于，我们能不能不要真的把子字符串生成出来，而是用一些其他形式的唯一标识来表示滑动窗口中的子字符串，并且还能在窗口滑动的过程中快速更新</strong>？</p><p>有办法的，回想一下本文开头我们讨论的那两个公式，现在你应该明白的用意了。</p><p>你把 <code>AGCT</code> 四种字符等价为 <code>0123</code> 四个数字，那么长度为 <code>L = 10</code> 的一个碱基序列其实就可以等价为一个十位数，这个数字可以唯一标识一个子串。<strong>而且窗口移动的过程，其实就是给这个数字的最低位添加数字，并删除最高位数字的过程</strong>，回顾之前的讲解，添加和删除数字的运算就是两个公式，可以在 <code>O(1)</code> 的时间完成。</p><p>然后，我们不要在哈希集合中直接存储子串了，而是存储子串对应的十位数。因为一个十位数可以唯一标识一个子串，所以也可以起到识别重复的作用。</p><p>这样，我们就避免了直接生成子串存入集合，而是生成一个十位数来表示子串，而且生成这个十位数的时间花费为 <code>O(1)</code>，从而降低了匹配算法的时间复杂度。</p><p>其实你想下，你把一个字符串对象转化成了一个数字，这是什么？这就是你设计的一个哈希算法，生成的数字就可以认为是字符串的哈希值。<strong>在滑动窗口中快速计算窗口中元素的哈希值，叫做滑动哈希技巧</strong>。</p><p>上述优化思路的伪码思路如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 集合中不要存储字符串了，而是存储字符串对应的哈希值</span></span><br><span class="line">HashSet&lt;Integer&gt; seen;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滑动窗口代码框架</span></span><br><span class="line">CharWindow window;</span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">    <span class="comment">// 扩大窗口，移入字符</span></span><br><span class="line">    window.addRight(s[right]);</span><br><span class="line">    right++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当子串的长度达到要求</span></span><br><span class="line">    <span class="keyword">if</span> (right - left == L) &#123;</span><br><span class="line">        <span class="comment">// 获取当前窗口内字符串的哈希值，时间 O(1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">windowHash</span> <span class="operator">=</span> window.hash();</span><br><span class="line">        <span class="comment">// 根据哈希值判断是否曾经出现过相同的子串</span></span><br><span class="line">        <span class="keyword">if</span> (seen.contains(windowHash)) &#123;</span><br><span class="line">            <span class="comment">// 当前窗口中的子串是重复出现的</span></span><br><span class="line">            print(<span class="string">&quot;找到一个重复子串: &quot;</span>, window.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前窗口中的子串之前没有出现过，记下来</span></span><br><span class="line">            seen.add(windowHash);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缩小窗口，移出字符</span></span><br><span class="line">        window.removeLeft();</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步，我们用一个 10 位数来标识一个长度为 10 的碱基字符序列，这需要 long 类型存储，int 存不下 10 位数。但你注意这个 10 位数中所有的数字只会局限于 <code>0,1,2,3</code>，是不是有些浪费？</p><p>换句话说，<strong>我们需要存储的其实只是一个四进制下的十位数</strong>（共包含 4^10 个数字），却用了十进制的十位数（可以包含 10^10 个数字）来保存，显然是有些浪费的。</p><p>因为 4^10 &#x3D; 1048576 &lt; 10^8，所以只要我们在四进制的运算规则下进行运算，十进制的八位数就能存下，这样的话 int 类型就够用了，不需要 long 类型。</p><p>具体来说，只要改变我们之前那两个公式的进制 <code>R</code> 就行了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在最低位添加一个数字 */</span></span><br><span class="line"><span class="comment">// number 的进制</span></span><br><span class="line"><span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 想在 number 的最低位添加的数字</span></span><br><span class="line"><span class="type">int</span> <span class="variable">appendVal</span> <span class="operator">=</span> <span class="number">0</span>~<span class="number">3</span> 中的任意数字;</span><br><span class="line"><span class="comment">// 运算，在最低位添加一位</span></span><br><span class="line">number = R * number + appendVal;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在最高位删除一个数字 */</span></span><br><span class="line"><span class="comment">// number 的进制</span></span><br><span class="line"><span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="comment">// number 最高位的数字</span></span><br><span class="line"><span class="type">int</span> <span class="variable">removeVal</span> <span class="operator">=</span> <span class="number">0</span>~<span class="number">3</span> 中的任意数字;</span><br><span class="line"><span class="comment">// 此时 number 的位数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> ?;</span><br><span class="line"><span class="comment">// 运算，删除最高位数字</span></span><br><span class="line">number = number - removeVal * R^(L-<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>结合数字最高&#x2F;最低位的处理技巧和滑动窗口代码框架，我们就可以轻松地写出最终的解法代码：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; <span class="title function_">findRepeatedDnaSequences</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">// 先把字符串转化成四进制的数字数组</span></span><br><span class="line">    <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (s.charAt(i)) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">                nums[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>:</span><br><span class="line">                nums[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">                nums[i] = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>:</span><br><span class="line">                nums[i] = <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录重复出现的哈希值</span></span><br><span class="line">    HashSet&lt;Integer&gt; seen = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 记录重复出现的字符串结果</span></span><br><span class="line">    HashSet&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数字位数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 进制</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 存储 R^(L - 1) 的结果</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">RL</span> <span class="operator">=</span> (<span class="type">int</span>) Math.pow(R, L - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 维护滑动窗口中字符串的哈希值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">windowHash</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 滑动窗口代码框架，时间 O(N)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; nums.length) &#123;</span><br><span class="line">        <span class="comment">// 扩大窗口，移入字符，并维护窗口哈希值（在最低位添加数字）</span></span><br><span class="line">        windowHash = R * windowHash + nums[right];</span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当子串的长度达到要求</span></span><br><span class="line">        <span class="keyword">if</span> (right - left == L) &#123;</span><br><span class="line">            <span class="comment">// 根据哈希值判断是否曾经出现过相同的子串</span></span><br><span class="line">            <span class="keyword">if</span> (seen.contains(windowHash)) &#123;</span><br><span class="line">                <span class="comment">// 当前窗口中的子串是重复出现的</span></span><br><span class="line">                res.add(s.substring(left, right));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 当前窗口中的子串之前没有出现过，记下来</span></span><br><span class="line">                seen.add(windowHash);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 缩小窗口，移出字符，并维护窗口哈希值（删除最高位数字）</span></span><br><span class="line">            windowHash = windowHash - nums[left] * RL;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转化成题目要求的 List 类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>滑动窗口算法本身的时间复杂度是 <code>O(N)</code>，再看看窗口滑动的过程中的操作耗时，给 <code>res</code> 添加子串的过程用到了 <code>substring</code> 方法需要 <code>O(L)</code> 的复杂度，但一般情况下 <code>substring</code> 方法不会调用很多次，只有极端情况（比如字符串全都是相同的字符）下才会每次滑动窗口时都调用 <code>substring</code> 方法。</p><p>所以我们可以说这个算法一般情况下的平均时间复杂度是 <code>O(N)</code>，极端情况下的时间复杂度会退化成 <code>O(NL)</code>。</p><h3 id="Rabin-Karp-算法"><a href="#Rabin-Karp-算法" class="headerlink" title="#Rabin-Karp 算法"></a><a href="https://labuladong.online/algo/practice-in-action/rabinkarp/#rabin-karp-%E7%AE%97%E6%B3%95">#</a>Rabin-Karp 算法</h3><p>有了上面由浅入深的铺垫，你理解 Rabin-Karp 算法就非常容易了，因为上面这道题目的本质就是一个字符串匹配的问题。</p><p>字符串匹配算法大家都很熟悉，让你在文本串 <code>txt</code> 中搜索模式串 <code>pat</code> 的起始索引，暴力字符串匹配算法是这样的：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在文本串 txt 中搜索模式串 pat 的起始索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(String txt, String pat)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> txt.length(), L = pat.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i + L &lt;= N; i++) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">subStr</span> <span class="operator">=</span> txt.substring(i, i + L);</span><br><span class="line">        <span class="keyword">if</span> (subStr.equals(pat))&#123;</span><br><span class="line">            <span class="comment">// 在 txt 中找到模式串 pat，返回起始索引</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// txt 中不存在模式串 pat</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以发现，这个逻辑和上面讲的那道题的暴力解法非常类似，总的时间复杂度是 <code>O(LN)</code>，优化的核心也是子串 <code>subStr</code> 和模式串 <code>pat</code> 匹配的部分。</p><p><strong>那么借鉴上面的思路，我们不要每次都去一个字符一个字符地比较子串和模式串，而是维护一个滑动窗口，运用滑动哈希算法一边滑动一边计算窗口中字符串的哈希值，拿这个哈希值去和模式串的哈希值比较，这样就可以避免截取子串，从而把匹配算法降低为 <code>O(N)</code>，这就是 Rabin-Karp 指纹字符串查找算法的核心逻辑</strong>。</p><p>那你可能会问，刚才我们处理的题目给你输入的只有 <code>AGCT</code> 四种字符，所以可以转化成数字，但面对五花八门的字符串，如何把他们转化成数字计算哈希值呢？其实很简单，字符本质上就是编码，而编码其实就是数字。</p><p>比方说以 ASCII 码为例，ASCII 码其实就是 0~255 这 256 个数字，分别对应所有英文字符和英文符号。那么一个长度为 <code>L</code> 的 ASCII 字符串，我们就可以等价理解成一个 <code>L</code> 位的 256 进制的数字，这个数字就可以唯一标识这个字符串，也就可以作为哈希值。</p><p>有了这个想法，我们就可以直接复制粘贴上一道题的大部分代码，写出 Rabin-Karp 算法的主要逻辑：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文本串</span></span><br><span class="line">String txt;</span><br><span class="line"><span class="comment">// 模式串</span></span><br><span class="line">String pat;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要寻找的子串长度为模式串 pat 的长度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> pat.length();</span><br><span class="line"><span class="comment">// 仅处理 ASCII 码字符串，可以理解为 256 进制的数字</span></span><br><span class="line"><span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">256</span>;</span><br><span class="line"><span class="comment">// 存储 R^(L - 1) 的结果</span></span><br><span class="line"><span class="type">int</span> <span class="variable">RL</span> <span class="operator">=</span> (<span class="type">int</span>) Math.pow(R, L - <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 维护滑动窗口中字符串的哈希值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">windowHash</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 计算模式串的哈希值</span></span><br><span class="line"><span class="type">long</span> <span class="variable">patHash</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pat.length(); i++) &#123;</span><br><span class="line">    patHash = R * patHash + pat.charAt(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滑动窗口代码框架</span></span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (right &lt; txt.length()) &#123;</span><br><span class="line">    <span class="comment">// 扩大窗口，移入字符（在最低位添加数字）</span></span><br><span class="line">    windowHash = R * windowHash + txt[right];</span><br><span class="line">    right++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当子串的长度达到要求</span></span><br><span class="line">    <span class="keyword">if</span> (right - left == L) &#123;</span><br><span class="line">        <span class="comment">// 根据哈希值判断窗口中的子串是否匹配模式串 pat</span></span><br><span class="line">        <span class="keyword">if</span> (patHash == windowHash) &#123;</span><br><span class="line">            <span class="comment">// 找到模式串</span></span><br><span class="line">            print(<span class="string">&quot;找到模式串，起始索引为&quot;</span>, left);</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 缩小窗口，移出字符（删除最高位数字）</span></span><br><span class="line">        windowHash = windowHash - txt[left] * RL;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有找到模式串</span></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>相对上一道题的解法，这段代码将进制数 <code>R</code> 改为了 256，同时计算了模式串 <code>pat</code> 的哈希值 <code>patHash</code> 用来和窗口中字符串的哈希值 <code>windowHash</code> 做对比，以便判断是否找到了模式串，其他的代码部分完全相同。</p><p><strong>不过呢，这段代码实际运行的时候会有一个严重的问题，那就是整型溢出</strong>。</p><p>你想，上一道题给定的 DNA 序列字符串只包含 <code>AGCT</code> 四种字符，所以我们可以把 DNA 序列抽象成四进制的数字，即算法中 <code>R = 4</code>。相同位数下，四进制包含的数字数量是小于十进制包含的数字数量的。比方说 <code>L = 10</code> 时，4^10 &#x3D; 1048576 &lt; 10^8，即 10 位四进制数字用 8 位十进制数字就可以存下了。</p><p>但现在输入为 ASCII 码字符串，我们不得不把字符串抽象成 256 进制的数字，即算法中 <code>R = 256</code>。而相同位数下，256 进制包含的数字数量显然是远大于十进制包含的数字数量的。比如 <code>L = 10</code> 时，256^10 &#x3D; 1.2 x 10^24 &lt; 10 ^25，所以你需要一个 25 位的十进制数才能表示一个 10 位的 256 进制数。</p><p>可想而知，如果你真的把字符串对应的 256 进制数字的十进制表示作为该字符串的哈希值，那恐怕 <code>L</code> 稍微大一点，像 <code>RL, windowHash, patHash</code> 这些变量就超级大了，long 类型都远远装不下。</p><p><strong>所以解决办法是什么呢？如何把一个很大的数字映射到一个较小的范围内呢？答案是求模（余数）</strong>。</p><p>无论一个数字多大，你让它除以 <code>Q</code>，余数一定会落在 <code>[0, Q-1]</code> 的范围内。所以我们可以设置一个 <code>Q</code>，用求模的方式让 <code>windowHash</code> 和 <code>patHash</code> 保持在 <code>[0, Q-1]</code> 之间，就可以有效避免整型溢出。</p><p>具体来说，对于一个字符串，我们不需要把完整的 256 进制数字存下来，而是对这个巨大的 256 进制数求 <code>Q</code> 的余数，然后把这个余数作为该字符串的哈希值即可。</p><p><strong>好，整型溢出的问题倒是解决了，但新的问题又来了：求模之后的哈希值不能和原始字符串一一对应了，可能出现一对多的情况，即哈希冲突</strong>。</p><p>比方说 10 % 7 等于 3，而 17 % 7 也等于 3，所以如果你得到余数 3，你能确定原始数字就一定是 10 么？不能。</p><p>类似的，如果你发现 <code>windowHash == patHash</code>，你也不敢完全肯定窗口中的字符串一定就和模式串 <code>pat</code> 匹配，有可能它俩不匹配，但恰好求模算出来的哈希值一样，这就产生了是「哈希冲突」。</p><p>在我的 <a href="https://labuladong.online/algo/ds-class/">数据结构精品课open in new window</a> 中哈希表的章节中用拉链法和线性探查法解决了哈希表的哈希冲突。对于 Rabin-Karp 算法来说，当发现 <code>windowHash == patHash</code> 时，使用暴力匹配算法检查一下窗口中的字符串和 <code>pat</code> 是否相同就可以避免哈希冲突了。因为希冲突出现的概率比较小，所以偶尔用一下暴力匹配算法是不影响总体的时间复杂度的。</p><p>明白了这些问题的解决方案，你就能很自然地写出 Rabin-Karp 算法了：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Rabin-Karp 指纹字符串查找算法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rabinKarp</span><span class="params">(String txt, String pat)</span> &#123;</span><br><span class="line">    <span class="comment">// 位数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> pat.length();</span><br><span class="line">    <span class="comment">// 进制（只考虑 ASCII 编码）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">256</span>;</span><br><span class="line">    <span class="comment">// 取一个比较大的素数作为求模的除数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">Q</span> <span class="operator">=</span> <span class="number">1658598167</span>;</span><br><span class="line">    <span class="comment">// R^(L - 1) 的结果</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">RL</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= L - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 计算过程中不断求模，避免溢出</span></span><br><span class="line">        RL = (RL * R) % Q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算模式串的哈希值，时间 O(L)</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">patHash</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pat.length(); i++) &#123;</span><br><span class="line">        patHash = (R * patHash + pat.charAt(i)) % Q;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 滑动窗口中子字符串的哈希值</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">windowHash</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 滑动窗口代码框架，时间 O(N)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; txt.length()) &#123;</span><br><span class="line">        <span class="comment">// 扩大窗口，移入字符</span></span><br><span class="line">        windowHash = ((R * windowHash) % Q + txt.charAt(right)) % Q;</span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当子串的长度达到要求</span></span><br><span class="line">        <span class="keyword">if</span> (right - left == L) &#123;</span><br><span class="line">            <span class="comment">// 根据哈希值判断是否匹配模式串</span></span><br><span class="line">            <span class="keyword">if</span> (windowHash == patHash) &#123;</span><br><span class="line">                <span class="comment">// 当前窗口中的子串哈希值等于模式串的哈希值</span></span><br><span class="line">                <span class="comment">// 还需进一步确认窗口子串是否真的和模式串相同，避免哈希冲突</span></span><br><span class="line">                <span class="keyword">if</span> (pat.equals(txt.substring(left, right))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 缩小窗口，移出字符</span></span><br><span class="line">            windowHash = (windowHash - (txt.charAt(left) * RL) % Q + Q) % Q;</span><br><span class="line">            <span class="comment">// X % Q == (X + Q) % Q 是一个模运算法则</span></span><br><span class="line">            <span class="comment">// 因为 windowHash - (txt[left] * RL) % Q 可能是负数</span></span><br><span class="line">            <span class="comment">// 所以额外再加一个 Q，保证 windowHash 不会是负数</span></span><br><span class="line"></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有找到模式串</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有之前那么多铺垫，算法逻辑应该没啥可说的，就说一下模运算的两个运算法则吧：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">X % Q == (X + Q) % Q</span><br><span class="line">(X + Y) % Q == (X % Q + Y % Q) % Q</span><br></pre></td></tr></table></figure><p>稍微想一想就能理解这两个运算法则，在代码中但凡涉及到乘法和加法，都可能产生很大的结果，所以一有机会就可以运用上述法则对结果进行求模，以避免造成溢出。</p><p>Rabin-Karp 算法的时间复杂度是 <code>O(N + L)</code>，<code>N</code> 为文本串 <code>txt</code> 的长度，<code>L</code> 为模式串 <code>pat</code> 的长度。当然，每次出现哈希冲突时会使用 <code>O(L)</code> 的时间进行暴力匹配，但考虑到只要 <code>Q</code> 设置的合理，哈希冲突的出现概率会很小，所以可以忽略不计。</p><p>最后说一下这个大素数 <code>Q</code> 的选择。</p><p><strong>为什么要这个 <code>Q</code> 尽可能大呢？主要是为了降低哈希冲突的概率</strong>。</p><p>因为代码中你把这个 <code>Q</code> 作为除数，余数（哈希值）一定落在 <code>[0, Q-1]</code> 之间，所以 <code>Q</code> 越大，哈希值的空间就越大，就越不容易出现哈希冲突，整个算法的效率就会高一些。</p><p><strong>为什么这个 <code>Q</code> 要是素数呢？依然是为了降低哈希冲突的概率</strong>。</p><p>举个极端一点的例子，你令 <code>Q = 100</code>，那么无论一个数 <code>X</code> 再大，<code>X % Q</code> 的结果必然是 <code>X</code> 的最后两位。换句话说 <code>X</code> 前面的那些位你根本没利用，可想而知你这个哈希算法存在某些规律性，不够随机，进而更容易导致哈希冲突，降低算法的效率。</p><p>而如果你把 <code>Q</code> 设置为一个素数，可以更充分利用被除数 <code>X</code> 的每一位，得到的结果更随机，哈希冲突的概率更小。这个结论是能够在数学上证明的，有兴趣的读者可以自行搜索学习，我这里就不展开了。</p><p>最后总结一下吧，你看 Rabin-Karp 算法难吗？其实就是滑动哈希配合滑动窗口，滑动哈希就是处理数字的一个小技巧，而 <a href="https://labuladong.online/algo/essential-technique/sliding-window-framework/">滑动窗口算法</a> 是我们早就套路化的一个算法技巧。</p><p>所以，学习算法的关键并不是比谁刷题多，更不是死记硬背，而是要培养框架性的思维，抽象和化简问题的能力，这也正是算法最有趣的地方，你学得越深入，越能体会到这种魅力。</p><p>更多滑动窗口算法的运用 <a href="https://labuladong.gitee.io/article/fname.html?fname=%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%A2%98%E7%9B%AE">见这里open in new window</a>，哈希表处理哈希冲突的原理看 <a href="https://labuladong.online/algo/ds-class/xian-xing--45efc/xian-xing--cc992/">线性探查法解决哈希冲突open in new window</a> 和 <a href="https://labuladong.online/algo/ds-class/yong-la-li-3b08e/xian-shi-x-56c6f/">拉链法解决哈希冲突open in new window</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个方法团灭 LeetCode 打家劫舍问题</title>
      <link href="/posts/7065.html"/>
      <url>/posts/7065.html</url>
      
        <content type="html"><![CDATA[<h1 id="一个方法团灭-LeetCode-打家劫舍问题"><a href="#一个方法团灭-LeetCode-打家劫舍问题" class="headerlink" title="一个方法团灭 LeetCode 打家劫舍问题"></a>一个方法团灭 LeetCode 打家劫舍问题</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/house-robber/">198. House Robberopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍open in new window</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/house-robber-ii/">213. House Robber IIopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 IIopen in new window</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/house-robber-iii/">337. House Robber IIIopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 IIIopen in new window</a></td><td align="center">🟠</td></tr><tr><td align="center">-</td><td align="center"><a href="https://leetcode.cn/problems/Gu0c2T/">剑指 Offer II 089. 房屋偷盗open in new window</a></td><td align="center">🟠</td></tr><tr><td align="center">-</td><td align="center"><a href="https://leetcode.cn/problems/PzWKhm/">剑指 Offer II 090. 环形房屋偷盗open in new window</a></td><td align="center">🟠</td></tr></tbody></table><p>有读者私下问我 LeetCode 「打家劫舍」系列问题（英文版叫 House Robber）怎么做，我发现这一系列题目的点赞非常之高，是比较有代表性和技巧性的动态规划题目，今天就来聊聊这道题目。</p><p>打家劫舍系列总共有三道，难度设计非常合理，层层递进。第一道是比较标准的动态规划问题，而第二道融入了环形数组的条件，第三道更绝，把动态规划的自底向上和自顶向下解法和二叉树结合起来，我认为很有启发性。如果没做过的朋友，建议学习一下。</p><p>下面，我们从第一道开始分析。</p><h3 id="打家劫舍-I"><a href="#打家劫舍-I" class="headerlink" title="#打家劫舍 I"></a><a href="https://labuladong.online/algo/dynamic-programming/house-robber/#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-i">#</a>打家劫舍 I</h3><p>力扣第 198 题「<a href="https://leetcode.cn/problems/house-robber/">打家劫舍open in new window</a>」的题目如下：</p><p>街上有一排房屋，用一个包含非负整数的数组 <code>nums</code> 表示，每个元素 <code>nums[i]</code> 代表第 <code>i</code> 间房子中的现金数额。现在你是一名专业小偷，你希望<strong>尽可能多</strong>的盗窃这些房子中的现金，但是，<strong>相邻的房子不能被同时盗窃</strong>，否则会触发报警器，你就凉凉了。</p><p>请你写一个算法，计算在不触动报警器的前提下，最多能够盗窃多少现金呢？函数签名如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span>;</span><br></pre></td></tr></table></figure><p>比如说输入 <code>nums=[2,1,7,9,3,1]</code>，算法返回 12，小偷可以盗窃 <code>nums[0], nums[3], nums[5]</code> 三个房屋，得到的现金之和为 2 + 9 + 1 &#x3D; 12，是最优的选择。</p><p>题目很容易理解，而且动态规划的特征很明显。我们前文 <a href="https://labuladong.online/algo/essential-technique/dynamic-programming-framework/">动态规划详解</a> 做过总结，<strong>解决动态规划问题就是找「状态」和「选择」，仅此而已</strong>。</p><p>🌟</p><hr><p>🌟</p><p>假想你就是这个专业强盗，从左到右走过这一排房子，在每间房子前都有两种<strong>选择</strong>：抢或者不抢。</p><p>如果你抢了这间房子，那么你<strong>肯定</strong>不能抢相邻的下一间房子了，只能从下下间房子开始做选择。</p><p>如果你不抢这件房子，那么你可以走到下一间房子前，继续做选择。</p><p>当你走过了最后一间房子后，你就没得抢了，能抢到的钱显然是 0（<strong>base case</strong>）。</p><p>以上的逻辑很简单吧，其实已经明确了「状态」和「选择」：<strong>你面前房子的索引就是状态，抢和不抢就是选择</strong>。</p><p><img src="https://labuladong.online/algo/images/robber/1.jpg" alt="img"></p><p>在两个选择中，每次都选更大的结果，最后得到的就是最多能抢到的 money：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 主函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dp(nums, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回 nums[start..] 能抢到的最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(</span><br><span class="line">                <span class="comment">// 不抢，去下家</span></span><br><span class="line">                dp(nums, start + <span class="number">1</span>), </span><br><span class="line">                <span class="comment">// 抢，去下下家</span></span><br><span class="line">                nums[start] + dp(nums, start + <span class="number">2</span>)</span><br><span class="line">            );</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明确了状态转移，就可以发现对于同一 <code>start</code> 位置，是存在重叠子问题的，比如下图：</p><p><img src="https://labuladong.online/algo/images/robber/2.jpg" alt="img"></p><p>盗贼有多种选择可以走到这个位置，如果每次到这都进入递归，岂不是浪费时间？所以说存在重叠子问题，可以用备忘录进行优化：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] memo;</span><br><span class="line">    <span class="comment">// 主函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化备忘录</span></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(memo, -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 强盗从第 0 间房子开始抢劫</span></span><br><span class="line">        <span class="keyword">return</span> dp(nums, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 dp[start..] 能抢到的最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 避免重复计算</span></span><br><span class="line">        <span class="keyword">if</span> (memo[start] != -<span class="number">1</span>) <span class="keyword">return</span> memo[start];</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(</span><br><span class="line">            dp(nums, start + <span class="number">1</span>), </span><br><span class="line">            dp(nums, start + <span class="number">2</span>) + nums[start]</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 记入备忘录</span></span><br><span class="line">        memo[start] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details data-v-fb30874b="" id="div_house-robber" class="hint-container details" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1.6em 0px; padding: 1rem 0px 0px; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary data-v-fb30874b="" style="position: relative; margin: -1.5rem 0px -0.5rem; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer; display: flex; align-items: center; font-size: large;"><strong data-v-fb30874b="" style="font-weight: 600;">🌈 代码可视化动画 🌈</strong><span data-v-fb30874b="" class="font-icon icon iconfont icon-resize" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-left: auto; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-refresh" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-link" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle;"></span></summary><div data-v-fb30874b="" class="resizable" style="width: 774.091px; max-width: 100%; height: 70vh; max-height: 70vh; overflow: auto; resize: both;"><iframe data-v-fb30874b="" id="iframe_house-robber" src="https://labuladong.online/algo-visualize/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>这就是自顶向下的动态规划解法，我们也可以略作修改，写出<strong>自底向上</strong>的解法：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// dp[i] = x 表示：</span></span><br><span class="line">    <span class="comment">// 从第 i 间房子开始抢劫，最多能抢到的钱为 x</span></span><br><span class="line">    <span class="comment">// base case: dp[n] = 0</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i + <span class="number">1</span>], nums[i] + dp[i + <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们又发现状态转移只和 <code>dp[i]</code> 最近的两个状态有关，所以可以进一步优化，将空间复杂度降低到 O(1)。</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 记录 dp[i+1] 和 dp[i+2]</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dp_i_1</span> <span class="operator">=</span> <span class="number">0</span>, dp_i_2 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录 dp[i]</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dp_i</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp_i = Math.max(dp_i_1, nums[i] + dp_i_2);</span><br><span class="line">        dp_i_2 = dp_i_1;</span><br><span class="line">        dp_i_1 = dp_i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的流程，在我们 <a href="https://labuladong.online/algo/essential-technique/dynamic-programming-framework/">动态规划详解</a> 中详细解释过，相信大家都能手到擒来了。我认为很有意思的是这个问题的 follow up，需要基于我们现在的思路做一些巧妙的应变。</p><h3 id="打家劫舍-II"><a href="#打家劫舍-II" class="headerlink" title="#打家劫舍 II"></a><a href="https://labuladong.online/algo/dynamic-programming/house-robber/#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-ii">#</a>打家劫舍 II</h3><p>力扣第 213 题「<a href="https://leetcode.cn/problems/house-robber-ii/">打家劫舍 IIopen in new window</a>」和上一道题描述基本一样，强盗依然不能抢劫相邻的房子，输入依然是一个数组，但是告诉你<strong>这些房子不是一排，而是围成了一个圈</strong>。</p><p>也就是说，现在第一间房子和最后一间房子也相当于是相邻的，不能同时抢。比如说输入数组 <code>nums=[2,3,2]</code>，算法返回的结果应该是 3 而不是 4，因为开头和结尾不能同时被抢。</p><p>这个约束条件看起来应该不难解决，我们前文 <a href="https://labuladong.online/algo/data-structure/monotonic-stack/">单调栈问题汇总</a> 说过一种解决环形数组的方案，那么在这个问题上怎么处理呢？</p><p>首先，首尾房间不能同时被抢，那么只可能有三种不同情况：要么都不被抢；要么第一间房子被抢最后一间不抢；要么最后一间房子被抢第一间不抢。</p><p><img src="https://labuladong.online/algo/images/robber/3.jpg" alt="img"></p><p>那就简单了啊，这三种情况，哪种的结果最大，就是最终答案呗！不过，其实我们不需要比较三种情况，只要比较情况二和情况三就行了，<strong>因为这两种情况对于房子的选择余地比情况一大呀，房子里的钱数都是非负数，所以选择余地大，最优决策结果肯定不会小</strong>。</p><p>所以只需对之前的解法稍作修改即可：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> Math.max(robRange(nums, <span class="number">0</span>, n - <span class="number">2</span>), </span><br><span class="line">                        robRange(nums, <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅计算闭区间 [start,end] 的最优结果</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">robRange</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dp_i_1</span> <span class="operator">=</span> <span class="number">0</span>, dp_i_2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dp_i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> end; i &gt;= start; i--) &#123;</span><br><span class="line">            dp_i = Math.max(dp_i_1, nums[i] + dp_i_2);</span><br><span class="line">            dp_i_2 = dp_i_1;</span><br><span class="line">            dp_i_1 = dp_i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp_i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，第二问也解决了。</p><h3 id="打家劫舍-III"><a href="#打家劫舍-III" class="headerlink" title="#打家劫舍 III"></a><a href="https://labuladong.online/algo/dynamic-programming/house-robber/#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-iii">#</a>打家劫舍 III</h3><p>力扣第 337 题「<a href="https://leetcode.cn/problems/house-robber-iii/">打家劫舍 IIIopen in new window</a>」又想法设法地变花样了，此强盗发现现在面对的房子不是一排，不是一圈，而是一棵二叉树！房子在二叉树的节点上，相连的两个房子不能同时被抢劫，果然是传说中的高智商犯罪：</p><p>函数的签名如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span>;</span><br></pre></td></tr></table></figure><p>比如说输入为下图这样一棵二叉树：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br><span class="line"> \   \ </span><br><span class="line">  3   1</span><br></pre></td></tr></table></figure><p>算法应该返回 7，因为抢劫第一层和第三层的房子可以得到最高金额 3 + 3 + 1 &#x3D; 7。</p><p>如果输入为下图这棵二叉树：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br><span class="line"> / \   \ </span><br><span class="line">1   3   1</span><br></pre></td></tr></table></figure><p>那么算法应该返回 9，如果抢劫第二层的房子可以获得最高金额 4 + 5 &#x3D; 9。</p><p>整体的思路完全没变，还是做抢或者不抢的选择，去收益较大的选择。甚至我们可以直接按这个套路写出代码：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;TreeNode, Integer&gt; memo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 利用备忘录消除重叠子问题</span></span><br><span class="line">        <span class="keyword">if</span> (memo.containsKey(root)) </span><br><span class="line">            <span class="keyword">return</span> memo.get(root);</span><br><span class="line">        <span class="comment">// 抢，然后去下下家</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">do_it</span> <span class="operator">=</span> root.val</span><br><span class="line">            + (root.left == <span class="literal">null</span> ? </span><br><span class="line">                <span class="number">0</span> : rob(root.left.left) + rob(root.left.right))</span><br><span class="line">            + (root.right == <span class="literal">null</span> ? </span><br><span class="line">                <span class="number">0</span> : rob(root.right.left) + rob(root.right.right));</span><br><span class="line">        <span class="comment">// 不抢，然后去下家</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">not_do</span> <span class="operator">=</span> rob(root.left) + rob(root.right);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(do_it, not_do);</span><br><span class="line">        memo.put(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details data-v-fb30874b="" id="div_house-robber-iii" class="hint-container details" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1.6em 0px; padding: 1rem 0px 0px; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary data-v-fb30874b="" style="position: relative; margin: -1.5rem 0px -0.5rem; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer; display: flex; align-items: center; font-size: large;"><strong data-v-fb30874b="" style="font-weight: 600;">👾 代码可视化动画 👾</strong><span data-v-fb30874b="" class="font-icon icon iconfont icon-resize" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-left: auto; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-refresh" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-link" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle;"></span></summary><div data-v-fb30874b="" class="resizable" style="width: 774.091px; max-width: 100%; height: 70vh; max-height: 70vh; overflow: auto; resize: both;"><iframe data-v-fb30874b="" id="iframe_house-robber-iii" src="https://labuladong.online/algo-visualize/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>这道题就解决了，时间复杂度 O(N)，<code>N</code> 为数的节点数。</p><p>但是这道题让我觉得巧妙的点在于，还有更漂亮的解法。比如下面是我在评论区看到的一个解法：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] res = dp(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回一个大小为 2 的数组 arr</span></span><br><span class="line"><span class="comment">    arr[0] 表示不抢 root 的话，得到的最大钱数</span></span><br><span class="line"><span class="comment">    arr[1] 表示抢 root 的话，得到的最大钱数 */</span></span><br><span class="line">    <span class="type">int</span>[] dp(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] left = dp(root.left);</span><br><span class="line">        <span class="type">int</span>[] right = dp(root.right);</span><br><span class="line">        <span class="comment">// 抢，下家就不能抢了</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rob</span> <span class="operator">=</span> root.val + left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 不抢，下家可抢可不抢，取决于收益大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">not_rob</span> <span class="operator">=</span> Math.max(left[<span class="number">0</span>], left[<span class="number">1</span>])</span><br><span class="line">                    + Math.max(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;not_rob, rob&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 O(N)，空间复杂度只有递归函数堆栈所需的空间，不需要备忘录的额外空间。</p><p>你看他和我们的思路不一样，修改了递归函数的定义，略微修改了思路，使得逻辑自洽，依然得到了正确的答案，而且代码更漂亮。这就是我们前文 <a href="https://labuladong.online/algo/dynamic-programming/four-keyboard/">不同定义产生不同解法</a> 所说过的动态规划问题的一个特性。</p><p>实际上，这个解法比我们的解法运行时间要快得多，虽然算法分析层面时间复杂度是相同的。原因在于此解法没有使用额外的备忘录，减少了数据操作的复杂性，所以实际运行效率会快。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典动态规划：戳气球</title>
      <link href="/posts/17880.html"/>
      <url>/posts/17880.html</url>
      
        <content type="html"><![CDATA[<h1 id="经典动态规划：戳气球"><a href="#经典动态规划：戳气球" class="headerlink" title="经典动态规划：戳气球"></a>经典动态规划：戳气球</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/burst-balloons/">312. Burst Balloonsopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/burst-balloons/">312. 戳气球open in new window</a></td><td align="center">🔴</td></tr></tbody></table><p>今天我们要聊的这道题「Burst Balloon」和之前我们写过的那篇 <a href="https://labuladong.online/algo/dynamic-programming/egg-drop/">经典动态规划：高楼扔鸡蛋问题</a> 分析过的高楼扔鸡蛋问题类似，知名度很高，但难度确实也很大。因此我的公众号就给这道题赐个座，来看一看这道题目到底有多难。</p><p>它是力扣第 312 题「<a href="https://leetcode.cn/problems/burst-balloons/">戳气球open in new window</a>」，题目如下：</p><details class="hint-container details" open="" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1rem 0px; padding: 1.5rem; border-radius: 0.5rem; background: var(--detail-bg-color); color: rgb(44, 62, 80); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, STHeiti, &quot;Microsoft YaHei&quot;, SimSun, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="position: relative; margin: -1.5rem -1.5rem 0.5em; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer;"><strong style="font-weight: 600;">312. 戳气球</strong>&nbsp;|<span>&nbsp;</span><a target="_blank" href="https://leetcode.cn/problems/burst-balloons/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|<span>&nbsp;</span><a target="_blank" href="https://leetcode.com/problems/burst-balloons/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">有<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">n</code><span>&nbsp;</span>个气球，编号为<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">0</code><span>&nbsp;</span>到<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">n - 1</code>，每个气球上都标有一个数字，这些数字存在数组&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">nums</code>&nbsp;中。</p><p style="line-height: 1.6; overflow-wrap: break-word;">现在要求你戳破所有的气球。戳破第<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">i</code><span>&nbsp;</span>个气球，你可以获得&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">nums[i - 1] * nums[i] * nums[i + 1]</code><span>&nbsp;</span>枚硬币。&nbsp;这里的<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">i - 1</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">i + 1</code><span>&nbsp;</span>代表和&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">i</code>&nbsp;相邻的两个气球的序号。如果<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">i - 1</code>或<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">i + 1</code><span>&nbsp;</span>超出了数组的边界，那么就当它是一个数字为<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1</code><span>&nbsp;</span>的气球。</p><p style="line-height: 1.6; overflow-wrap: break-word;">求所能获得硬币的最大数量。</p><strong style="font-weight: 600;">示例 1：</strong><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>nums = [3,1,5,8]<strong style="font-weight: 600;">输出：</strong>167<strong style="font-weight: 600;">解释：</strong>nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>nums = [1,5]<strong style="font-weight: 600;">输出：</strong>10</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">n == nums.length</code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 &lt;= n &lt;= 300</code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">0 &lt;= nums[i] &lt;= 100</code></li></ul></div></details><p>首先必须要说明，这个题目的状态转移方程真的比较巧妙，所以说如果你看了题目之后完全没有思路恰恰是正常的。虽然最优答案不容易想出来，但基本的思路分析是我们应该力求做到的。所以本文会先分析一下常规思路，然后再引入动态规划解法。</p><h3 id="一、回溯思路"><a href="#一、回溯思路" class="headerlink" title="#一、回溯思路"></a><a href="https://labuladong.online/algo/dynamic-programming/burst-balloons/#%E4%B8%80%E3%80%81%E5%9B%9E%E6%BA%AF%E6%80%9D%E8%B7%AF">#</a>一、回溯思路</h3><p>先来顺一下解决这种问题的套路：</p><p>🌟</p><hr><p>🌟</p><p><strong>我们前文多次强调过，很显然只要涉及求最值，没有任何特殊方法，一定是穷举所有可能的结果，然后对比得出最值</strong>。</p><p>所以说，只要遇到求最值的算法问题，首先要思考的就是：如何穷举出所有可能的结果？</p><p>穷举主要有两种算法，就是回溯算法和动态规划，前者就是暴力穷举，而后者是根据状态转移方程推导「状态」。</p><p>如何将我们的扎气球问题转化成回溯算法呢？这个应该不难想到的，<strong>我们其实就是想穷举戳气球的顺序</strong>，不同的戳气球顺序可能得到不同的分数，我们需要把所有可能的分数中最高的那个找出来，对吧。</p><p>那么，这不就是一个「全排列」问题嘛，我们前文 <a href="https://labuladong.online/algo/essential-technique/backtrack-framework/">回溯算法框架套路详解</a> 中有全排列算法的详解和代码，其实只要稍微改一下逻辑即可，伪码思路如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"><span class="comment">/* 输入一组气球，返回戳破它们获得的最大分数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxCoins</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    backtrack(nums, <span class="number">0</span>); </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 回溯算法的伪码解法 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> socre)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums 为空) &#123;</span><br><span class="line">        res = max(res, score);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">point</span> <span class="operator">=</span> nums[i-<span class="number">1</span>] * nums[i] * nums[i+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        在 nums 中删除元素 nums[i]</span><br><span class="line">        <span class="comment">// 递归回溯</span></span><br><span class="line">        backtrack(nums, score + point);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        将 temp 还原到 nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回溯算法就是这么简单粗暴，但是相应的，算法的效率非常低。这个解法等同于全排列，所以时间复杂度是阶乘级别，非常高，题目说了 <code>nums</code> 的大小 <code>n</code> 最多为 500，所以回溯算法肯定是不能通过所有测试用例的。</p><h3 id="二、动态规划思路"><a href="#二、动态规划思路" class="headerlink" title="#二、动态规划思路"></a><a href="https://labuladong.online/algo/dynamic-programming/burst-balloons/#%E4%BA%8C%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%9D%E8%B7%AF">#</a>二、动态规划思路</h3><p>这个动态规划问题和我们之前的动态规划系列文章相比有什么特别之处？为什么它比较难呢？</p><p><strong>原因在于，这个问题中我们每戳破一个气球 <code>nums[i]</code>，得到的分数和该气球相邻的气球 <code>nums[i-1]</code> 和 <code>nums[i+1]</code> 是有相关性的</strong>。</p><p>我们前文 <a href="https://labuladong.online/algo/essential-technique/dynamic-programming-framework/">动态规划套路框架详解</a> 说过运用动态规划算法的一个重要条件：<strong>子问题必须独立</strong>。所以对于这个戳气球问题，如果想用动态规划，必须巧妙地定义 <code>dp</code> 数组的含义，避免子问题产生相关性，才能推出合理的状态转移方程。</p><p>如何定义 <code>dp</code> 数组呢，这里需要对问题进行一个简单地转化。题目说可以认为 <code>nums[-1] = nums[n] = 1</code>，那么我们先直接把这两个边界加进去，形成一个新的数组 <code>points</code>：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxCoins</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 两端加入两个虚拟气球</span></span><br><span class="line">    <span class="type">int</span>[] points = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>];</span><br><span class="line">    points[<span class="number">0</span>] = points[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        points[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在气球的索引变成了从 <code>1</code> 到 <code>n</code>，<code>points[0]</code> 和 <code>points[n+1]</code> 可以认为是两个「虚拟气球」。</p><p>那么我们可以改变问题：<strong>在一排气球 <code>points</code> 中，请你戳破气球 <code>0</code> 和气球 <code>n+1</code> 之间的所有气球（不包括 <code>0</code> 和 <code>n+1</code>），使得最终只剩下气球 <code>0</code> 和气球 <code>n+1</code> 两个气球，最多能够得到多少分</strong>？</p><p>现在可以定义 <code>dp</code> 数组的含义：</p><p>**<code>dp[i][j] = x</code> 表示，戳破气球 <code>i</code> 和气球 <code>j</code> 之间（开区间，不包括 <code>i</code> 和 <code>j</code>）的所有气球，可以获得的最高分数为 <code>x</code>**。</p><p>那么根据这个定义，题目要求的结果就是 <code>dp[0][n+1]</code> 的值，而 base case 就是 <code>dp[i][j] = 0</code>，其中 <code>0 &lt;= i &lt;= n+1, j &lt;= i+1</code>，因为这种情况下，开区间 <code>(i, j)</code> 中间根本没有气球可以戳。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// base case 已经都被初始化为 0</span></span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>现在我们要根据这个 <code>dp</code> 数组来推导状态转移方程了，根据我们前文的套路，所谓的推导「状态转移方程」，实际上就是在思考怎么「做选择」，也就是这道题目最有技巧的部分：</p><p>不就是想求戳破气球 <code>i</code> 和气球 <code>j</code> 之间的最高分数吗，如果「正向思考」，就只能写出前文的回溯算法；<strong>我们需要「反向思考」，想一想气球 <code>i</code> 和气球 <code>j</code> 之间最后一个被戳破的气球可能是哪一个</strong>？</p><p>其实气球 <code>i</code> 和气球 <code>j</code> 之间的所有气球都可能是最后被戳破的那一个，不防假设为 <code>k</code>。回顾动态规划的套路，这里其实已经找到了「状态」和「选择」：<code>i</code> 和 <code>j</code> 就是两个「状态」，最后戳破的那个气球 <code>k</code> 就是「选择」。</p><p><strong>根据刚才对 <code>dp</code> 数组的定义，如果最后一个戳破气球 <code>k</code>，<code>dp[i][j]</code> 的值应该为</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i][k] + dp[k][j] </span><br><span class="line">         + points[i]*points[k]*points[j]</span><br></pre></td></tr></table></figure><p>你不是要最后戳破气球 <code>k</code> 吗？那得先把开区间 <code>(i, k)</code> 的气球都戳破，再把开区间 <code>(k, j)</code> 的气球都戳破；最后剩下的气球 <code>k</code>，相邻的就是气球 <code>i</code> 和气球 <code>j</code>，这时候戳破 <code>k</code> 的话得到的分数就是 <code>points[i]*points[k]*points[j]</code>。</p><p>那么戳破开区间 <code>(i, k)</code> 和开区间 <code>(k, j)</code> 的气球最多能得到的分数是多少呢？嘿嘿，就是 <code>dp[i][k]</code> 和 <code>dp[k][j]</code>，这恰好就是我们对 <code>dp</code> 数组的定义嘛！</p><p><img src="https://labuladong.online/algo/images/burstBalloon/1.jpeg" alt="img"></p><p>结合这个图，就能体会出 <code>dp</code> 数组定义的巧妙了。由于是开区间，<code>dp[i][k]</code> 和 <code>dp[k][j]</code> 不会影响气球 <code>k</code>；而戳破气球 <code>k</code> 时，旁边相邻的就是气球 <code>i</code> 和气球 <code>j</code> 了，最后还会剩下气球 <code>i</code> 和气球 <code>j</code>，这也恰好满足了 <code>dp</code> 数组开区间的定义。</p><p>那么，对于一组给定的 <code>i</code> 和 <code>j</code>，我们只要穷举 <code>i &lt; k &lt; j</code> 的所有气球 <code>k</code>，选择得分最高的作为 <code>dp[i][j]</code> 的值即可，这也就是状态转移方程：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最后戳破的气球是哪个？</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">    <span class="comment">// 择优做选择，使得 dp[i][j] 最大</span></span><br><span class="line">    dp[i][j] = Math.max(</span><br><span class="line">        dp[i][j], </span><br><span class="line">        dp[i][k] + dp[k][j] + points[i]*points[j]*points[k]</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写出状态转移方程就完成这道题的一大半了，但是还有问题：对于 <code>k</code> 的穷举仅仅是在做「选择」，但是应该如何穷举「状态」<code>i</code> 和 <code>j</code> 呢？</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ...; ; )</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> ...; ; )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">            dp[i][j] = Math.max(</span><br><span class="line">                dp[i][j], </span><br><span class="line">                dp[i][k] + dp[k][j] + points[i]*points[j]*points[k]</span><br><span class="line">            );</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][n+<span class="number">1</span>];</span><br></pre></td></tr></table></figure><h3 id="三、写出代码"><a href="#三、写出代码" class="headerlink" title="#三、写出代码"></a><a href="https://labuladong.online/algo/dynamic-programming/burst-balloons/#%E4%B8%89%E3%80%81%E5%86%99%E5%87%BA%E4%BB%A3%E7%A0%81">#</a>三、写出代码</h3><p><strong>关于「状态」的穷举，最重要的一点就是：状态转移所依赖的状态必须被提前计算出来</strong>。</p><p>拿这道题举例，<code>dp[i][j]</code> 所依赖的状态是 <code>dp[i][k]</code> 和 <code>dp[k][j]</code>，那么我们必须保证：在计算 <code>dp[i][j]</code> 时，<code>dp[i][k]</code> 和 <code>dp[k][j]</code> 已经被计算出来了（其中 <code>i &lt; k &lt; j</code>）。</p><p>那么应该如何安排 <code>i</code> 和 <code>j</code> 的遍历顺序，来提供上述的保证呢？我们前文 <a href="https://labuladong.online/algo/dynamic-programming/faq-summary/">动态规划答疑篇</a> 写过处理这种问题的一个鸡贼技巧：<strong>根据 base case 和最终状态进行推导</strong>。</p><p>注</p><p>最终状态就是指题目要求的结果，对于这道题目也就是 <code>dp[0][n+1]</code>。</p><p>我们先把 base case 和最终的状态在 DP table 上画出来：</p><p><img src="https://labuladong.online/algo/images/burstBalloon/2.jpeg" alt="img"></p><p>对于任一 <code>dp[i][j]</code>，我们希望所有 <code>dp[i][k]</code> 和 <code>dp[k][j]</code> 已经被计算，画在图上就是这种情况：</p><p><img src="https://labuladong.online/algo/images/burstBalloon/3.jpeg" alt="img"></p><p>那么，为了达到这个要求，可以有两种遍历方法，要么斜着遍历，要么从下到上从左到右遍历：</p><p><img src="https://labuladong.online/algo/images/burstBalloon/4.jpeg" alt="img"></p><p><img src="https://labuladong.online/algo/images/burstBalloon/5.jpeg" alt="img"></p><p>斜着遍历有一点难写，所以一般我们就从下往上遍历，下面看完整代码：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxCoins</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 添加两侧的虚拟气球</span></span><br><span class="line">    <span class="type">int</span>[] points = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>];</span><br><span class="line">    points[<span class="number">0</span>] = points[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        points[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// base case 已经都被初始化为 0</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 开始状态转移</span></span><br><span class="line">    <span class="comment">// i 应该从下往上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// j 应该从左往右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n + <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 最后戳破的气球是哪个？</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                <span class="comment">// 择优做选择</span></span><br><span class="line">                dp[i][j] = Math.max(</span><br><span class="line">                    dp[i][j], </span><br><span class="line">                    dp[i][k] + dp[k][j] + points[i]*points[j]*points[k]</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details data-v-fb30874b="" id="div_burst-balloons" class="hint-container details" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1.6em 0px; padding: 1rem 0px 0px; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary data-v-fb30874b="" style="position: relative; margin: -1.5rem 0px -0.5rem; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer; display: flex; align-items: center; font-size: large;"><strong data-v-fb30874b="" style="font-weight: 600;">🎃 代码可视化动画 🎃</strong><span data-v-fb30874b="" class="font-icon icon iconfont icon-resize" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-left: auto; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-refresh" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-link" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle;"></span></summary><div data-v-fb30874b="" class="resizable" style="width: 774.091px; max-width: 100%; height: 70vh; max-height: 70vh; overflow: auto; resize: both;"><iframe data-v-fb30874b="" id="iframe_burst-balloons" src="https://labuladong.online/algo-visualize/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>至此，这道题目就完全解决了，十分巧妙，但也不是那么难，对吧？</p><p>关键在于 <code>dp</code> 数组的定义，需要避免子问题互相影响，所以我们反向思考，将 <code>dp[i][j]</code> 的定义设为开区间，考虑最后戳破的气球是哪一个，以此构建了状态转移方程。</p><p>对于如何穷举「状态」，我们使用了小技巧，通过 base case 和最终状态推导出 <code>i, j</code> 的遍历方向，保证正确的状态转移。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典动态规划：正则表达式</title>
      <link href="/posts/37545.html"/>
      <url>/posts/37545.html</url>
      
        <content type="html"><![CDATA[<h1 id="经典动态规划：正则表达式"><a href="#经典动态规划：正则表达式" class="headerlink" title="经典动态规划：正则表达式"></a>经典动态规划：正则表达式</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/regular-expression-matching/">10. Regular Expression Matchingopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/regular-expression-matching/">10. 正则表达式匹配open in new window</a></td><td align="center">🔴</td></tr><tr><td align="center">-</td><td align="center"><a href="https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">剑指 Offer 19. 正则表达式匹配open in new window</a></td><td align="center">🔴</td></tr></tbody></table><p>正则表达式是一个非常强力的工具，本文就来具体看一看正则表达式的底层原理是什么。力扣第 10 题「<a href="https://leetcode.cn/problems/regular-expression-matching/">正则表达式匹配open in new window</a>」就要求我们实现一个简单的正则匹配算法，包括「.」通配符和「*」通配符。</p><p>这两个通配符是最常用的，其中点号「.」可以匹配任意一个字符，星号「*」可以让之前的那个字符重复任意次数（包括 0 次）。</p><p>比如说模式串 <code>&quot;.a*b&quot;</code> 就可以匹配文本 <code>&quot;zaaab&quot;</code>，也可以匹配 <code>&quot;cb&quot;</code>；模式串 <code>&quot;a..b&quot;</code> 可以匹配文本 <code>&quot;amnb&quot;</code>；而模式串 <code>&quot;.*&quot;</code> 就比较牛逼了，它可以匹配任何文本。</p><p>题目会给我们输入两个字符串 <code>s</code> 和 <code>p</code>，<code>s</code> 代表文本，<code>p</code> 代表模式串，请你判断模式串 <code>p</code> 是否可以匹配文本 <code>s</code>。我们可以假设模式串只包含小写字母和上述两种通配符且一定合法，不会出现 <code>*a</code> 或者 <code>b**</code> 这种不合法的模式串，</p><p>函数签名如下：</p><p>java 🤖cpp 🟢python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：java 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span></span><br><span class="line"><span class="comment">// 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 cpp 代码对比查看。</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span>;</span><br></pre></td></tr></table></figure><p>对于我们将要实现的这个正则表达式，难点在那里呢？</p><p>点号通配符其实很好实现，<code>s</code> 中的任何字符，只要遇到 <code>.</code> 通配符，无脑匹配就完事了。主要是这个星号通配符不好实现，一旦遇到 <code>*</code> 通配符，前面的那个字符可以选择重复一次，可以重复多次，也可以一次都不出现，这该怎么办？</p><p>对于这个问题，答案很简单，对于所有可能出现的情况，全部穷举一遍，只要有一种情况可以完成匹配，就认为 <code>p</code> 可以匹配 <code>s</code>。那么一旦涉及两个字符串的穷举，我们就应该条件反射地想到动态规划的技巧了。</p><h3 id="一、思路分析"><a href="#一、思路分析" class="headerlink" title="#一、思路分析"></a><a href="https://labuladong.online/algo/dynamic-programming/regular-expression-matching/#%E4%B8%80%E3%80%81%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90">#</a>一、思路分析</h3><p>我们先脑补一下，<code>s</code> 和 <code>p</code> 相互匹配的过程大致是，两个指针 <code>i, j</code> 分别在 <code>s</code> 和 <code>p</code> 上移动，如果最后两个指针都能移动到字符串的末尾，那么久匹配成功，反之则匹配失败。</p><p><strong>如果不考虑 <code>\*</code> 通配符，面对两个待匹配字符 <code>s[i]</code> 和 <code>p[j]</code>，我们唯一能做的就是看他俩是否匹配</strong>：</p><p>java 🤖cpp 🟢python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：java 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span></span><br><span class="line"><span class="comment">// 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 cpp 代码对比查看。</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; j &lt; p.length()) &#123;</span><br><span class="line">        <span class="comment">// 「.」通配符就是万金油</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == p.charAt(j) || p.charAt(j) == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 匹配，接着匹配 s[i+1..] 和 p[j+1..]</span></span><br><span class="line">            i++; j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不匹配</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i == j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么考虑一下，如果加入 <code>*</code> 通配符，局面就会稍微复杂一些，不过只要分情况来分析，也不难理解。</p><p><strong>当 <code>p[j + 1]</code> 为 <code>\*</code> 通配符时，我们分情况讨论下</strong>：</p><p>1、如果 <code>s[i] == p[j]</code>，那么有两种情况：</p><p>1.1 <code>p[j]</code> 有可能会匹配多个字符，比如 <code>s = &quot;aaa&quot;, p = &quot;a*&quot;</code>，那么 <code>p[0]</code> 会通过 <code>*</code> 匹配 3 个字符 <code>&quot;a&quot;</code>。</p><p>1.2 <code>p[i]</code> 也有可能匹配 0 个字符，比如 <code>s = &quot;aa&quot;, p = &quot;a*aa&quot;</code>，由于后面的字符可以匹配 <code>s</code>，所以 <code>p[0]</code> 只能匹配 0 次。</p><p>2、如果 <code>s[i] != p[j]</code>，只有一种情况：</p><p><code>p[j]</code> 只能匹配 0 次，然后看下一个字符是否能和 <code>s[i]</code> 匹配。比如说 <code>s = &quot;aa&quot;, p = &quot;b*aa&quot;</code>，此时 <code>p[0]</code> 只能匹配 0 次。</p><p>综上，可以把之前的代码针对 <code>*</code> 通配符进行一下改造：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 匹配</span></span><br><span class="line">    <span class="keyword">if</span> (j &lt; p.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 有 * 通配符，可以匹配 0 次或多次</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 无 * 通配符，老老实实匹配 1 次</span></span><br><span class="line">        i++; j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不匹配</span></span><br><span class="line">    <span class="keyword">if</span> (j &lt; p.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 有 * 通配符，只能匹配 0 次</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 无 * 通配符，匹配无法进行下去了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体的思路已经很清晰了，但现在的问题是，遇到 <code>*</code> 通配符时，到底应该匹配 0 次还是匹配多次？多次是几次？</p><p>你看，这就是一个做「选择」的问题，要把所有可能的选择都穷举一遍才能得出结果。动态规划算法的核心就是「状态」和「选择」，<strong>「状态」无非就是 <code>i</code> 和 <code>j</code> 两个指针的位置，「选择」就是 <code>p[j]</code> 选择匹配几个字符</strong>。</p><h3 id="二、动态规划解法"><a href="#二、动态规划解法" class="headerlink" title="#二、动态规划解法"></a><a href="https://labuladong.online/algo/dynamic-programming/regular-expression-matching/#%E4%BA%8C%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E6%B3%95">#</a>二、动态规划解法</h3><p>根据「状态」，我们可以定义一个 <code>dp</code> 函数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dp</span><span class="params">(string&amp; s, <span class="type">int</span> i, string&amp; p, <span class="type">int</span> j)</span></span>;</span><br></pre></td></tr></table></figure><p>🌟</p><hr><p>🌟</p><p><code>dp</code> 函数的定义如下：</p><p>**若 <code>dp(s, i, p, j) = true</code>，则表示 <code>s[i..]</code> 可以匹配 <code>p[j..]</code>；若 <code>dp(s, i, p, j) = false</code>，则表示 <code>s[i..]</code> 无法匹配 <code>p[j..]</code>**。</p><p>根据这个定义，我们想要的答案就是 <code>i = 0, j = 0</code> 时 <code>dp</code> 函数的结果，所以可以这样使用这个 <code>dp</code> 函数：</p><p>java 🤖cpp 🟢python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：java 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span></span><br><span class="line"><span class="comment">// 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 cpp 代码对比查看。</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">    <span class="comment">// 指针 i，j 从索引 0 开始移动</span></span><br><span class="line">     <span class="keyword">return</span> dp(s, <span class="number">0</span>, p, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>可以根据之前的代码写出 <code>dp</code> 函数的主要逻辑：</p><p>java 🤖cpp 🟢python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：java 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span></span><br><span class="line"><span class="comment">// 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 cpp 代码对比查看。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dp</span><span class="params">(String s, <span class="type">int</span> i, String p, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.charAt(i) == p.charAt(j) || p.charAt(j) == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 匹配</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; p.length() - <span class="number">1</span> &amp;&amp; p.charAt(j + <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 1.1 通配符匹配 0 次或多次</span></span><br><span class="line">            <span class="keyword">return</span> dp(s, i, p, j + <span class="number">2</span>)</span><br><span class="line">                || dp(s, i + <span class="number">1</span>, p, j);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 1.2 常规匹配 1 次</span></span><br><span class="line">            <span class="keyword">return</span> dp(s, i + <span class="number">1</span>, p, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不匹配</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; p.length() - <span class="number">1</span> &amp;&amp; p.charAt(j + <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.1 通配符匹配 0 次</span></span><br><span class="line">            <span class="keyword">return</span> dp(s, i, p, j + <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2.2 无法继续匹配</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>根据 <code>dp</code> 函数的定义</strong>，这几种情况都很好解释：</p><p><strong>1.1 通配符匹配 0 次或多次</strong></p><p>将 <code>j</code> 加 2，<code>i</code> 不变，含义就是直接跳过 <code>p[j]</code> 和之后的通配符，即通配符匹配 0 次。</p><p>即便 <code>s[i] == p[j]</code>，依然可能出现这种情况，如下图：</p><p><img src="https://labuladong.online/algo/images/%E6%AD%A3%E5%88%99/5.jpeg" alt="img"></p><p>将 <code>i</code> 加 1，<code>j</code> 不变，含义就是 <code>p[j]</code> 匹配了 <code>s[i]</code>，但 <code>p[j]</code> 还可以继续匹配，即通配符匹配多次的情况：</p><p><img src="https://labuladong.online/algo/images/%E6%AD%A3%E5%88%99/2.jpeg" alt="img"></p><p>两种情况只要有一种可以完成匹配即可，所以对上面两种情况求或运算。</p><p><strong>1.2 常规匹配 1 次</strong></p><p>由于这个条件分支是无 <code>*</code> 的常规匹配，那么如果 <code>s[i] == p[j]</code>，就是 <code>i</code> 和 <code>j</code> 分别加一：</p><p><img src="https://labuladong.online/algo/images/%E6%AD%A3%E5%88%99/3.jpeg" alt="img"></p><p><strong>2.1 通配符匹配 0 次</strong></p><p>类似情况 1.1，将 <code>j</code> 加 2，<code>i</code> 不变：</p><p><img src="https://labuladong.online/algo/images/%E6%AD%A3%E5%88%99/1.jpeg" alt="img"></p><p><strong>2.2 如果没有 <code>\*</code> 通配符，也无法匹配，那只能说明匹配失败了</strong></p><p><img src="https://labuladong.online/algo/images/%E6%AD%A3%E5%88%99/4.jpeg" alt="img"></p><p>看图理解应该很容易了，现在可以思考一下 <code>dp</code> 函数的 base case：</p><p><strong>一个 base case 是 <code>j == p.size()</code> 时</strong>，按照 <code>dp</code> 函数的定义，这意味着模式串 <code>p</code> 已经被匹配完了，那么应该看看文本串 <code>s</code> 匹配到哪里了，如果 <code>s</code> 也恰好被匹配完，则说明匹配成功：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (j == p.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> i == s.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>另一个 base case 是 <code>i == s.size()</code> 时</strong>，按照 <code>dp</code> 函数的定义，这种情况意味着文本串 <code>s</code> 已经全部被匹配了，那么是不是只要简单地检查一下 <code>p</code> 是否也匹配完就行了呢？</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="comment">// 这样行吗？</span></span><br><span class="line">    <span class="keyword">return</span> j == p.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这是不正确的，此时并不能根据 <code>j</code> 是否等于 <code>p.size()</code> 来判断是否完成匹配，只要 <code>p[j..]</code> 能够匹配空串，就可以算完成匹配</strong>。比如说 <code>s = &quot;a&quot;, p = &quot;ab*c*&quot;</code>，当 <code>i</code> 走到 <code>s</code> 末尾的时候，<code>j</code> 并没有走到 <code>p</code> 的末尾，但是 <code>p</code> 依然可以匹配 <code>s</code>。</p><p>所以我们可以写出如下代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> m = s.<span class="built_in">size</span>(), n = p.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="comment">// 如果能匹配空串，一定是字符和 * 成对儿出现</span></span><br><span class="line">    <span class="keyword">if</span> ((n - j) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查是否为 x*y*z* 这种形式</span></span><br><span class="line">    <span class="keyword">for</span> (; j + <span class="number">1</span> &lt; p.<span class="built_in">size</span>(); j += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[j + <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据以上思路，就可以写出完整的代码：</p><p>java 🤖cpp 🟢python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：java 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span></span><br><span class="line"><span class="comment">// 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 cpp 代码对比查看。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 备忘录</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] memo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length(), n = p.length();</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : memo)</span><br><span class="line">            Arrays.fill(row, -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 指针 i，j 从索引 0 开始移动</span></span><br><span class="line">        <span class="keyword">return</span> dp(s.toCharArray(), <span class="number">0</span>, p.toCharArray(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 计算 p[j..] 是否匹配 s[i..] */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dp</span><span class="params">(<span class="type">char</span>[] s, <span class="type">int</span> i, <span class="type">char</span>[] p, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length, n = p.length;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> i == m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n - j) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (; j + <span class="number">1</span> &lt; n; j += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p[j + <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查备忘录，防止重复计算</span></span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i][j] == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; n - <span class="number">1</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                res = dp(s, i, p, j + <span class="number">2</span>) || dp(s, i + <span class="number">1</span>, p, j);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = dp(s, i + <span class="number">1</span>, p, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; n - <span class="number">1</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                res = dp(s, i, p, j + <span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将当前结果记入备忘录</span></span><br><span class="line">        memo[i][j] = res ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details data-v-fb30874b="" id="div_regular-expression-matching" class="hint-container details" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1.6em 0px; padding: 1rem 0px 0px; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary data-v-fb30874b="" style="position: relative; margin: -1.5rem 0px -0.5rem; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer; display: flex; align-items: center; font-size: large;"><strong data-v-fb30874b="" style="font-weight: 600;">🎃 代码可视化动画 🎃</strong><span data-v-fb30874b="" class="font-icon icon iconfont icon-resize" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-left: auto; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-refresh" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-link" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle;"></span></summary><div data-v-fb30874b="" class="resizable" style="width: 774.091px; max-width: 100%; height: 70vh; max-height: 70vh; overflow: auto; resize: both;"><iframe data-v-fb30874b="" id="iframe_regular-expression-matching" src="https://labuladong.online/algo-visualize/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>代码中用了一个哈希表 <code>memo</code> 消除重叠子问题。如何一眼看出重叠子问题？可以参考前文 <a href="https://labuladong.online/algo/dynamic-programming/faq-summary/">动态规划系列答疑</a> 中所讲的技巧，抽出正则表达算法的递归框架：</p><p>java 🤖cpp 🟢python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：java 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span></span><br><span class="line"><span class="comment">// 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 cpp 代码对比查看。</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">dp</span><span class="params">(String s, <span class="type">int</span> i, String p, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    dp(s, i, p, j + <span class="number">2</span>);     <span class="comment">// 1</span></span><br><span class="line">    dp(s, i + <span class="number">1</span>, p, j);     <span class="comment">// 2</span></span><br><span class="line">    dp(s, i + <span class="number">1</span>, p, j + <span class="number">1</span>); <span class="comment">// 3</span></span><br><span class="line">    dp(s, i, p, j + <span class="number">2</span>);     <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果让你从 <code>dp(s, i, p, j)</code> 得到 <code>dp(s, i+2, p, j+2)</code>，至少有两条路径：<code>1 -&gt; 2 -&gt; 2</code> 和 <code>3 -&gt; 3</code>。这就说明 <code>(i+2, j+2)</code> 这个状态的计算必然存在重复，也就说明存在重叠子问题，我们需要用备忘录消除重叠子问题，提高效率。</p><p>动态规划的时间复杂度为「状态的总数」*「每次递归花费的时间」，本题中状态的总数当然就是 <code>i</code> 和 <code>j</code> 的组合，也就是 <code>M * N</code>（<code>M</code> 为 <code>s</code> 的长度，<code>N</code> 为 <code>p</code> 的长度）；递归函数 <code>dp</code> 中没有循环（base case 中的不考虑，因为 base case 的触发次数有限），所以一次递归花费的时间为常数。二者相乘，总的时间复杂度为 <code>O(MN)</code>。</p><p>空间复杂度很简单，就是备忘录 <code>memo</code> 的大小，即 <code>O(MN)</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典动态规划：高楼扔鸡蛋</title>
      <link href="/posts/53645.html"/>
      <url>/posts/53645.html</url>
      
        <content type="html"><![CDATA[<h1 id="经典动态规划：高楼扔鸡蛋"><a href="#经典动态规划：高楼扔鸡蛋" class="headerlink" title="经典动态规划：高楼扔鸡蛋"></a>经典动态规划：高楼扔鸡蛋</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/super-egg-drop/">887. Super Egg Dropopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/super-egg-drop/">887. 鸡蛋掉落open in new window</a></td><td align="center">🔴</td></tr></tbody></table><p>本文要聊一个很经典的算法问题，若干层楼，若干个鸡蛋，让你算出最少的尝试次数，找到鸡蛋恰好摔不碎的那层楼。国内大厂以及谷歌脸书面试都经常考察这道题，只不过他们觉得扔鸡蛋太浪费，改成扔杯子，扔破碗什么的。</p><p>具体的问题等会再说，但是这道题的解法技巧很多，光动态规划就好几种效率不同的思路，最后还有一种极其高效数学解法。秉承本书一贯的作风，拒绝过于诡异的技巧，因为这些技巧无法举一反三，学了也不划算。</p><p>下面就来用我们一直强调的动态规划通用思路来研究一下这道题。</p><h3 id="一、解析题目"><a href="#一、解析题目" class="headerlink" title="#一、解析题目"></a><a href="https://labuladong.online/algo/dynamic-programming/egg-drop/#%E4%B8%80%E3%80%81%E8%A7%A3%E6%9E%90%E9%A2%98%E7%9B%AE">#</a>一、解析题目</h3><p>这是力扣第 887 题「<a href="https://leetcode.cn/problems/super-egg-drop/">鸡蛋掉落open in new window</a>」，我描述一下题目：</p><p>你面前有一栋从 1 到 <code>N</code> 共 <code>N</code> 层的楼，然后给你 <code>K</code> 个鸡蛋（<code>K</code> 至少为 1）。现在确定这栋楼存在楼层 <code>0 &lt;= F &lt;= N</code>，在这层楼将鸡蛋扔下去，鸡蛋<strong>恰好没摔碎</strong>（高于 <code>F</code> 的楼层都会碎，低于 <code>F</code> 的楼层都不会碎，如果鸡蛋没有碎，可以捡回来继续扔）。现在问你，<strong>最坏</strong>情况下，你<strong>至少</strong>要扔几次鸡蛋，才能<strong>确定</strong>这个楼层 <code>F</code> 呢？</p><p>也就是让你找摔不碎鸡蛋的最高楼层 <code>F</code>，但什么叫「最坏情况」下「至少」要扔几次呢？我们分别举个例子就明白了。</p><p>比方说<strong>现在先不管鸡蛋个数的限制</strong>，有 7 层楼，你怎么去找鸡蛋恰好摔碎的那层楼？</p><p>最原始的方式就是线性扫描：我先在 1 楼扔一下，没碎，我再去 2 楼扔一下，没碎，我再去 3 楼……</p><p>以这种策略，<strong>最坏</strong>情况应该就是我试到第 7 层鸡蛋也没碎（<code>F = 7</code>），也就是我扔了 7 次鸡蛋。</p><p>先在你应该理解什么叫做「最坏情况」下了，<strong>鸡蛋破碎一定发生在搜索区间穷尽时</strong>，不会说你在第 1 层摔一下鸡蛋就碎了，这是你运气好，不是最坏情况。</p><p>现在再来理解一下什么叫「至少」要扔几次。依然不考虑鸡蛋个数限制，同样是 7 层楼，我们可以优化策略。</p><p>最好的策略是使用二分查找思路，我先去第 <code>(1 + 7) / 2 = 4</code> 层扔一下：</p><p>如果碎了说明 <code>F</code> 小于 4，我就去第 <code>(1 + 3) / 2 = 2</code> 层试……</p><p>如果没碎说明 <code>F</code> 大于等于 4，我就去第 <code>(5 + 7) / 2 = 6</code> 层试……</p><p>以这种策略，<strong>最坏</strong>情况应该是试到第 7 层鸡蛋还没碎（<code>F = 7</code>），或者鸡蛋一直碎到第 1 层（<code>F = 0</code>）。然而无论那种最坏情况，只需要试 <code>log7</code> 向上取整等于 3 次，比刚才尝试 7 次要少，这就是所谓的<strong>至少</strong>要扔几次。</p><p>实际上，如果不限制鸡蛋个数的话，二分思路显然可以得到最少尝试的次数，但问题是，<strong>现在给你了鸡蛋个数的限制 <code>K</code>，直接使用二分思路就不行了</strong>。</p><p>比如说只给你 1 个鸡蛋，7 层楼，你敢用二分吗？你直接去第 4 层扔一下，如果鸡蛋没碎还好，你可以把鸡蛋捡起来再去更高的楼层尝试；但如果碎了，你就没有鸡蛋继续测试了，无法确定鸡蛋恰好摔不碎的楼层 <code>F</code> 了。</p><p>其实这种情况下只能用线性扫描的方法，从下网上一层层尝试扔鸡蛋，那么最坏情况下需要扔 7 次，算法返回结果应该是 7。</p><p>有的读者也许会有这种想法：二分查找排除楼层的速度无疑是最快的，那干脆先用二分查找，等到只剩 1 个鸡蛋的时候再执行线性扫描，这样得到的结果是不是就是最少的扔鸡蛋次数呢？</p><p>很遗憾，并不是，比如说把楼层变高一些，100 层，给你 2 个鸡蛋，你在 50 层扔一下，碎了，那就只能线性扫描 1～49 层了，最坏情况下要扔 50 次。</p><p>如果不要「二分」，变成「五分」「十分」都会大幅减少最坏情况下的尝试次数。比方说第一个鸡蛋每隔十层楼扔，在哪里碎了第二个鸡蛋一个个线性扫描，总共不会超过 20 次。最优解其实是 14 次。最优策略非常多，而且并没有什么规律可言。</p><p>说了这么多废话，就是确保大家理解了题目的意思，而且认识到这个题目确实复杂，就连我们手算都不容易，如何用算法解决呢？</p><p>🌟</p><hr><p>🌟</p><h3 id="二、思路分析"><a href="#二、思路分析" class="headerlink" title="#二、思路分析"></a><a href="https://labuladong.online/algo/dynamic-programming/egg-drop/#%E4%BA%8C%E3%80%81%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90">#</a>二、思路分析</h3><p>对动态规划问题，直接套我们以前多次强调的框架即可：这个问题有什么「状态」，有什么「选择」，然后穷举。</p><p>**「状态」很明显，就是当前拥有的鸡蛋数 <code>K</code> 和需要测试的楼层数 <code>N</code>**。随着测试的进行，鸡蛋个数可能减少，楼层的搜索范围会减小，这就是状态的变化。</p><p><strong>「选择」其实就是去选择哪层楼扔鸡蛋</strong>。回顾刚才的线性扫描和二分思路，二分查找每次选择到楼层区间的中间去扔鸡蛋，而线性扫描选择一层层向上测试。不同的选择会造成状态的转移。</p><p>现在明确了「状态」和「选择」，<strong>动态规划的基本思路就形成了</strong>：肯定是个二维的 <code>dp</code> 数组或者带有两个状态参数的 <code>dp</code> 函数来表示状态转移；外加一个 for 循环来遍历所有选择，择最优的选择更新状态：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：当前状态为 K 个鸡蛋，面对 N 层楼</span></span><br><span class="line"><span class="comment">// 返回这个状态下最少的扔鸡蛋次数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> K, <span class="type">int</span> N)</span>:</span><br><span class="line">    <span class="type">int</span> res</span><br><span class="line">    <span class="keyword">for</span> <span class="number">1</span> &lt;= i &lt;= N:</span><br><span class="line">        res = min(res, 这次在第 i 层楼扔鸡蛋)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这段伪码还没有展示递归和状态转移，不过大致的算法框架已经完成了。</p><p>我们选择在第 <code>i</code> 层楼扔了鸡蛋之后，可能出现两种情况：鸡蛋碎了，鸡蛋没碎。<strong>注意，这时候状态转移就来了</strong>：</p><p><strong>如果鸡蛋碎了</strong>，那么鸡蛋的个数 <code>K</code> 应该减一，搜索的楼层区间应该从 <code>[1..N]</code> 变为 <code>[1..i-1]</code> 共 <code>i-1</code> 层楼；</p><p><strong>如果鸡蛋没碎</strong>，那么鸡蛋的个数 <code>K</code> 不变，搜索的楼层区间应该从 <code>[1..N]</code> 变为 <code>[i+1..N]</code> 共 <code>N-i</code> 层楼。</p><p><img src="https://labuladong.online/algo/images/%E6%89%94%E9%B8%A1%E8%9B%8B/1.jpg" alt="img"></p><p>注</p><p>细心的读者可能会问，在第 <code>i</code> 层楼扔鸡蛋如果没碎，楼层的搜索区间缩小至上面的楼层，是不是应该包含第 <code>i</code> 层楼呀？不必，因为已经包含了。开头说了 <code>F</code> 是可以等于 0 的，向上递归后，第 <code>i</code> 层楼其实就相当于第 0 层，可以被取到，所以说并没有错误。</p><p>因为我们要求的是<strong>最坏情况</strong>下扔鸡蛋的次数，所以鸡蛋在第 <code>i</code> 层楼碎没碎，取决于那种情况的结果<strong>更大</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> K, <span class="type">int</span> N)</span>:</span><br><span class="line">    <span class="keyword">for</span> <span class="number">1</span> &lt;= i &lt;= N:</span><br><span class="line">        <span class="comment">// 最坏情况下的最少扔鸡蛋次数</span></span><br><span class="line">        res = min(res, </span><br><span class="line">                  max( </span><br><span class="line">                    dp(K - <span class="number">1</span>, i - <span class="number">1</span>), <span class="comment">// 碎</span></span><br><span class="line">                    dp(K, N - i)      <span class="comment">// 没碎</span></span><br><span class="line">                  ) + <span class="number">1</span> <span class="comment">// 在第 i 楼扔了一次</span></span><br><span class="line">                 )</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>递归的 base case 很容易理解，当楼层数 <code>N</code> 等于 0 时，显然不需要扔鸡蛋；当鸡蛋数 <code>K</code> 为 1 时，显然只能线性扫描所有楼层：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> K, <span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (K == <span class="number">1</span>) <span class="keyword">return</span> N;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，其实这道题就解决了！只要添加一个备忘录消除重叠子问题即可：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 备忘录</span></span><br><span class="line">    <span class="type">int</span>[][] memo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">superEggDrop</span><span class="params">(<span class="type">int</span> K, <span class="type">int</span> N)</span> &#123;</span><br><span class="line">        <span class="comment">// m 最多不会超过 N 次（线性扫描）</span></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[K + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : memo) &#123;</span><br><span class="line">            Arrays.fill(row, -<span class="number">666</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp(K, N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：手握 K 个鸡蛋，面对 N 层楼，最少的扔鸡蛋次数为 dp(K, N)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> K, <span class="type">int</span> N)</span> &#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (K == <span class="number">1</span>) <span class="keyword">return</span> N;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查备忘录避免冗余计算</span></span><br><span class="line">        <span class="keyword">if</span> (memo[K][N] != -<span class="number">666</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[K][N];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 状态转移方程</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="comment">// 在所有楼层进行尝试，取最少扔鸡蛋次数</span></span><br><span class="line">            res = Math.min(</span><br><span class="line">                res,</span><br><span class="line">                <span class="comment">// 碎和没碎取最坏情况</span></span><br><span class="line">                Math.max(dp(K, N - i), dp(K - <span class="number">1</span>, i - <span class="number">1</span>)) + <span class="number">1</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结果存入备忘录</span></span><br><span class="line">        memo[K][N] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法的时间复杂度是多少呢？<strong>动态规划算法的时间复杂度就是子问题个数 × 函数本身的复杂度</strong>。</p><p>函数本身的复杂度就是忽略递归部分的复杂度，这里 <code>dp</code> 函数中有一个 for 循环，所以函数本身的复杂度是 O(N)。</p><p>子问题个数也就是不同状态组合的总数，显然是两个状态的乘积，也就是 O(KN)。所以算法的总时间复杂度是 O(K*N^2), 空间复杂度 O(KN)。</p><p>这个问题很复杂，但是算法代码却十分简洁，这就是动态规划的特性，穷举加备忘录&#x2F;DP table 优化，真的没啥新意。</p><p>有读者可能不理解代码中为什么用一个 for 循环遍历楼层 <code>[1..N]</code>，也许会把这个逻辑和之前探讨的线性扫描混为一谈。其实不是的，<strong>这只是在做一次「选择」</strong>。</p><p>比方说你有 2 个鸡蛋，面对 10 层楼，你<strong>这次</strong>选择去哪一层楼扔呢？不知道，那就把这 10 层楼全试一遍。至于下次怎么选择不用你操心，有正确的状态转移，递归算法会把每个选择的代价都算出来，我们取最优的那个就是最优解。</p><p>另外，这个问题还有更好的解法，比如修改代码中的 for 循环为二分搜索，可以将时间复杂度降为 O(K<em>N</em>logN)；再改进动态规划解法可以进一步降为 O(KN)；使用数学方法解决，时间复杂度达到最优 O(K*logN)，空间复杂度达到 O(1)。</p><p>二分的解法也有点误导性，你很可能以为它跟我们之前讨论的二分思路扔鸡蛋有关系，实际上没有半毛钱关系。能用二分搜索是因为状态转移方程的函数图像具有单调性，可以快速找到最值。</p><p>接下来我们看一看如何优化。</p><h3 id="三、二分搜索优化"><a href="#三、二分搜索优化" class="headerlink" title="#三、二分搜索优化"></a><a href="https://labuladong.online/algo/dynamic-programming/egg-drop/#%E4%B8%89%E3%80%81%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E4%BC%98%E5%8C%96">#</a>三、二分搜索优化</h3><p>二分搜索的优化的核心是状态转移方程的单调性，首先简述一下原始动态规划的思路：</p><p>1、暴力穷举尝试在所有楼层 <code>1 &lt;= i &lt;= N</code> 扔鸡蛋，每次选择尝试次数<strong>最少</strong>的那一层；</p><p>2、每次扔鸡蛋有两种可能，要么碎，要么没碎；</p><p>3、如果鸡蛋碎了，<code>F</code> 应该在第 <code>i</code> 层下面，否则，<code>F</code> 应该在第 <code>i</code> 层上面；</p><p>4、鸡蛋是碎了还是没碎，取决于哪种情况下尝试次数<strong>更多</strong>，因为我们想求的是最坏情况下的结果。</p><p>核心的状态转移代码是这段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前状态为 K 个鸡蛋，面对 N 层楼</span></span><br><span class="line"><span class="comment">// 返回这个状态下的最优结果</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> K, <span class="type">int</span> N)</span>:</span><br><span class="line">    <span class="keyword">for</span> <span class="number">1</span> &lt;= i &lt;= N:</span><br><span class="line">        <span class="comment">// 最坏情况下的最少扔鸡蛋次数</span></span><br><span class="line">        res = min(res,</span><br><span class="line">                  max( </span><br><span class="line">                        dp(K - <span class="number">1</span>, i - <span class="number">1</span>), <span class="comment">// 碎</span></span><br><span class="line">                        dp(K, N - i)      <span class="comment">// 没碎</span></span><br><span class="line">                     ) + <span class="number">1</span> <span class="comment">// 在第 i 楼扔了一次</span></span><br><span class="line">                 )</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这个 for 循环就是下面这个状态转移方程的具体代码实现：</p><p><img src="https://labuladong.online/algo/images/%E6%89%94%E9%B8%A1%E8%9B%8B/formula1.png" alt="img"></p><p>如果能够理解这个状态转移方程，那么就很容易理解二分查找的优化思路。</p><p>首先我们根据 <code>dp(K, N)</code> 数组的定义（有 <code>K</code> 个鸡蛋面对 <code>N</code> 层楼，最少需要扔几次），<strong>很容易知道 <code>K</code> 固定时，这个函数随着 <code>N</code> 的增加一定是单调递增的</strong>，无论你策略多聪明，楼层增加测试次数一定要增加。</p><p>那么注意 <code>dp(K - 1, i - 1)</code> 和 <code>dp(K, N - i)</code> 这两个函数，其中 <code>i</code> 是从 1 到 <code>N</code> 单增的，如果我们固定 <code>K</code> 和 <code>N</code>，<strong>把这两个函数看做关于 <code>i</code> 的函数，前者随着 <code>i</code> 的增加应该也是单调递增的，而后者随着 <code>i</code> 的增加应该是单调递减的</strong>：</p><p><img src="https://labuladong.online/algo/images/%E6%89%94%E9%B8%A1%E8%9B%8B/2.jpg" alt="img"></p><p>这时候求二者的较大值，再求这些最大值之中的最小值，其实就是求这两条直线交点，也就是红色折线的最低点嘛。</p><p>我们前文 <a href="https://labuladong.online/algo/frequency-interview/binary-search-in-action/">二分查找的运用技巧</a> 讲过，二分查找的运用很广泛，只要能够找到具有单调性的函数关系，都很有可能可以运用二分查找来优化线性搜索的复杂度。回顾这两个 <code>dp</code> 函数的曲线，我们要找的最低点其实就是这种情况：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dp(K - <span class="number">1</span>, i - <span class="number">1</span>) == dp(K, N - i))</span><br><span class="line">        <span class="keyword">return</span> dp(K, N - i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>熟悉二分搜索的同学肯定敏感地想到了，这不就是相当于求 Valley（山谷）值嘛，可以用二分查找来快速寻找这个点的，直接看代码吧，将 <code>dp</code> 函数的线性搜索改造成了二分搜索，加快了搜索速度：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> K, <span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (K == <span class="number">1</span>) <span class="keyword">return</span> N;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (memo[K][N] != -<span class="number">666</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[K][N];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt;= N; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     res = Math.min(</span></span><br><span class="line">    <span class="comment">//         res,</span></span><br><span class="line">    <span class="comment">//         Math.max(dp(K, N - i), dp(K - 1, i - 1)) + 1</span></span><br><span class="line">    <span class="comment">//     );</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用二分搜索代替线性搜索</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">1</span>, hi = N;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 鸡蛋在第 mid 层碎了和没碎两种情况</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">broken</span> <span class="operator">=</span> dp(K - <span class="number">1</span>, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">not_broken</span> <span class="operator">=</span> dp(K, N - mid);</span><br><span class="line">        <span class="comment">// res = min(max(碎，没碎) + 1)</span></span><br><span class="line">        <span class="keyword">if</span> (broken &gt; not_broken) &#123;</span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">            res = Math.min(res, broken + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">            res = Math.min(res, not_broken + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memo[K][N] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法的时间复杂度是多少呢？<strong>动态规划算法的时间复杂度就是子问题个数 × 函数本身的复杂度</strong>。</p><p>函数本身的复杂度就是忽略递归部分的复杂度，这里 <code>dp</code> 函数中用了一个二分搜索，所以函数本身的复杂度是 O(logN)。</p><p>子问题个数也就是不同状态组合的总数，显然是两个状态的乘积，也就是 O(KN)。</p><p>所以算法的总时间复杂度是 O(KNlogN), 空间复杂度 O(KN)。效率上比之前的算法 O(KN^2) 要高效一些。</p><h3 id="四、重新定义状态转移"><a href="#四、重新定义状态转移" class="headerlink" title="#四、重新定义状态转移"></a><a href="https://labuladong.online/algo/dynamic-programming/egg-drop/#%E5%9B%9B%E3%80%81%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB">#</a>四、重新定义状态转移</h3><p>找动态规划的状态转移本就是见仁见智，比较玄学的事情，不同的状态定义可以衍生出不同的解法，其解法和复杂程度都可能有巨大差异，这里就是一个很好的例子。</p><p>再回顾一下我们之前定义的 <code>dp</code> 数组含义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span></span><br><span class="line"><span class="comment">// 当前状态为 k 个鸡蛋，面对 n 层楼</span></span><br><span class="line"><span class="comment">// 返回这个状态下最少的扔鸡蛋次数</span></span><br></pre></td></tr></table></figure><p>用 <code>dp</code> 数组表示的话也是一样的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[k][n] = m</span><br><span class="line"><span class="comment">// 当前状态为 k 个鸡蛋，面对 n 层楼</span></span><br><span class="line"><span class="comment">// 这个状态下最少的扔鸡蛋次数为 m</span></span><br></pre></td></tr></table></figure><p>按照这个定义，就是<strong>确定当前的鸡蛋个数和面对的楼层数，就知道最小扔鸡蛋次数</strong>。最终我们想要的答案就是 <code>dp(K, N)</code> 的结果。</p><p>这种思路下，肯定要穷举所有可能的扔法的，用二分搜索优化也只是做了「剪枝」，减小了搜索空间，但本质思路没有变，还是穷举。</p><p>现在，我们稍微修改 <code>dp</code> 数组的定义，<strong>确定当前的鸡蛋个数和最多允许的扔鸡蛋次数，就知道能够确定 <code>F</code> 的最高楼层数</strong>。具体来说是这个意思：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[k][m] = n</span><br><span class="line"><span class="comment">// 当前有 k 个鸡蛋，可以尝试扔 m 次鸡蛋</span></span><br><span class="line"><span class="comment">// 这个状态下，最坏情况下最多能确切测试一栋 n 层的楼</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比如说 dp[1][7] = 7 表示：</span></span><br><span class="line"><span class="comment">// 现在有 1 个鸡蛋，允许你扔 7 次;</span></span><br><span class="line"><span class="comment">// 这个状态下最多给你 7 层楼，</span></span><br><span class="line"><span class="comment">// 使得你可以确定楼层 F 使得鸡蛋恰好摔不碎</span></span><br><span class="line"><span class="comment">// （一层一层线性探查嘛）</span></span><br></pre></td></tr></table></figure><p>这其实就是我们原始思路的一个「反向」版本，我们先不管这种思路的状态转移怎么写，先来思考一下这种定义之下，最终想求的答案是什么？</p><p>我们最终要求的其实是扔鸡蛋次数 <code>m</code>，但是这时候 <code>m</code> 在状态之中而不是 <code>dp</code> 数组的结果，可以这样处理：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">superEggDrop</span><span class="params">(<span class="type">int</span> K, <span class="type">int</span> N)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (dp[K][m] &lt; N) &#123;</span><br><span class="line">        m++;</span><br><span class="line">        <span class="comment">// 状态转移...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目不是<strong>给你 <code>K</code> 鸡蛋，<code>N</code> 层楼，让你求最坏情况下最少的测试次数 <code>m</code></strong> 吗？<code>while</code> 循环结束的条件是 <code>dp[K][m] == N</code>，也就是<strong>给你 <code>K</code> 个鸡蛋，测试 <code>m</code> 次，最坏情况下最多能测试 <code>N</code> 层楼</strong>。</p><p>注意看这两段描述，是完全一样的！所以说这样组织代码是正确的，关键就是状态转移方程怎么找呢？还得从我们原始的思路开始讲。之前的解法配了这样图帮助大家理解状态转移思路：</p><p><img src="https://labuladong.online/algo/images/%E6%89%94%E9%B8%A1%E8%9B%8B/1.jpg" alt="img"></p><p>这个图描述的仅仅是某一个楼层 <code>i</code>，原始解法还得线性或者二分扫描所有楼层，要求最大值、最小值。但是现在这种 <code>dp</code> 定义根本不需要这些了，基于下面两个事实：</p><p><strong>1、无论你在哪层楼扔鸡蛋，鸡蛋只可能摔碎或者没摔碎，碎了的话就测楼下，没碎的话就测楼上</strong>。</p><p><strong>2、无论你上楼还是下楼，总的楼层数 &#x3D; 楼上的楼层数 + 楼下的楼层数 + 1（当前这层楼）</strong>。</p><p>根据这个特点，可以写出下面的状态转移方程：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp[k][m] = dp[k][m - <span class="number">1</span>] + dp[k - <span class="number">1</span>][m - <span class="number">1</span>] + <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong><code>dp[k][m - 1]</code> 就是楼上的楼层数</strong>，因为鸡蛋个数 <code>k</code> 不变，也就是鸡蛋没碎，扔鸡蛋次数 <code>m</code> 减一；</p><p><strong><code>dp[k - 1][m - 1]</code> 就是楼下的楼层数</strong>，因为鸡蛋个数 <code>k</code> 减一，也就是鸡蛋碎了，同时扔鸡蛋次数 <code>m</code> 减一。</p><p>注</p><p>这个 <code>m</code> 为什么要减一而不是加一？之前定义得很清楚，这个 <code>m</code> 是一个允许扔鸡蛋的次数上界，而不是扔了几次。</p><p><img src="https://labuladong.online/algo/images/%E6%89%94%E9%B8%A1%E8%9B%8B/3.jpg" alt="img"></p><p>至此，整个思路就完成了，只要把状态转移方程填进框架即可：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">superEggDrop</span><span class="params">(<span class="type">int</span> K, <span class="type">int</span> N)</span> &#123;</span><br><span class="line">        <span class="comment">// m 最多不会超过 N 次（线性扫描）</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[K + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// base case:</span></span><br><span class="line">        <span class="comment">// dp[0][..] = 0</span></span><br><span class="line">        <span class="comment">// dp[..][0] = 0</span></span><br><span class="line">        <span class="comment">// Java 默认初始化数组都为 0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (dp[K][m] &lt; N) &#123;</span><br><span class="line">            m++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= K; k++)</span><br><span class="line">                dp[k][m] = dp[k][m - <span class="number">1</span>] + dp[k - <span class="number">1</span>][m - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details data-v-fb30874b="" id="div_super-egg-drop" class="hint-container details" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1.6em 0px; padding: 1rem 0px 0px; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary data-v-fb30874b="" style="position: relative; margin: -1.5rem 0px -0.5rem; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer; display: flex; align-items: center; font-size: large;"><strong data-v-fb30874b="" style="font-weight: 600;">🌟 代码可视化动画 🌟</strong><span data-v-fb30874b="" class="font-icon icon iconfont icon-resize" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-left: auto; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-refresh" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-link" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle;"></span></summary><div data-v-fb30874b="" class="resizable" style="width: 774.091px; max-width: 100%; height: 70vh; max-height: 70vh; overflow: auto; resize: both;"><iframe data-v-fb30874b="" id="iframe_super-egg-drop" src="https://labuladong.online/algo-visualize/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>如果你还觉得这段代码有点难以理解，其实它就等同于这样写：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span>; dp[K][m] &lt; N; m++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= K; k++)</span><br><span class="line">        dp[k][m] = dp[k][m - <span class="number">1</span>] + dp[k - <span class="number">1</span>][m - <span class="number">1</span>] + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>看到这种代码形式就熟悉多了吧，因为我们要求的不是 <code>dp</code> 数组里的值，而是某个符合条件的索引 <code>m</code>，所以用 <code>while</code> 循环来找到这个 <code>m</code> 而已。</p><p>这个算法的时间复杂度是多少？很明显就是两个嵌套循环的复杂度 O(KN)。</p><p>另外注意到 <code>dp[m][k]</code> 转移只和左边和左上的两个状态有关，可以根据前文 <a href="https://labuladong.online/algo/dynamic-programming/space-optimization/">动态规划的空间压缩技巧</a> 优化成一维 <code>dp</code> 数组，这里就不写了。</p><h3 id="五、还可以再优化"><a href="#五、还可以再优化" class="headerlink" title="#五、还可以再优化"></a><a href="https://labuladong.online/algo/dynamic-programming/egg-drop/#%E4%BA%94%E3%80%81%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%86%8D%E4%BC%98%E5%8C%96">#</a>五、还可以再优化</h3><p>再往下还可以继续优化，我就不具体展开了，仅仅简单提一下思路吧。</p><p>在刚才的思路之上，<strong>注意函数 <code>dp(m, k)</code> 是随着 <code>m</code> 单增的，因为鸡蛋个数 <code>k</code> 不变时，允许的测试次数越多，可测试的楼层就越高</strong>。</p><p>这里又可以借助二分搜索算法快速逼近 <code>dp[K][m] == N</code> 这个终止条件，时间复杂度进一步下降为 O(KlogN)。不过我觉得我们能够写出 O(K<em>N</em>logN) 的二分优化算法就行了，后面的这些解法呢，我认为不太有必要掌握，把欲望限制在能力的范围之内才能拥有快乐！</p><p>不过可以肯定的是，根据二分搜索代替线性扫描 <code>m</code> 的取值，代码的大致框架肯定是修改穷举 <code>m</code> 的 while 循环：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把线性搜索改成二分搜索</span></span><br><span class="line"><span class="comment">// for (int m = 1; dp[K][m] &lt; N; m++)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">1</span>, hi = N;</span><br><span class="line"><span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (lo + hi) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (... &lt; N) &#123;</span><br><span class="line">        lo = ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hi = ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= K; k++) &#123;</span><br><span class="line">        <span class="comment">// 状态转移方程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单总结一下吧，第一个二分优化是利用了 <code>dp</code> 函数的单调性，用二分查找技巧快速搜索答案；第二种优化是巧妙地修改了状态转移方程，简化了求解了流程，但相应的，解题逻辑比较难以想到；后续还可以用一些数学方法和二分搜索进一步优化第二种解法，不过不太值得掌握。</p><p>本文终，希望对你有一点启发。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>目标和：背包问题的变体</title>
      <link href="/posts/41284.html"/>
      <url>/posts/41284.html</url>
      
        <content type="html"><![CDATA[<h1 id="目标和：背包问题的变体"><a href="#目标和：背包问题的变体" class="headerlink" title="目标和：背包问题的变体"></a>目标和：背包问题的变体</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/target-sum/">494. Target Sumopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/target-sum/">494. 目标和open in new window</a></td><td align="center">🟠</td></tr><tr><td align="center">-</td><td align="center"><a href="https://leetcode.cn/problems/YaVDxD/">剑指 Offer II 102. 加减的目标值open in new window</a></td><td align="center">🟠</td></tr></tbody></table><p>我们前文经常说回溯算法和递归算法有点类似，有的问题如果实在想不出状态转移方程，尝试用回溯算法暴力解决也是一个聪明的策略，总比写不出来解法强。</p><p>那么，回溯算法和动态规划到底是啥关系？它俩都涉及递归，算法模板看起来还挺像的，都涉及做「选择」，真的酷似父与子。</p><p><img src="https://labuladong.online/algo/images/targetSum/1.jpg" alt="img"></p><p>那么，它俩具体有啥区别呢？回溯算法和动态规划之间，是否可能互相转化呢？</p><p>今天就用力扣第 494 题「<a href="https://leetcode.cn/problems/target-sum/">目标和open in new window</a>」来详细对比一下回溯算法和动态规划，题目如下：</p><p>给你输入一个非负整数数组 <code>nums</code> 和一个目标值 <code>target</code>，现在你可以给每一个元素 <code>nums[i]</code> 添加正号 <code>+</code> 或负号 <code>-</code>，请你计算有几种符号的组合能够使得 <code>nums</code> 中元素的和为 <code>target</code>。</p><p>函数的签名如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>;</span><br></pre></td></tr></table></figure><p>比如说输入 <code>nums = [1,3,1,4,2], target = 5</code>，算法返回 3，因为有如下 3 种组合能够使得 <code>target</code> 等于 5：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">-1+3+1+4-2=5</span><br><span class="line">-1+3+1+4-2=5</span><br><span class="line">+1-3+1+4+2=5</span><br></pre></td></tr></table></figure><p><code>nums</code> 的元素也有可能包含 0，我们可以正常地给 0 分配正负号。</p><h3 id="一、回溯思路"><a href="#一、回溯思路" class="headerlink" title="#一、回溯思路"></a><a href="https://labuladong.online/algo/dynamic-programming/target-sum/#%E4%B8%80%E3%80%81%E5%9B%9E%E6%BA%AF%E6%80%9D%E8%B7%AF">#</a>一、回溯思路</h3><p>其实我第一眼看到这个题目，花了两分钟就写出了一个回溯解法。</p><p>任何算法的核心都是穷举，回溯算法就是一个暴力穷举算法，前文 <a href="https://labuladong.online/algo/essential-technique/backtrack-framework/">回溯算法解题框架</a> 就写了回溯算法框架：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">路径, 选择列表</span>):</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><p>关键就是搞清楚什么是「选择」，而对于这道题，「选择」不是明摆着的吗？**对于每个数字 <code>nums[i]</code>，我们可以选择给一个正号 <code>+</code> 或者一个负号 <code>-</code>**，然后利用回溯模板穷举出来所有可能的结果，数一数到底有几种组合能够凑出 <code>target</code> 不就行了嘛？</p><p>伪码思路如下：</p><p>🌟</p><hr><p>🌟</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">nums, i</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="built_in">len</span>(nums):</span><br><span class="line">        <span class="keyword">if</span> 达到 target:</span><br><span class="line">            result += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> op <span class="keyword">in</span> &#123; +<span class="number">1</span>, -<span class="number">1</span> &#125;:</span><br><span class="line">        选择 op * nums[i]</span><br><span class="line">        <span class="comment"># 穷举 nums[i + 1] 的选择</span></span><br><span class="line">        backtrack(nums, i + <span class="number">1</span>)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><p>如果看过我们之前的几篇回溯算法文章，这个代码可以说是比较简单的了：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 主函数 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        backtrack(nums, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 回溯算法模板 */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> remain)</span> &#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (i == nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (remain == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 说明恰好凑出 target</span></span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 给 nums[i] 选择 - 号</span></span><br><span class="line">        remain += nums[i];</span><br><span class="line">        <span class="comment">// 穷举 nums[i + 1]</span></span><br><span class="line">        backtrack(nums, i + <span class="number">1</span>, remain);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        remain -= nums[i]; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 给 nums[i] 选择 + 号</span></span><br><span class="line">        remain -= nums[i];</span><br><span class="line">        <span class="comment">// 穷举 nums[i + 1]</span></span><br><span class="line">        backtrack(nums, i + <span class="number">1</span>, remain);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        remain += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有的读者可能问，选择 <code>-</code> 的时候，为什么是 <code>remain += nums[i]</code>，选择 <code>+</code> 的时候，为什么是 <code>remain -= nums[i]</code> 呢，是不是写反了？</p><p>不是的，「如何凑出 <code>target</code>」和「如何把 <code>target</code> 减到 0」其实是一样的。我们这里选择后者，因为前者必须给 <code>backtrack</code> 函数多加一个参数，我觉得不美观：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> sum, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (i == nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，如果我们给 <code>nums[i]</code> 选择 <code>+</code> 号，就要让 <code>remain - nums[i]</code>，反之亦然。</p><p>以上回溯算法可以解决这个问题，时间复杂度为 <code>O(2^N)</code>，<code>N</code> 为 <code>nums</code> 的大小。这个复杂度怎么算的？回忆前文 <a href="https://labuladong.online/algo/essential-technique/abstraction-of-algorithm/">学习数据结构和算法的框架思维</a>，发现这个回溯算法就是个二叉树的遍历问题：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> remain)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == nums.length) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    backtrack(nums, i + <span class="number">1</span>, remain - nums[i]);</span><br><span class="line">    backtrack(nums, i + <span class="number">1</span>, remain + nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>树的高度就是 <code>nums</code> 的长度嘛，所以说时间复杂度就是这棵二叉树的节点数，为 <code>O(2^N)</code>，其实是非常低效的。</p><p>那么，这个问题如何用动态规划思想进行优化呢？</p><h3 id="二、消除重叠子问题"><a href="#二、消除重叠子问题" class="headerlink" title="#二、消除重叠子问题"></a><a href="https://labuladong.online/algo/dynamic-programming/target-sum/#%E4%BA%8C%E3%80%81%E6%B6%88%E9%99%A4%E9%87%8D%E5%8F%A0%E5%AD%90%E9%97%AE%E9%A2%98">#</a>二、消除重叠子问题</h3><p>动态规划之所以比暴力算法快，是因为动态规划技巧消除了重叠子问题。</p><p>如何发现重叠子问题？看是否可能出现重复的「状态」。对于递归函数来说，函数参数中会变的参数就是「状态」，对于 <code>backtrack</code> 函数来说，会变的参数为 <code>i</code> 和 <code>remain</code>。</p><p>前文 <a href="https://labuladong.online/algo/dynamic-programming/edit-distance/">动态规划之编辑距离</a> 说了一种一眼看出重叠子问题的方法，先抽象出递归框架：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> remain)</span> &#123;</span><br><span class="line">    backtrack(i + <span class="number">1</span>, remain - nums[i]);</span><br><span class="line">    backtrack(i + <span class="number">1</span>, remain + nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个简单的例子，如果 <code>nums[i] = 0</code>，会发生什么？</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> remain)</span> &#123;</span><br><span class="line">    backtrack(i + <span class="number">1</span>, remain);</span><br><span class="line">    backtrack(i + <span class="number">1</span>, remain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你看，这样就出现了两个「状态」完全相同的递归函数，无疑这样的递归计算就是重复的。<strong>这就是重叠子问题，而且只要我们能够找到一个重叠子问题，那一定还存在很多的重叠子问题</strong>。</p><p>因此，状态 <code>(i, remain)</code> 是可以用备忘录技巧进行优化的：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dp(nums, <span class="number">0</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 备忘录</span></span><br><span class="line">    HashMap&lt;String, Integer&gt; memo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> remain)</span> &#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (i == nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (remain == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把它俩转成字符串才能作为哈希表的键</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> i + <span class="string">&quot;,&quot;</span> + remain;</span><br><span class="line">        <span class="comment">// 避免重复计算</span></span><br><span class="line">        <span class="keyword">if</span> (memo.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 还是穷举</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> dp(nums, i + <span class="number">1</span>, remain - nums[i]) + dp(nums, i + <span class="number">1</span>, remain + nums[i]);</span><br><span class="line">        <span class="comment">// 记入备忘录</span></span><br><span class="line">        memo.put(key, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details data-v-fb30874b="" id="div_target-sum" class="hint-container details" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1.6em 0px; padding: 1rem 0px 0px; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary data-v-fb30874b="" style="position: relative; margin: -1.5rem 0px -0.5rem; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer; display: flex; align-items: center; font-size: large;"><strong data-v-fb30874b="" style="font-weight: 600;">🌈 代码可视化动画 🌈</strong><span data-v-fb30874b="" class="font-icon icon iconfont icon-resize" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-left: auto; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-refresh" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-link" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle;"></span></summary><div data-v-fb30874b="" class="resizable" style="width: 774.091px; max-width: 100%; height: 70vh; max-height: 70vh; overflow: auto; resize: both;"><iframe data-v-fb30874b="" id="iframe_target-sum" src="https://labuladong.online/algo-visualize/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>以前我们都是用 Python 的元组配合哈希表 <code>dict</code> 来做备忘录的，其他语言没有元组，可以用把「状态」转化为字符串作为哈希表的键，这是一个常用的小技巧。</p><p>这个解法通过备忘录消除了很多重叠子问题，效率有一定的提升，但是这就结束了吗？</p><h3 id="三、动态规划"><a href="#三、动态规划" class="headerlink" title="#三、动态规划"></a><a href="https://labuladong.online/algo/dynamic-programming/target-sum/#%E4%B8%89%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">#</a>三、动态规划</h3><p>其实，这个问题可以转化为一个子集划分问题，而子集划分问题又是一个典型的背包问题。动态规划总是这么玄学，让人摸不着头脑……</p><p>首先，如果我们把 <code>nums</code> 划分成两个子集 <code>A</code> 和 <code>B</code>，分别代表分配 <code>+</code> 的数和分配 <code>-</code> 的数，那么他们和 <code>target</code> 存在如下关系：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sum</span>(A) - <span class="built_in">sum</span>(B) = target</span><br><span class="line"><span class="built_in">sum</span>(A) = target + <span class="built_in">sum</span>(B)</span><br><span class="line"><span class="built_in">sum</span>(A) + <span class="built_in">sum</span>(A) = target + <span class="built_in">sum</span>(B) + <span class="built_in">sum</span>(A)</span><br><span class="line"><span class="number">2</span> * <span class="built_in">sum</span>(A) = target + <span class="built_in">sum</span>(nums)</span><br></pre></td></tr></table></figure><p>综上，可以推出 <code>sum(A) = (target + sum(nums)) / 2</code>，也就是把原问题转化成：**<code>nums</code> 中存在几个子集 <code>A</code>，使得 <code>A</code> 中元素的和为 <code>(target + sum(nums)) / 2</code>**？</p><p>类似的子集划分问题我们前文 <a href="https://labuladong.online/algo/dynamic-programming/knapsack2/">经典背包问题：子集划分</a> 讲过，现在实现这么一个函数：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 计算 nums 中有几个子集的和为 sum */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> sum)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>然后，可以这样调用这个函数：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : nums) sum += n;</span><br><span class="line">    <span class="comment">// 这两种情况，不可能存在合法的子集划分</span></span><br><span class="line">    <span class="keyword">if</span> (sum &lt; Math.abs(target) || (sum + target) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subsets(nums, (sum + target) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的，变成背包问题的标准形式：</p><p><strong>有一个背包，容量为 <code>sum</code>，现在给你 <code>N</code> 个物品，第 <code>i</code> 个物品的重量为 <code>nums[i - 1]</code>（注意 <code>1 &lt;= i &lt;= N</code>），每个物品只有一个，请问你有几种不同的方法能够恰好装满这个背包</strong>？</p><p>现在，这就是一个正宗的动态规划问题了，下面按照我们一直强调的动态规划套路走流程：</p><p><strong>第一步要明确两点，「状态」和「选择」</strong>。</p><p>对于背包问题，这个都是一样的，状态就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」。</p><p><strong>第二步要明确 <code>dp</code> 数组的定义</strong>。</p><p>按照背包问题的套路，可以给出如下定义：</p><p><code>dp[i][j] = x</code> 表示，若只在前 <code>i</code> 个物品中选择，若当前背包的容量为 <code>j</code>，则最多有 <code>x</code> 种方法可以恰好装满背包。</p><p>翻译成我们探讨的子集问题就是，若只在 <code>nums</code> 的前 <code>i</code> 个元素中选择，若目标和为 <code>j</code>，则最多有 <code>x</code> 种方法划分子集。</p><p>根据这个定义，显然 <code>dp[0][..] = 0</code>，因为没有物品的话，根本没办法装背包；但是 <code>dp[0][0]</code> 应该是个例外，因为如果背包的最大载重为 0，「什么都不装」也算是一种装法，即 <code>dp[0][0] = 1</code>。</p><p>注</p><p>可能有些看过前文 <a href="https://labuladong.online/algo/dynamic-programming/knapsack1/">0-1 背包问题</a> 和 <a href="https://labuladong.online/algo/dynamic-programming/knapsack3/">完全背包问题</a> 这两篇背包问题的文章之后会有疑问，为什么 base case 不是 <code>dp[..][0] = 1</code> 呢？即背包容量为 0 时，只有「什么都不装」这一种装法。这里不能这样初始化，是因为本题 <code>nums</code> 数组中的元素是可能为 0 的，那么背包容量为 0 时，「什么都不装」可能就不是唯一的装法了，而需要在状态转移的过程中具体去计算。</p><p>我们所求的答案就是 <code>dp[N][sum]</code>，即使用所有 <code>N</code> 个物品，有几种方法可以装满容量为 <code>sum</code> 的背包。</p><p><strong>第三步，根据「选择」，思考状态转移的逻辑</strong>。</p><p>回想刚才的 <code>dp</code> 数组含义，可以根据「选择」对 <code>dp[i][j]</code> 得到以下状态转移：</p><p>如果不把 <code>nums[i]</code> 算入子集，<strong>或者说你不把这第 <code>i</code> 个物品装入背包</strong>，那么恰好装满背包的方法数就取决于上一个状态 <code>dp[i-1][j]</code>，继承之前的结果。</p><p>如果把 <code>nums[i]</code> 算入子集，<strong>或者说你把这第 <code>i</code> 个物品装入了背包</strong>，那么只要看前 <code>i - 1</code> 个物品有几种方法可以装满 <code>j - nums[i-1]</code> 的重量就行了，所以取决于状态 <code>dp[i-1][j-nums[i-1]]</code>。</p><p>注</p><p>注意我们说的 <code>i</code> 是从 1 开始算的，而数组 <code>nums</code> 的索引时从 0 开始算的，所以 <code>nums[i-1]</code> 代表的是第 <code>i</code> 个物品的重量，<code>j - nums[i-1]</code> 就是背包装入物品 <code>i</code> 之后还剩下的容量。</p><p><strong>由于 <code>dp[i][j]</code> 为装满背包的总方法数，所以应该以上两种选择的结果求和，得到状态转移方程</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i-<span class="number">1</span>][j-nums[i-<span class="number">1</span>]];</span><br></pre></td></tr></table></figure><p>然后，根据状态转移方程写出动态规划算法：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 计算 nums 中有几个子集的和为 sum */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][sum + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= sum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 两种选择的结果之和</span></span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i-<span class="number">1</span>][j-nums[i-<span class="number">1</span>]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 背包的空间不足，只能选择不装物品 i</span></span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，发现这个 <code>dp[i][j]</code> 只和前一行 <code>dp[i-1][..]</code> 有关，那么肯定可以优化成一维 <code>dp</code>：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 计算 nums 中有几个子集的和为 sum */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[sum + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// j 要从后往前遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> sum; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="comment">// 状态转移方程</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                dp[j] = dp[j] + dp[j-nums[i-<span class="number">1</span>]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j] = dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对照二维 <code>dp</code>，只要把 <code>dp</code> 数组的第一个维度全都去掉就行了，唯一的区别就是这里的 <code>j</code> 要从后往前遍历，原因如下</strong>：</p><p>因为二维压缩到一维的根本原理是，<code>dp[j]</code> 和 <code>dp[j-nums[i-1]]</code> 还没被新结果覆盖的时候，相当于二维 <code>dp</code> 中的 <code>dp[i-1][j]</code> 和 <code>dp[i-1][j-nums[i-1]]</code>。</p><p>那么，我们就要做到：<strong>在计算新的 <code>dp[j]</code> 的时候，<code>dp[j]</code> 和 <code>dp[j-nums[i-1]]</code> 还是上一轮外层 for 循环的结果</strong>。</p><p>如果你从前往后遍历一维 <code>dp</code> 数组，<code>dp[j]</code> 显然是没问题的，但是 <code>dp[j-nums[i-1]]</code> 已经不是上一轮外层 for 循环的结果了，这里就会使用错误的状态，当然得不到正确的答案。</p><p>现在，这道题算是彻底解决了。</p><p>总结一下，回溯算法虽好，但是复杂度高，即便消除一些冗余计算，也只是「剪枝」，没有本质的改进。而动态规划就比较玄学了，经过各种改造，从一个加减法问题变成子集问题，又变成背包问题，经过各种套路写出解法，又搞出空间压缩，还得反向遍历。</p><p>现在我都搞不清楚自己是来干嘛的了。嗯，这也许就是动态规划的魅力吧。</p><p>接下来可阅读：</p><ul><li><a href="https://labuladong.online/algo/practice-in-action/divide-and-conquer/">分治算法：运算优先级</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剪视频剪出一个贪心算法</title>
      <link href="/posts/23808.html"/>
      <url>/posts/23808.html</url>
      
        <content type="html"><![CDATA[<h1 id="剪视频剪出一个贪心算法"><a href="#剪视频剪出一个贪心算法" class="headerlink" title="剪视频剪出一个贪心算法"></a>剪视频剪出一个贪心算法</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/video-stitching/">1024. Video Stitchingopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/video-stitching/">1024. 视频拼接open in new window</a></td><td align="center">🟠</td></tr></tbody></table><p>前面发过几个视频，也算是对视频剪辑入了个门。像我这种非专业剪辑玩家，不做什么宏大特效电影镜头，只是做个视频教程，其实也没啥难度，只需要把视频剪流畅，所以用到最多的功能就是切割功能，然后删除和拼接视频片接。</p><p>没有剪过视频的读者可能不知道，在常用的剪辑软件中视频被切割成若干片段之后，每个片段都可以还原成原始视频。</p><p>就比如一个 10 秒的视频，在中间切一刀剪成两个 5 秒的视频，这两个五秒的视频各自都可以还原成 10 秒的原视频。就好像蚯蚓，把自己切成 4 段就能搓麻，把自己切成 11 段就可以凑一个足球队。</p><p><img src="https://labuladong.online/algo/images/%E5%89%AA%E8%A7%86%E9%A2%91/1.jpg" alt="img"></p><p>剪视频时，每个视频片段都可以抽象成了一个个区间，时间就是区间的端点，这些区间有的相交，有的不相交……</p><p>假设剪辑软件不支持将视频片段还原成原视频，那么如果给我若干视频片段，我怎么将它们还原成原视频呢？</p><p>🌟</p><hr><p>🌟</p><p>这是个很有意思的区间算法问题，也是力扣第 1024 题「<a href="https://leetcode.cn/problems/video-stitching/">视频拼接open in new window</a>」，题目如下：</p><details class="hint-container details" open="" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1rem 0px; padding: 1.5rem; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary style="position: relative; margin: -1.5rem -1.5rem 0.5em; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer;"><strong style="font-weight: 600;">1024. 视频拼接</strong>&nbsp;|<span>&nbsp;</span><a target="_blank" href="https://leetcode.cn/problems/video-stitching/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|<span>&nbsp;</span><a target="_blank" href="https://leetcode.com/problems/video-stitching/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">你将会获得一系列视频片段，这些片段来自于一项持续时长为&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">time</code>&nbsp;秒的体育赛事。这些片段可能有所重叠，也可能长度不一。</p><p style="line-height: 1.6; overflow-wrap: break-word;">使用数组&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">clips</code><span>&nbsp;</span>描述所有的视频片段，其中<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">clips[i] = [start<sub>i</sub>, end<sub>i</sub>]</code><span>&nbsp;</span>表示：某个视频片段开始于&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">start<sub>i</sub></code>&nbsp;并于&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">end<sub>i</sub></code>&nbsp;结束。</p><p style="line-height: 1.6; overflow-wrap: break-word;">甚至可以对这些片段自由地再剪辑：</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li>例如，片段&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">[0, 7]</code>&nbsp;可以剪切成&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">[0, 1] +&nbsp;[1, 3] + [3, 7]</code>&nbsp;三部分。</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">[0, time]</code>）。返回所需片段的最小数目，如果无法完成该任务，则返回&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">-1</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], time = 10<strong style="font-weight: 600;">输出：</strong>3<strong style="font-weight: 600;">解释：</strong>选中 [0,2], [8,10], [1,9] 这三个片段。然后，按下面的方案重制比赛片段：将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。现在手上的片段为 [0,2] + [2,8] + [8,10]，而这些覆盖了整场比赛 [0, 10]。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>clips = [[0,1],[1,2]], time = 5<strong style="font-weight: 600;">输出：</strong>-1<strong style="font-weight: 600;">解释：</strong>无法只用 [0,1] 和 [1,2] 覆盖 [0,5] 的整个过程。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 3：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], time = 9<strong style="font-weight: 600;">输出：</strong>3<strong style="font-weight: 600;">解释： </strong>选取片段 [0,4], [4,7] 和 [6,9] 。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 &lt;= clips.length &lt;= 100</code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">0 &lt;= start<sub>i</sub><span>&nbsp;</span>&lt;= end<sub>i</sub><span>&nbsp;</span>&lt;= 100</code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 &lt;= time &lt;= 100</code></li></ul></div></details><p>函数签名如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">videoStitching</span><span class="params">(<span class="type">int</span>[][] clips, <span class="type">int</span> T)</span>;</span><br></pre></td></tr></table></figure><p>记得以前写过好几篇区间相关的问题：</p><p><a href="https://labuladong.online/algo/practice-in-action/interval-problem-summary/">区间问题合集</a> 写过求区间交集、区间并集、区间覆盖这几个问题。</p><p><a href="https://labuladong.online/algo/frequency-interview/interval-scheduling/">贪心算法做时间管理</a> 写过利用贪心算法求不相交的区间。</p><p>算上本文的区间剪辑问题，经典的区间问题也就都讲完了。</p><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="#思路分析"></a><a href="https://labuladong.online/algo/frequency-interview/cut-video/#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90">#</a>思路分析</h3><p>题目并不难理解，给定一个目标区间和若干小区间，如何通过裁剪和组合小区间拼凑出目标区间？最少需要几个小区间？</p><p><strong>前文多次说过，区间问题肯定按照区间的起点或者终点进行排序</strong>。</p><p>因为排序之后更容易找到相邻区间之间的联系，如果是求最值的问题，可以使用贪心算法进行求解。</p><p>区间问题特别容易用贪心算法，公众号历史文章除了 <a href="https://labuladong.online/algo/frequency-interview/interval-scheduling/">贪心算法之区间调度</a>，还有一篇 <a href="https://labuladong.online/algo/frequency-interview/jump-game-summary/">贪心算法玩跳跃游戏</a>，其实这个跳跃游戏就相当于一个将起点排序的区间问题，你细品，你细品。</p><p>至于到底如何排序，这个就要因题而异了，我做这道题的思路是先按照起点升序排序，如果起点相同的话按照终点降序排序。</p><p>为什么这样排序呢，主要考虑到这道题的以下两个特点：</p><p>1、要用若干短视频凑出完成视频 <code>[0, T]</code>，至少得有一个短视频的起点是 0。</p><p>这个很好理解，如果没有一个短视频是从 0 开始的，那么区间 <code>[0, T]</code> 肯定是凑不出来的。</p><p>2、如果有几个短视频的起点都相同，那么一定应该选择那个最长（终点最大）的视频。</p><p>这一条就是贪心的策略，因为题目让我们计算最少需要的短视频个数，如果起点相同，那肯定是越长越好，不要白不要，多出来了大不了剪辑掉嘛。</p><p>基于以上两个特点，将 <code>clips</code> 按照起点升序排序，起点相同的按照终点降序排序，最后得到的区间顺序就像这样：</p><p><img src="https://labuladong.online/algo/images/%E5%89%AA%E8%A7%86%E9%A2%91/2.jpeg" alt="img"></p><p>这样我们就可以确定，如果 <code>clips[0]</code> 是的起点是 0，那么 <code>clips[0]</code> 这个视频一定会被选择。</p><p><img src="https://labuladong.online/algo/images/%E5%89%AA%E8%A7%86%E9%A2%91/3.jpeg" alt="img"></p><p>当我们确定 <code>clips[0]</code> 一定会被选择之后，就可以选出下一个会被选择的视频：</p><p><img src="https://labuladong.online/algo/images/%E5%89%AA%E8%A7%86%E9%A2%91/4.jpeg" alt="img"></p><p><strong>我们会比较所有起点小于 <code>clips[0][1]</code> 的区间，根据贪心策略，它们中终点最大的那个区间就是第二个会被选中的视频</strong>。</p><p>然后可以通过第二个视频区间贪心选择出第三个视频，以此类推，直到覆盖区间 <code>[0, T]</code>，或者无法覆盖返回 -1。</p><p>以上就是这道题的解题思路，仔细想想，这题的核心和后文 <a href="https://labuladong.online/algo/frequency-interview/jump-game-summary/">贪心算法玩跳跃游戏</a> 写的跳跃游戏是相同的，如果你能看出这两者的联系，就可以说理解贪心算法的奥义了。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="#代码实现"></a><a href="https://labuladong.online/algo/frequency-interview/cut-video/#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">#</a>代码实现</h3><p>实现上述思路需要我们用两个变量 <code>curEnd</code> 和 <code>nextEnd</code> 来进行，如下 GIF 所示：</p><p><img src="https://labuladong.online/algo/images/%E5%89%AA%E8%A7%86%E9%A2%91/5.gif" alt="img"></p><p>最终代码实现如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">videoStitching</span><span class="params">(<span class="type">int</span>[][] clips, <span class="type">int</span> T)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (T == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 按起点升序排列，起点相同的降序排列</span></span><br><span class="line">        Arrays.sort(clips, (a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> b[<span class="number">1</span>] - a[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 记录选择的短视频个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">curEnd</span> <span class="operator">=</span> <span class="number">0</span>, nextEnd = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = clips.length;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; clips[i][<span class="number">0</span>] &lt;= curEnd) &#123;</span><br><span class="line">            <span class="comment">// 在第 res 个视频的区间内贪心选择下一个视频</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; clips[i][<span class="number">0</span>] &lt;= curEnd) &#123;</span><br><span class="line">                nextEnd = Math.max(nextEnd, clips[i][<span class="number">1</span>]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到下一个视频，更新 curEnd</span></span><br><span class="line">            res++;</span><br><span class="line">            curEnd = nextEnd;</span><br><span class="line">            <span class="keyword">if</span> (curEnd &gt;= T) &#123;</span><br><span class="line">                <span class="comment">// 已经可以拼出区间 [0, T]</span></span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 无法连续拼出区间 [0, T]</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details data-v-fb30874b="" id="div_video-stitching" class="hint-container details" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1.6em 0px; padding: 1rem 0px 0px; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary data-v-fb30874b="" style="position: relative; margin: -1.5rem 0px -0.5rem; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer; display: flex; align-items: center; font-size: large;"><strong data-v-fb30874b="" style="font-weight: 600;">🥳 代码可视化动画 🥳</strong><span data-v-fb30874b="" class="font-icon icon iconfont icon-resize" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-left: auto; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-refresh" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-link" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle;"></span></summary><div data-v-fb30874b="" class="resizable" style="width: 774.091px; max-width: 100%; height: 70vh; max-height: 70vh; overflow: auto; resize: both;"><iframe data-v-fb30874b="" id="iframe_video-stitching" src="https://labuladong.online/algo-visualize/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>这段代码的时间复杂度是多少呢？虽然代码中有一个嵌套的 while 循环，但这个嵌套 while 循环的时间复杂度是 <code>O(N)</code>。因为当 <code>i</code> 递增到 <code>n</code> 时循环就会结束，所以这段代码只会执行 <code>O(N)</code> 次。</p><p>但是别忘了我们对 <code>clips</code> 数组进行了一次排序，消耗了 <code>O(NlogN)</code> 的时间，所以本算法的总时间复杂度是 <code>O(NlogN)</code>。</p><p>最后说一句，我去 B 站做 up 了，B 站搜索同名账号「labuladong」即可关注！</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何运用贪心思想玩跳跃游戏</title>
      <link href="/posts/47236.html"/>
      <url>/posts/47236.html</url>
      
        <content type="html"><![CDATA[<h1 id="如何运用贪心思想玩跳跃游戏"><a href="#如何运用贪心思想玩跳跃游戏" class="headerlink" title="如何运用贪心思想玩跳跃游戏"></a>如何运用贪心思想玩跳跃游戏</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/jump-game-ii/">45. Jump Game IIopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 IIopen in new window</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/jump-game/">55. Jump Gameopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏open in new window</a></td><td align="center">🟠</td></tr></tbody></table><p>经常有读者在后台问，动态规划和贪心算法到底有啥关系。我们之前的文章 <a href="https://labuladong.online/algo/frequency-interview/interval-scheduling/">贪心算法之区间调度问题</a> 就说过一个常见的时间区间调度的贪心算法问题。</p><p>说白了，贪心算法可以理解为一种特殊的动态规划问题，拥有一些更特殊的性质，可以进一步降低动态规划算法的时间复杂度。那么这篇文章，就讲 LeetCode 上两道经典的贪心算法：跳跃游戏 I 和跳跃游戏 II。</p><p>我们可以对这两道题分别使用动态规划算法和贪心算法进行求解，通过实践，你就能更深刻地理解贪心和动规的区别和联系了。</p><p>🌟</p><hr><p>🌟</p><h3 id="Jump-Game-I"><a href="#Jump-Game-I" class="headerlink" title="#Jump Game I"></a><a href="https://labuladong.online/algo/frequency-interview/jump-game-summary/#jump-game-i">#</a>Jump Game I</h3><p>这是力扣第 55 题「<a href="https://leetcode.cn/problems/jump-game/">跳跃游戏open in new window</a>」，难度是中等，但实际上比较简单，看题目：</p><details class="hint-container details" open="" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1rem 0px; padding: 1.5rem; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary style="position: relative; margin: -1.5rem -1.5rem 0.5em; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer;"><strong style="font-weight: 600;">55. 跳跃游戏</strong>&nbsp;|<span>&nbsp;</span><a target="_blank" href="https://leetcode.cn/problems/jump-game/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|<span>&nbsp;</span><a target="_blank" href="https://leetcode.com/problems/jump-game/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个非负整数数组&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">nums</code><span>&nbsp;</span>，你最初位于数组的<span>&nbsp;</span><strong style="font-weight: 600;">第一个下标</strong><span>&nbsp;</span>。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p style="line-height: 1.6; overflow-wrap: break-word;">判断你是否能够到达最后一个下标，如果可以，返回<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">true</code><span>&nbsp;</span>；否则，返回<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">false</code><span>&nbsp;</span>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例&nbsp;1：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>nums = [2,3,1,1,4]<strong style="font-weight: 600;">输出：</strong>true<strong style="font-weight: 600;">解释：</strong>可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例&nbsp;2：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入：</strong>nums = [3,2,1,0,4]<strong style="font-weight: 600;">输出：</strong>false<strong style="font-weight: 600;">解释：</strong>无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li></ul></div></details><p><strong>不知道读者有没有发现，有关动态规划的问题，大多是让你求最值的</strong>，比如最长子序列，最小编辑距离，最长公共子串等等等。这就是规律，因为动态规划本身就是运筹学里的一种求最值的算法。</p><p>那么贪心算法作为特殊的动态规划也是一样，也一定是让你求个最值。这道题表面上不是求最值，但是可以改一改：</p><p><strong>请问通过题目中的跳跃规则，最多能跳多远</strong>？如果能够越过最后一格，返回 true，否则返回 false。</p><p>所以说，这道题肯定可以用动态规划求解的。但是由于它比较简单，下一道题再用动态规划和贪心思路进行对比，现在直接上贪心的思路：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">farthest</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 不断计算能跳到的最远距离</span></span><br><span class="line">        farthest = Math.max(farthest, i + nums[i]);</span><br><span class="line">        <span class="comment">// 可能碰到了 0，卡住跳不动了</span></span><br><span class="line">        <span class="keyword">if</span> (farthest &lt;= i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> farthest &gt;= n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details data-v-fb30874b="" id="div_jump-game" class="hint-container details" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1.6em 0px; padding: 1rem 0px 0px; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary data-v-fb30874b="" style="position: relative; margin: -1.5rem 0px -0.5rem; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer; display: flex; align-items: center; font-size: large;"><strong data-v-fb30874b="" style="font-weight: 600;">👾 代码可视化动画 👾</strong><span data-v-fb30874b="" class="font-icon icon iconfont icon-resize" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-left: auto; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-refresh" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-link" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle;"></span></summary><div data-v-fb30874b="" class="resizable" style="width: 774.091px; max-width: 100%; height: 70vh; max-height: 70vh; overflow: auto; resize: both;"><iframe data-v-fb30874b="" id="iframe_jump-game" src="https://labuladong.online/algo-visualize/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>你别说，如果之前没有做过类似的题目，还真不一定能够想出来这个解法。每一步都计算一下从当前位置最远能够跳到哪里，然后和一个全局最优的最远位置 <code>farthest</code> 做对比，通过每一步的最优解，更新全局最优解，这就是贪心。</p><p>很简单是吧？记住这一题的思路，看第二题，你就发现事情没有这么简单。。。</p><h3 id="Jump-Game-II"><a href="#Jump-Game-II" class="headerlink" title="#Jump Game II"></a><a href="https://labuladong.online/algo/frequency-interview/jump-game-summary/#jump-game-ii">#</a>Jump Game II</h3><p>这是力扣第 45 题「<a href="https://leetcode.cn/problems/jump-game-ii/">跳跃游戏 IIopen in new window</a>」，也是让你在数组上跳，不过难度是 Hard，解法可没上一题那么简单直接：</p><details class="hint-container details" open="" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1rem 0px; padding: 1.5rem; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary style="position: relative; margin: -1.5rem -1.5rem 0.5em; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer;"><strong style="font-weight: 600;">45. 跳跃游戏 II</strong>&nbsp;|<span>&nbsp;</span><a target="_blank" href="https://leetcode.cn/problems/jump-game-ii/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|<span>&nbsp;</span><a target="_blank" href="https://leetcode.com/problems/jump-game-ii/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给定一个长度为<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">n</code><span>&nbsp;</span>的<span>&nbsp;</span><strong style="font-weight: 600;">0 索引</strong>整数数组<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">nums</code>。初始位置为<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">nums[0]</code>。</p><p style="line-height: 1.6; overflow-wrap: break-word;">每个元素<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">nums[i]</code><span>&nbsp;</span>表示从索引<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">i</code><span>&nbsp;</span>向前跳转的最大长度。换句话说，如果你在<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">nums[i]</code><span>&nbsp;</span>处，你可以跳转到任意<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">nums[i + j]</code><span>&nbsp;</span>处:</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">0 &lt;= j &lt;= nums[i]</code>&nbsp;</li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">i + j &lt; n</code></li></ul><p style="line-height: 1.6; overflow-wrap: break-word;">返回到达&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">nums[n - 1]</code><span>&nbsp;</span>的最小跳跃次数。生成的测试用例可以到达<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">nums[n - 1]</code>。</p><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1:</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入:</strong> nums = [2,3,1,1,4]<strong style="font-weight: 600;">输出:</strong> 2<strong style="font-weight: 600;">解释:</strong> 跳到最后一个位置的最小跳跃数是 <code style="margin: 0px; padding: 0px; border-radius: 0px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: unset; font-family: var(--font-family-mono); transition: color var(--color-transition); color: var(--code-color); text-align: left; white-space: pre; word-spacing: normal; word-break: normal; hyphens: none; -webkit-font-smoothing: auto;">2</code>。&nbsp;    从下标为 0 跳到下标为 1 的位置，跳&nbsp;<code style="margin: 0px; padding: 0px; border-radius: 0px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: unset; font-family: var(--font-family-mono); transition: color var(--color-transition); color: var(--code-color); text-align: left; white-space: pre; word-spacing: normal; word-break: normal; hyphens: none; -webkit-font-smoothing: auto;">1</code>&nbsp;步，然后跳&nbsp;<code style="margin: 0px; padding: 0px; border-radius: 0px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: unset; font-family: var(--font-family-mono); transition: color var(--color-transition); color: var(--code-color); text-align: left; white-space: pre; word-spacing: normal; word-break: normal; hyphens: none; -webkit-font-smoothing: auto;">3</code>&nbsp;步到达数组的最后一个位置。</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 2:</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入:</strong> nums = [2,3,0,1,4]<strong style="font-weight: 600;">输出:</strong> 2</pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示:</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">0 &lt;= nums[i] &lt;= 1000</code></li><li>题目保证可以到达&nbsp;<code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">nums[n-1]</code></li></ul></div></details><p><strong>现在的问题是，保证你一定可以跳到最后一格，请问你最少要跳多少次，才能跳过去</strong>。</p><p>我们先来说说动态规划的思路，采用自顶向下的递归动态规划，可以这样定义一个 <code>dp</code> 函数：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：从索引 p 跳到最后一格，至少需要 dp(nums, p) 步</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> p)</span>;</span><br></pre></td></tr></table></figure><p>我们想求的结果就是 <code>dp(nums, 0)</code>，base case 就是当 <code>p</code> 超过最后一格时，不需要跳跃：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (p &gt;= nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据前文 <a href="https://labuladong.online/algo/essential-technique/dynamic-programming-framework/">动态规划套路详解</a> 的动规框架，就可以暴力穷举所有可能的跳法，通过备忘录 <code>memo</code> 消除重叠子问题，取其中的最小值最为最终答案：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] memo;</span><br><span class="line">    <span class="comment">// 主函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 备忘录都初始化为 n，相当于 INT_MAX</span></span><br><span class="line">        <span class="comment">// 因为从 0 跳到 n - 1 最多 n - 1 步</span></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(memo, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp(nums, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：从索引 p 跳到最后一格，至少需要 dp(nums, p) 步</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (p &gt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子问题已经计算过</span></span><br><span class="line">        <span class="keyword">if</span> (memo[p] != n) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">steps</span> <span class="operator">=</span> nums[p];</span><br><span class="line">        <span class="comment">// 你可以选择跳 1 步，2 步...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= steps; i++) &#123;</span><br><span class="line">            <span class="comment">// 穷举每一个选择</span></span><br><span class="line">            <span class="comment">// 计算每一个子问题的结果</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">subProblem</span> <span class="operator">=</span> dp(nums, p + i);</span><br><span class="line">            <span class="comment">// 取其中最小的作为最终结果</span></span><br><span class="line">            memo[p] = Math.min(memo[p], subProblem + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个动态规划应该很明显了，按照前文 <a href="https://labuladong.online/algo/essential-technique/dynamic-programming-framework/">动态规划套路详解</a> 所说的套路，状态就是当前所站立的索引 <code>p</code>，选择就是可以跳出的步数。</p><p>该算法的时间复杂度是 递归深度 × 每次递归需要的时间复杂度，即 O(N^2)，在 LeetCode 上是无法通过所有用例的，会超时。</p><p><strong>贪心算法比动态规划多了一个性质：贪心选择性质</strong>。我知道大家都不喜欢看严谨但枯燥的数学形式定义，那么我们就来直观地看一看什么样的问题满足贪心选择性质。</p><p>刚才的动态规划思路，不是要穷举所有子问题，然后取其中最小的作为结果吗？核心的代码框架是这样：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">steps</span> <span class="operator">=</span> nums[p];</span><br><span class="line"><span class="comment">// 你可以选择跳 1 步，2 步...</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= steps; i++) &#123;</span><br><span class="line">    <span class="comment">// 计算每一个子问题的结果</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">subProblem</span> <span class="operator">=</span> dp(nums, p + i);</span><br><span class="line">    res = min(subProblem + <span class="number">1</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for 循环中会陷入递归计算子问题，这是动态规划时间复杂度高的根本原因。</p><p>但是，真的需要「递归地」计算出每一个子问题的结果，然后求最值吗？<strong>直观地想一想，似乎不需要递归，只需要判断哪一个选择最具有「潜力」即可</strong>：</p><p><img src="https://labuladong.online/algo/images/jumpGame/1.jpg" alt="img"></p><p>比如上图这种情况，我们站在索引 0 的位置，可以向前跳 1，2 或 3 步，你说应该选择跳多少呢？</p><p><strong>显然应该跳 2 步调到索引 2，因为 <code>nums[2]</code> 的可跳跃区域涵盖了索引区间 <code>[3..6]</code>，比其他的都大</strong>。如果想求最少的跳跃次数，那么往索引 2 跳必然是最优的选择。</p><p>你看，<strong>这就是贪心选择性质，我们不需要「递归地」计算出所有选择的具体结果然后比较求最值，而只需要做出那个最有「潜力」，看起来最优的选择即可</strong>。</p><p>绕过这个弯儿来，就可以写代码了：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>, farthest = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">jumps</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        farthest = Math.max(nums[i] + i, farthest);</span><br><span class="line">        <span class="keyword">if</span> (end == i) &#123;</span><br><span class="line">            jumps++;</span><br><span class="line">            end = farthest;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jumps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details data-v-fb30874b="" id="div_jump-game-ii" class="hint-container details" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1.6em 0px; padding: 1rem 0px 0px; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary data-v-fb30874b="" style="position: relative; margin: -1.5rem 0px -0.5rem; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer; display: flex; align-items: center; font-size: large;"><strong data-v-fb30874b="" style="font-weight: 600;">🌈 代码可视化动画 🌈</strong><span data-v-fb30874b="" class="font-icon icon iconfont icon-resize" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-left: auto; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-refresh" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-link" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle;"></span></summary><div data-v-fb30874b="" class="resizable" style="width: 774.091px; max-width: 100%; height: 70vh; max-height: 70vh; overflow: auto; resize: both;"><iframe data-v-fb30874b="" id="iframe_jump-game-ii" src="https://labuladong.online/algo-visualize/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>结合刚才那个图，就知道这段短小精悍的代码在干什么了：</p><p><img src="https://labuladong.online/algo/images/jumpGame/2.jpg" alt="img"></p><p><code>i</code> 和 <code>end</code> 标记了可以选择的跳跃步数，<code>farthest</code> 标记了所有选择 <code>[i..end]</code> 中能够跳到的最远距离，<code>jumps</code> 记录了跳跃次数。</p><p>本算法的时间复杂度 O(N)，空间复杂度 O(1)，可以说是非常高效，动态规划都被吊起来打了。</p><p>至此，两道跳跃问题都使用贪心算法解决了。</p><p>其实对于贪心选择性质，是可以有严格的数学证明的，有兴趣的读者可以参看《算法导论》第十六章，专门有一个章节介绍贪心算法。这里限于篇幅和通俗性，就不展开了。</p><p>使用贪心算法的实际应用还挺多，比如赫夫曼编码也是一个经典的贪心算法应用。更多时候运用贪心算法可能不是求最优解，而是求次优解以节约时间，比如经典的旅行商问题。</p><p>不过我们常见的贪心算法题目，就像本文的题目，大多一眼就能看出来，大不了就先用动态规划求解，如果动态规划都超时，说明该问题存在贪心选择性质无疑了。</p><p>接下来可阅读：</p><ul><li><a href="https://labuladong.online/algo/frequency-interview/interval-scheduling/">贪心问题之区间调度</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扫描线技巧：安排会议室</title>
      <link href="/posts/49633.html"/>
      <url>/posts/49633.html</url>
      
        <content type="html"><![CDATA[<h1 id="扫描线技巧：安排会议室"><a href="#扫描线技巧：安排会议室" class="headerlink" title="扫描线技巧：安排会议室"></a>扫描线技巧：安排会议室</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/meeting-rooms-ii/">253. Meeting Rooms IIopen in new window</a>🔒</td><td align="center"><a href="https://leetcode.cn/problems/meeting-rooms-ii/">253. 会议室 IIopen in new window</a>🔒</td><td align="center">🟠</td></tr></tbody></table><p>之前面试，被问到一道非常经典且非常实用的算法题目：会议室安排问题。</p><p>力扣上类似的问题是会员题目，你可能没办法做，但对于这种经典的算法题，掌握思路还是必要的。</p><p>先说下题目，力扣第 253 题「<a href="https://leetcode.cn/problems/meeting-rooms-ii/">会议室 IIopen in new window</a>」：</p><p>给你输入若干形如 <code>[begin, end]</code> 的区间，代表若干会议的开始时间和结束时间，请你计算至少需要申请多少间会议室。</p><p>函数签名如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回需要申请的会议室数量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">minMeetingRooms</span><span class="params">(<span class="type">int</span>[][] meetings)</span>;</span><br></pre></td></tr></table></figure><p>比如给你输入 <code>meetings = [[0,30],[5,10],[15,20]]</code>，算法应该返回 2，因为后两个会议和第一个会议时间是冲突的，至少申请两个会议室才能让所有会议顺利进行。</p><p>如果会议之间的时间有重叠，那就得额外申请会议室来开会，想求至少需要多少间会议室，就是让你计算同一时刻最多有多少会议在同时进行。</p><p>换句话说，<strong>如果把每个会议的起始时间看做一个线段区间，那么题目就是让你求最多有几个重叠区间</strong>，仅此而已。</p><p>对于这种时间安排的问题，本质上讲就是区间调度问题，十有八九得排序，然后找规律来解决。</p><h3 id="题目延伸"><a href="#题目延伸" class="headerlink" title="#题目延伸"></a><a href="https://labuladong.online/algo/frequency-interview/scan-line-technique/#%E9%A2%98%E7%9B%AE%E5%BB%B6%E4%BC%B8">#</a>题目延伸</h3><p>我们之前写过很多区间调度相关的文章，这里就顺便帮大家梳理一下这类问题的思路：</p><p>🌟</p><hr><p>🌟</p><p><strong>第一个场景</strong>，假设现在只有一个会议室，还有若干会议，你如何将尽可能多的会议安排到这个会议室里？</p><p>这个问题需要将这些会议（区间）按结束时间（右端点）排序，然后进行处理，详见前文 <a href="https://labuladong.online/algo/frequency-interview/interval-scheduling/">贪心算法做时间管理</a>。</p><p><strong>第二个场景</strong>，给你若干较短的视频片段，和一个较长的视频片段，请你从较短的片段中尽可能少地挑出一些片段，拼接出较长的这个片段。</p><p>这个问题需要将这些视频片段（区间）按开始时间（左端点）排序，然后进行处理，详见后文 <a href="https://labuladong.online/algo/frequency-interview/cut-video/">剪视频剪出一个贪心算法</a>。</p><p><strong>第三个场景</strong>，给你若干区间，其中可能有些区间比较短，被其他区间完全覆盖住了，请你删除这些被覆盖的区间。</p><p>这个问题需要将这些区间按左端点排序，然后就能找到并删除那些被完全覆盖的区间了，详见后文 <a href="https://labuladong.online/algo/practice-in-action/interval-problem-summary/">删除覆盖区间</a>。</p><p><strong>第四个场景</strong>，给你若干区间，请你将所有有重叠部分的区间进行合并。</p><p>这个问题需要将这些区间按左端点排序，方便找出存在重叠的区间，详见后文 <a href="https://labuladong.online/algo/practice-in-action/interval-problem-summary/">合并重叠区间</a>。</p><p><strong>第五个场景</strong>，有两个部门同时预约了同一个会议室的若干时间段，请你计算会议室的冲突时段。</p><p>这个问题就是给你两组区间列表，请你找出这两组区间的交集，这需要你将这些区间按左端点排序，详见后文 <a href="https://labuladong.online/algo/practice-in-action/interval-problem-summary/">区间交集问题</a>。</p><p><strong>第六个场景</strong>，假设现在只有一个会议室，还有若干会议，如何安排会议才能使这个会议室的闲置时间最少？</p><p>这个问题需要动动脑筋，说白了这就是个 0-1 背包问题的变形：</p><p>会议室可以看做一个背包，每个会议可以看做一个物品，物品的价值就是会议的时长，请问你如何选择物品（会议）才能最大化背包中的价值（会议室的使用时长）？</p><p>当然，这里背包的约束不是一个最大重量，而是各个物品（会议）不能互相冲突。把各个会议按照结束时间进行排序，然后参考前文 <a href="https://labuladong.online/algo/dynamic-programming/knapsack1/">0-1 背包问题详解</a> 的思路即可解决，等我以后有机会可以写一写这个问题。</p><p><strong>第七个场景</strong>，就是本文想讲的场景，给你若干会议，让你合理申请会议室。</p><p>好了，举例了这么多，来看看今天的这个问题如何解决。</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="#题目分析"></a><a href="https://labuladong.online/algo/frequency-interview/scan-line-technique/#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90">#</a>题目分析</h3><p>重复一下题目的本质：</p><p><strong>给你输入若干时间区间，让你计算同一时刻「最多」有几个区间重叠</strong>。</p><p>题目的关键点在于，给你任意一个时刻，你是否能够说出这个时刻有几个会议？</p><p>如果可以做到，那我遍历所有的时刻，找个最大值，就是需要申请的会议室数量。</p><p>有没有一种数据结构或者算法，给我输入若干区间，我能知道每个位置有多少个区间重叠？</p><p>老读者肯定可以联想到之前说过的一个算法技巧：<a href="https://labuladong.online/algo/data-structure/diff-array/">差分数组技巧</a>。</p><p>把时间线想象成一个初始值为 0 的数组，每个时间区间 <code>[i, j]</code> 就相当于一个子数组，这个时间区间有一个会议，那我就把这个子数组中的元素都加一。</p><p>最后，每个时刻有几个会议我不就知道了吗？我遍历整个数组，不就知道至少需要几间会议室了吗？</p><p>举例来说，如果输入 <code>meetings = [[0,30],[5,10],[15,20]]</code>，那么我们就给数组中 <code>[0,30],[5,10],[15,20]</code> 这几个索引区间分别加一，最后遍历数组，求个最大值就行了。</p><p>还记得吗，差分数组技巧可以在 O(1) 时间对整个区间的元素进行加减，所以可以拿来解决这道题。</p><p>不过，这个解法的效率不算高，所以我这里不准备具体写差分数组的解法，参照 <a href="https://labuladong.online/algo/data-structure/diff-array/">差分数组技巧</a> 的原理，有兴趣的读者可以自己尝试去实现。</p><p><strong>基于差分数组的思路，我们可以推导出一种更高效，更优雅的解法</strong>。</p><p>我们首先把这些会议的时间区间进行投影：</p><p><img src="https://labuladong.online/algo/images/%E5%AE%89%E6%8E%92%E4%BC%9A%E8%AE%AE%E5%AE%A4/1.jpeg" alt="img"></p><p>红色的点代表每个会议的开始时间点，绿色的点代表每个会议的结束时间点。</p><p>现在假想有一条带着计数器的线，在时间线上从左至右进行扫描，每遇到红色的点，计数器 <code>count</code> 加一，每遇到绿色的点，计数器 <code>count</code> 减一：</p><p><img src="https://labuladong.online/algo/images/%E5%AE%89%E6%8E%92%E4%BC%9A%E8%AE%AE%E5%AE%A4/2.jpeg" alt="img"></p><p><strong>这样一来，每个时刻有多少个会议在同时进行，就是计数器 <code>count</code> 的值，<code>count</code> 的最大值，就是需要申请的会议室数量</strong>。</p><p>对差分数组技巧熟悉的读者一眼就能看出来了，这个扫描线其实就是差分数组的遍历过程，所以我们说这是差分数组技巧衍生出来的解法。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="#代码实现"></a><a href="https://labuladong.online/algo/frequency-interview/scan-line-technique/#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">#</a>代码实现</h3><p>那么，如何写代码实现这个扫描的过程呢？</p><p>首先，对区间进行投影，就相当于对每个区间的起点和终点分别进行排序：</p><p><img src="https://labuladong.online/algo/images/%E5%AE%89%E6%8E%92%E4%BC%9A%E8%AE%AE%E5%AE%A4/3.jpeg" alt="img"></p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minMeetingRooms</span><span class="params">(<span class="type">int</span>[][] meetings)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> meetings.length;</span><br><span class="line">    <span class="type">int</span>[] begin = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span>[] end = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="comment">// 把左端点和右端点单独拿出来</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        begin[i] = meetings[i][<span class="number">0</span>];</span><br><span class="line">        end[i] = meetings[i][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排序后就是图中的红点</span></span><br><span class="line">    Arrays.sort(begin);</span><br><span class="line">    <span class="comment">// 排序后就是图中的绿点</span></span><br><span class="line">    Arrays.sort(end);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就简单了，扫描线从左向右前进，遇到红点就对计数器加一，遇到绿点就对计数器减一，计数器 <code>count</code> 的最大值就是答案：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">minMeetingRooms</span><span class="params">(<span class="type">int</span>[][] meetings)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> meetings.length;</span><br><span class="line">        <span class="type">int</span>[] begin = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] end = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            begin[i] = meetings[i][<span class="number">0</span>];</span><br><span class="line">            end[i] = meetings[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(begin);</span><br><span class="line">        Arrays.sort(end);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扫描过程中的计数器</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 双指针技巧</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (begin[i] &lt; end[j]) &#123;</span><br><span class="line">                <span class="comment">// 扫描到一个红点</span></span><br><span class="line">                count++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 扫描到一个绿点</span></span><br><span class="line">                count--;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录扫描过程中的最大值</span></span><br><span class="line">            res = Math.max(res, count);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用的是 <a href="https://labuladong.online/algo/essential-technique/array-two-pointers-summary/">双指针技巧</a>，根据 <code>i, j</code> 的相对位置模拟扫描线前进的过程。</p><p>至此，这道题就做完了。当然，这个题目也可以变形，比如给你若干会议，问你 <code>k</code> 个会议室够不够用，其实你套用本文的解法代码，也可以很轻松解决。</p><p>接下来可阅读：</p><ul><li><a href="https://labuladong.online/algo/practice-in-action/interval-problem-summary/">区间问题系列合集</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法之区间调度问题</title>
      <link href="/posts/8899.html"/>
      <url>/posts/8899.html</url>
      
        <content type="html"><![CDATA[<h1 id="贪心算法之区间调度问题"><a href="#贪心算法之区间调度问题" class="headerlink" title="贪心算法之区间调度问题"></a>贪心算法之区间调度问题</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/non-overlapping-intervals/">435. Non-overlapping Intervalsopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/non-overlapping-intervals/">435. 无重叠区间open in new window</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/">452. Minimum Number of Arrows to Burst Balloonsopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球open in new window</a></td><td align="center">🟠</td></tr></tbody></table><p>什么是贪心算法呢？贪心算法可以认为是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高。</p><p>比如说一个算法问题使用暴力解法需要指数级时间，如果能使用动态规划消除重叠子问题，就可以降到多项式级别的时间，如果满足贪心选择性质，那么可以进一步降低时间复杂度，达到线性级别的。</p><p>什么是贪心选择性质呢，简单说就是：每一步都做出一个局部最优的选择，最终的结果就是全局最优。注意哦，这是一种特殊性质，其实只有一部分问题拥有这个性质。</p><p>比如你面前放着 100 张人民币，你只能拿十张，怎么才能拿最多的面额？显然每次选择剩下钞票中面值最大的一张，最后你的选择一定是最优的。</p><p>然而，大部分问题明显不具有贪心选择性质。比如打斗地主，对手出对儿三，按照贪心策略，你应该出尽可能小的牌刚好压制住对方，但现实情况我们甚至可能会出王炸。这种情况就不能用贪心算法，而得使用动态规划解决，参见前文 <a href="https://labuladong.online/algo/dynamic-programming/game-theory/">动态规划解决博弈问题</a>。</p><h3 id="一、问题概述"><a href="#一、问题概述" class="headerlink" title="#一、问题概述"></a><a href="https://labuladong.online/algo/frequency-interview/interval-scheduling/#%E4%B8%80%E3%80%81%E9%97%AE%E9%A2%98%E6%A6%82%E8%BF%B0">#</a>一、问题概述</h3><p>言归正传，本文解决一个很经典的贪心算法问题 Interval Scheduling（区间调度问题），也就是力扣第 435 题「<a href="https://leetcode.cn/problems/non-overlapping-intervals/">无重叠区间open in new window</a>」：</p><p>给你很多形如 <code>[start, end]</code> 的闭区间，请你设计一个算法，<strong>算出这些区间中最多有几个互不相交的区间</strong>。</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">intervalSchedule</span><span class="params">(<span class="type">int</span>[][] intvs)</span>;</span><br></pre></td></tr></table></figure><p>举个例子，<code>intvs = [[1,3], [2,4], [3,6]]</code>，这些区间最多有 2 个区间互不相交，即 <code>[[1,3], [3,6]]</code>，你的算法应该返回 2。注意边界相同并不算相交。</p><p>这个问题在生活中的应用广泛，比如你今天有好几个活动，每个活动都可以用区间 <code>[start, end]</code> 表示开始和结束的时间，请问你今天<strong>最多能参加几个活动呢</strong>？显然你一个人不能同时参加两个活动，所以说这个问题就是求这些时间区间的最大不相交子集。</p><p>🌟</p><hr><p>🌟</p><h3 id="二、贪心解法"><a href="#二、贪心解法" class="headerlink" title="#二、贪心解法"></a><a href="https://labuladong.online/algo/frequency-interview/interval-scheduling/#%E4%BA%8C%E3%80%81%E8%B4%AA%E5%BF%83%E8%A7%A3%E6%B3%95">#</a>二、贪心解法</h3><p>这个问题有许多看起来不错的贪心思路，却都不能得到正确答案。比如说：</p><p>也许我们可以每次选择可选区间中开始最早的那个？但是可能存在某些区间开始很早，但是很长，使得我们错误地错过了一些短的区间。或者我们每次选择可选区间中最短的那个？或者选择出现冲突最少的那个区间？这些方案都能很容易举出反例，不是正确的方案。</p><p>正确的思路其实很简单，可以分为以下三步：</p><p>1、从区间集合 <code>intvs</code> 中选择一个区间 <code>x</code>，这个 <code>x</code> 是在当前所有区间中<strong>结束最早的</strong>（<code>end</code> 最小）。</p><p>2、把所有与 <code>x</code> 区间相交的区间从区间集合 <code>intvs</code> 中删除。</p><p>3、重复步骤 1 和 2，直到 <code>intvs</code> 为空为止。之前选出的那些 <code>x</code> 就是最大不相交子集。</p><p>把这个思路实现成算法的话，可以按每个区间的 <code>end</code> 数值升序排序，因为这样处理之后实现步骤 1 和步骤 2 都方便很多，如下 GIF 所示：</p><p><img src="https://labuladong.online/algo/images/interval/1.gif" alt="img"></p><p>现在来实现算法，对于步骤 1，由于我们预先按照 <code>end</code> 排了序，所以选择 <code>x</code> 是很容易的。关键在于，如何去除与 <code>x</code> 相交的区间，选择下一轮循环的 <code>x</code> 呢？</p><p><strong>由于我们事先排了序</strong>，不难发现所有与 <code>x</code> 相交的区间必然会与 <code>x</code> 的 <code>end</code> 相交；如果一个区间不想与 <code>x</code> 的 <code>end</code> 相交，它的 <code>start</code> 必须要大于（或等于）<code>x</code> 的 <code>end</code>：</p><p><img src="https://labuladong.online/algo/images/interval/2.jpg" alt="img"></p><p>看下代码：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">intervalSchedule</span><span class="params">(<span class="type">int</span>[][] intvs)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (intvs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 按 end 升序排序</span></span><br><span class="line">    Arrays.sort(intvs, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span>[] b)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 至少有一个区间不相交</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 排序后，第一个区间就是 x</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x_end</span> <span class="operator">=</span> intvs[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] interval : intvs) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> interval[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= x_end) &#123;</span><br><span class="line">            <span class="comment">// 找到下一个选择的区间了</span></span><br><span class="line">            count++;</span><br><span class="line">            x_end = interval[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、应用举例"><a href="#三、应用举例" class="headerlink" title="#三、应用举例"></a><a href="https://labuladong.online/algo/frequency-interview/interval-scheduling/#%E4%B8%89%E3%80%81%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B">#</a>三、应用举例</h3><p>下面再举例几道具体的题目应用一下区间调度算法。</p><p>首先是力扣第 435 题「<a href="https://leetcode.cn/problems/non-overlapping-intervals/">无重叠区间open in new window</a>」问题：</p><p>输入一个区间的集合，请你计算，要想使其中的区间都互不重叠，至少需要移除几个区间？函数签名如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intvs)</span>;</span><br></pre></td></tr></table></figure><p>其中，可以假设输入的区间的终点总是大于起点，另外边界相等的区间只算接触，但并不算相互重叠。</p><p>比如说输入是 <code>intvs = [[1,2],[2,3],[3,4],[1,3]]</code>，算法返回 1，因为只要移除 <code>[1,3]</code> 后，剩下的区间就没有重叠了。</p><p>我们已经会求最多有几个区间不会重叠了，那么剩下的不就是至少需要去除的区间吗？</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> intervals.length;</span><br><span class="line">    <span class="keyword">return</span> n - intervalSchedule(intervals);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details data-v-fb30874b="" id="div_non-overlapping-intervals" class="hint-container details" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1.6em 0px; padding: 1rem 0px 0px; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary data-v-fb30874b="" style="position: relative; margin: -1.5rem 0px -0.5rem; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer; display: flex; align-items: center; font-size: large;"><strong data-v-fb30874b="" style="font-weight: 600;">🍭 代码可视化动画 🍭</strong><span data-v-fb30874b="" class="font-icon icon iconfont icon-resize" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-left: auto; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-refresh" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-link" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle;"></span></summary><div data-v-fb30874b="" class="resizable" style="width: 774.091px; max-width: 100%; height: 70vh; max-height: 70vh; overflow: auto; resize: both;"><iframe data-v-fb30874b="" id="iframe_non-overlapping-intervals" src="https://labuladong.online/algo-visualize/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>再说说力扣第 452 题「<a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">用最少的箭头射爆气球open in new window</a>」，我来描述一下题目：</p><p>假设在二维平面上有很多圆形的气球，这些圆形投影到 x 轴上会形成一个个区间对吧。那么给你输入这些区间，你沿着 x 轴前进，可以垂直向上射箭，请问你至少要射几箭才能把这些气球全部射爆呢？</p><p>函数签名如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] intvs)</span>;</span><br></pre></td></tr></table></figure><p>比如说输入为 <code>[[10,16],[2,8],[1,6],[7,12]]</code>，算法应该返回 2，因为我们可以在 <code>x</code> 为 6 的地方射一箭，射爆 <code>[2,8]</code> 和 <code>[1,6]</code> 两个气球，然后在 <code>x</code> 为 10，11 或 12 的地方射一箭，射爆 <code>[10,16]</code> 和 <code>[7,12]</code> 两个气球。</p><p>其实稍微思考一下，这个问题和区间调度算法一模一样！如果最多有 <code>n</code> 个不重叠的区间，那么就至少需要 <code>n</code> 个箭头穿透所有区间：</p><p><img src="https://labuladong.online/algo/images/interval/3.jpg" alt="img"></p><p>只是有一点不一样，在 <code>intervalSchedule</code> 算法中，如果两个区间的边界触碰，不算重叠；而按照这道题目的描述，箭头如果碰到气球的边界气球也会爆炸，所以说相当于区间的边界触碰也算重叠：</p><p><img src="https://labuladong.online/algo/images/interval/4.jpg" alt="img"></p><p>所以只要将之前的算法稍作修改，就是这道题目的答案：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] intvs)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] interval : intvs) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> interval[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 把 &gt;= 改成 &gt; 就行了</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt; x_end) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            x_end = interval[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details data-v-fb30874b="" id="div_minimum-number-of-arrows-to-burst-balloons" class="hint-container details" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1.6em 0px; padding: 1rem 0px 0px; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary data-v-fb30874b="" style="position: relative; margin: -1.5rem 0px -0.5rem; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer; display: flex; align-items: center; font-size: large;"><strong data-v-fb30874b="" style="font-weight: 600;">👾 代码可视化动画 👾</strong><span data-v-fb30874b="" class="font-icon icon iconfont icon-resize" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-left: auto; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-refresh" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-link" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle;"></span></summary><div data-v-fb30874b="" class="resizable" style="width: 774.091px; max-width: 100%; height: 70vh; max-height: 70vh; overflow: auto; resize: both;"><iframe data-v-fb30874b="" id="iframe_minimum-number-of-arrows-to-burst-balloons" src="https://labuladong.online/algo-visualize/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>接下来可阅读：</p><ul><li><a href="https://labuladong.online/algo/frequency-interview/jump-game-summary/">贪心算法之跳跃游戏</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何同时寻找缺失和重复的元素</title>
      <link href="/posts/9364.html"/>
      <url>/posts/9364.html</url>
      
        <content type="html"><![CDATA[<h1 id="如何同时寻找缺失和重复的元素"><a href="#如何同时寻找缺失和重复的元素" class="headerlink" title="如何同时寻找缺失和重复的元素"></a>如何同时寻找缺失和重复的元素</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/set-mismatch/">645. Set Mismatchopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/set-mismatch/">645. 错误的集合open in new window</a></td><td align="center">🟢</td></tr></tbody></table><p>今天就聊一道很看起来简单却十分巧妙的问题，寻找缺失和重复的元素。之前的一篇文章 <a href="https://labuladong.online/algo/frequency-interview/bitwise-operation/">常用的位操作</a> 中也写过类似的问题，不过这次的和上次的问题使用的技巧不同。</p><p>这是力扣第 645 题「<a href="https://leetcode.cn/problems/set-mismatch/">错误的集合open in new window</a>」，我来描述一下这个题目：</p><p>给一个长度为 <code>N</code> 的数组 <code>nums</code>，其中本来装着 <code>[1..N]</code> 这 <code>N</code> 个元素，无序。但是现在出现了一些错误，<code>nums</code> 中的一个元素出现了重复，也就同时导致了另一个元素的缺失。请你写一个算法，找到 <code>nums</code> 中的重复元素和缺失元素的值。</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回两个数字，分别是 &#123;dup, missing&#125;</span></span><br><span class="line"><span class="type">int</span>[] findErrorNums(<span class="type">int</span>[] nums);</span><br></pre></td></tr></table></figure><p>比如说输入：<code>nums = [1,2,2,4]</code>，算法返回 <code>[2,3]</code>。</p><p>其实很容易解决这个问题，先遍历一次数组，用一个哈希表记录每个数字出现的次数，然后遍历一次 <code>[1..N]</code>，看看那个元素重复出现，那个元素没有出现，就 OK 了。</p><p>但问题是，这个常规解法需要一个哈希表，也就是 O(N) 的空间复杂度。你看题目给的条件那么巧，在 <code>[1..N]</code> 的几个数字中恰好有一个重复，一个缺失，<strong>事出反常必有妖</strong>，对吧。</p><p>O(N) 的时间复杂度遍历数组是无法避免的，所以我们可以想想办法如何降低空间复杂度，是否可以在 O(1) 的空间复杂度之下找到重复和缺失的元素呢？</p><p>🌟</p><hr><p>🌟</p><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="#思路分析"></a><a href="https://labuladong.online/algo/frequency-interview/mismatch-set/#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90">#</a>思路分析</h3><p>这个问题的特点是，每个元素和数组索引有一定的对应关系。</p><p>我们现在自己改造下问题，<strong>暂且将 <code>nums</code> 中的元素变为 <code>[0..N-1]</code>，这样每个元素就和一个数组索引完全对应了，这样方便理解一些</strong>。</p><p>如果说 <code>nums</code> 中不存在重复元素和缺失元素，那么每个元素就和唯一一个索引值对应，对吧？</p><p>现在的问题是，有一个元素重复了，同时导致一个元素缺失了，这会产生什么现象呢？<strong>会导致有两个元素对应到了同一个索引，而且会有一个索引没有元素对应过去</strong>。</p><p>那么，如果我能够通过某些方法，找到这个重复对应的索引，不就是找到了那个重复元素么？找到那个没有元素对应的索引，不就是找到了那个缺失的元素了么？</p><p>那么，如何不使用额外空间判断某个索引有多少个元素对应呢？这就是这个问题的精妙之处了：</p><p><strong>通过将每个索引对应的元素变成负数，以表示这个索引被对应过一次了</strong>，算法过程如下 GIF 所示：</p><p><img src="https://labuladong.online/algo/images/dupmissing/1.gif" alt="img"></p><p>如果出现重复元素 <code>4</code>，直观结果就是，索引 <code>4</code> 所对应的元素已经是负数了：</p><p><img src="https://labuladong.online/algo/images/dupmissing/2.jpg" alt="img"></p><p>对于缺失元素 <code>3</code>，直观结果就是，索引 <code>3</code> 所对应的元素是正数：</p><p><img src="https://labuladong.online/algo/images/dupmissing/3.jpg" alt="img"></p><p>对于这个现象，我们就可以翻译成代码了：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] findErrorNums(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dup</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Math.abs(nums[i]);</span><br><span class="line">        <span class="comment">// nums[index] 小于 0 则说明重复访问</span></span><br><span class="line">        <span class="keyword">if</span> (nums[index] &lt; <span class="number">0</span>)</span><br><span class="line">            dup = Math.abs(nums[i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nums[index] *= -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">missing</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="comment">// nums[i] 大于 0 则说明没有访问</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">            missing = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;dup, missing&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题就基本解决了，别忘了我们刚才为了方便分析，假设元素是 <code>[0..N-1]</code>，但题目要求是 <code>[1..N]</code>，所以只要简单修改两处地方即可得到原题的答案：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] findErrorNums(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dup</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 现在的元素是从 1 开始的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Math.abs(nums[i]) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[index] &lt; <span class="number">0</span>)</span><br><span class="line">            dup = Math.abs(nums[i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nums[index] *= -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">missing</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 将索引转换成元素</span></span><br><span class="line">            missing = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;dup, missing&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details data-v-fb30874b="" id="div_set-mismatch" class="hint-container details" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1.6em 0px; padding: 1rem 0px 0px; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary data-v-fb30874b="" style="position: relative; margin: -1.5rem 0px -0.5rem; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer; display: flex; align-items: center; font-size: large;"><strong data-v-fb30874b="" style="font-weight: 600;">🥳 代码可视化动画 🥳</strong><span data-v-fb30874b="" class="font-icon icon iconfont icon-resize" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-left: auto; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-refresh" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-link" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle;"></span></summary><div data-v-fb30874b="" class="resizable" style="width: 774.091px; max-width: 100%; height: 70vh; max-height: 70vh; overflow: auto; resize: both;"><iframe data-v-fb30874b="" id="iframe_set-mismatch" src="https://labuladong.online/algo-visualize/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>其实，元素从 1 开始是有道理的，也必须从一个非零数开始。因为如果元素从 0 开始，那么 0 的相反数还是自己，所以如果数字 0 出现了重复或者缺失，算法就无法判断 0 是否被访问过。我们之前的假设只是为了简化题目，更通俗易懂。</p><h3 id="最后总结"><a href="#最后总结" class="headerlink" title="#最后总结"></a><a href="https://labuladong.online/algo/frequency-interview/mismatch-set/#%E6%9C%80%E5%90%8E%E6%80%BB%E7%BB%93">#</a>最后总结</h3><p>对于这种数组问题，<strong>关键点在于元素和索引是成对儿出现的，常用的方法是排序、异或、映射</strong>。</p><p>映射的思路就是我们刚才的分析，将每个索引和元素映射起来，通过正负号记录某个元素是否被映射。</p><p>排序的方法也很好理解，对于这个问题，可以想象如果元素都被从小到大排序，如果发现索引对应的元素如果不相符，就可以找到重复和缺失的元素。</p><p>异或运算也是常用的，因为异或性质 <code>a ^ a = 0, a ^ 0 = a</code>，如果将索引和元素同时异或，就可以消除成对儿的索引和元素，留下的就是重复或者缺失的元素。可以看看前文 <a href="https://labuladong.online/algo/frequency-interview/bitwise-operation/">常用的位运算</a>，介绍过这种方法。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>讲两道常考的阶乘算法题</title>
      <link href="/posts/41483.html"/>
      <url>/posts/41483.html</url>
      
        <content type="html"><![CDATA[<h1 id="讲两道常考的阶乘算法题"><a href="#讲两道常考的阶乘算法题" class="headerlink" title="讲两道常考的阶乘算法题"></a>讲两道常考的阶乘算法题</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/factorial-trailing-zeroes/">172. Factorial Trailing Zeroesopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/factorial-trailing-zeroes/">172. 阶乘后的零open in new window</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/preimage-size-of-factorial-zeroes-function/">793. Preimage Size of Factorial Zeroes Functionopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function/">793. 阶乘函数后 K 个零open in new window</a></td><td align="center">🔴</td></tr></tbody></table><p>笔试题中经常看到阶乘相关的题目，今天说两个最常见的题目：</p><p><strong>1、输入一个非负整数 <code>n</code>，请你计算阶乘 <code>n!</code> 的结果末尾有几个 0</strong>。</p><p>这也是力扣第 172 题「<a href="https://leetcode.cn/problems/factorial-trailing-zeroes/">阶乘后的零open in new window</a>」，比如说输入 <code>n = 5</code>，算法返回 1，因为 <code>5! = 120</code>，末尾有一个 0。</p><p>函数签名如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span>;</span><br></pre></td></tr></table></figure><p><strong>2、输入一个非负整数 <code>K</code>，请你计算有多少个 <code>n</code>，满足 <code>n!</code> 的结果末尾恰好有 <code>K</code> 个 0</strong>。</p><p>这也是力扣第 793 题「<a href="https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function/">阶乘后 K 个零open in new window</a>」，比如说输入 <code>K = 1</code>，算法返回 5，因为 <code>5!,6!,7!,8!,9!</code> 这 5 个阶乘的结果最后只有一个 0，即有 5 个 <code>n</code> 满足条件。</p><p>函数签名如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">preimageSizeFZF</span><span class="params">(<span class="type">int</span> K)</span>;</span><br></pre></td></tr></table></figure><p>我把这两个题放在一起，肯定是因为它们有共性，下面我们来逐一分析。</p><p>🌟</p><hr><p>🌟</p><h3 id="题目一"><a href="#题目一" class="headerlink" title="#题目一"></a><a href="https://labuladong.online/algo/frequency-interview/factorial-problems/#%E9%A2%98%E7%9B%AE%E4%B8%80">#</a>题目一</h3><p>肯定不可能真去把 <code>n!</code> 的结果算出来，阶乘增长可是比指数增长都恐怖，趁早死了这条心吧。</p><p>那么，结果的末尾的 0 从哪里来的？我们有没有投机取巧的方法计算出来？</p><p>首先，两个数相乘结果末尾有 0，一定是因为两个数中有因子 2 和 5，因为 10 &#x3D; 2 x 5。</p><p><strong>也就是说，问题转化为：<code>n!</code> 最多可以分解出多少个因子 2 和 5</strong>？</p><p>比如说 <code>n = 25</code>，那么 <code>25!</code> 最多可以分解出几个 2 和 5 相乘？这个主要取决于能分解出几个因子 5，因为每个偶数都能分解出因子 2，因子 2 肯定比因子 5 多得多。</p><p><code>25!</code> 中 5 可以提供一个，10 可以提供一个，15 可以提供一个，20 可以提供一个，25 可以提供两个，总共有 6 个因子 5，所以 <code>25!</code> 的结果末尾就有 6 个 0。</p><p><strong>现在，问题转化为：<code>n!</code> 最多可以分解出多少个因子 5</strong>？</p><p>难点在于像 25，50，125 这样的数，可以提供不止一个因子 5，怎么才能不漏掉呢？</p><p>这样，我们假设 <code>n = 125</code>，来算一算 <code>125!</code> 的结果末尾有几个 0：</p><p>首先，125 &#x2F; 5 &#x3D; 25，这一步就是计算有多少个像 5，15，20，25 这些 5 的倍数，它们一定可以提供一个因子 5。</p><p>但是，这些足够吗？刚才说了，像 25，50，75 这些 25 的倍数，可以提供两个因子 5，那么我们再计算出 <code>125!</code> 中有 125 &#x2F; 25 &#x3D; 5 个 25 的倍数，它们每人可以额外再提供一个因子 5。</p><p>够了吗？我们发现 125 &#x3D; 5 x 5 x 5，像 125，250 这些 125 的倍数，可以提供 3 个因子 5，那么我们还得再计算出 <code>125!</code> 中有 125 &#x2F; 125 &#x3D; 1 个 125 的倍数，它还可以额外再提供一个因子 5。</p><p>这下应该够了，<code>125!</code> 最多可以分解出 25 + 5 + 1 &#x3D; 31 个因子 5，也就是说阶乘结果的末尾有 31 个 0。</p><p>理解了这个思路，就可以理解解法代码了：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">divisor</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">while</span> (divisor &lt;= n) &#123;</span><br><span class="line">            res += n / divisor;</span><br><span class="line">            divisor *= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details data-v-fb30874b="" id="div_factorial-trailing-zeroes" class="hint-container details" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1.6em 0px; padding: 1rem 0px 0px; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary data-v-fb30874b="" style="position: relative; margin: -1.5rem 0px -0.5rem; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer; display: flex; align-items: center; font-size: large;"><strong data-v-fb30874b="" style="font-weight: 600;">🥳 代码可视化动画 🥳</strong><span data-v-fb30874b="" class="font-icon icon iconfont icon-resize" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-left: auto; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-refresh" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-link" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle;"></span></summary><div data-v-fb30874b="" class="resizable" style="width: 774.091px; max-width: 100%; height: 70vh; max-height: 70vh; overflow: auto; resize: both;"><iframe data-v-fb30874b="" id="iframe_factorial-trailing-zeroes" src="https://labuladong.online/algo-visualize/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>这里 <code>divisor</code> 变量使用 long 型，因为假如 <code>n</code> 比较大，考虑 while 循环的结束条件，<code>divisor</code> 可能出现整型溢出。</p><p>上述代码可以改写地更简单一些：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> n; d / <span class="number">5</span> &gt; <span class="number">0</span>; d = d / <span class="number">5</span>) &#123;</span><br><span class="line">            res += d / <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，这道题就解决了，时间复杂度是底数为 5 的对数，也就是 <code>O(logN)</code>，我们看看下如何基于这道题的解法完成下一道题目。</p><h3 id="第二题"><a href="#第二题" class="headerlink" title="#第二题"></a><a href="https://labuladong.online/algo/frequency-interview/factorial-problems/#%E7%AC%AC%E4%BA%8C%E9%A2%98">#</a>第二题</h3><p>现在是给你一个非负整数 <code>K</code>，问你有多少个 <code>n</code>，使得 <code>n!</code> 结果末尾有 <code>K</code> 个 0。</p><p>一个直观地暴力解法就是穷举呗，因为随着 <code>n</code> 的增加，<code>n!</code> 肯定是递增的，<code>trailingZeroes(n!)</code> 肯定也是递增的，伪码逻辑如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>; n &lt; +inf; n++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (trailingZeroes(n) &lt; K) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (trailingZeroes(n) &gt; K) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (trailingZeroes(n) == K) &#123;</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><p>前文 <a href="https://labuladong.online/algo/frequency-interview/binary-search-in-action/">二分查找如何运用</a> 说过，<strong>对于这种具有单调性的函数，用 for 循环遍历，可以用二分查找进行降维打击</strong>，对吧？</p><p>搜索有多少个 <code>n</code> 满足 <code>trailingZeroes(n) == K</code>，其实就是在问，<strong>满足条件的 <code>n</code> 最小是多少，最大是多少，最大值和最小值一减，就可以算出来有多少个 <code>n</code> 满足条件了</strong>，对吧？那不就是 <a href="https://labuladong.online/algo/essential-technique/binary-search-framework/">二分查找</a> 中「搜索左侧边界」和「搜索右侧边界」这两个事儿嘛？</p><p>先不急写代码，因为二分查找需要给一个搜索区间，也就是上界和下界，上述伪码中 <code>n</code> 的下界显然是 0，但上界是 <code>+inf</code>，这个正无穷应该如何表示出来呢？</p><p>首先，数学上的正无穷肯定是无法编程表示出来的，我们一般的方法是用一个非常大的值，大到这个值一定不会被取到。比如说 int 类型的最大值 <code>INT_MAX</code>（2^31 - 1，大约 21 亿），还不够的话就 long 类型的最大值 <code>LONG_MAX</code>（2^63 - 1，这个值就大到离谱了）。</p><p>那么我怎么知道需要多大才能「一定不会被取到」呢？<strong>这就需要认真读题，看看题目给的数据范围有多大</strong>。</p><p>这道题目实际上给了限制，<code>K</code> 是在 <code>[0, 10^9]</code> 区间内的整数，也就是说，<code>trailingZeroes(n)</code> 的结果最多可以达到 <code>10^9</code>。</p><p>然后我们可以反推，当 <code>trailingZeroes(n)</code> 结果为 <code>10^9</code> 时，<code>n</code> 为多少？这个不需要你精确计算出来，你只要找到一个数 <code>hi</code>，使得 <code>trailingZeroes(hi)</code> 比 <code>10^9</code> 大，就可以把 <code>hi</code> 当做正无穷，作为搜索区间的上界。</p><p>刚才说了，<code>trailingZeroes</code> 函数是单调函数，那我们就可以猜，先算一下 <code>trailingZeroes(INT_MAX)</code> 的结果，比 <code>10^9</code> 小一些，那再用 <code>LONG_MAX</code> 算一下，远超 <code>10^9</code> 了，所以 <code>LONG_MAX</code> 可以作为搜索的上界。</p><p><strong>注意为了避免整型溢出的问题，<code>trailingZeroes</code> 函数需要把所有数据类型改成 long</strong>：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 逻辑不变，数据类型全部改成 long</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">trailingZeroes</span><span class="params">(<span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">d</span> <span class="operator">=</span> n; d / <span class="number">5</span> &gt; <span class="number">0</span>; d = d / <span class="number">5</span>) &#123;</span><br><span class="line">        res += d / <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在就明确了问题：</p><p><strong>在区间 <code>[0, LONG_MAX]</code> 中寻找满足 <code>trailingZeroes(n) == K</code> 的左侧边界和右侧边界</strong>。</p><p>根据前文 <a href="https://labuladong.online/algo/essential-technique/binary-search-framework/">二分查找算法框架</a>，可以直接把搜索左侧边界和右侧边界的框架 copy 过来：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/* 主函数 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">preimageSizeFZF</span><span class="params">(<span class="type">int</span> K)</span> &#123;</span><br><span class="line">        <span class="comment">// 左边界和右边界之差 + 1 就是答案</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(right_bound(K) - left_bound(K) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 搜索 trailingZeroes(n) == K 的左侧边界 */</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">left_bound</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>, hi = Long.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (trailingZeroes(mid) &lt; target) &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (trailingZeroes(mid) &gt; target) &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 搜索 trailingZeroes(n) == K 的右侧边界 */</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">right_bound</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>, hi = Long.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (trailingZeroes(mid) &lt; target) &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (trailingZeroes(mid) &gt; target) &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对二分查找的框架有任何疑问，建议好好复习一下前文 <a href="https://labuladong.online/algo/essential-technique/binary-search-framework/">二分查找算法框架</a>，这里就不展开了。</p><p>现在，这道题基本上就解决了，我们来分析一下它的时间复杂度吧。</p><p>时间复杂度主要是二分搜索，从数值上来说 <code>LONG_MAX</code> 是 2^63 - 1，大得离谱，但是二分搜索是对数级的复杂度，log(LONG_MAX) 是一个常数；每次二分的时候都会调用一次 <code>trailingZeroes</code> 函数，复杂度 O(logK)；所以总体的时间复杂度就是 O(logK)。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈游戏中的随机算法</title>
      <link href="/posts/56152.html"/>
      <url>/posts/56152.html</url>
      
        <content type="html"><![CDATA[<h1 id="谈谈游戏中的随机算法"><a href="#谈谈游戏中的随机算法" class="headerlink" title="谈谈游戏中的随机算法"></a>谈谈游戏中的随机算法</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/linked-list-random-node/">382. Linked List Random Nodeopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/linked-list-random-node/">382. 链表随机节点open in new window</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/shuffle-an-array/">384. Shuffle an Arrayopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/shuffle-an-array/">384. 打乱数组open in new window</a></td><td align="center">🟠</td></tr><tr><td align="center"><a href="https://leetcode.com/problems/random-pick-index/">398. Random Pick Indexopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/random-pick-index/">398. 随机数索引open in new window</a></td><td align="center">🟠</td></tr></tbody></table><p>没事儿的时候我喜欢玩玩那些经典的 2D 网页小游戏，我发现很多游戏都要涉及地图的随机生成，比如扫雷游戏中雷的位置应该是随机分布的：</p><p><img src="https://labuladong.online/algo/images/%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/1.jpg" alt="img"></p><p>再比如经典炸弹人游戏，障碍物的位置也是有一定随机性的：</p><p><img src="https://labuladong.online/algo/images/%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/2.jpg" alt="img"></p><p>这些 2D 游戏相较现在的大型 3D 游戏虽然看起来有些简陋，但依然用到很多有趣算法技巧，本文就来深入研究一下地图的随机生成算法。</p><p>2D 游戏的地图肯定可以抽象成一个二维矩阵，就拿扫雷举例吧，我们可以用下面这个类表示扫雷的棋盘：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="comment">// 大小为 m * n 的二维棋盘</span></span><br><span class="line">    <span class="comment">// 值为 true 的地方代表有雷，false 代表没有雷</span></span><br><span class="line">    <span class="type">boolean</span>[][] board;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想在棋盘中随机生成 <code>k</code> 个雷，也就是说你需要在 <code>board</code> 中生成 <code>k</code> 个不同的 <code>(x, y)</code> 坐标，且这里面 <code>x, y</code> 都是随机生成的。</p><p>对于这个需求，<strong>首先一个优化就是对二维矩阵进行「降维打击」，把二维数组转化成一维数组</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="comment">// 长度为 m * n 的一维棋盘</span></span><br><span class="line">    <span class="comment">// 值为 true 的地方代表有雷，false 代表没有雷</span></span><br><span class="line">    <span class="type">boolean</span>[] board;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将二维数组中的坐标 (x, y) 转化为一维数组中的索引</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">encode</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x * n + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将一维数组中的索引转化为二维数组中的坐标 (x, y)</span></span><br><span class="line">    <span class="type">int</span>[] decode(<span class="type">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;index / n, index % n&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们只要在 <code>[0, m * n)</code> 中选取一个随机数，就相当于在二维数组中随机选取了一个元素。</p><p>但问题是，我们现在需要随机选出 <code>k</code> 个<strong>不同的位置</strong>放雷。你可能说，那在 <code>[0, m * n)</code> 中选出来 <code>k</code> 个随机数不就行了？</p><p>是的，但实际操作起来有些麻烦，因为你很难保证随机数不重复。如果出现重复的随机数，你就得再随机选一次，直到找到 <code>k</code> 个不同的随机数。</p><p>如果 <code>k</code> 比较小 <code>m * n</code> 比较大，那出现重复随机数的概率还比较低，但如果 <code>k</code> 和 <code>m * n</code> 的大小接近，那么出现重复随机数的概率非常高，算法的效率就会大幅下降。</p><p>那么，我们有没有更好的办法能够在线性的时间复杂度解决这个问题？其实是有的，而且有很多种解决方案。</p><p>🌟</p><hr><p>🌟</p><h3 id="洗牌算法"><a href="#洗牌算法" class="headerlink" title="#洗牌算法"></a><a href="https://labuladong.online/algo/frequency-interview/random-algorithm/#%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95">#</a>洗牌算法</h3><p><strong>第一个解决方案，我们可以换个思路，避开「在数组中随机选择 <code>k</code> 个元素」这个问题，把问题转化成「如何随机打乱一个数组」</strong>。</p><p>现在想随机初始化 <code>k</code> 颗雷的位置，你可以先把这 <code>k</code> 颗雷放在 <code>board</code> 开头，然后把 <code>board</code> 数组随机打乱，这样雷不就随机分布到 <code>board</code> 数组的各个地方了吗？</p><p>洗牌算法，或者叫随机乱置算法就是专门解决这个问题的，我们可以看下力扣第 384 题「<a href="https://leetcode.cn/problems/shuffle-an-array/">打乱数组open in new window</a>」：</p><details class="hint-container details" open="" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1rem 0px; padding: 1.5rem; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary style="position: relative; margin: -1.5rem -1.5rem 0.5em; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer;"><strong style="font-weight: 600;">384. 打乱数组</strong>&nbsp;|<span>&nbsp;</span><a target="_blank" href="https://leetcode.cn/problems/shuffle-an-array/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">力扣<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|<span>&nbsp;</span><a target="_blank" href="https://leetcode.com/problems/shuffle-an-array/" rel="noopener noreferrer" style="color: var(--vp-tc); font-weight: 500; text-decoration: none; overflow-wrap: break-word;">LeetCode<span>&nbsp;</span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only" style="position: absolute; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; border-width: 0px; user-select: none;">open in new window</span></span></a><span>&nbsp;</span>|</summary><div><p style="line-height: 1.6; overflow-wrap: break-word;">给你一个整数数组<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">nums</code><span>&nbsp;</span>，设计算法来打乱一个没有重复元素的数组。打乱后，数组的所有排列应该是&nbsp;<strong style="font-weight: 600;">等可能</strong>&nbsp;的。</p><p style="line-height: 1.6; overflow-wrap: break-word;">实现<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">Solution</code><span>&nbsp;</span>class:</p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">Solution(int[] nums)</code><span>&nbsp;</span>使用整数数组<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">nums</code><span>&nbsp;</span>初始化对象</li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">int[] reset()</code><span>&nbsp;</span>重设数组到它的初始状态并返回</li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">int[] shuffle()</code><span>&nbsp;</span>返回数组随机打乱后的结果</li></ul><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">示例 1：</strong></p><pre style="direction: ltr; overflow: auto; margin: 0.85rem 0px; padding: 1rem; border-radius: 6px; line-height: 1.375;"><strong style="font-weight: 600;">输入</strong>["Solution", "shuffle", "reset", "shuffle"][[[1, 2, 3]], [], [], []]<strong style="font-weight: 600;">输出</strong>[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]<p><strong style="font-weight: 600;">解释</strong><br>Solution solution &#x3D; new Solution([1, 2, 3]);<br>solution.shuffle();    &#x2F;&#x2F; 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。例如，返回 [3, 1, 2]<br>solution.reset();      &#x2F;&#x2F; 重设数组到它的初始状态 [1, 2, 3] 。返回 [1, 2, 3]<br>solution.shuffle();    &#x2F;&#x2F; 随机返回数组 [1, 2, 3] 打乱后的结果。例如，返回 [1, 3, 2]<br></pre><p style="line-height: 1.6; overflow-wrap: break-word;"><strong style="font-weight: 600;">提示：</strong></p><ul style="line-height: 1.6; overflow-wrap: break-word; padding-inline-start: 1.2em;"><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">1 &lt;= nums.length &lt;= 50</code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">-10<sup>6</sup><span>&nbsp;</span>&lt;= nums[i] &lt;= 10<sup>6</sup></code></li><li><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">nums</code><span>&nbsp;</span>中的所有元素都是<span>&nbsp;</span><strong style="font-weight: 600;">唯一的</strong></li><li>最多可以调用<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">10<sup>4</sup></code><span>&nbsp;</span>次<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">reset</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="margin: 0px; padding: 0.2rem 0.4rem; border-radius: 5px; background: var(--detail-code-bg-color); font-size: 0.85em; overflow-wrap: break-word; font-family: var(--font-family-mono); transition: background var(--color-transition),color var(--color-transition);">shuffle</code></li></ul></div></details></p><p>这个 <code>shuffle</code> 函数是算法的关键，直接看解法代码吧：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Solution</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reset() &#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 洗牌算法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] shuffle() &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] copy =  Arrays.copyOf(nums, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 生成一个 [i, n-1] 区间内的随机数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> i + rand.nextInt(n - i);</span><br><span class="line">            <span class="comment">// 交换 nums[i] 和 nums[r]</span></span><br><span class="line">            swap(copy, i, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>洗牌算法的时间复杂度是 O(N)，而且逻辑很简单，关键在于让你证明为什么这样做是正确的。排序算法的结果是唯一可以很容易检验的，但随机乱置算法不一样，乱可以有很多种，你怎么能证明你的算法是「真的乱」呢？</p><p><strong>分析洗牌算法正确性的准则：产生的结果必须有 <code>n!</code> 种可能</strong>。这个很好解释，因为一个长度为 <code>n</code> 的数组的全排列就有 <code>n!</code> 种，也就是说打乱结果总共有 <code>n!</code> 种。算法必须能够反映这个事实，才是正确的。</p><p>有了这个原则再看代码应该就容易理解了：</p><p>对于 <code>nums[0]</code>，我们把它随机换到了索引 <code>[0, n)</code> 上，共有 <code>n</code> 种可能性；</p><p>对于 <code>nums[1]</code>，我们把它随机换到了索引 <code>[1, n)</code> 上，共有 <code>n - 1</code> 种可能性；</p><p>对于 <code>nums[2]</code>，我们把它随机换到了索引 <code>[2, n)</code> 上，共有 <code>n - 2</code> 种可能性；</p><p>以此类推，该算法可以生成 <code>n!</code> 种可能的结果，所以这个算法是正确的，能够保证随机性。</p><h3 id="水塘抽样算法"><a href="#水塘抽样算法" class="headerlink" title="#水塘抽样算法"></a><a href="https://labuladong.online/algo/frequency-interview/random-algorithm/#%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A0%B7%E7%AE%97%E6%B3%95">#</a>水塘抽样算法</h3><p>学会了洗牌算法，扫雷游戏的随机初始化问题就解决了。不过别忘了，洗牌算法只是一个取巧方案，我们还是得面对「在若干元素中随机选择 <code>k</code> 个元素」这个终极问题。</p><p>要知道洗牌算法能够生效的前提是你使用数组这种数据结构，如果让你在一条链表中随机选择 <code>k</code> 个元素，肯定不能再用洗牌算法来蒙混过关了。</p><p>再比如，假设我们的扫雷游戏中棋盘的长和宽非常大，已经不能在内存中装下一个大小为 <code>m * n</code> 的 <code>board</code> 数组了，我们只能维护一个大小为 <code>k</code> 的数组记录雷的位置：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    <span class="comment">// 棋盘的行数和列数（非常大）</span></span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="comment">// 长度为 k 的数组，记录 k 个雷的一维索引</span></span><br><span class="line">    <span class="type">int</span>[] mines;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将二维数组中的坐标 (x, y) 转化为一维数组中的索引</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">encode</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x * n + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将一维数组中的索引转化为二维数组中的坐标 (x, y)</span></span><br><span class="line">    <span class="type">int</span>[] decode(<span class="type">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;index / n, index % n&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，我们必须想办法在 <code>[0, m*n)</code> 中随机选取 <code>k</code> 个不同的数字了。</p><p><strong>这就是常见的随机抽样场景，常用的解法是水塘抽样算法（Reservoir Sampling）</strong>。水塘抽样算法是一种随机概率算法，会者不难，难者不会。</p><p>我第一次见到这个算法问题是谷歌的一道算法题：给你一个<strong>未知长度</strong>的单链表，请你设计一个算法，<strong>只能遍历一次</strong>，随机地返回链表中的一个节点。力扣第 382 题「<a href="https://leetcode.cn/problems/linked-list-random-node/">链表随机节点open in new window</a>」也是类似的问题。</p><p>这里说的随机是均匀随机（uniform random），也就是说，如果有 <code>n</code> 个元素，每个元素被选中的概率都是 <code>1/n</code>，不可以有统计意义上的偏差。</p><p>一般的想法就是，我先遍历一遍链表，得到链表的总长度 <code>n</code>，再生成一个 <code>[0,n-1)</code> 之间的随机数为索引，然后找到索引对应的节点。但这不符合只能遍历一次链表的要求。</p><p>这个问题的难点在于随机选择是「动态」的，比如说你现在你已经遍历了 5 个元素，你已经随机选取了其中的某个元素 <code>a</code> 作为结果，但是现在再给你一个新元素 <code>b</code>，你应该留着 <code>a</code> 还是将 <code>b</code> 作为结果呢？以什么逻辑做出的选择，才能保证你的选择方法在概率上是公平的呢？</p><p><strong>先说结论，当你遇到第 <code>i</code> 个元素时，应该有 <code>1/i</code> 的概率选择该元素，<code>1 - 1/i</code> 的概率保持原有的选择</strong>。看代码容易理解这个思路：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 返回链表中一个随机节点的值 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRandom</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// while 循环遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="comment">// 生成一个 [0, i) 之间的整数</span></span><br><span class="line">        <span class="comment">// 这个整数等于 0 的概率就是 1/i</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == r.nextInt(i)) &#123;</span><br><span class="line">            res = p.val;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于概率算法，代码往往都是很浅显的，但是这种问题的关键在于证明，你的算法为什么是对的？为什么每次以 <code>1/i</code> 的概率更新结果就可以保证结果是平均随机的？</p><p>我们来证明一下，假设总共有 <code>n</code> 个元素，我们要的随机性无非就是每个元素被选择的概率都是 <code>1/n</code> 对吧，那么对于第 <code>i</code> 个元素，它被选择的概率就是：</p><p><img src="https://labuladong.online/algo/images/%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A0%B7/formula1.png" alt="img"></p><p>第 <code>i</code> 个元素被选择的概率是 <code>1/i</code>，在第 <code>i+1</code> 次不被替换的概率是 <code>1 - 1/(i+1)</code>，在第 <code>i+2</code> 次不被替换的概率是 <code>1 - 1/(i+2)</code>，以此类推，相乘的结果是第 <code>i</code> 个元素最终被选中的概率，也就是 <code>1/n</code>。因此，该算法的逻辑是正确的。</p><p><strong>同理，如果要在单链表中随机选择 <code>k</code> 个数，只要在第 <code>i</code> 个元素处以 <code>k/i</code> 的概率选择该元素，以 <code>1 - k/i</code> 的概率保持原有选择即可</strong>。代码如下：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 返回链表中 k 个随机节点的值 */</span></span><br><span class="line"><span class="type">int</span>[] getRandom(ListNode head, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前 k 个元素先默认选上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k &amp;&amp; p != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">        res[i] = p.val;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k;</span><br><span class="line">    <span class="comment">// while 循环遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="comment">// 生成一个 [0, i) 之间的整数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> r.nextInt(i);</span><br><span class="line">        <span class="comment">// 这个整数小于 k 的概率就是 k/i</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; k) &#123;</span><br><span class="line">            res[j] = p.val;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个思路可以解决力扣第 398 题「<a href="https://leetcode.cn/problems/random-pick-index/">随机数索引open in new window</a>」。对于算法正确性的数学证明，和上面区别不大：</p><p><img src="https://labuladong.online/algo/images/%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A0%B7/formula2.png" alt="img"></p><p>虽然每次更新选择的概率增大了 <code>k</code> 倍，但是选到具体第 <code>i</code> 个元素的概率还是要乘 <code>1/k</code>，也就回到了上一个推导。</p><p>类似的，回到扫雷游戏的随机初始化问题，我们可以写一个这样的 <code>sample</code> 抽样函数：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在区间 [lo, hi) 中随机抽取 k 个数字</span></span><br><span class="line"><span class="type">int</span>[] sample(<span class="type">int</span> lo, <span class="type">int</span> hi, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前 k 个元素先默认选上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        res[i] = lo + i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k;</span><br><span class="line">    <span class="comment">// while 循环遍历数字区间</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; hi - lo) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="comment">// 生成一个 [0, i) 之间的整数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> r.nextInt(i);</span><br><span class="line">        <span class="comment">// 这个整数小于 k 的概率就是 k/i</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; k) &#123;</span><br><span class="line">            res[j] = lo + i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数能够在一定的区间内随机选择 <code>k</code> 个数字，确保抽样结果是均匀随机的且只需要 O(N) 的时间复杂度。</p><h3 id="蒙特卡洛验证法"><a href="#蒙特卡洛验证法" class="headerlink" title="#蒙特卡洛验证法"></a><a href="https://labuladong.online/algo/frequency-interview/random-algorithm/#%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E9%AA%8C%E8%AF%81%E6%B3%95">#</a>蒙特卡洛验证法</h3><p>上面讲到的洗牌算法和水塘抽样算法都属于随机概率算法，虽然从数学上推导上可以证明算法的思路是正确的，但如果你笔误写出 bug，就会导致概率上的不均等。更神奇的是，力扣的判题机制能够检测出这种概率错误。</p><p>那么最后我就来介绍一种方法检测随机算法的正确性：蒙特卡洛方法。我猜测力扣的判题系统也是利用这个方法来判断随机算法的正确性的。</p><p>记得高中有道数学题：往一个正方形里面随机打点，这个正方形里紧贴着一个圆，告诉你打点的总数和落在圆里的点的数量，让你计算圆周率。</p><p><img src="https://labuladong.online/algo/images/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/4.png" alt="img"></p><p>这其实就是利用了蒙特卡罗方法：当打的点足够多的时候，点的数量就可以近似代表图形的面积。结合面积公式，可以很容易通过正方形和圆中点的数量比值推出圆周率的。</p><p>当然，打的点越多，算出的圆周率越准确，充分体现了大力出奇迹的道理。</p><p>比如，我们可以这样检验水塘抽样算法 <code>sample</code> 函数的正确性：</p><p>java 🟢cpp 🤖python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 在 [12, 22) 中随机选 3 个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">12</span>, hi = <span class="number">22</span>, k = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 记录每个元素被选中的次数</span></span><br><span class="line">    <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[hi - lo];</span><br><span class="line">    <span class="comment">// 重复 10 万次</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = sample(lo, hi, k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> elem : res) &#123;</span><br><span class="line">            <span class="comment">// 对随机选取的元素进行记录</span></span><br><span class="line">            count[elem - lo]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(count));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的输出如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">300821</span>, <span class="number">299598</span>, <span class="number">299792</span>, <span class="number">299198</span>, <span class="number">299510</span>, <span class="number">300789</span>, <span class="number">300022</span>, <span class="number">300326</span>, <span class="number">299362</span>, <span class="number">300582</span>]</span><br></pre></td></tr></table></figure><p>当然你可以做更细致的检查，不过粗略看看，各个元素被选中的次数大致是相同的，这个算法实现的应该没啥问题。</p><p>对于洗牌算法中的 <code>shuffle</code> 函数也可以采取类似的验证方法，我们可以跟踪某一个元素 <code>x</code> 被打乱后的索引位置，如果 <code>x</code> 落在各个索引的次数基本相同，则说明算法正确，你可以自己尝试实现，我就不贴代码验证了。</p><h3 id="拓展延伸"><a href="#拓展延伸" class="headerlink" title="#拓展延伸"></a><a href="https://labuladong.online/algo/frequency-interview/random-algorithm/#%E6%8B%93%E5%B1%95%E5%BB%B6%E4%BC%B8">#</a>拓展延伸</h3><p>到这里，常见的随机算法就讲完了，简单总结下吧。</p><p>洗牌算法主要用于打乱数组，比如我们在 <a href="https://labuladong.online/algo/practice-in-action/quick-sort/">快速排序详解及运用</a> 中就用到了洗牌算法保证快速排序的效率。</p><p>水塘抽样算法的运用更加广泛，可以在序列中随机选择若干元素，且能保证每个元素被选中的概率均等。</p><p>对于这些随机概率算法，我们可以用蒙特卡洛方法检验其正确性。</p><p>最后留几个拓展题目：</p><p>1、本文开头讲到了将二维数组坐标 <code>(x, y)</code> 转化成一维数组索引的技巧，那么你是否有办法把三维坐标 <code>(x, y, z)</code> 转化成一维数组的索引呢？</p><p>2、如何对带有权重的样本进行加权随机抽取？比如给你一个数组 <code>w</code>，每个元素 <code>w[i]</code> 代表权重，请你写一个算法，按照权重随机抽取索引。比如 <code>w = [1,99]</code>，算法抽到索引 0 的概率是 1%，抽到索引 1 的概率是 99%，答案见 <a href="https://labuladong.online/algo/frequency-interview/random-pick-with-weight/">我的这篇文章</a>。</p><p>3、实现一个生成器类，构造函数传入一个很长的数组，请你实现 <code>randomGet</code> 方法，每次调用随机返回数组中的一个元素，多次调用不能重复返回相同索引的元素。要求不能对该数组进行任何形式的修改，且操作的时间复杂度是 O(1)，答案见 <a href="https://labuladong.online/algo/data-structure/random-set/">我的这篇文章</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何高效进行模幂运算</title>
      <link href="/posts/42555.html"/>
      <url>/posts/42555.html</url>
      
        <content type="html"><![CDATA[<h1 id="如何高效进行模幂运算"><a href="#如何高效进行模幂运算" class="headerlink" title="如何高效进行模幂运算"></a>如何高效进行模幂运算</h1><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p><table><thead><tr><th align="center">LeetCode</th><th align="center">力扣</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.com/problems/super-pow/">372. Super Powopen in new window</a></td><td align="center"><a href="https://leetcode.cn/problems/super-pow/">372. 超级次方open in new window</a></td><td align="center">🟠</td></tr></tbody></table><p>今天来聊一道与数学运算有关的题目，力扣第 372 题「<a href="https://leetcode.cn/problems/super-pow/">超级次方open in new window</a>」，让你进行巨大的幂运算，然后求余数。</p><p>java 🤖cpp 🟢python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：java 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span></span><br><span class="line"><span class="comment">// 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 cpp 代码对比查看。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">superPow</span><span class="params">(<span class="type">int</span> a, List&lt;Integer&gt; b)</span>;</span><br></pre></td></tr></table></figure><p><strong>要求你的算法返回幂运算 <code>a^b</code> 的计算结果与 1337 取模（mod，也就是余数）后的结果</strong>。就是你先得计算幂 <code>a^b</code>，但是这个 <code>b</code> 会非常大，所以 <code>b</code> 是用数组的形式表示的。</p><p>这个算法其实就是广泛应用于离散数学的模幂算法，至于为什么要对 1337 求模我们不管，单就这道题可以有三个难点：</p><p><strong>一是如何处理用数组表示的指数</strong>，现在 <code>b</code> 是一个数组，也就是说 <code>b</code> 可以非常大，没办法直接转成整型，否则可能溢出。你怎么把这个数组作为指数，进行运算呢？</p><p><strong>二是如何得到求模之后的结果</strong>？按道理，起码应该先把幂运算结果算出来，然后做 <code>% 1337</code> 这个运算。但问题是，指数运算你懂得，真实结果肯定会大得吓人，也就是说，算出来真实结果也没办法表示，早都溢出报错了。</p><p><strong>三是如何高效进行幂运算</strong>，进行幂运算也是有算法技巧的，如果你不了解这个算法，后文会讲解。</p><p>那么对于这几个问题，我们分开思考，逐个击破。</p><p>🌟</p><hr><p>🌟</p><h3 id="如何处理数组指数"><a href="#如何处理数组指数" class="headerlink" title="#如何处理数组指数"></a><a href="https://labuladong.online/algo/frequency-interview/quick-power/#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%95%B0%E7%BB%84%E6%8C%87%E6%95%B0">#</a>如何处理数组指数</h3><p><strong>首先明确问题</strong>：现在 <code>b</code> 是一个数组，不能表示成整型，而且数组的特点是随机访问，删除最后一个元素比较高效。</p><p>不考虑求模的要求，以 <code>b = [1,5,6,4]</code> 来举例，结合指数运算的法则，我们可以发现这样的一个规律：</p><p><img src="https://labuladong.online/algo/images/superPower/formula1.png" alt="img"></p><p>看到这，我们的老读者肯定已经敏感地意识到了，这就是递归的标志呀！因为问题的规模缩小了：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="built_in">superPow</span>(a, [<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>])</span><br><span class="line">=&gt;  <span class="built_in">superPow</span>(a, [<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br></pre></td></tr></table></figure><p>那么，发现了这个规律，我们可以先简单翻译出代码框架：</p><p>java 🤖cpp 🟢python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：java 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span></span><br><span class="line"><span class="comment">// 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 cpp 代码对比查看。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 a 的 k 次方的结果</span></span><br><span class="line"><span class="comment">// 后文我们会手动实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mypow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">superPow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>[] b)</span> &#123;</span><br><span class="line">    <span class="comment">// 递归的 base case</span></span><br><span class="line">    <span class="keyword">if</span> (b.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 取出最后一个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> b[b.length - <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span>[] newArr = Arrays.copyOfRange(b, <span class="number">0</span>, b.length - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将原问题化简，缩小规模递归求解</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">part1</span> <span class="operator">=</span> mypow(a, last);</span><br><span class="line">    <span class="type">int</span> <span class="variable">part2</span> <span class="operator">=</span> mypow(superPow(a, newArr), <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 合并出结果</span></span><br><span class="line">    <span class="keyword">return</span> part1 * part2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，应该都不难理解吧！我们已经解决了 <code>b</code> 是一个数组的问题，现在来看看如何处理 mod，避免结果太大而导致的整型溢出。</p><h3 id="如何处理-mod-运算"><a href="#如何处理-mod-运算" class="headerlink" title="#如何处理 mod 运算"></a><a href="https://labuladong.online/algo/frequency-interview/quick-power/#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-mod-%E8%BF%90%E7%AE%97">#</a>如何处理 mod 运算</h3><p><strong>首先明确问题</strong>：由于计算机的编码方式，形如 <code>(a * b) % base</code> 这样的运算，乘法的结果可能导致溢出，我们希望找到一种技巧，能够化简这种表达式，避免溢出同时得到结果。</p><p>比如在二分查找中，我们求中点索引时用 <code>(l+r)/2</code> 转化成 <code>l+(r-l)/2</code>，避免溢出的同时得到正确的结果。</p><p>那么，说一个关于模运算的技巧吧，毕竟模运算在算法中比较常见：</p><p><strong><code>(a \* b) % k = (a % k) \* (b % k) % k</code></strong></p><p>证明很简单，假设：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = Ak + B；b = Ck + D</span><br></pre></td></tr></table></figure><p>其中 <code>A,B,C,D</code> 是任意常数，那么：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ab = ACk^2 + ADk + BCk +BD</span><br><span class="line">ab % k = BD % k</span><br></pre></td></tr></table></figure><p>又因为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a % k = B；b % k = D</span><br></pre></td></tr></table></figure><p>所以：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(a % k)(b % k) % k = BD % k</span><br></pre></td></tr></table></figure><p>综上，就可以得到我们化简求模的等式了。</p><p><strong>换句话说，对乘法的结果求模，等价于先对每个因子都求模，然后对因子相乘的结果再求模</strong>。</p><p>那么扩展到这道题，求一个数的幂不就是对这个数连乘么？所以说只要简单扩展刚才的思路，即可给幂运算求模：</p><p>java 🤖cpp 🟢python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：java 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span></span><br><span class="line"><span class="comment">// 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 cpp 代码对比查看。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">1337</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算 a 的 k 次方然后与 base 求模的结果</span></span><br><span class="line">    <span class="comment">// 使用快速幂算法</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">mypow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 对因子求模</span></span><br><span class="line">        a %= base;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">_</span> <span class="operator">=</span> <span class="number">0</span>; _ &lt; k; _++) &#123;</span><br><span class="line">            <span class="comment">// 这里有乘法，是潜在的溢出点</span></span><br><span class="line">            res *= a;</span><br><span class="line">            <span class="comment">// 对乘法结果求模</span></span><br><span class="line">            res %= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">superPow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>[] b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (b.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> b[b.length - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] newB = <span class="keyword">new</span> <span class="title class_">int</span>[b.length - <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(b, <span class="number">0</span>, newB, <span class="number">0</span>, b.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">part1</span> <span class="operator">=</span> mypow(a, last);</span><br><span class="line">        <span class="type">int</span> <span class="variable">part2</span> <span class="operator">=</span> mypow(superPow(a, newB), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每次乘法都要求模</span></span><br><span class="line">        <span class="keyword">return</span> (part1 * part2) % base;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details data-v-fb30874b="" id="div_super-pow" class="hint-container details" style="position: relative; transition: background var(--vp-tt),color var(--vp-tt); display: block; margin: 1.6em 0px; padding: 1rem 0px 0px; border-radius: 0.5rem; background: var(--detail-bg-color); color: var(--detail-text-color);"><summary data-v-fb30874b="" style="position: relative; margin: -1.5rem 0px -0.5rem; padding-block: 1.5rem; padding-inline: 4rem 1.5rem; list-style: none; cursor: pointer; display: flex; align-items: center; font-size: large;"><strong data-v-fb30874b="" style="font-weight: 600;">🌈 代码可视化动画 🌈</strong><span data-v-fb30874b="" class="font-icon icon iconfont icon-resize" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-left: auto; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-refresh" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle; margin-right: 10px;"></span><span data-v-fb30874b="" class="font-icon icon iconfont icon-link" style="display: inline-block; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; font-family: iconfont !important; vertical-align: middle;"></span></summary><div data-v-fb30874b="" class="resizable" style="width: 774.091px; max-width: 100%; height: 70vh; max-height: 70vh; overflow: auto; resize: both;"><iframe data-v-fb30874b="" id="iframe_super-pow" src="https://labuladong.online/algo-visualize/" width="100%" height="100%" loading="lazy" scrolling="auto" frameborder="0" style="overflow: auto;"></iframe></div></details><p>你看，<strong>先对因子 <code>a</code> 求模，然后每次都对乘法结果 <code>res</code> 求模</strong>，这样可以保证 <code>res *= a</code> 这句代码执行时两个因子都是小于 <code>base</code> 的，也就一定不会造成溢出，同时结果也是正确的。</p><p>至此，这个问题就已经完全解决了，已经可以通过 LeetCode 的判题系统了。</p><p>但是有的读者可能会问，这个求幂的算法就这么简单吗，直接一个 for 循环累乘就行了？复杂度会不会比较高，有没有更高效地算法呢？</p><p>有更高效地算法的，但是单就这道题来说，已经足够了。</p><p>因为你想想，调用 <code>mypow</code> 函数传入的 <code>k</code> 最多有多大？<code>k</code> 不过是 <code>b</code> 数组中的一个数，也就是在 0 到 9 之间，所以可以说这里每次调用 <code>mypow</code> 的时间复杂度就是 O(1)。整个算法的时间复杂度是 O(N)，N 为 <code>b</code> 的长度。</p><p>但是既然说到幂运算了，不妨顺带说一下如何高效计算幂运算吧。</p><h3 id="如何高效求幂"><a href="#如何高效求幂" class="headerlink" title="#如何高效求幂"></a><a href="https://labuladong.online/algo/frequency-interview/quick-power/#%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E6%B1%82%E5%B9%82">#</a>如何高效求幂</h3><p>快速求幂的算法不止一个，就说一个我们应该掌握的基本思路吧。利用幂运算的性质，我们可以写出这样一个递归式：</p><p><img src="https://labuladong.online/algo/images/superPower/formula2.png" alt="img"></p><p>这个思想肯定比直接用 for 循环求幂要高效，因为有机会直接把问题规模（<code>b</code> 的大小）直接减小一半，该算法的复杂度肯定是 log 级了。</p><p>那么就可以修改之前的 <code>mypow</code> 函数，翻译这个递归公式，再加上求模的运算：</p><p>java 🤖cpp 🟢python 🤖go 🤖javascript 🤖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：java 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span></span><br><span class="line"><span class="comment">// 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 cpp 代码对比查看。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">mypow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">1337</span>;</span><br><span class="line">    a %= base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// k 是奇数</span></span><br><span class="line">        <span class="keyword">return</span> (a * mypow(a, k - <span class="number">1</span>)) % base;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// k 是偶数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sub</span> <span class="operator">=</span> mypow(a, k / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> (sub * sub) % base;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然对于题目，这个优化没有啥特别明显的效率提升，但是这个求幂算法已经升级了，以后如果别人让你写幂算法，起码要写出这个算法。</p><p>至此，Super Pow 就算完全解决了，包括了递归思想以及处理模运算、幂运算的技巧，可以说这个题目还是挺有意思的，你有什么有趣的题目，不妨留言分享一下。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git使用指南</title>
      <link href="/posts/undefined.html"/>
      <url>/posts/undefined.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h1><p><strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p><p><strong>工作原理 &#x2F; 流程</strong></p><p><img src="https://pic2.zhimg.com/80/v2-3bc9d5f2c49a713c776e69676d7d56c5_1440w.webp" alt="git流程图"></p><h2 id="Git下载与安装"><a href="#Git下载与安装" class="headerlink" title="Git下载与安装"></a>Git下载与安装</h2><p>具体安装教程已有详细博客，不多说，上链接</p><p>[Git下载与安装_pingcode的博客-CSDN博客_git](<a href="https://blog.csdn.net/qq_41521682/article/details/122764915#:~:text=%E7%AC%AC%E4%B8%80%E6%AD%A5">https://blog.csdn.net/qq_41521682/article/details/122764915#:~:text=第一步</a> 下载git (找到自己需要的版本) 第二步 下载 完点击 安装 包进入使用许可声明界面,这里我是选择装在D盘，大家如果嫌麻烦就默认 安装 在C盘 第四步 点击Next进入选择 安装 组件界面 上图红框内的选项是默认勾选的，建议不要动。)</p><h2 id="Git初始配置"><a href="#Git初始配置" class="headerlink" title="Git初始配置"></a>Git初始配置</h2><p>​</p><p>​安装完成后，需要对软件进行配置，右键点Git Bash Here, 输入以下指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;你的用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure><p>​解释一下，用户名和邮箱起标识作用，git命令行和Linux指令很相似，<code>--</code>后面加完整名称的单词做参数，<code>-</code>后面则是单词简写</p><h3 id="扩展-git配置的优先级"><a href="#扩展-git配置的优先级" class="headerlink" title="扩展 git配置的优先级"></a>扩展 git配置的优先级</h3><p>​<code>-- global</code> 是指git配置的位置，位置所管辖的范围约小，配置生效的优先级越高，优先级越高的配置会覆盖掉优先级较低的配置，优先生效<img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202301311730216.png" alt="image-20230131170032912"></p><p>​git的配置基于配置文件，有如下四个配置范围</p><p><img src="https://img.panyanbin.com/img/2021/06/30/1624986904-3edb6dce65621f97c0e649eee007e1e5.png" alt="image-20230131164336991"></p><p>​常用的有三个（<code>local</code>、<code>global</code>、<code>system</code>），worktree基本不使用所以不多说。</p><ul><li><strong>system系统级</strong></li></ul><p>​系统级配置文件含有系统里每位用户及他们所拥有的仓库的配置值。其位置为git的安装目录下的<code>/etc/gitconfig</code>，即如果git的安装目录为<code>D:\Git</code>，则配置文件地址为<code>D:\Git\etc\gitconfig</code>。</p><p><strong>优先度最低，其配置值可被全局级配置和本地级配置的值覆盖</strong>。一般我们很少会使用系统级的配置。</p><ul><li><strong>global全局级</strong></li></ul><p>​全局级配置文件包含当前系统用户的拥有的仓库配置值，每个系统用户的全局级配置相互隔离。全局级别的配置默认保存在当前系统用户的主目录下的 .gitconfig 文件内。Windows通常保存在<code>C:\Users\xxxx\.gitconfig</code>，Linux为<code>/home/xxx/.gitconfig</code>。</p><p><strong>优先度比系统级高，可覆盖系统级的配置值</strong>。全局级的配置平时使用得比较多，比如设置账号和邮箱：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name panyanbin</span><br><span class="line">git config --global user.email me@panyanbin.com</span><br></pre></td></tr></table></figure><ul><li><strong>local本地级</strong></li></ul><p>​本地级别的配置保存在当前仓库下面的 <code>.git\config</code> 文件内，通常 .git 文件夹是隐藏的，Window要在文件管理器的文件夹选项中打开显示隐藏文件夹才可以看到。这里的配置仅对当前仓库有效，不影响其他的仓库。</p><p><strong>优先级别最高，如果全局级别或系统级别的配置里出现了同一配置项，则以本地级别配置内容为准</strong></p><p>​了解这些后，你就可以进行不同优先级和生效范围的配置了</p><h2 id="Git-创建版本库"><a href="#Git-创建版本库" class="headerlink" title="Git 创建版本库"></a>Git 创建版本库</h2><p>​<code>版本库（repository）</code>,你可以理解为一个目录，它存储了所有你在不同时间上对<code>工作目录</code>中文件的更改，也就是某个时间点上你所提交的<code>工作目录</code>中文件的状态，这个文件状态我们称之为<code>版本</code> ， 以便你能任意在多个版本间跳转（初学者看会有点抽象）</p><p>​创建一个仓库很简单，只要先创建一个目录，这个目录就是你的<code>工作目录</code>（也称<code>工作区</code>），然后在目录中 Git Bash Here,输入指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202301311722914.png" alt="image-20230131172231949"></p><p>此时，目录中会生成一个<code>.git</code>文件夹，这个就是<code>版本库</code>，不要随意乱动，以免损坏</p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202301311724121.png" alt="image-20230131172436286"></p><p>​git记录版本是通过提交（<code>commit</code>）实现的，但并不是每次对文件修改就直接提交这些修改，因为提交后版本就无法删除的永远存在于版本库中了（除非你删掉仓库或者损坏.git文件），git在对文件从修改到提交的过程中增加了一个叫<code>暂存区</code>的概念，为提交的提供了容错的空间</p><p>​<img src="https://www.runoob.com/wp-content/uploads/2015/02/1352126739_7909.jpg"></p><p>​我们来理解下 Git 工作区、暂存区和版本库概念</p><ul><li><strong>工作区：</strong>就是你在电脑里能看到的目录。</li><li><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）。</li><li><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库</li></ul><p>​提交一个版本，需要首先在<code>工作区</code>中对文件进行修改，然后再添加到<code>暂存区</code>，最后提交到<code>版本库</code>,初学者理解这个流程，方便记忆指令（其实用多了自然也就记住了）</p><p>​下面我们按照这个流程呢来学习git的常用指令</p><h2 id="Git基本操作指令"><a href="#Git基本操作指令" class="headerlink" title="Git基本操作指令"></a>Git基本操作指令</h2><ul><li>将工作目录的修改提交到暂存区（index）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//添加一个或多个文件到暂存区（index）</span><br><span class="line"></span><br><span class="line">git add [file1] [file2] .....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 添加所有文件到暂存区</span><br><span class="line"></span><br><span class="line">git add .</span><br></pre></td></tr></table></figure><p>🚧🚧🚧 暂待施工🚧🚧🚧</p><ul><li>查看暂存区情况</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java API</title>
      <link href="/posts/13796.html"/>
      <url>/posts/13796.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java-API"><a href="#Java-API" class="headerlink" title="Java API"></a>Java API</h1><h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><h3 id="流收集合"><a href="#流收集合" class="headerlink" title="流收集合"></a>流收集合</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//流转化为集合</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">stream.collect(Collectors.toList())</span><br><span class="line">stream.collect(Collectors.toSet())</span><br><span class="line">stream.collect(Collectors.toCollection(ArraysList::<span class="keyword">new</span>))</span><br><span class="line"><span class="comment">//流转化为数组</span></span><br><span class="line">stream.toArray()</span><br><span class="line">stream.toArray(<span class="type">int</span>[]::<span class="keyword">new</span>)</span><br><span class="line"><span class="comment">//聚合计算</span></span><br><span class="line">stream.collect(Collectors.maxBy())</span><br><span class="line">stream.collect(Collectors.minBy())</span><br><span class="line">stream.collect(Collectors.counting())</span><br><span class="line">stream.collect(Collectors.summingInt())</span><br><span class="line">stream.collect(Collectors.averagingInt())</span><br><span class="line"><span class="comment">//分组  分组函数  值收集器默认为List</span></span><br><span class="line">stream.collect(Collectors.groupingBy())</span><br><span class="line"><span class="comment">//分区</span></span><br><span class="line">stream.collcet(Collectors.partitionBy())</span><br><span class="line"><span class="comment">//拼接</span></span><br><span class="line">stream.collect(Collectors.joining())</span><br></pre></td></tr></table></figure><p>Java Stream API 提供了多种方法将流（Stream）转换为不同的集合类型、数组，以及进行聚合计算和复杂的数据操作。以下是一些常用的 Stream 操作的总结，包括代码示例和注释：</p><h3 id="1-流转换为集合"><a href="#1-流转换为集合" class="headerlink" title="1. 流转换为集合"></a>1. 流转换为集合</h3><ul><li><p><strong>List</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = stream.collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>将流收集到一个列表中。</p></li><li><p><strong>Set</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; set = stream.collect(Collectors.toSet());</span><br></pre></td></tr></table></figure><p>将流收集到一个集合中，自动去除重复元素。</p></li><li><p><strong>Map</strong></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Fruit&gt; fruitMap = fruits.stream()</span><br><span class="line">   .collect(Collectors.toMap(Fruit::getName, fruit -&gt; fruit));</span><br></pre></td></tr></table></figure><ul><li><p><strong>自定义集合</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Collection&lt;String&gt; collection = stream.collect(Collectors.toCollection(ArrayList::new));</span><br></pre></td></tr></table></figure><p>将流收集到一个由提供 Supplier 函数指定的集合中。</p></li></ul><h3 id="2-流转换为数组"><a href="#2-流转换为数组" class="headerlink" title="2. 流转换为数组"></a>2. 流转换为数组</h3><ul><li><p><strong>Object 数组</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object[] array = stream.toArray();</span><br></pre></td></tr></table></figure><p>将流转换为 Object 数组。</p></li><li><p><strong>特定类型数组</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int[] intArray = stream.mapToInt(String::length).toArray();</span><br></pre></td></tr></table></figure><p>将流转换为特定类型的数组，需要流的中间操作以确定数组的类型。</p></li></ul><h3 id="3-聚合计算"><a href="#3-聚合计算" class="headerlink" title="3. 聚合计算"></a>3. 聚合计算</h3><ul><li><p><strong>最大值</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; max = stream.collect(Collectors.maxBy(Comparator.naturalOrder()));</span><br></pre></td></tr></table></figure><p>找出流中的最大元素。</p></li><li><p><strong>最小值</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; min = stream.collect(Collectors.minBy(Comparator.naturalOrder()));</span><br></pre></td></tr></table></figure><p>找出流中的最小元素。</p></li><li><p><strong>计数</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long count = stream.collect(Collectors.counting());</span><br></pre></td></tr></table></figure><p>计算流中元素的数量。</p></li><li><p><strong>求和</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sum = stream.collect(Collectors.summingInt(String::length));</span><br></pre></td></tr></table></figure><p>对流中的元素进行求和，适用于数字类型的流。</p></li><li><p><strong>平均值</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double average = stream.collect(Collectors.averagingInt(String::length));</span><br></pre></td></tr></table></figure><p>计算流中元素的平均值。</p></li></ul><h3 id="4-分组"><a href="#4-分组" class="headerlink" title="4. 分组"></a>4. 分组</h3><ul><li><p>GroupingBy</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;String, List&lt;String&gt;&gt; groupedByLength = stream.collect(Collectors.groupingBy(String::length));</span><br></pre></td></tr></table></figure><p>按元素的某种属性将流分组。</p></li></ul><h3 id="5-分区"><a href="#5-分区" class="headerlink" title="5. 分区"></a>5. 分区</h3><ul><li><p>PartitionBy</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;String&gt;&gt; partitioned = stream.collect(Collectors.partitioningBy(s -&gt; s.startsWith(&quot;A&quot;)));</span><br></pre></td></tr></table></figure><p>根据谓词将流分为两部分。</p></li></ul><h3 id="6-拼接"><a href="#6-拼接" class="headerlink" title="6. 拼接"></a>6. 拼接</h3><ul><li><p>Joining</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String joinedString = stream.collect(Collectors.joining(&quot;, &quot;));</span><br></pre></td></tr></table></figure><p>将流中的元素拼接成一个字符串。</p></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>每个 <code>collect</code> 操作都会消费流，因此一个流只能进行一次终端操作，除非使用 <code>peek</code> 或者 <code>forEach</code> 进行中间操作。</li><li><code>toArray</code> 方法有几个重载版本，可以创建任何对象类型或原始类型的数组。</li><li><code>Collectors</code> 类提供了多种收集器，可以进行复杂的数据转换和聚合操作。</li><li>一些操作如 <code>groupingBy</code> 和 <code>partitioningBy</code> 可以与 <code>downstream</code> 结合使用，以对分组或分区后的流进行进一步的收集操作。</li></ul><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个字符串列表</span></span><br><span class="line">        List&lt;String&gt; words = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>, <span class="string">&quot;date&quot;</span>, <span class="string">&quot;elderberry&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// filter + forEach：过滤出长度大于4的单词，并打印出来</span></span><br><span class="line">        words.stream()</span><br><span class="line">             .filter(word -&gt; word.length() &gt; <span class="number">4</span>)</span><br><span class="line">             .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// map + collect：将所有单词转换为大写，并收集到一个新的列表中</span></span><br><span class="line">        List&lt;String&gt; uppercasedWords = words.stream()</span><br><span class="line">                                             .map(String::toUpperCase)</span><br><span class="line">                                             .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// limit + sorted：获取按字典序排序后前3个单词</span></span><br><span class="line">        List&lt;String&gt; firstThreeSorted = words.stream()</span><br><span class="line">                                             .sorted()</span><br><span class="line">                                             .limit(<span class="number">3</span>)</span><br><span class="line">                                             .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// reduce：使用 reduce 方法找到最长的单词</span></span><br><span class="line">        Optional&lt;String&gt; longestWord = words.stream()</span><br><span class="line">                                              .reduce((w1, w2) -&gt; w1.length() &gt;= w2.length() ? w1 : w2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// allMatch + anyMatch + noneMatch：检查单词长度</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">allLong</span> <span class="operator">=</span> words.stream()</span><br><span class="line">                               .allMatch(word -&gt; word.length() &gt; <span class="number">4</span>); <span class="comment">// 检查所有单词是否都大于4个字符</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">anyLong</span> <span class="operator">=</span> words.stream()</span><br><span class="line">                               .anyMatch(word -&gt; word.length() &gt; <span class="number">4</span>); <span class="comment">// 检查是否有单词大于4个字符</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">noneLong</span> <span class="operator">=</span> words.stream()</span><br><span class="line">                                .noneMatch(word -&gt; word.length() &gt; <span class="number">4</span>); <span class="comment">// 检查没有单词大于4个字符</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// count：计算单词的数量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">wordCount</span> <span class="operator">=</span> words.stream().count();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// max + min：找出最长和最短的单词</span></span><br><span class="line">        Optional&lt;String&gt; maxWord = words.stream().max(byLength());</span><br><span class="line">        Optional&lt;String&gt; minWord = words.stream().min(byLength());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// distinct：去除重复的单词</span></span><br><span class="line">        List&lt;String&gt; distinctWords = words.stream()</span><br><span class="line">                                           .distinct()</span><br><span class="line">                                           .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// parallel：创建并行流处理数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">parallelSum</span> <span class="operator">=</span> Arrays.stream(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;)</span><br><span class="line">                               .parallel()</span><br><span class="line">                               .sum();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助方法，用于按长度比较单词</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparator&lt;String&gt; <span class="title function_">byLength</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (s1, s2) -&gt; Integer.compare(s1.length(), s2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>加密安全</title>
      <link href="/posts/26365.html"/>
      <url>/posts/26365.html</url>
      
        <content type="html"><![CDATA[<h1 id="加密安全"><a href="#加密安全" class="headerlink" title="加密安全"></a>加密安全</h1><h2 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a><code>Base64</code>编码</h2><p>将<strong>二进制字节</strong>转化为<strong>文本格式</strong></p><p>将任意二进制字节数据转化为只包含 <code>A</code><del><code>Z</code>   <code>a</code></del><code>z</code>  <code>0</code>~&#96;9<code>  </code>+<code>  </code>&#x2F;<code>  </code>&#x3D;&#96; 这64个字符</p><p>原理是将3个字节的二进制数据按照<code>6bit</code>一组, 用<code>4个int整数</code>表示, 然后将int整数用索引对应到字符, 得到编码后的字符串</p><p>3个byte数据分别是<code>e4</code>、<code>b8</code>、<code>ad</code>，按<code>6bit</code>分组得到<code>39</code>、<code>0b</code>、<code>22</code>和<code>2d</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌───────────────┬───────────────┬───────────────┐</span><br><span class="line">│      e4       │      b8       │      ad       │</span><br><span class="line">└───────────────┴───────────────┴───────────────┘</span><br><span class="line">┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐</span><br><span class="line">│1│1│1│0│0│1│0│0│1│0│1│1│1│0│0│0│1│0│1│0│1│1│0│1│</span><br><span class="line">└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘</span><br><span class="line">┌───────────┬───────────┬───────────┬───────────┐</span><br><span class="line">│    39     │    0b     │    22     │    2d     │</span><br><span class="line">└───────────┴───────────┴───────────┴───────────┘</span><br></pre></td></tr></table></figure><p>字符<code>A</code><del><code>Z</code>对应索引<code>0</code></del><code>25</code>，字符<code>a</code><del><code>z</code>对应索引<code>26</code></del><code>51</code>，字符<code>0</code><del><code>9</code>对应索引<code>52</code></del><code>61</code>，最后两个索引<code>62</code>、<code>63</code>分别用字符<code>+</code>和<code>/</code>表示。</p><p>如果字节数不是3的倍数, 用 <code>=</code> 或者 <code>==</code> 补到三的倍数</p><p>例如  :</p><p>16个字节  补成 18个字节</p><p>最后会生成 24个字符(18 &#x2F; 3 * 4)</p><h2 id="哈希算法-Digest"><a href="#哈希算法-Digest" class="headerlink" title="哈希算法(Digest)"></a>哈希算法(Digest)</h2><p>常用的哈希算法有：</p><table><thead><tr><th align="left">算法</th><th align="left">输出长度（位）</th><th align="left">输出长度（字节）</th></tr></thead><tbody><tr><td align="left"><code>MD5</code></td><td align="left">128 bits</td><td align="left">16 bytes</td></tr><tr><td align="left"><code>SHA-1</code></td><td align="left">160 bits</td><td align="left">20 bytes</td></tr><tr><td align="left"><code>RipeMD-160</code></td><td align="left">160 bits</td><td align="left">20 bytes</td></tr><tr><td align="left"><code>SHA-256</code></td><td align="left">256 bits</td><td align="left">32 bytes</td></tr><tr><td align="left"><code>SHA-512</code></td><td align="left">512 bits</td><td align="left">64 bytes</td></tr></tbody></table><p>用哈希存储口令时要考虑彩虹表攻击, 通常通过加盐来加大破解难度(即便有彩虹表(数据量为m)和salt(数据量为n) 复杂度也会是O(m * n))</p><p>非安全专业不要尝试自己写哈希算法库, 直接用开源得到公众认可的库</p><h2 id="消息认证算法-MAC"><a href="#消息认证算法-MAC" class="headerlink" title="消息认证算法(MAC)"></a>消息认证算法(MAC)</h2><p><code>Hmac</code>算法就是一种基于密钥的消息认证码算法</p><p><code>Hmac</code>算法总是和某种哈希算法配合起来用的, 本质上就是把key混入摘要的算法。验证此哈希时，除了原始的输入数据，还要提供key</p><p>这里的key可以理解为盐</p><p>可以配合<code>MD5</code>、<code>SHA-1</code>等哈希算法，计算的摘要长度和原摘要算法长度相同。</p><h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>在软件开发中，常用的对称加密算法有：</p><table><thead><tr><th align="left">算法</th><th align="left">密钥长度</th><th align="left">工作模式</th><th align="left">填充模式</th></tr></thead><tbody><tr><td align="left"><code>DES</code></td><td align="left">56&#x2F;64</td><td align="left"><code>ECB/CBC/PCBC/CTR/...</code></td><td align="left"><code>NoPadding/PKCS5Padding/...</code></td></tr><tr><td align="left"><code>AES</code></td><td align="left">128&#x2F;192&#x2F;256</td><td align="left"><code>ECB/CBC/PCBC/CTR/...</code></td><td align="left"><code>NoPadding/PKCS5Padding/PKCS7Padding/...</code></td></tr><tr><td align="left"><code>IDEA</code></td><td align="left">128</td><td align="left"><code>ECB</code></td><td align="left"><code>PKCS5Padding/PKCS7Padding/...</code></td></tr></tbody></table><p><a href="https://blog.csdn.net/bandaoyu/article/details/105552003">【加密】DES加密算法中，ECB和CBC模式有什么区别？_ecb cbc-CSDN博客</a></p><p>对称加密算法决定了口令必须是固定长度，然后对明文进行分块加密。又因为安全需求，口令长度往往都是128位以上，即至少16个字符</p><p>DES算法由于密钥过短，可以在短时间内被暴力破解，所以现在已经不安全了。</p><p><code>ECB</code>模式是最简单的<code>AES</code>加密模式，它只需要一个固定长度的密钥，固定的明文会生成固定的密文，这种一对一的加密方式会导致安全性降低</p><p>更好的方式是通过<code>CBC</code>模式，它需要一个随机数作为IV参数，这样对于同一份明文，每次生成的密文都不同</p><h2 id="口令加密算法"><a href="#口令加密算法" class="headerlink" title="口令加密算法"></a>口令加密算法</h2><p><code>PBE</code>就是<code>Password Based Encryption</code>, 作用就是把用户输入的口令和一个安全随机的口令采用杂凑后计算出真正的密钥</p><p><code>PBE算法</code>并没有真正构建新的加密&#x2F;解密算法，而是对我们已经知道的对称加密算法（如DES算法）做了包装。使用PBE算法对数据做加密&#x2F;解密操作的时候，其实是使用了<code>DES</code>或者是<code>AES</code>等其它对称加密算法做了相应的操作。</p><h2 id="密钥交换算法"><a href="#密钥交换算法" class="headerlink" title="密钥交换算法"></a>密钥交换算法</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>高效搜索</title>
      <link href="/posts/43428.html"/>
      <url>/posts/43428.html</url>
      
        <content type="html"><![CDATA[<h1 id="高效搜索"><a href="#高效搜索" class="headerlink" title="高效搜索"></a>高效搜索</h1><h1 id="🕵️‍♂️高效搜索的艺术：解锁信息宝藏的秘籍🗝️"><a href="#🕵️‍♂️高效搜索的艺术：解锁信息宝藏的秘籍🗝️" class="headerlink" title="🕵️‍♂️高效搜索的艺术：解锁信息宝藏的秘籍🗝️"></a>🕵️‍♂️高效搜索的艺术：解锁信息宝藏的秘籍🗝️</h1><p>在浩瀚的信息海洋中航行，如何快速定位到你需要的宝藏？这不仅仅是一门技术，更是一种艺术。让我们一起探索如何通过高效搜索，直达知识的核心。🔍</p><h2 id="📚信息分类"><a href="#📚信息分类" class="headerlink" title="📚信息分类"></a>📚信息分类</h2><p>信息可以分为四大类：</p><ul><li>信息</li><li>学习</li><li>素材</li><li>工具</li></ul><p>掌握这些分类，有助于你更有针对性地搜索。🚀</p><h2 id="💡信息搜索技巧"><a href="#💡信息搜索技巧" class="headerlink" title="💡信息搜索技巧"></a>💡信息搜索技巧</h2><h3 id="📈信息渠道效率排名"><a href="#📈信息渠道效率排名" class="headerlink" title="📈信息渠道效率排名"></a>📈信息渠道效率排名</h3><ol><li><p><strong>谷歌</strong>：全球最大的搜索引擎，覆盖广泛，信息更新快。</p></li><li><p><strong>微信知道</strong>：中文环境下的知识问答平台，适合寻找本土化信息。</p></li><li><p><strong>长短视频平台</strong>(<code>bilibili</code>, 抖音)：直观、生动，适合获取快速资讯或娱乐信息。</p></li><li><p><strong>百度</strong>：中文互联网咨询的主要搜索引擎，资源丰富。</p></li></ol><h3 id="🔍高效搜索命令"><a href="#🔍高效搜索命令" class="headerlink" title="🔍高效搜索命令"></a>🔍高效搜索命令</h3><ul><li><code>&quot;关键词&quot;</code>：精确匹配关键词。</li><li><code>intitle:标题</code>：搜索标题中含有特定词汇的页面。</li><li><code>allintitle:标题1 标题2</code>：同时在标题中搜索多个关键词。</li><li><code>intext:&quot;文章内容&quot;</code>：查找包含特定短语的网页。</li><li><code>inurl:</code>：限定网址中包含的关键词。</li><li><code>site:</code>：限定搜索范围在特定网站内。</li><li><code>imagesize:</code>：指定图片尺寸。</li><li><code>filetype:</code>：限定文件类型，如<code>PDF</code>、<code>PPT</code>等。</li></ul><p>示例:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`&quot;关键词&quot;  `  双引号  限定关键词</span><br><span class="line"></span><br><span class="line">`intitle:标题` 限定标题</span><br><span class="line"></span><br><span class="line">`allintitle: 标题1 标题2 `</span><br><span class="line"></span><br><span class="line">`intext: 文章内容` 文章内容必定包含文章内容</span><br><span class="line"></span><br><span class="line">`inurl 限定网址`</span><br><span class="line"></span><br><span class="line">`site: 限定域名`</span><br><span class="line"></span><br><span class="line">`imagesize: 2560 x  1440`</span><br><span class="line"></span><br><span class="line">`filetype: ppt` </span><br></pre></td></tr></table></figure><h3 id="📡直奔信息源头"><a href="#📡直奔信息源头" class="headerlink" title="📡直奔信息源头"></a>📡直奔信息源头</h3><p>根据不同需求，直接访问权威网站或平台：</p><ul><li>行业报告：寻找<code>.pdf</code>文件。</li><li>医药领域：官方备案网站。</li><li>产品信息：电商网站。</li><li>最新动态：国际社交平台（<code>Twitter(X)</code>、<code>YouTube</code>）</li><li>….</li></ul><h2 id="📝知识的形态与获取"><a href="#📝知识的形态与获取" class="headerlink" title="📝知识的形态与获取"></a>📝知识的形态与获取</h2><p>知识存在于各种载体中，从网页到视频，从电子书到学术论文。根据知识的公开程度，可以分为：</p><ul><li>完全公开</li><li>私域（免费或收费）</li></ul><h3 id="🌐国外资源"><a href="#🌐国外资源" class="headerlink" title="🌐国外资源"></a>🌐国外资源</h3><ul><li><strong>谷歌图书、学术</strong></li><li><strong>维基百科</strong></li><li><strong>在线课程平台</strong>：<code>Udemy、EDX、Coursera</code></li><li><strong>教育网站</strong>：<code>Khan Academy、Duolingo</code></li><li><strong>专业资源</strong>：<code>Wolfram</code></li></ul><h3 id="📱国内资源"><a href="#📱国内资源" class="headerlink" title="📱国内资源"></a>📱国内资源</h3><p>国内开始有很多用爱发电的大神, 而随着内容电商和自媒体的兴起, 大家都浮躁了,, 知识0成本的抄袭和短视频零碎的交付,导致网络上传播的都是<code>同质化</code>, <code>低质量</code>, <code>十八手的</code>, 零碎的知识垃圾</p><ul><li>B站：长视频学习资源</li><li>得到：音频课程。</li><li>知乎：深度问答社区</li></ul><p>算是最后的希望了。</p><p>知识积累时期：</p><ul><li><p>15年前的知识沉淀主要在  百度系列和一些论坛中</p></li><li><p>10年前   知乎, 公众号</p></li><li><p>5年前     短视频平台 , <code>bilibili</code>长视频, <strong>得到</strong>音频</p></li></ul><h2 id="🌐搜索策略"><a href="#🌐搜索策略" class="headerlink" title="🌐搜索策略"></a>🌐搜索策略</h2><ul><li><p><strong>载体选择</strong>：考虑知识最可能出现在哪种载体上。</p></li><li><p><strong>目的导向</strong>：根据搜索目的选择最佳平台。</p></li><li><p>想要的知识技能最可能附着在那类型载体上</p></li><li><p>看搜索知识技能的目的 (某某行业导航网址) (<code>SimilarSites</code>(同类网站搜索) Sci-hub Google Scholar,  网盘搜索引擎  学搜搜, 盘搜搜, 云盘狗)等等</p></li></ul><hr><p>在这场信息搜索的旅程中，记住，高效搜索不仅关乎技巧，更关乎策略和判断力。希望这些指南能帮助你成为信息海洋中的探险家，找到属于你的知识宝藏。✨</p><p>- </p><p><a href="https://www.youtube.com/watch?v=tiN6T1LewmQ">https://www.youtube.com/watch?v=tiN6T1LewmQ</a></p>]]></content>
      
      
      <categories>
          
          <category> 日常工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 学习工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高效搜索</title>
      <link href="/posts/43428.html"/>
      <url>/posts/43428.html</url>
      
        <content type="html"><![CDATA[<h1 id="高效搜索"><a href="#高效搜索" class="headerlink" title="高效搜索"></a>高效搜索</h1><h1 id="🕵️‍♂️高效搜索的艺术：解锁信息宝藏的秘籍🗝️"><a href="#🕵️‍♂️高效搜索的艺术：解锁信息宝藏的秘籍🗝️" class="headerlink" title="🕵️‍♂️高效搜索的艺术：解锁信息宝藏的秘籍🗝️"></a>🕵️‍♂️高效搜索的艺术：解锁信息宝藏的秘籍🗝️</h1><p>在浩瀚的信息海洋中航行，如何快速定位到你需要的宝藏？这不仅仅是一门技术，更是一种艺术。让我们一起探索如何通过高效搜索，直达知识的核心。🔍</p><h2 id="📚信息分类"><a href="#📚信息分类" class="headerlink" title="📚信息分类"></a>📚信息分类</h2><p>信息可以分为四大类：</p><ul><li>信息</li><li>学习</li><li>素材</li><li>工具</li></ul><p>掌握这些分类，有助于你更有针对性地搜索。🚀</p><h2 id="💡信息搜索技巧"><a href="#💡信息搜索技巧" class="headerlink" title="💡信息搜索技巧"></a>💡信息搜索技巧</h2><h3 id="📈信息渠道效率排名"><a href="#📈信息渠道效率排名" class="headerlink" title="📈信息渠道效率排名"></a>📈信息渠道效率排名</h3><ol><li><p><strong>谷歌</strong>：全球最大的搜索引擎，覆盖广泛，信息更新快。</p></li><li><p><strong>微信知道</strong>：中文环境下的知识问答平台，适合寻找本土化信息。</p></li><li><p><strong>长短视频平台</strong>(<code>bilibili</code>, 抖音)：直观、生动，适合获取快速资讯或娱乐信息。</p></li><li><p><strong>百度</strong>：中文互联网咨询的主要搜索引擎，资源丰富。</p></li></ol><h3 id="🔍高效搜索命令"><a href="#🔍高效搜索命令" class="headerlink" title="🔍高效搜索命令"></a>🔍高效搜索命令</h3><ul><li><code>&quot;关键词&quot;</code>：精确匹配关键词。</li><li><code>intitle:标题</code>：搜索标题中含有特定词汇的页面。</li><li><code>allintitle:标题1 标题2</code>：同时在标题中搜索多个关键词。</li><li><code>intext:&quot;文章内容&quot;</code>：查找包含特定短语的网页。</li><li><code>inurl:</code>：限定网址中包含的关键词。</li><li><code>site:</code>：限定搜索范围在特定网站内。</li><li><code>imagesize:</code>：指定图片尺寸。</li><li><code>filetype:</code>：限定文件类型，如<code>PDF</code>、<code>PPT</code>等。</li></ul><p>示例:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`&quot;关键词&quot;  `  双引号  限定关键词</span><br><span class="line"></span><br><span class="line">`intitle:标题` 限定标题</span><br><span class="line"></span><br><span class="line">`allintitle: 标题1 标题2 `</span><br><span class="line"></span><br><span class="line">`intext: 文章内容` 文章内容必定包含文章内容</span><br><span class="line"></span><br><span class="line">`inurl 限定网址`</span><br><span class="line"></span><br><span class="line">`site: 限定域名`</span><br><span class="line"></span><br><span class="line">`imagesize: 2560 x  1440`</span><br><span class="line"></span><br><span class="line">`filetype: ppt` </span><br></pre></td></tr></table></figure><h3 id="📡直奔信息源头"><a href="#📡直奔信息源头" class="headerlink" title="📡直奔信息源头"></a>📡直奔信息源头</h3><p>根据不同需求，直接访问权威网站或平台：</p><ul><li>行业报告：寻找<code>.pdf</code>文件。</li><li>医药领域：官方备案网站。</li><li>产品信息：电商网站。</li><li>最新动态：国际社交平台（<code>Twitter(X)</code>、<code>YouTube</code>）</li><li>….</li></ul><h2 id="📝知识的形态与获取"><a href="#📝知识的形态与获取" class="headerlink" title="📝知识的形态与获取"></a>📝知识的形态与获取</h2><p>知识存在于各种载体中，从网页到视频，从电子书到学术论文。根据知识的公开程度，可以分为：</p><ul><li>完全公开</li><li>私域（免费或收费）</li></ul><h3 id="🌐国外资源"><a href="#🌐国外资源" class="headerlink" title="🌐国外资源"></a>🌐国外资源</h3><ul><li><strong>谷歌图书、学术</strong></li><li><strong>维基百科</strong></li><li><strong>在线课程平台</strong>：<code>Udemy、EDX、Coursera</code></li><li><strong>教育网站</strong>：<code>Khan Academy、Duolingo</code></li><li><strong>专业资源</strong>：<code>Wolfram</code></li></ul><h3 id="📱国内资源"><a href="#📱国内资源" class="headerlink" title="📱国内资源"></a>📱国内资源</h3><p>国内开始有很多用爱发电的大神, 而随着内容电商和自媒体的兴起, 大家都浮躁了,, 知识0成本的抄袭和短视频零碎的交付,导致网络上传播的都是<code>同质化</code>, <code>低质量</code>, <code>十八手的</code>, 零碎的知识垃圾</p><ul><li>B站：长视频学习资源</li><li>得到：音频课程。</li><li>知乎：深度问答社区</li></ul><p>算是最后的希望了。</p><p>知识积累时期：</p><ul><li>15年前的知识沉淀主要在  百度系列和一些论坛中</li><li>10年前   知乎, 公众号</li><li>5年前     短视频平台 , <code>bilibili</code>长视频, <strong>得到</strong>音频</li></ul><h2 id="🌐搜索策略"><a href="#🌐搜索策略" class="headerlink" title="🌐搜索策略"></a>🌐搜索策略</h2><ul><li><p><strong>载体选择</strong>：考虑知识最可能出现在哪种载体上。</p></li><li><p><strong>目的导向</strong>：根据搜索目的选择最佳平台。</p></li><li><p>想要的知识技能最可能附着在那类型载体上</p></li><li><p>看搜索知识技能的目的 (某某行业导航网址) (<code>SimilarSites</code>(同类网站搜索) Sci-hub Google Scholar,  网盘搜索引擎  学搜搜, 盘搜搜, 云盘狗)等等</p></li></ul><hr><p>在这场信息搜索的旅程中，记住，高效搜索不仅关乎技巧，更关乎策略和判断力。希望这些指南能帮助你成为信息海洋中的探险家，找到属于你的知识宝藏。✨</p><p>参考资料：</p><ul><li><a href="https://www.youtube.com/watch?v=tiN6T1LewmQ">https://www.youtube.com/watch?v=tiN6T1LewmQ</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 日常工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 学习工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS源码解析</title>
      <link href="/posts/31851.html"/>
      <url>/posts/31851.html</url>
      
        <content type="html"><![CDATA[<h1 id="AQS源码解析"><a href="#AQS源码解析" class="headerlink" title="AQS源码解析"></a><code>AQS</code>源码解析</h1><p>​<code>AQS</code>是Java里的一个<code>同步工具类</code>，全称为<code>AbstractQueuedSynchronizer</code>。它是<code>JUC</code>包中中实现锁和同步机制的基础。</p><p>​它可以被认为是一种框架或模板，用于实现多种同步器，比如<code>ReentrantLock</code>、<code>CountDownLatch</code>、<code>Semaphore</code> 、<code>ReentrantReadWriteLock</code>等。</p><p>作为本系列第一节， 我们先了解这些同步工具的共同的祖先(虽然实际上是聚合关系)   —-<code>AQS</code></p><p>在了解<code>AQS</code>之前, 我们要知道: </p><p><code>AQS</code>本质上是一个队列，它是将等待锁或资源的线程排队，并在锁或资源可用时将其唤醒。</p><p>建立在这个基础上, 方便理解后序讲解</p><p>我们以平常最常用的<code>ReentrantLock</code>为例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock lock= <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次获取锁</span></span><br><span class="line">lock.lock(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同步代码块块</span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 第一次释放锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们点进<code>lock()</code>方法, 会发现调用的是<code>sync.lock();</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">       sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sync</code>是什么呢? 这其实是<code>ReentrantLock</code>一个内部类<code>Sync</code>的实例</p><p><strong>Sync</strong>：是提供<code>AQS</code>实现的工具，类似于适配器，提供了抽象的lock()，便于快速创建非公平锁。</p><p>而<code>Sync</code>继承自<code>AQS(AbstractQueuedSynchronizer)</code>, 事实上, 上述几乎每个同步工具都又一个<code>Sync</code>的实现子类, 而且均继承自<code>AQS</code>, 这下就明白为什么说 <code>AQS</code>是一种框架或模板, 如果你想定义一个同步工具, 也完全可以通过继承<code>AQS</code>这个抽象类来实现, 文末我们会给出一个通过<code>AQS</code>简单自定义的互斥锁</p><p>而这个内部类也引出了我们本篇讲解的重点  <code>AQS</code></p><p>这是</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 互斥锁 Mutex 的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mutex</span> &#123;</span><br><span class="line">    <span class="comment">// 内部类 Sync 继承 AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 尝试获取互斥锁</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> arg 获取锁的参数</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 如果获取锁成功返回 true，否则返回 false</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123; <span class="comment">// 尝试将状态从 0 设置为 1，表示成功获取锁</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread()); <span class="comment">// 设置当前线程为独占线程</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 获取锁成功</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 获取锁失败</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 尝试释放互斥锁</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> arg 释放锁的参数</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 如果释放锁成功返回 true，否则返回 false</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>) &#123; <span class="comment">// 状态为 0 表示锁没有被持有</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>(); <span class="comment">// 抛出异常</span></span><br><span class="line">            &#125;</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>); <span class="comment">// 将独占线程设置为 null</span></span><br><span class="line">            setState(<span class="number">0</span>); <span class="comment">// 释放锁，将状态设置为 0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 释放锁成功</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断是否为独占线程持有互斥锁</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 如果当前线程独占持有锁返回 true，否则返回 false</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>; <span class="comment">// 状态为 1，表示当前线程独占持有锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取互斥锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>); <span class="comment">// 获取锁，如果锁已被持有，则当前线程进入阻塞状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放互斥锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>); <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断互斥锁是否被独占持有</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果锁被独占持有返回 true，否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个使用内部类和 <code>AQS </code>实现的互斥锁（<code>Mutex</code>）类。</p><ul><li><code>tryAcquire</code>：尝试获取资源。如果当前状态为0（未锁定），那么设置为1（锁定），并设 置当前线程为独占资源的线程。</li><li><code>tryRelease</code>：尝试释放资源。设置状态为0并清除持有资源的线程。 </li><li><code>isHeldExclusively</code>：判断当前资源是否被独占。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AQS </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CountDownLatch</title>
      <link href="/posts/39998.html"/>
      <url>/posts/39998.html</url>
      
        <content type="html"><![CDATA[<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p><code>CountDownLatch</code>是一个<code>JUC</code>包下的同步工具   计数器</p><p>作用是:  使一个或者多个线程等待其他线程完成后再执行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造一个用给定计数初始化的 CountDownLatch。</span></span><br><span class="line">CountDownLatch(<span class="type">int</span> count)</span><br><span class="line"><span class="comment">// 使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断或超出了指定的等待时间。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line"><span class="comment">// 递减锁存器的计数，如果计数到达零，则释放所有等待的线程。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 返回当前计数。</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">getCount</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 返回标识此锁存器及其状态的字符串。</span></span><br><span class="line">String <span class="title function_">toString</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLathTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每个线程去收集 1 颗龙珠</span></span><br><span class="line">    <span class="comment">// 定义需要收集龙珠的目标数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DRAGON_BALL_TOTAL_NUM</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义需要等待的线程数量</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(DRAGON_BALL_TOTAL_NUM);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">// 每个线程收集完一颗龙珠后, countDownlatch(减数板) - 1</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;收集到第 &quot;</span> + index + <span class="string">&quot;号龙珠!&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 只有当countDownlatch(减数板)数量减少为 0 时, 主线程才会被唤醒, 也就是 7 颗龙珠收集完毕</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;龙珠收集完毕!!! \n&quot;</span> +   <span class="string">&quot;召唤神龙!!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由上述代码可见, <code>CountDownLatch</code> 通过计数定义了线程之间的同步关系</p><p><code>JUC</code>包下所有同步工具离不开<code>ASQ</code>的框架(不得不感叹Doug Lea教授强大的抽象和设计)</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> CountDownLatch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shio Jottings</title>
      <link href="/posts/31848.html"/>
      <url>/posts/31848.html</url>
      
        <content type="html"><![CDATA[<h1 id="Jotting"><a href="#Jotting" class="headerlink" title="Jotting"></a>Jotting</h1><blockquote><p>“你可以拿走我的另一条腿，但我会比现在更加坚强。”                                                                     永远的 Terry Fox</p></blockquote><hr><p>​每个人都会经过这个阶段,，喜欢标新立意的概念， 若是有人出来反对主流观念,，反对家庭，工作，责任的束缚,，并且技巧又很出色,，往往就能俘获很多拥护， 你会觉得反抗比什么都难得可贵。</p><p>​可在尝试过后又发现主流能成为主流是有道理的，这是属于大多数人的最简单的路径,，逆流而上太痛苦了。</p><p>​于是你学会了欣赏主流生活，奇怪的是，当你开始热爱主流的东西， 反而逐渐积累起逆流而上的勇气，因为你不是为了逃避而逆行， 你不怕回到芸芸众生当中,，而这会给予你真正的勇气。</p><hr><p>​但是太阳,，它每时每刻都是夕阳也都是旭日，当它熄灭着走下山去,，收尽苍凉残照之际，正是它在另一面燃烧着爬上山，巅布散烈烈朝晖之时。那一天，我也将沉静着走下山去， 扶着我的拐杖。有一天，在某一处山洼里， 势必会跑上来一个欢蹦的孩子， 抱着他的玩具。当然，那必不是我。但是，那不是我吗？</p><hr><p>​  空冥的想象可以负载任意的梦境，而实在的答案便会限定出真切的痛苦</p>]]></content>
      
      
      <categories>
          
          <category> Jottings </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> Jottings </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题思路</title>
      <link href="/posts/39628.html"/>
      <url>/posts/39628.html</url>
      
        <content type="html"><![CDATA[<h1 id="线程不安全的本质"><a href="#线程不安全的本质" class="headerlink" title="线程不安全的本质:"></a>线程不安全的本质:</h1><p>线程内存存副本</p><ul><li>更改副本不可见,互相覆盖(可见性)</li><li>线程切换, 更改操作不具有原子性(原子性)</li><li>有序性</li></ul><p>类没有状态, 成员变量一定线程安全</p><p>成员变量只是可读也一定是线程安全的</p><p>修改成员变量时加互斥锁也一定是线程安全的</p><h2 id="String为什么线程安全"><a href="#String为什么线程安全" class="headerlink" title="String为什么线程安全"></a>String为什么线程安全</h2><p>final 只读 光这一点不够, 还因为是private 无法更改数组某一元素</p><p>因为字符串是不可变的，所以在它创建的时候HashCode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解放双手，每日强国</title>
      <link href="/posts/40882.html"/>
      <url>/posts/40882.html</url>
      
        <content type="html"><![CDATA[<h1 id="解放双手，每日强国"><a href="#解放双手，每日强国" class="headerlink" title="解放双手，每日强国"></a>解放双手，每日强国</h1><p>​学习强国是好事,但有些学校功利性的算各种学分,大多数人以这种动机的学习显然更像是一种负担,其实如果大家有余力还是推荐自己学习</p><p>​<em>本教程全程傻瓜式操作，适用于未使用过油猴和GitHub的小白，脚本内容搬运自：<a href="https://github.com/Xu22Web/tech-study-js/issues%EF%BC%88%E4%BB%A3%E7%A0%81%E6%88%91%E4%BC%9A%E8%B4%B4%E5%9C%A8%E6%96%87%E7%AB%A0%E6%9C%AB%E5%B0%BE%EF%BC%8C%E5%86%8D%E6%AC%A1%E5%BC%BA%E8%B0%83%E6%88%91%E5%8F%AA%E6%98%AF%E6%90%AC%E8%BF%90%E5%B7%A5%EF%BC%8C%E5%A6%82%E6%9C%89%E4%BE%B5%E6%9D%83%E4%BC%9A%E7%AB%8B%E5%8D%B3%E5%88%A0%E9%99%A4%EF%BC%89">https://github.com/Xu22Web/tech-study-js/issues（代码我会贴在文章末尾，再次强调我只是搬运工，如有侵权会立即删除）</a></em></p><p>​一年前的博客了,现在学习强国也做了很多”改进”,亲测目前只有<strong>自动刷视频和文章是无风险支持</strong>(***warning !!!!!***自动刷题会被警告,警告到一定次数会被封禁7~30天)</p><h2 id="一、安装油猴"><a href="#一、安装油猴" class="headerlink" title="一、安装油猴"></a>一、安装油猴</h2><p>​<em>已经安装过的可以跳过这里</em></p><ol><li>打开你的edge浏览器，点击扩展</li></ol><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202207131226862.jpg" alt="img"></p><ol start="2"><li>点击获取下图选项获取扩展</li></ol><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202207131227984.jpg" alt="img"></p><ol start="3"><li>搜索框输入“tempermonkey”，搜索该扩展并获取</li></ol><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202207131227875.jpg" alt="img"></p><ol start="4"><li>之后会有弹窗，点“添加扩展”</li></ol><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202207131227120.jpg" alt="img"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202207131227430.jpg" alt="img"></p><ol start="5"><li>把目光聚焦到浏览器的右上方</li></ol><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202207131227455.jpg" alt="img"></p><ol start="6"><li>这时候可能还看不到安装上的Tempermonkey(之后步骤简称油猴)，因为添加扩展后，默认设置是不可视的</li></ol><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202207131227521.jpg" alt="img"></p><ol start="7"><li>按下图顺序点击，便可设置为工具栏可见了</li></ol><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202207131227990.jpg" alt="img"></p><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202207131227805.jpg" alt="img"></p><h2 id="二、添加脚本"><a href="#二、添加脚本" class="headerlink" title="二、添加脚本"></a>二、添加脚本</h2><ol start="8"><li>按下图操作，会进入一个新的界面</li></ol><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202207131227043.jpg" alt="img"></p><ol start="9"><li>新的界面如下</li></ol><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202207131227747.png" alt="img"></p><ol start="10"><li>底下这些内容是可以编辑的，首先把原本的内容删掉</li></ol><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202207131227861.png" alt="img"></p><ol start="11"><li>然后把从<a href="https://github.com/Xu22Web/tech-study-js/issues">https://github.com/Xu22Web/tech-study-js/issues</a> (文章末尾的代码)Ctrl+A(全选)，然后Ctrl+C（复制），最后Ctrl+V（粘贴）到这里</li></ol><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202207131227559.png" alt="img"></p><ol start="12"><li>Ctrl+S（保存），脚本就新建成功了，启用它</li></ol><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202207131301723.png" alt="img"></p><h2 id="三、脚本使用"><a href="#三、脚本使用" class="headerlink" title="三、脚本使用"></a>三、脚本使用</h2><ol start="13"><li><p>进入学习强国网页版，<a href="https://www.xuexi.cn/">学习强国 (xuexi.cn)</a>，然后扫码用户登录（这里就不截图演示了）</p></li><li><p>右上角的浮窗点，开始学习，之后什么都不用不做，慢慢等待完成即可；以后每天只需要重复最后两步，就可以懒人式斩获25分了</p></li></ol><p><img src="https://ohtoai-images.oss-cn-beijing.aliyuncs.com/imgs/OhtoAi_Blog/202309042118286.png" alt="image-20230904211513385"></p><p>代码如下: </p><p>代码比较长,复制时可能会卡一下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name   不学习何以强国</span></span><br><span class="line"><span class="comment">// @namespace   http://tampermonkey.net/</span></span><br><span class="line"><span class="comment">// @version   1.7.0</span></span><br><span class="line"><span class="comment">// @description   有趣的 `学习强国` 油猴插件。读文章,看视频，做习题。问题反馈： https://github.com/Xu22Web/tech-study-js/issues 。</span></span><br><span class="line"><span class="comment">// @author   原作者：techxuexi 荷包蛋。现作者：Xu22Web</span></span><br><span class="line"><span class="comment">// @match   https://www.xuexi.cn/*</span></span><br><span class="line"><span class="comment">// @match   https://pc.xuexi.cn/points/exam-practice.html</span></span><br><span class="line"><span class="comment">// @match   https://pc.xuexi.cn/points/exam-weekly-detail.html?id=*</span></span><br><span class="line"><span class="comment">// @match   https://pc.xuexi.cn/points/exam-paper-detail.html?id=*</span></span><br><span class="line"><span class="comment">// @match   https://login.xuexi.cn/login/xuexiWeb?appid=dingoankubyrfkttorhpou&amp;goto=https%3A%2F%2Foa.xuexi.cn&amp;type=1&amp;state=ffdea2ded23f45ab%2FKQreTlDFe1Id3B7BVdaaYcTMp6lsTBB%2Fs3gGevuMKfvpbABDEl9ymG3bbOgtpSN&amp;check_login=https%3A%2F%2Fpc-api.xuexi.cn</span></span><br><span class="line"><span class="comment">// @require   https://cdn.jsdelivr.net/npm/blueimp-md5@2.9.0</span></span><br><span class="line"><span class="comment">// @run-at   document-start</span></span><br><span class="line"><span class="comment">// @grant   GM_addStyle</span></span><br><span class="line"><span class="comment">// @grant   GM_setValue</span></span><br><span class="line"><span class="comment">// @grant   GM_getValue</span></span><br><span class="line"><span class="comment">// @grant   GM_openInTab</span></span><br><span class="line"><span class="comment">// @grant   unsafeWindow</span></span><br><span class="line"><span class="comment">// @updateURL   https://raw.githubusercontent.com/Xu22Web/tech-study-js/master/tech-study.js</span></span><br><span class="line"><span class="comment">// @downloadURL   https://raw.githubusercontent.com/Xu22Web/tech-study-js/master/tech-study.js</span></span><br><span class="line"><span class="comment">// @supportURL   https://github.com/Xu22Web</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"><span class="keyword">const</span> css = <span class="string">&#x27;* &#123;  -webkit-tap-highlight-color: transparent;&#125;:root &#123;  --themeColor: #fa3333;  --scale: 1;  font-size: calc(10px * var(--scale));&#125;@media (min-height: 678px) and (max-height: 768px) &#123;  :root &#123;    --scale: 0.8;  &#125;&#125;@media (max-height: 667px) &#123;  :root &#123;    --scale: 0.75;  &#125;&#125;@keyframes fade &#123;  from &#123;    opacity: 0.8;  &#125;  to &#123;    opacity: 0.4;    background: #ccc;  &#125;&#125;.egg_icon &#123;  width: 1em;  height: 1em;  fill: currentColor;&#125;.egg_hr_wrap &#123;  position: relative;  display: flex;  justify-content: center;  color: #ccc;&#125;.egg_hr_wrap .egg_hr &#123;  position: absolute;  top: 50%;  transform: translateY(-50%);  background: currentColor;  height: 0.1rem;  width: 30%;&#125;.egg_hr_wrap .egg_hr:nth-of-type(1) &#123;  left: 0;&#125;.egg_hr_wrap .egg_hr:nth-last-of-type(1) &#123;  right: 0;&#125;.egg_hr_title &#123;  font-size: 1.2rem;&#125;.egg_exam_btn &#123;  transition: background-color 80ms;  outline: none;  border: none;  padding: 1.2rem 2rem;  border-radius: 1.2rem;  cursor: pointer;  font-size: 1.8rem;  font-weight: bold;  text-align: center;  color: #ffffff;  background: #666777;&#125;.egg_exam_btn.manual &#123;  background: #e3484b;&#125;.egg_panel_wrap * &#123;  padding: 0;  margin: 0;  box-sizing: border-box;  outline: none;  border: none;&#125;.egg_panel_wrap &#123;  position: fixed;  left: 0;  top: 0;  z-index: 99999;  width: 100%;  height: 100%;  color: #333;  font-size: 1.6rem;  pointer-events: none;&#125;.egg_panel &#123;  position: absolute;  top: 5rem;  left: 1rem;  padding: 1.2rem 2rem;  border-radius: 1rem;  background: #ffffffe6;  backdrop-filter: blur(1rem);  box-shadow: 0 0 0.1rem 0.1rem #f1f1f1;  transition: 80ms ease-out;  pointer-events: all;&#125;.egg_panel.hide &#123;  left: 0;  transform: translateX(-100%);&#125;.egg_panel_wrap.mobile .egg_panel &#123;  top: 1rem;&#125;@media (min-height: 678px) and (max-height: 768px) &#123;  .egg_panel &#123;    top: 2rem;  &#125;&#125;@media (max-height: 667px) &#123;  .egg_panel &#123;    top: 1rem;  &#125;&#125;.egg_panel button &#123;  outline: none;  border: none;  padding: 0;  cursor: pointer;  background: none;&#125;.egg_panel .egg_btns_wrap &#123;  position: absolute;  left: 100%;  top: 50%;  transform: translate(-50%, -50%);  transition: 80ms ease;  z-index: 9;&#125;.egg_panel.hide .egg_btns_wrap &#123;  left: 100%;  transform: translate(0, -50%);&#125;.egg_panel .egg_btns_wrap button &#123;  border-radius: 50%;  width: 3rem;  height: 3rem;  padding: 0;  overflow: hidden;  border: 0.2rem solid currentColor;  color: white;  display: grid;  place-items: center;  font-size: 1.8rem;&#125;.egg_panel.hide .egg_panel_show_btn &#123;  background: var(--themeColor);&#125;.egg_panel .egg_panel_show_btn &#123;  background: #ccc;&#125;.egg_panel .egg_frame_show_btn &#123;  background: var(--themeColor);  margin-bottom: 1rem;&#125;.egg_panel .egg_frame_show_btn.hide &#123;  display: none;&#125;.egg_panel .egg_settings_show_btn &#123;  background: #ccc;  margin-top: 1rem;&#125;.egg_panel .egg_settings_show_btn.active &#123;  background: var(--themeColor);&#125;.egg_panel .egg_settings_reset_btn &#123;  background: #ccc;  margin-top: 1rem;&#125;.egg_panel .egg_settings_reset_btn:active &#123;  background: var(--themeColor);&#125;.egg_login_item &#123;  display: flex;  justify-content: center;  align-items: center;  flex-direction: column;  padding: 0.5rem 0;&#125;.egg_login_item .egg_login_btn &#123;  font-size: 1.4rem;  border-radius: 1rem;  transition: 80ms ease;  color: white;  background: var(--themeColor);  padding: 0.8rem 2.4rem;&#125;.egg_login_item .egg_login_btn:active &#123;  opacity: 0.8;&#125;.egg_login_item .egg_login_img_wrap &#123;  height: 0;  border-radius: 1rem;  transition: height 80ms ease;  overflow: hidden;&#125;.egg_login_item .egg_login_img_wrap.active &#123;  padding: 0.8rem;  margin-top: 0.8rem;  height: auto;  background: white;&#125;.egg_login_img_wrap .egg_login_img &#123;  width: 15rem;  height: 15rem;&#125;.egg_info_item .egg_login_btn &#123;  font-size: 1.4rem;  border-radius: 1rem;  transition: 80ms ease;  color: white;&#125;.egg_info_item .egg_login_btn:active &#123;  opacity: 0.8;&#125;.egg_info_item .egg_login_btn &#123;  background: #ccc;  padding: 0.4rem 0.8rem;&#125;.egg_info_item &#123;  display: flex;  justify-content: space-between;  align-items: center;&#125;.egg_info_item .egg_userinfo &#123;  display: flex;  justify-content: center;  align-items: center;  padding: 0.5rem 0;&#125;.egg_userinfo .egg_avatar .egg_avatar_nick,.egg_userinfo .egg_avatar .egg_avatar_img &#123;  height: 5rem;  width: 5rem;  border-radius: 50%;  background: var(--themeColor);  display: flex;  justify-content: center;  align-items: center;  text-overflow: ellipsis;  overflow: hidden;  white-space: nowrap;  font-size: 2rem;  color: white;&#125;.egg_userinfo .egg_nick &#123;  padding-left: 0.5rem;  text-overflow: ellipsis;  overflow: hidden;  white-space: nowrap;  max-width: 10rem;&#125;.egg_score_item .egg_scoreinfo &#123;  display: flex;  justify-content: space-between;  align-items: center;  padding: 0.5rem 0;&#125;.egg_scoreinfo .egg_totalscore,.egg_scoreinfo .egg_todayscore &#123;  font-size: 1.2rem;  user-select: none;&#125;.egg_scoreinfo .egg_totalscore span,.egg_scoreinfo .egg_todayscore .egg_todayscore_btn span &#123;  padding-left: 0.2rem;&#125;.egg_scoreinfo .egg_totalscore span,.egg_todayscore .egg_todayscore_btn span,.egg_todayscore .egg_score_details span &#123;  color: var(--themeColor);  font-weight: bold;&#125;.egg_scoreinfo .egg_todayscore &#123;  position: relative;&#125;.egg_todayscore .egg_todayscore_btn &#123;  display: flex;  align-items: center;&#125;.egg_todayscore_btn .egg_icon &#123;  opacity: 0.3;&#125;.egg_todayscore .egg_score_details &#123;  position: absolute;  left: calc(100% + 1rem);  top: 0;  background: #fffffff2;  border-radius: 0.5rem;  opacity: 1;  width: 10rem;  box-shadow: 0 0 0.1rem 0.1rem #f1f1f1;  transition: 80ms ease;  z-index: 9;&#125;.egg_todayscore .egg_score_details.hide &#123;  visibility: hidden;  opacity: 0;  left: 100%;&#125;.egg_score_details .egg_score_title &#123;  border-bottom: 0.1rem solid #eee;  padding: 0.5rem 0.8rem;  display: flex;  align-items: center;&#125;.egg_score_details .egg_score_title .egg_icon &#123;  font-size: 1.4rem;&#125;.egg_score_details .egg_score_title .egg_score_title_text &#123;  font-weight: bold;  padding-left: 0.2rem;&#125;.egg_score_details .egg_score_item &#123;  display: flex;  align-items: center;  justify-content: space-between;  padding: 0.5rem 0.8rem;&#125;.egg_task_list &#123;  position: relative;&#125;.egg_task_item &#123;  user-select: none;  min-height: 3rem;  min-width: 18rem;  display: flex;  align-items: center;  justify-content: space-between;  padding: 0.5rem 0;&#125;.egg_task_item .egg_label_wrap &#123;  flex-grow: 1;  padding-right: 0.5rem;&#125;.egg_label_wrap .egg_task_title_wrap &#123;  display: flex;  justify-content: space-between;  align-items: center;&#125;.egg_task_title_wrap .egg_task_progress_wrap &#123;  display: flex;  align-items: center;  font-size: 1.4rem;  width: 3.5rem;&#125;.egg_task_progress_wrap .egg_task_current &#123;  color: var(--themeColor);&#125;.egg_task_progress_wrap .egg_task_max &#123;  color: #999;  font-size: 1.2rem;&#125;.egg_label_wrap .egg_progress &#123;  display: flex;  justify-content: space-between;  align-items: center;  padding-top: 0.8rem;&#125;.egg_progress .egg_track &#123;  background: #ccc;  height: 0.5rem;  border-radius: 1rem;  flex: 1 1 auto;  overflow: hidden;&#125;.egg_progress .egg_track .egg_bar &#123;  height: 0.5rem;  background: var(--themeColor);  border-radius: 1rem;  width: 0;  transition: width 0.5s;&#125;.egg_setting_item &#123;  min-height: 3rem;  min-width: 18rem;  display: flex;  align-items: center;  justify-content: space-between;  box-sizing: border-box;&#125;.egg_setting_item .egg_label_wrap &#123;  flex-grow: 1;&#125;.egg_detail &#123;  background: #ccc;  color: white;  border-radius: 10rem;  font-size: 1.2rem;  width: 1.6rem;  height: 1.6rem;  margin-left: 0.4rem;  display: inline-block;  text-align: center;  line-height: 1.6rem;  cursor: pointer;&#125;.egg_switch &#123;  cursor: pointer;  margin: 0;  outline: 0;  appearance: none;  -webkit-appearance: none;  -moz-appearance: none;  position: relative;  width: 4.2rem;  height: 2.2rem;  background: #ccc;  border-radius: 5rem;  transition: background 0.3s;  --border-padding: 0.5rem;  box-shadow: -0.1rem 0 0.1rem -0.1rem #999 inset,    0.1rem 0 0.1rem -0.1rem #999 inset;&#125;.egg_switch::after &#123;  content: \&#x27;\&#x27;;  display: inline-block;  width: 1.4rem;  height: 1.4rem;  border-radius: 50%;  background: #fff;  box-shadow: 0 0 0.2rem #999;  transition: left 0.4s;  position: absolute;  top: calc(50% - (1.4rem / 2));  position: absolute;  left: var(--border-padding);&#125;.egg_switch:checked &#123;  background: var(--themeColor);&#125;.egg_switch:disabled &#123;  opacity: 0.5;  background: #ccc;&#125;.egg_switch:checked::after &#123;  left: calc(100% - var(--border-padding) - 1.4rem);&#125;.egg_tip_list &#123;  font-size: 1.2rem;  max-width: 18rem;  line-height: 2rem;  color: var(--themeColor);&#125;.egg_tip_list .egg_tip_btn &#123;  padding: 0.2rem 0.4rem;  background: #f1f1f1;  color: #333;&#125;.egg_tip_list .egg_tip_btn:disabled &#123;  opacity: 0.5;  background: #ccc;&#125;.egg_study_item &#123;  display: flex;  justify-content: center;  padding-top: 0.5rem;&#125;.egg_study_item .egg_study_btn &#123;  background: var(--themeColor);  padding: 0.8rem 2.4rem;  font-size: 1.4rem;  border-radius: 1rem;  color: white;  transition: 80ms ease;&#125;.egg_study_item .egg_study_btn:not(.loading):active &#123;  opacity: 0.8;&#125;.egg_study_item .egg_study_btn.loading &#123;  animation: fade 2s ease infinite alternate;&#125;.egg_study_item .egg_study_btn:disabled &#123;  background: #ccc;&#125;.egg_tip_wrap &#123;  position: fixed;  left: 0;  top: 0;  z-index: 999999;  width: 100%;  height: 100%;  pointer-events: none;&#125;.egg_tip_wrap * &#123;  padding: 0;  margin: 0;  box-sizing: border-box;  outline: none;  border: none;&#125;.egg_tip_wrap .egg_tip &#123;  position: absolute;  bottom: 2rem;  left: 2rem;  padding: 1.2rem 1.4rem;  border: none;  border-radius: 1rem;  background: var(--themeColor);  color: white;  font-size: 1.4rem;  transition: 200ms ease;  opacity: 0;  transform: scale(0.9) translateY(1rem);&#125;.egg_tip_wrap .egg_tip.active &#123;  opacity: 1;  transform: scale(1) translateY(0);&#125;.egg_tip_wrap .egg_tip.active.delay &#123;  opacity: 0.5;&#125;.egg_tip_wrap .egg_tip .egg_countdown &#123;  display: inline-block;  color: var(--themeColor);  background: white;  border-radius: 0.5rem;  padding: 0.2rem 0.4rem;  font-weight: bold;  margin-left: 0.4rem;  font-size: 1.2rem;&#125;.egg_frame_wrap &#123;  position: fixed;  left: 0;  top: 0;  z-index: 999;  width: 100%;  height: 100%;  visibility: visible;&#125;.egg_frame_wrap * &#123;  padding: 0;  margin: 0;  box-sizing: border-box;  outline: none;  border: none;&#125;.egg_frame_wrap.hide &#123;  visibility: hidden;&#125;.egg_frame_wrap.hide .egg_frame_mask,.egg_frame_wrap.hide .egg_frame_content_wrap &#123;  opacity: 0;&#125;.egg_frame_wrap.hide .egg_frame_content_wrap &#123;  transform: scale(0);&#125;.egg_frame_mask &#123;  background: #00000030;  width: 100%;  height: 100%;  opacity: 1;  transition: 200ms ease;&#125;.egg_frame_content_wrap &#123;  position: absolute;  width: 80%;  height: 80%;  top: 10%;  left: 10%;  display: flex;  flex-direction: column;  transition: 200ms ease;  border-radius: 1rem;  background: #ffffffe6;  backdrop-filter: blur(1rem);  overflow: hidden;  transform: scale(1);&#125;.egg_frame_content_wrap.max &#123;  top: 0;  left: 0;  width: 100%;  height: 100%;  border-radius: 0;&#125;.egg_frame_content_wrap .egg_frame_controls_wrap &#123;  width: 100%;  display: flex;  justify-content: space-between;  align-items: center;  box-sizing: border-box;&#125;.egg_frame_controls_wrap .egg_frame_title &#123;  padding: 1rem 2rem;  font-size: 1.6rem;&#125;.egg_frame_controls .egg_frame_btn &#123;  outline: none;  border: none;  background: none;  padding: 1rem 2rem;  transition: 80ms ease;  cursor: pointer;  color: #333;  font-size: 1.8rem;&#125;.egg_frame_controls .egg_frame_btn:active &#123;  opacity: 0.8;&#125;.egg_frame_wrap .egg_frame_content &#123;  width: 100%;  flex-grow: 1;  border-top: 0.1rem solid #ccc;  min-height: 40rem;  min-width: 30rem;  background: white;&#125;.egg_frame_content .egg_frame &#123;  width: 100%;  height: 100%;  outline: none;  border: none;&#125;.egg_time_input &#123;  display: inline-flex;  align-items: center;  justify-content: center;&#125;.egg_time_input .egg_hour_wrap,.egg_time_input .egg_minute_wrap &#123;  width: 4rem;&#125;.egg_time_input .egg_separator &#123;  padding: 0 0.5rem;  font-size: 1.5rem;&#125;.egg_settings_item &#123;  position: absolute;  top: 0;  left: 0;  width: 100%;  height: 100%;  pointer-events: none;  overflow: hidden;  border-radius: 1rem;&#125;.egg_settings_item .egg_settings &#123;  display: inline-flex;  flex-direction: column;  font-size: 1.4rem;  background: white;  border-radius: 1rem;  overflow: hidden;  width: 100%;  height: 100%;  pointer-events: all;  transform: translateX(100%);  transition: transform 300ms ease;  padding-top: 1rem;&#125;.egg_settings_item .egg_settings.active &#123;  transform: translateX(0);&#125;.egg_settings .egg_settings_label &#123;  padding-bottom: 1rem;  user-select: none;&#125;.egg_settings_item .egg_settings_version_wrap &#123;  padding: 1rem 2rem 0 2rem;  display: flex;  align-items: center;  justify-content: space-between;&#125;.egg_settings_version_wrap .egg_settings_version &#123;  color: #999;  display: flex;  align-items: center;&#125;.egg_settings_version .egg_settings_version_detail &#123;  color: #24292f;  font-size: 1.6rem;  width: 1.6rem;  height: 1.6rem;  margin-left: 0.4rem;&#125;.egg_settings_item .egg_settings_theme_wrap &#123;  padding: 1rem 2rem 0 2rem;&#125;.egg_settings_theme_wrap .egg_settings_theme_colors &#123;  display: flex;  align-items: center;  justify-content: space-between;&#125;.egg_settings_theme_color_wrap .egg_settings_theme_color &#123;  border-radius: 50%;  width: 1.6rem;  height: 1.6rem;  background: currentColor;&#125;.egg_settings .egg_settings_read_time_wrap,.egg_settings .egg_settings_watch_time_wrap &#123;  padding: 1rem 2rem 0 2rem;  display: flex;  justify-content: space-between;  align-items: center;&#125;.egg_settings_read_time_wrap .egg_settings_label,.egg_settings_watch_time_wrap .egg_settings_label &#123;  padding: 0.5rem 0;&#125;.egg_settings_read_time_wrap .egg_select,.egg_settings_watch_time_wrap .egg_select &#123;  width: 6rem;&#125;.egg_settings .egg_settings_token_wrap &#123;  padding: 1rem 2rem 0 2rem;&#125;.egg_settings_token_wrap .egg_settings_token_input &#123;  outline: none;  border: 0.1rem solid #eee;  padding: 1rem;  background: white;  border-radius: 0.2rem;  width: 100%;  box-sizing: border-box;  color: #ccc;&#125;.egg_settings_token_wrap .egg_settings_token_input.active &#123;  color: #333;&#125;.egg_settings_token_input::placeholder &#123;  color: #ccc;&#125;.egg_settings .egg_settings_submit_btn_wrap &#123;  text-align: right;  padding-top: 1rem;  display: none;&#125;.egg_settings .egg_settings_submit_btn_wrap.active &#123;  display: block;&#125;.egg_settings_submit_btn_wrap .egg_settings_submit_btn &#123;  outline: none;  border: 0.1rem solid #eee;  padding: 0.5rem 1rem;  text-align: center;  background: white;  border-radius: 0.2rem;  cursor: pointer;&#125;.egg_settings_submit_btn_wrap .egg_settings_submit_btn:active &#123;  background: #eee;&#125;.egg_schedule &#123;  height: 100%;  display: flex;  flex-direction: column;&#125;.egg_schedule_time_wrap &#123;  padding: 1rem 2rem;  border-bottom: 0.1rem solid #eee;&#125;.egg_schedule_time .egg_schedule_label &#123;  padding-bottom: 1rem;  user-select: none;&#125;.egg_schedule_time .egg_schedule_time_input_wrap &#123;  display: flex;  justify-content: space-between;  align-items: center;&#125;.egg_schedule_time_input_wrap .egg_schedule_add_btn &#123;  outline: none;  border: 0.1rem solid #eee;  padding: 0.5rem 1rem;  text-align: center;  background: white;  border-radius: 0.2rem;  cursor: pointer;&#125;.egg_schedule_time_input_wrap .egg_schedule_add_btn:active &#123;  background: #eee;&#125;.egg_schedule_list &#123;  height: 100%;  overflow: auto;&#125;.egg_schedule_list .egg_schedule_item &#123;  display: flex;  justify-content: space-between;  padding: 0.5rem 1.5rem;  font-size: 1.4rem;  border-bottom: 0.1rem solid #eee;&#125;.egg_schedule_list::-webkit-scrollbar &#123;  width: 0.4rem;  background: white;  border-radius: 0.2rem;&#125;.egg_schedule_list::-webkit-scrollbar-thumb &#123;  background: #ccc;  border-radius: 0.2rem;&#125;.egg_schedule_detail_time_wrap &#123;  display: flex;  align-items: center;&#125;.egg_schedule_detail_time_wrap.inactive &#123;  color: #ccc;&#125;.egg_schedule_detail_time_wrap .egg_schedule_detail_icon &#123;  padding-right: 0.4rem;  display: flex;  color: #ccc;&#125;.egg_schedule_detail_del_wrap .egg_schedule_del_btn &#123;  outline: none;  padding: 1rem;  text-align: center;  background: white;  border-radius: 0.2rem;  font-size: 1.4rem;  cursor: pointer;  color: #ccc;&#125;.egg_schedule_detail_del_wrap .egg_schedule_del_btn:hover &#123;  color: #333;&#125;.egg_schedule_detail_del_wrap .egg_schedule_del_btn:active &#123;  color: #eee;&#125;.egg_schedule_list .egg_schedule_list_none &#123;  width: 100%;  height: 100%;  display: flex;  flex-direction: column;  justify-content: center;  align-items: center;  color: #ccc;&#125;.egg_schedule_list_none .egg_icon &#123;  font-size: 2.5rem;&#125;.egg_schedule_list_none_text &#123;  padding-top: 1rem;&#125;.egg_select &#123;  position: relative;&#125;.egg_select .egg_select_input &#123;  outline: none;  border: 0.1rem solid #eee;  padding: 0.8rem;  text-align: center;  background: white;  border-radius: 0.2rem;  display: inline-block;  width: 100%;  box-sizing: border-box;&#125;.egg_select .egg_select_input::placeholder &#123;  color: #ccc;&#125;.egg_select_list &#123;  max-height: 12rem;  border-radius: 0 0 0.2rem 0.2rem;  box-shadow: 0 0.1rem 0.1rem 0.1rem #eee;  background: white;  user-select: none;  transition: 100ms ease;  scrollbar-width: thin;  overflow: auto;  opacity: 1;  z-index: 9;  width: 100%;  position: absolute;&#125;.egg_select_list.hide &#123;  opacity: 0;  visibility: hidden;&#125;.egg_select_list::-webkit-scrollbar &#123;  width: 0.4rem;  background: white;  border-radius: 0.2rem;&#125;.egg_select_list::-webkit-scrollbar-thumb &#123;  background: #ccc;  border-radius: 0.2rem;&#125;.egg_select_list .egg_select_item &#123;  padding: 0.6rem 1rem;  border-bottom: 0.1rem solid #eee;  cursor: pointer;  color: #333;  transition: 300ms ease;  text-align: center;&#125;.egg_select_list .egg_select_item.selected &#123;  font-weight: bold;  background: #f6f6f6;&#125;.egg_select_list .egg_select_item.active &#123;  background: #eee;&#125;.egg_select_list .egg_select_item:hover &#123;  background: #eee;&#125;&#x27;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 嵌入样式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">GM_addStyle</span>(css);</span><br><span class="line"><span class="title function_">load</span>(<span class="function">(<span class="params">href</span>) =&gt;</span> href.<span class="title function_">match</span>(<span class="variable constant_">URL_CONFIG</span>.<span class="property">home</span>), <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化logo</span></span><br><span class="line">    <span class="title function_">initLogo</span>();</span><br><span class="line">    <span class="comment">// 页面提示</span></span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;进入主页面!&#x27;</span>);</span><br><span class="line">    <span class="comment">// 初始化主题</span></span><br><span class="line">    <span class="title function_">initThemeColor</span>();</span><br><span class="line">    <span class="comment">// 初始化任务配置</span></span><br><span class="line">    <span class="title function_">initTaskConfig</span>();</span><br><span class="line">    <span class="comment">// 初始化设置</span></span><br><span class="line">    <span class="title function_">initSettings</span>();</span><br><span class="line">    <span class="comment">// 设置字体</span></span><br><span class="line">    <span class="title function_">initFontSize</span>();</span><br><span class="line">    <span class="comment">// 初始化主页面</span></span><br><span class="line">    <span class="title function_">initMainListener</span>();</span><br><span class="line">    <span class="comment">// 初始化提示</span></span><br><span class="line">    <span class="title function_">renderTip</span>();</span><br><span class="line">    <span class="comment">// 渲染面板</span></span><br><span class="line">    <span class="title function_">renderPanel</span>();</span><br><span class="line">    <span class="comment">// 渲染窗口</span></span><br><span class="line">    <span class="title function_">renderFrame</span>();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">load</span>(<span class="function">(<span class="params">href</span>) =&gt;</span> href === <span class="title function_">GM_getValue</span>(<span class="string">&#x27;readingUrl&#x27;</span>), <span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 页面提示</span></span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;进入文章选读页面!&#x27;</span>);</span><br><span class="line">    <span class="comment">// 初始化主题</span></span><br><span class="line">    <span class="title function_">initThemeColor</span>();</span><br><span class="line">    <span class="comment">// 初始化设置</span></span><br><span class="line">    <span class="title function_">initSettings</span>();</span><br><span class="line">    <span class="comment">// 设置字体</span></span><br><span class="line">    <span class="title function_">initFontSize</span>();</span><br><span class="line">    <span class="comment">// 最大阅读</span></span><br><span class="line">    <span class="title function_">initMaxRead</span>();</span><br><span class="line">    <span class="comment">// 初始化子页面</span></span><br><span class="line">    <span class="title function_">initChildListener</span>();</span><br><span class="line">    <span class="comment">// 初始化提示</span></span><br><span class="line">    <span class="title function_">renderTip</span>();</span><br><span class="line">    <span class="comment">// 处理文章</span></span><br><span class="line">    <span class="title function_">handleNews</span>();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">load</span>(<span class="function">(<span class="params">href</span>) =&gt;</span> href === <span class="title function_">GM_getValue</span>(<span class="string">&#x27;watchingUrl&#x27;</span>), <span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 页面提示</span></span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;进入视听学习页面!&#x27;</span>);</span><br><span class="line">    <span class="comment">// 初始化主题</span></span><br><span class="line">    <span class="title function_">initThemeColor</span>();</span><br><span class="line">    <span class="comment">// 初始化设置</span></span><br><span class="line">    <span class="title function_">initSettings</span>();</span><br><span class="line">    <span class="comment">// 设置字体</span></span><br><span class="line">    <span class="title function_">initFontSize</span>();</span><br><span class="line">    <span class="comment">// 最大视听</span></span><br><span class="line">    <span class="title function_">initMaxWatch</span>();</span><br><span class="line">    <span class="comment">// 初始化子页面</span></span><br><span class="line">    <span class="title function_">initChildListener</span>();</span><br><span class="line">    <span class="comment">// 初始化提示</span></span><br><span class="line">    <span class="title function_">renderTip</span>();</span><br><span class="line">    <span class="comment">// 处理视频</span></span><br><span class="line">    <span class="title function_">handleVideo</span>();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">load</span>(<span class="function">(<span class="params">href</span>) =&gt;</span> href === <span class="variable constant_">URL_CONFIG</span>.<span class="property">examPractice</span>, <span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 页面提示</span></span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;进入每日答题页面!&#x27;</span>);</span><br><span class="line">    <span class="comment">// 初始化主题</span></span><br><span class="line">    <span class="title function_">initThemeColor</span>();</span><br><span class="line">    <span class="comment">// 初始化设置</span></span><br><span class="line">    <span class="title function_">initSettings</span>();</span><br><span class="line">    <span class="comment">// 设置字体</span></span><br><span class="line">    <span class="title function_">initFontSize</span>();</span><br><span class="line">    <span class="comment">// 初始化子页面</span></span><br><span class="line">    <span class="title function_">initChildListener</span>();</span><br><span class="line">    <span class="comment">// 初始化提示</span></span><br><span class="line">    <span class="title function_">renderTip</span>();</span><br><span class="line">    <span class="comment">// 创建答题按钮</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">renderExamBtn</span>();</span><br><span class="line">    <span class="comment">// 开始答题</span></span><br><span class="line">    <span class="title function_">doingExam</span>(<span class="title class_">ExamType</span>.<span class="property">PRACTICE</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">load</span>(<span class="function">(<span class="params">href</span>) =&gt;</span> href.<span class="title function_">includes</span>(<span class="variable constant_">URL_CONFIG</span>.<span class="property">examPaper</span>), <span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 页面提示</span></span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;进入专项练习页面!&#x27;</span>);</span><br><span class="line">    <span class="comment">// 初始化主题</span></span><br><span class="line">    <span class="title function_">initThemeColor</span>();</span><br><span class="line">    <span class="comment">// 初始化设置</span></span><br><span class="line">    <span class="title function_">initSettings</span>();</span><br><span class="line">    <span class="comment">// 设置字体</span></span><br><span class="line">    <span class="title function_">initFontSize</span>();</span><br><span class="line">    <span class="comment">// 初始化子页面</span></span><br><span class="line">    <span class="title function_">initChildListener</span>();</span><br><span class="line">    <span class="comment">// 初始化提示</span></span><br><span class="line">    <span class="title function_">renderTip</span>();</span><br><span class="line">    <span class="comment">// 创建答题按钮</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">renderExamBtn</span>();</span><br><span class="line">    <span class="comment">// 开始答题</span></span><br><span class="line">    <span class="title function_">doingExam</span>(<span class="title class_">ExamType</span>.<span class="property">PAPER</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 初始化logo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initLogo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`%c tech-study.js %c <span class="subst">$&#123;version&#125;</span> `</span>, <span class="string">&#x27;background:dodgerblue;color:white;font-size:15px;border-radius:4px 0 0 4px;padding:2px 0;&#x27;</span>, <span class="string">&#x27;background:black;color:gold;font-size:15px;border-radius:0 4px 4px 0;padding:2px 0;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 初始化配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initTaskConfig</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> configTemp = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title function_">GM_getValue</span>(<span class="string">&#x27;taskConfig&#x27;</span>));</span><br><span class="line">        <span class="keyword">if</span> (configTemp &amp;&amp; <span class="title class_">Array</span>.<span class="title function_">isArray</span>(configTemp)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (configTemp.<span class="property">length</span> === taskConfig.<span class="property">length</span>) &#123;</span><br><span class="line">                taskConfig.<span class="title function_">forEach</span>(<span class="function">(<span class="params">task, i</span>) =&gt;</span> &#123;</span><br><span class="line">                    task.<span class="property">active</span> = configTemp[i].<span class="property">active</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (e) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 初始化配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initSettings</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> settingsTemp = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title function_">GM_getValue</span>(<span class="string">&#x27;studySettings&#x27;</span>));</span><br><span class="line">        <span class="keyword">if</span> (settingsTemp &amp;&amp; <span class="title class_">Array</span>.<span class="title function_">isArray</span>(settingsTemp)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (settingsTemp.<span class="property">length</span> === settings.<span class="property">length</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">in</span> settingsTemp) &#123;</span><br><span class="line">                    settings[i] = settingsTemp[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (e) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 初始化配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initFontSize</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 移动端</span></span><br><span class="line">    <span class="keyword">const</span> moblie = <span class="title function_">hasMobile</span>();</span><br><span class="line">    <span class="keyword">if</span> (moblie) &#123;</span><br><span class="line">        <span class="comment">// 清除缩放</span></span><br><span class="line">        <span class="keyword">const</span> meta = $$(<span class="string">&#x27;meta[name=viewport]&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (meta) &#123;</span><br><span class="line">            meta.<span class="property">content</span> = <span class="string">&#x27;initial-scale=0, user-scalable=yes&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 缩放比例</span></span><br><span class="line">        <span class="keyword">const</span> scale = ~~(<span class="variable language_">window</span>.<span class="property">innerWidth</span> / <span class="variable language_">window</span>.<span class="property">outerWidth</span>) || <span class="number">1</span>;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">style</span>.<span class="title function_">setProperty</span>(<span class="string">&#x27;--scale&#x27;</span>, <span class="title class_">String</span>(scale));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 初始化最大阅读时长</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initMaxRead</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> maxReadTemp = <span class="title function_">GM_getValue</span>(<span class="string">&#x27;maxRead&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (maxReadTemp) &#123;</span><br><span class="line">            maxRead.<span class="property">value</span> = maxReadTemp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (error) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 初始化最大视听时长</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initMaxWatch</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> maxWatchTemp = <span class="title function_">GM_getValue</span>(<span class="string">&#x27;maxWatch&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (maxWatchTemp) &#123;</span><br><span class="line">            maxWatch.<span class="property">value</span> = maxWatchTemp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (error) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 初始化主题色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initThemeColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 监听主题变化</span></span><br><span class="line">        <span class="title function_">watch</span>(themeColor, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 设置主题</span></span><br><span class="line">            <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">style</span>.<span class="title function_">setProperty</span>(<span class="string">&#x27;--themeColor&#x27;</span>, themeColor.<span class="property">value</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主题色</span></span><br><span class="line">        <span class="keyword">const</span> themeColorTemp = <span class="title function_">GM_getValue</span>(<span class="string">&#x27;themeColor&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (themeColorTemp) &#123;</span><br><span class="line">            themeColor.<span class="property">value</span> = themeColorTemp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (error) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 渲染提示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">renderTip</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> tipWrap = <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">        <span class="attr">class</span>: <span class="string">&#x27;egg_tip_wrap&#x27;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title function_">mountElement</span>(tipWrap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 渲染答题按钮</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">renderExamBtn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> titles = <span class="keyword">await</span> $_(<span class="string">&#x27;.title&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (titles.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="comment">// 插入节点</span></span><br><span class="line">        titles[<span class="number">0</span>].<span class="property">parentNode</span>?.<span class="title function_">insertBefore</span>(<span class="title class_">ExamBtn</span>().<span class="property">ele</span>, titles[<span class="number">0</span>].<span class="property">nextSibling</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 渲染面板</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">renderPanel</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 面板</span></span><br><span class="line">    <span class="keyword">const</span> panel = <span class="title class_">Panel</span>();</span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="title function_">mountElement</span>(panel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 渲染窗口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">renderFrame</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 窗口</span></span><br><span class="line">    <span class="keyword">const</span> frame = <span class="title class_">Frame</span>();</span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="title function_">mountElement</span>(frame);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 答案 API */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 获取答案</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getAnswer</span>(<span class="params">question</span>) &#123;</span><br><span class="line">    <span class="comment">// 数据</span></span><br><span class="line">    <span class="keyword">const</span> data = &#123;</span><br><span class="line">        <span class="attr">txt_name</span>: <span class="title function_">md5</span>(question),</span><br><span class="line">        <span class="attr">password</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(data);</span><br><span class="line">        <span class="comment">// 请求</span></span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="variable constant_">API_CONFIG</span>.<span class="property">answerSearch</span>, &#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">            <span class="attr">mode</span>: <span class="string">&#x27;cors&#x27;</span>,</span><br><span class="line">            <span class="attr">headers</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">body</span>: params.<span class="title function_">toString</span>(),</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 请求成功</span></span><br><span class="line">        <span class="keyword">if</span> (res.<span class="property">ok</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> result = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">            <span class="keyword">const</span> &#123; data, status &#125; = result;</span><br><span class="line">            <span class="keyword">if</span> (status !== <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 答案列表</span></span><br><span class="line">                <span class="keyword">const</span> answerList = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(data.<span class="property">txt_content</span>);</span><br><span class="line">                <span class="comment">// 答案</span></span><br><span class="line">                <span class="keyword">const</span> answers = answerList[<span class="number">0</span>].<span class="property">content</span>.<span class="title function_">split</span>(<span class="regexp">/[;\s]/</span>);</span><br><span class="line">                <span class="keyword">return</span> answers;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (error) &#123; &#125;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 保存答案</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">saveAnswer</span>(<span class="params">question, answer</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 内容</span></span><br><span class="line">        <span class="keyword">const</span> content = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>([&#123; <span class="attr">title</span>: <span class="title function_">md5</span>(question), <span class="attr">content</span>: answer &#125;]);</span><br><span class="line">        <span class="comment">// 数据</span></span><br><span class="line">        <span class="keyword">const</span> data = &#123;</span><br><span class="line">            <span class="attr">txt_name</span>: <span class="title function_">md5</span>(question),</span><br><span class="line">            <span class="attr">txt_content</span>: content,</span><br><span class="line">            <span class="attr">password</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="attr">v_id</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">const</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(data);</span><br><span class="line">        <span class="comment">// 请求</span></span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="variable constant_">API_CONFIG</span>.<span class="property">answerSave</span>, &#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">            <span class="attr">mode</span>: <span class="string">&#x27;cors&#x27;</span>,</span><br><span class="line">            <span class="attr">headers</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">body</span>: params.<span class="title function_">toString</span>(),</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 请求成功</span></span><br><span class="line">        <span class="keyword">if</span> (res.<span class="property">ok</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (error) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 数据 API */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 获取新闻数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getNewsList</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 随机</span></span><br><span class="line">    <span class="keyword">const</span> randNum = ~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="variable constant_">API_CONFIG</span>.<span class="property">todayNews</span>.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取重要新闻</span></span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="variable constant_">API_CONFIG</span>.<span class="property">todayNews</span>[randNum], &#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 请求成功</span></span><br><span class="line">        <span class="keyword">if</span> (res.<span class="property">ok</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 获取视频数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getVideoList</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 随机</span></span><br><span class="line">    <span class="keyword">const</span> randNum = ~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="variable constant_">API_CONFIG</span>.<span class="property">todayVideos</span>.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取重要新闻</span></span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="variable constant_">API_CONFIG</span>.<span class="property">todayVideos</span>[randNum], &#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 请求成功</span></span><br><span class="line">        <span class="keyword">if</span> (res.<span class="property">ok</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 专项练习数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getExamPaper</span>(<span class="params">pageNo</span>) &#123;</span><br><span class="line">    <span class="comment">// 链接</span></span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">`<span class="subst">$&#123;API_CONFIG.paperList&#125;</span>?pageSize=50&amp;pageNo=<span class="subst">$&#123;pageNo&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取专项练习</span></span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">            <span class="attr">credentials</span>: <span class="string">&#x27;include&#x27;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 请求成功</span></span><br><span class="line">        <span class="keyword">if</span> (res.<span class="property">ok</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">            <span class="keyword">const</span> paperJson = <span class="built_in">decodeURIComponent</span>(<span class="built_in">escape</span>(<span class="variable language_">window</span>.<span class="title function_">atob</span>(data.<span class="property">data_str</span>.<span class="title function_">replace</span>(<span class="regexp">/-/g</span>, <span class="string">&#x27;+&#x27;</span>).<span class="title function_">replace</span>(<span class="regexp">/_/g</span>, <span class="string">&#x27;/&#x27;</span>))));</span><br><span class="line">            <span class="comment">// JSON格式化</span></span><br><span class="line">            <span class="keyword">const</span> paper = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(paperJson);</span><br><span class="line">            <span class="keyword">return</span> paper;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 生成二维码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">generateQRCode</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 推送</span></span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="variable constant_">API_CONFIG</span>.<span class="property">generateQRCode</span>, &#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">            <span class="attr">mode</span>: <span class="string">&#x27;cors&#x27;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 请求成功</span></span><br><span class="line">        <span class="keyword">if</span> (res.<span class="property">ok</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">            <span class="keyword">if</span> (data.<span class="property">success</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> data.<span class="property">result</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (error) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 用二维码登录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">loginWithQRCode</span>(<span class="params">qrCode</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(&#123;</span><br><span class="line">            qrCode,</span><br><span class="line">            <span class="attr">goto</span>: <span class="string">&#x27;https://oa.xuexi.cn&#x27;</span>,</span><br><span class="line">            <span class="attr">pdmToken</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 推送</span></span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="variable constant_">API_CONFIG</span>.<span class="property">loginWithQRCode</span>, &#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">            <span class="attr">mode</span>: <span class="string">&#x27;cors&#x27;</span>,</span><br><span class="line">            <span class="attr">credentials</span>: <span class="string">&#x27;include&#x27;</span>,</span><br><span class="line">            <span class="attr">headers</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded;charset=UTF-8&#x27;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">body</span>: params.<span class="title function_">toString</span>(),</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 请求成功</span></span><br><span class="line">        <span class="keyword">if</span> (res.<span class="property">ok</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (error) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 签名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getSign</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 推送</span></span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="variable constant_">API_CONFIG</span>.<span class="property">sign</span>, &#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">            <span class="attr">mode</span>: <span class="string">&#x27;cors&#x27;</span>,</span><br><span class="line">            <span class="attr">credentials</span>: <span class="string">&#x27;include&#x27;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 请求成功</span></span><br><span class="line">        <span class="keyword">if</span> (res.<span class="property">ok</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">            <span class="keyword">if</span> (data.<span class="property">ok</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> data.<span class="property">data</span>.<span class="property">sign</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (error) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 安全检查</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">data</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">secureCheck</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(data);</span><br><span class="line">        <span class="keyword">const</span> url = <span class="string">`<span class="subst">$&#123;API_CONFIG.secureCheck&#125;</span>?<span class="subst">$&#123;params&#125;</span>`</span>;</span><br><span class="line">        <span class="comment">// 推送</span></span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">            <span class="attr">mode</span>: <span class="string">&#x27;cors&#x27;</span>,</span><br><span class="line">            <span class="attr">credentials</span>: <span class="string">&#x27;include&#x27;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 请求成功</span></span><br><span class="line">        <span class="keyword">if</span> (res.<span class="property">ok</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">            <span class="keyword">return</span> data.<span class="property">success</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (error) &#123; &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 推送 API */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 推送</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">pushPlus</span>(<span class="params">token, title, content, template, toToken</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 参数体</span></span><br><span class="line">        <span class="keyword">const</span> body = &#123;</span><br><span class="line">            token,</span><br><span class="line">            title,</span><br><span class="line">            content,</span><br><span class="line">            template,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 好友令牌</span></span><br><span class="line">        <span class="keyword">if</span> (toToken) &#123;</span><br><span class="line">            body.<span class="property">to</span> = toToken;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 推送</span></span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="variable constant_">API_CONFIG</span>.<span class="property">push</span>, &#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">            <span class="attr">mode</span>: <span class="string">&#x27;cors&#x27;</span>,</span><br><span class="line">            <span class="attr">headers</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(body),</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 请求成功</span></span><br><span class="line">        <span class="keyword">if</span> (res.<span class="property">ok</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (error) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 用户 API */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 获取用户信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getUserInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="variable constant_">API_CONFIG</span>.<span class="property">userInfo</span>, &#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">            <span class="attr">credentials</span>: <span class="string">&#x27;include&#x27;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 请求成功</span></span><br><span class="line">        <span class="keyword">if</span> (res.<span class="property">ok</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 获取总积分</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getTotalScore</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="variable constant_">API_CONFIG</span>.<span class="property">totalScore</span>, &#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">            <span class="attr">credentials</span>: <span class="string">&#x27;include&#x27;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 请求成功</span></span><br><span class="line">        <span class="keyword">if</span> (res.<span class="property">ok</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">            <span class="comment">// 总分</span></span><br><span class="line">            <span class="keyword">const</span> &#123; score &#125; = data;</span><br><span class="line">            <span class="keyword">return</span> score;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 获取当天总积分</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getTodayScore</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="variable constant_">API_CONFIG</span>.<span class="property">todayScore</span>, &#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">            <span class="attr">credentials</span>: <span class="string">&#x27;include&#x27;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 请求成功</span></span><br><span class="line">        <span class="keyword">if</span> (res.<span class="property">ok</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">            <span class="comment">// 当天总分</span></span><br><span class="line">            <span class="keyword">const</span> &#123; score &#125; = data;</span><br><span class="line">            <span class="keyword">return</span> score;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 获取任务列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getTaskList</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="variable constant_">API_CONFIG</span>.<span class="property">taskList</span>, &#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">            <span class="attr">credentials</span>: <span class="string">&#x27;include&#x27;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 请求成功</span></span><br><span class="line">        <span class="keyword">if</span> (res.<span class="property">ok</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">            <span class="comment">// 进度和当天总分</span></span><br><span class="line">            <span class="keyword">const</span> &#123; taskProgress &#125; = data;</span><br><span class="line">            <span class="keyword">return</span> taskProgress;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* task·配置 */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 单次最大新闻数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> maxNewsNum = <span class="number">6</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 单次最大视频数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> maxVideoNum = <span class="number">6</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 二维码最大刷新次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> maxRefreshCount = <span class="number">10</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 二维码自动刷新间隔</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> autoRefreshQRCodeInterval = <span class="number">100000</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 视频静音</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> muted = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> url配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">URL_CONFIG</span> = &#123;</span><br><span class="line">    <span class="comment">// 主页正则</span></span><br><span class="line">    <span class="attr">home</span>: <span class="regexp">/^https\:\/\/www\.xuexi\.cn(\/(index\.html)?)?$/</span>,</span><br><span class="line">    <span class="comment">// 主页</span></span><br><span class="line">    <span class="attr">homeOrigin</span>: <span class="string">&#x27;https://www.xuexi.cn&#x27;</span>,</span><br><span class="line">    <span class="comment">// 每日答题页面</span></span><br><span class="line">    <span class="attr">examPractice</span>: <span class="string">&#x27;https://pc.xuexi.cn/points/exam-practice.html&#x27;</span>,</span><br><span class="line">    <span class="comment">// 专项练习页面</span></span><br><span class="line">    <span class="attr">examPaper</span>: <span class="string">&#x27;https://pc.xuexi.cn/points/exam-paper-detail.html&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> api配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">API_CONFIG</span> = &#123;</span><br><span class="line">    <span class="comment">// 用户信息</span></span><br><span class="line">    <span class="attr">userInfo</span>: <span class="string">&#x27;https://pc-api.xuexi.cn/open/api/user/info&#x27;</span>,</span><br><span class="line">    <span class="comment">// 总分</span></span><br><span class="line">    <span class="attr">totalScore</span>: <span class="string">&#x27;https://pc-proxy-api.xuexi.cn/delegate/score/get&#x27;</span>,</span><br><span class="line">    <span class="comment">// 当天分数</span></span><br><span class="line">    <span class="attr">todayScore</span>: <span class="string">&#x27;https://pc-proxy-api.xuexi.cn/delegate/score/today/query&#x27;</span>,</span><br><span class="line">    <span class="comment">// 任务列表</span></span><br><span class="line">    <span class="attr">taskList</span>: <span class="string">&#x27;https://pc-proxy-api.xuexi.cn/delegate/score/days/listScoreProgress?sence=score&amp;deviceType=2&#x27;</span>,</span><br><span class="line">    <span class="comment">// 新闻数据</span></span><br><span class="line">    <span class="attr">todayNews</span>: [</span><br><span class="line">        <span class="string">&#x27;https://www.xuexi.cn/lgdata/35il6fpn0ohq.json&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://www.xuexi.cn/lgdata/1ap1igfgdn2.json&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://www.xuexi.cn/lgdata/vdppiu92n1.json&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://www.xuexi.cn/lgdata/152mdtl3qn1.json&#x27;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 视频数据</span></span><br><span class="line">    <span class="attr">todayVideos</span>: [</span><br><span class="line">        <span class="string">&#x27;https://www.xuexi.cn/lgdata/525pi8vcj24p.json&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://www.xuexi.cn/lgdata/11vku6vt6rgom.json&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://www.xuexi.cn/lgdata/2qfjjjrprmdh.json&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://www.xuexi.cn/lgdata/3o3ufqgl8rsn.json&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://www.xuexi.cn/lgdata/591ht3bc22pi.json&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://www.xuexi.cn/lgdata/1742g60067k.json&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://www.xuexi.cn/lgdata/1novbsbi47k.json&#x27;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 专项练习列表</span></span><br><span class="line">    <span class="attr">paperList</span>: <span class="string">&#x27;https://pc-proxy-api.xuexi.cn/api/exam/service/paper/pc/list&#x27;</span>,</span><br><span class="line">    <span class="comment">// 文本服务器保存答案</span></span><br><span class="line">    <span class="attr">answerSave</span>: <span class="string">&#x27;https://a6.qikekeji.com/txt/data/save&#x27;</span>,</span><br><span class="line">    <span class="comment">// 文本服务器获取答案</span></span><br><span class="line">    <span class="attr">answerSearch</span>: <span class="string">&#x27;https://a6.qikekeji.com/txt/data/detail&#x27;</span>,</span><br><span class="line">    <span class="comment">// 推送</span></span><br><span class="line">    <span class="attr">push</span>: <span class="string">&#x27;https://www.pushplus.plus/send&#x27;</span>,</span><br><span class="line">    <span class="comment">// 生成二维码</span></span><br><span class="line">    <span class="attr">generateQRCode</span>: <span class="string">&#x27;https://login.xuexi.cn/user/qrcode/generate&#x27;</span>,</span><br><span class="line">    <span class="comment">//二维码登录</span></span><br><span class="line">    <span class="attr">loginWithQRCode</span>: <span class="string">&#x27;https://login.xuexi.cn/login/login_with_qr&#x27;</span>,</span><br><span class="line">    <span class="comment">// 签名</span></span><br><span class="line">    <span class="attr">sign</span>: <span class="string">&#x27;https://pc-api.xuexi.cn/open/api/sns/sign&#x27;</span>,</span><br><span class="line">    <span class="comment">// 安全检查</span></span><br><span class="line">    <span class="attr">secureCheck</span>: <span class="string">&#x27;https://pc-api.xuexi.cn/login/secure_check&#x27;</span>,</span><br><span class="line">    <span class="comment">// 二维码</span></span><br><span class="line">    <span class="attr">qrcode</span>: <span class="string">&#x27;https://api.qrserver.com/v1/create-qr-code&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 版本号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> version = <span class="string">&#x27;1.7.0&#x27;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 任务类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">TaskType</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">TaskType</span>) &#123;</span><br><span class="line">    <span class="title class_">TaskType</span>[<span class="title class_">TaskType</span>[<span class="string">&quot;LOGIN&quot;</span>] = <span class="number">0</span>] = <span class="string">&quot;LOGIN&quot;</span>;</span><br><span class="line">    <span class="title class_">TaskType</span>[<span class="title class_">TaskType</span>[<span class="string">&quot;READ&quot;</span>] = <span class="number">1</span>] = <span class="string">&quot;READ&quot;</span>;</span><br><span class="line">    <span class="title class_">TaskType</span>[<span class="title class_">TaskType</span>[<span class="string">&quot;WATCH&quot;</span>] = <span class="number">2</span>] = <span class="string">&quot;WATCH&quot;</span>;</span><br><span class="line">    <span class="title class_">TaskType</span>[<span class="title class_">TaskType</span>[<span class="string">&quot;PRACTICE&quot;</span>] = <span class="number">3</span>] = <span class="string">&quot;PRACTICE&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">TaskType</span> || (<span class="title class_">TaskType</span> = &#123;&#125;));</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 设置类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">SettingType</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">SettingType</span>) &#123;</span><br><span class="line">    <span class="title class_">SettingType</span>[<span class="title class_">SettingType</span>[<span class="string">&quot;AUTO_START&quot;</span>] = <span class="number">0</span>] = <span class="string">&quot;AUTO_START&quot;</span>;</span><br><span class="line">    <span class="title class_">SettingType</span>[<span class="title class_">SettingType</span>[<span class="string">&quot;SAME_TAB&quot;</span>] = <span class="number">1</span>] = <span class="string">&quot;SAME_TAB&quot;</span>;</span><br><span class="line">    <span class="title class_">SettingType</span>[<span class="title class_">SettingType</span>[<span class="string">&quot;SILENT_RUN&quot;</span>] = <span class="number">2</span>] = <span class="string">&quot;SILENT_RUN&quot;</span>;</span><br><span class="line">    <span class="title class_">SettingType</span>[<span class="title class_">SettingType</span>[<span class="string">&quot;SCHEDULE_RUN&quot;</span>] = <span class="number">3</span>] = <span class="string">&quot;SCHEDULE_RUN&quot;</span>;</span><br><span class="line">    <span class="title class_">SettingType</span>[<span class="title class_">SettingType</span>[<span class="string">&quot;RANDOM_EXAM&quot;</span>] = <span class="number">4</span>] = <span class="string">&quot;RANDOM_EXAM&quot;</span>;</span><br><span class="line">    <span class="title class_">SettingType</span>[<span class="title class_">SettingType</span>[<span class="string">&quot;REMOTE_PUSH&quot;</span>] = <span class="number">5</span>] = <span class="string">&quot;REMOTE_PUSH&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">SettingType</span> || (<span class="title class_">SettingType</span> = &#123;&#125;));</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 进度类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">TaskStatusType</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">TaskStatusType</span>) &#123;</span><br><span class="line">    <span class="title class_">TaskStatusType</span>[<span class="title class_">TaskStatusType</span>[<span class="string">&quot;LOADING&quot;</span>] = <span class="number">0</span>] = <span class="string">&quot;LOADING&quot;</span>;</span><br><span class="line">    <span class="title class_">TaskStatusType</span>[<span class="title class_">TaskStatusType</span>[<span class="string">&quot;LOADED&quot;</span>] = <span class="number">1</span>] = <span class="string">&quot;LOADED&quot;</span>;</span><br><span class="line">    <span class="title class_">TaskStatusType</span>[<span class="title class_">TaskStatusType</span>[<span class="string">&quot;START&quot;</span>] = <span class="number">2</span>] = <span class="string">&quot;START&quot;</span>;</span><br><span class="line">    <span class="title class_">TaskStatusType</span>[<span class="title class_">TaskStatusType</span>[<span class="string">&quot;PAUSE&quot;</span>] = <span class="number">3</span>] = <span class="string">&quot;PAUSE&quot;</span>;</span><br><span class="line">    <span class="title class_">TaskStatusType</span>[<span class="title class_">TaskStatusType</span>[<span class="string">&quot;FINISH&quot;</span>] = <span class="number">4</span>] = <span class="string">&quot;FINISH&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">TaskStatusType</span> || (<span class="title class_">TaskStatusType</span> = &#123;&#125;));</span><br><span class="line"><span class="comment">// 当前订阅</span></span><br><span class="line"><span class="keyword">let</span> currentSub;</span><br><span class="line"><span class="comment">// 订阅</span></span><br><span class="line"><span class="keyword">const</span> subscription = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> Proxy Map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> proxyMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 收集 Ref 依赖</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">key</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">trackRef</span> = (<span class="params">target</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 当前订阅</span></span><br><span class="line">    <span class="keyword">if</span> (!currentSub) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// target 订阅列表</span></span><br><span class="line">    <span class="keyword">let</span> subList = subscription.<span class="title function_">get</span>(target);</span><br><span class="line">    <span class="comment">// 不存在订阅列表</span></span><br><span class="line">    <span class="keyword">if</span> (!subList) &#123;</span><br><span class="line">        subList = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">        <span class="comment">// 键订阅</span></span><br><span class="line">        <span class="keyword">const</span> subkeyList = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">        <span class="comment">// 添加订阅</span></span><br><span class="line">        subkeyList.<span class="title function_">add</span>(currentSub);</span><br><span class="line">        subList.<span class="title function_">set</span>(<span class="string">&#x27;value&#x27;</span>, subkeyList);</span><br><span class="line">        subscription.<span class="title function_">set</span>(target, subList);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 键订阅</span></span><br><span class="line">    <span class="keyword">let</span> subkeyList = subList.<span class="title function_">get</span>(<span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!subkeyList) &#123;</span><br><span class="line">        <span class="comment">// 键订阅</span></span><br><span class="line">        subkeyList = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">        <span class="comment">// 添加订阅</span></span><br><span class="line">        subkeyList.<span class="title function_">add</span>(currentSub);</span><br><span class="line">        subList.<span class="title function_">set</span>(<span class="string">&#x27;value&#x27;</span>, subkeyList);</span><br><span class="line">        subscription.<span class="title function_">set</span>(target, subList);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加订阅</span></span><br><span class="line">    subkeyList.<span class="title function_">add</span>(currentSub);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 通知 Ref 订阅</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">terget</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">key</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">triggerRef</span>(<span class="params">target, newVal, oldVal</span>) &#123;</span><br><span class="line">    <span class="comment">// target 订阅列表</span></span><br><span class="line">    <span class="keyword">const</span> subList = subscription.<span class="title function_">get</span>(target);</span><br><span class="line">    <span class="keyword">if</span> (!subList) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 键订阅</span></span><br><span class="line">    <span class="keyword">let</span> subkeyList = subList.<span class="title function_">get</span>(<span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!subkeyList) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知订阅</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> subkeyList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fn <span class="keyword">instanceof</span> <span class="title class_">Function</span>) &#123;</span><br><span class="line">            <span class="title function_">fn</span>(newVal, oldVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 收集依赖</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">key</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">track</span> = (<span class="params">target, key</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 当前订阅</span></span><br><span class="line">    <span class="keyword">if</span> (!currentSub) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// proxy</span></span><br><span class="line">    <span class="keyword">const</span> proxyTarget = proxyMap.<span class="title function_">get</span>(target);</span><br><span class="line">    <span class="keyword">if</span> (!proxyTarget) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// target 订阅列表</span></span><br><span class="line">    <span class="keyword">let</span> subList = subscription.<span class="title function_">get</span>(target);</span><br><span class="line">    <span class="comment">// 不存在订阅列表</span></span><br><span class="line">    <span class="keyword">if</span> (!subList) &#123;</span><br><span class="line">        subList = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">        <span class="comment">// 键订阅</span></span><br><span class="line">        <span class="keyword">const</span> subkeyList = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">        <span class="comment">// 添加订阅</span></span><br><span class="line">        subkeyList.<span class="title function_">add</span>(currentSub);</span><br><span class="line">        subList.<span class="title function_">set</span>(key, subkeyList);</span><br><span class="line">        subscription.<span class="title function_">set</span>(target, subList);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 键订阅</span></span><br><span class="line">    <span class="keyword">let</span> subkeyList = subList.<span class="title function_">get</span>(key);</span><br><span class="line">    <span class="keyword">if</span> (!subkeyList) &#123;</span><br><span class="line">        <span class="comment">// 键订阅</span></span><br><span class="line">        subkeyList = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">        <span class="comment">// 添加订阅</span></span><br><span class="line">        subkeyList.<span class="title function_">add</span>(currentSub);</span><br><span class="line">        subList.<span class="title function_">set</span>(key, subkeyList);</span><br><span class="line">        subscription.<span class="title function_">set</span>(target, subList);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加订阅</span></span><br><span class="line">    subkeyList.<span class="title function_">add</span>(currentSub);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 通知订阅</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">terget</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">key</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, key, newVal, oldVal</span>) &#123;</span><br><span class="line">    <span class="comment">// proxy</span></span><br><span class="line">    <span class="keyword">const</span> proxyTarget = proxyMap.<span class="title function_">get</span>(target);</span><br><span class="line">    <span class="keyword">if</span> (!proxyTarget) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// proxyTarget 订阅列表</span></span><br><span class="line">    <span class="keyword">const</span> subList = subscription.<span class="title function_">get</span>(target);</span><br><span class="line">    <span class="keyword">if</span> (!subList) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 键订阅</span></span><br><span class="line">    <span class="keyword">let</span> subkeyList = subList.<span class="title function_">get</span>(key);</span><br><span class="line">    <span class="keyword">if</span> (!subkeyList) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知订阅</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> subkeyList) &#123;</span><br><span class="line">        <span class="title function_">fn</span>(newVal, oldVal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 只读键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ReactiveFlags</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">ReactiveFlags</span>) &#123;</span><br><span class="line">    <span class="title class_">ReactiveFlags</span>[<span class="string">&quot;IS_REF&quot;</span>] = <span class="string">&quot;_isRef&quot;</span>;</span><br><span class="line">    <span class="title class_">ReactiveFlags</span>[<span class="string">&quot;IS_SHALLOW&quot;</span>] = <span class="string">&quot;_isShallow&quot;</span>;</span><br><span class="line">    <span class="title class_">ReactiveFlags</span>[<span class="string">&quot;IS_REACTIVE&quot;</span>] = <span class="string">&quot;_isReactive&quot;</span>;</span><br><span class="line">    <span class="title class_">ReactiveFlags</span>[<span class="string">&quot;IS_READONLY&quot;</span>] = <span class="string">&quot;_isReadonly&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">ReactiveFlags</span> || (<span class="title class_">ReactiveFlags</span> = &#123;&#125;));</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> <span class="variable">Ref</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ref</span> &#123;</span><br><span class="line">    _isShallow = <span class="literal">false</span>;</span><br><span class="line">    _isRef = <span class="literal">true</span>;</span><br><span class="line">    _value;</span><br><span class="line">    value;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">val, shallow = <span class="literal">false</span></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> _this = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_isShallow</span> = shallow;</span><br><span class="line">        <span class="keyword">if</span> (val &amp;&amp; <span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span> &amp;&amp; shallow) &#123;</span><br><span class="line">            <span class="keyword">const</span> reactiveVal = <span class="title function_">reactive</span>(val);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_value</span> = reactiveVal;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">value</span> = reactiveVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_value</span> = val;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">value</span> = val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定义属性</span></span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>, <span class="string">&#x27;value&#x27;</span>, &#123;</span><br><span class="line">            <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="comment">// 收集依赖</span></span><br><span class="line">                <span class="title function_">trackRef</span>(<span class="variable language_">this</span>);</span><br><span class="line">                <span class="keyword">return</span> _this.<span class="property">_value</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">                <span class="comment">// 旧数据</span></span><br><span class="line">                <span class="keyword">const</span> oldVal = <span class="variable language_">this</span>.<span class="property">_value</span>;</span><br><span class="line">                <span class="comment">// 数据变化</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal !== newVal) &#123;</span><br><span class="line">                    <span class="comment">// 设置新数据值</span></span><br><span class="line">                    _this.<span class="property">_value</span> = newVal;</span><br><span class="line">                    <span class="comment">// 通知依赖</span></span><br><span class="line">                    <span class="title function_">triggerRef</span>(<span class="variable language_">this</span>, newVal, oldVal);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">toJSON</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> <span class="variable">ref</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">v</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isRef</span> = (<span class="params">v</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> !!(v &amp;&amp; v[<span class="title class_">ReactiveFlags</span>.<span class="property">IS_REF</span>]);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 浅层 shallow</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">v</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isShallow</span> = (<span class="params">v</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> !!(v &amp;&amp; v[<span class="title class_">ReactiveFlags</span>.<span class="property">IS_SHALLOW</span>]);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 创建 ref</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">v</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createRef</span> = (<span class="params">rawVal, shallow</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Ref</span>(rawVal, shallow);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 解除 ref</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">unref</span> = (<span class="params">val</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="title function_">isRef</span>(val) ? val.<span class="property">value</span> : val);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 顶层 ref</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">v</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ref</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">isRef</span>(value)</span><br><span class="line">        ? value</span><br><span class="line">        : <span class="title function_">createRef</span>(value, <span class="literal">true</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> <span class="variable">ref</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">value</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">shallowRef</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">isRef</span>(value)</span><br><span class="line">        ? value</span><br><span class="line">        : <span class="title function_">createRef</span>(value, <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 创建处理 reactive</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">isReadonly</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">isShallow</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createReactiveHandlers</span> = (<span class="params">isReadonly, isShallow</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">get</span>: <span class="title function_">createGetters</span>(isReadonly, isShallow),</span><br><span class="line">        <span class="attr">set</span>: <span class="title function_">createSetters</span>(isReadonly, isShallow),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> <span class="variable">getters</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">isReadonly</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">isShallow</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createGetters</span> = (<span class="params">isReadonly, isShallow</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_REACTIVE</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> !isReadonly;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_READONLY</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> isReadonly;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_SHALLOW</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> isShallow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结果</span></span><br><span class="line">        <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br><span class="line">        <span class="keyword">if</span> (!isReadonly) &#123;</span><br><span class="line">            <span class="comment">// 收集依赖</span></span><br><span class="line">            <span class="title function_">track</span>(target, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isShallow) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isRef</span>(res)) &#123;</span><br><span class="line">            <span class="keyword">return</span> res.<span class="property">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &amp;&amp; <span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res <span class="keyword">instanceof</span> <span class="title class_">Element</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> isReadonly ? <span class="title function_">readonly</span>(res) : <span class="title function_">reactive</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> <span class="variable">setters</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">readonly</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">shallow</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createSetters</span> = (<span class="params">readonly, shallow</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">set</span>(<span class="params">target, key, newVal, receiver</span>) &#123;</span><br><span class="line">        <span class="comment">// 只读</span></span><br><span class="line">        <span class="keyword">if</span> (readonly) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 旧值</span></span><br><span class="line">        <span class="keyword">const</span> oldVal = target[key];</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isReadonly</span>(oldVal) &amp;&amp; <span class="title function_">isRef</span>(oldVal) &amp;&amp; !<span class="title function_">isRef</span>(newVal)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!shallow) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isRef</span>(oldVal) &amp;&amp; !<span class="title function_">isRef</span>(newVal)) &#123;</span><br><span class="line">                oldVal.<span class="property">value</span> = newVal;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newVal, receiver);</span><br><span class="line">        <span class="comment">// length</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) &amp;&amp; key === <span class="string">&#x27;length&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 通知依赖</span></span><br><span class="line">            <span class="title function_">trigger</span>(target, key, newVal, oldVal);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数据变化</span></span><br><span class="line">        <span class="keyword">if</span> (oldVal !== newVal) &#123;</span><br><span class="line">            <span class="comment">// 通知依赖</span></span><br><span class="line">            <span class="title function_">trigger</span>(target, key, newVal, oldVal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> reactive object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createReactiveObj</span> = (<span class="params">target, isReadonly, shallow</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 存在 Proxy</span></span><br><span class="line">    <span class="keyword">const</span> existingProxy = proxyMap.<span class="title function_">get</span>(target);</span><br><span class="line">    <span class="keyword">if</span> (existingProxy) &#123;</span><br><span class="line">        <span class="keyword">return</span> existingProxy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新建</span></span><br><span class="line">    <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, <span class="title function_">createReactiveHandlers</span>(isReadonly, shallow));</span><br><span class="line">    proxyMap.<span class="title function_">set</span>(target, proxy);</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> <span class="variable">reactive</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isReactive</span> = (<span class="params">val</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> !!(val &amp;&amp; val[<span class="title class_">ReactiveFlags</span>.<span class="property">IS_REACTIVE</span>]);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 创建 reactive</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createReactive</span> = (<span class="params">target</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createReactiveObj</span>(target, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 顶层 reactive</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">shallowReactive</span> = (<span class="params">target</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createReactiveObj</span>(target, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> <span class="variable">reactive</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isReadonly</span> = (<span class="params">val</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> !!(val &amp;&amp; val[<span class="title class_">ReactiveFlags</span>.<span class="property">IS_READONLY</span>]);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 创建 readonly</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createReadonly</span> = (<span class="params">target</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createReactiveObj</span>(target, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 顶层 readonly</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">shallowReadonly</span> = (<span class="params">target</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createReactiveObj</span>(target, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> <span class="variable">proxy</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isProxy</span> = (<span class="params">val</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">isReactive</span>(val) || <span class="title function_">isReadonly</span>(val);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> <span class="variable">reactive</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reactive</span> = (<span class="params">target</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createReactive</span>(target);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> <span class="variable">readonly</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">readonly</span> = (<span class="params">target</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createReadonly</span>(target);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 监听数据变化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">source</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">callback</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">watch</span> = (<span class="params">source, callback, immediate = <span class="literal">false</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 立刻执行</span></span><br><span class="line">    immediate &amp;&amp; <span class="title function_">callback</span>(<span class="title function_">unref</span>(source), <span class="title function_">unref</span>(source));</span><br><span class="line">    <span class="comment">// array</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(source) &amp;&amp; source.<span class="title function_">every</span>(<span class="function">(<span class="params">s</span>) =&gt;</span> <span class="title function_">isRef</span>(s))) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">in</span> source) &#123;</span><br><span class="line">            <span class="comment">// Proxy</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isProxy</span>(source[i])) &#123;</span><br><span class="line">                <span class="title function_">watch</span>(source[i], <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> res = source.<span class="title function_">map</span>(<span class="function">(<span class="params">s</span>) =&gt;</span> <span class="title function_">unref</span>(s));</span><br><span class="line">                    <span class="title function_">callback</span>(res, res);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">watch</span>(<span class="function">() =&gt;</span> source.<span class="title function_">map</span>(<span class="function">(<span class="params">s</span>) =&gt;</span> <span class="title function_">unref</span>(s)), callback);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// function</span></span><br><span class="line">    <span class="keyword">if</span> (source <span class="keyword">instanceof</span> <span class="title class_">Function</span>) &#123;</span><br><span class="line">        <span class="title function_">watch</span>(<span class="title function_">watchEffectRef</span>(source), <span class="function">(<span class="params">n, o</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">callback</span>(<span class="title function_">unref</span>(n), <span class="title function_">unref</span>(o));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Proxy</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isProxy</span>(source)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">            currentSub = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">callback</span>(source, source);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// sub source</span></span><br><span class="line">            <span class="keyword">const</span> subSource = source[key];</span><br><span class="line">            currentSub = <span class="literal">undefined</span>;</span><br><span class="line">            <span class="title function_">watch</span>(subSource, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">callback</span>(source, source);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Ref</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isRef</span>(source)) &#123;</span><br><span class="line">        <span class="comment">// Ref.value Proxy</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isProxy</span>(source.<span class="property">value</span>)) &#123;</span><br><span class="line">            <span class="title function_">watch</span>(source.<span class="property">value</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">callback</span>(<span class="title function_">unref</span>(source), <span class="title function_">unref</span>(source));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        currentSub = callback;</span><br><span class="line">        <span class="comment">// 收集依赖</span></span><br><span class="line">        <span class="title function_">trackRef</span>(source);</span><br><span class="line">        currentSub = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 监听数据变化影响</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">callback</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">watchEffect</span> = (<span class="params">callback</span>) =&gt; &#123;</span><br><span class="line">    currentSub = callback;</span><br><span class="line">    <span class="comment">// 收集依赖</span></span><br><span class="line">    <span class="title function_">callback</span>();</span><br><span class="line">    currentSub = <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 监听影响 ref</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">refVal</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">callback</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">watchRef</span> = (<span class="params">source, callback</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 收集依赖</span></span><br><span class="line">    <span class="keyword">const</span> effectRes = <span class="title function_">shallowRef</span>(<span class="title function_">callback</span>());</span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    <span class="title function_">watch</span>(source, <span class="function">() =&gt;</span> (effectRes.<span class="property">value</span> = <span class="title function_">unref</span>(<span class="title function_">callback</span>())));</span><br><span class="line">    <span class="keyword">return</span> effectRes;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 监听影响 ref</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">refVal</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">callback</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">watchEffectRef</span> = (<span class="params">callback</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 收集依赖</span></span><br><span class="line">    <span class="keyword">const</span> effectRes = <span class="title function_">shallowRef</span>(<span class="literal">undefined</span>);</span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    <span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> (effectRes.<span class="property">value</span> = <span class="title function_">unref</span>(<span class="title function_">callback</span>())));</span><br><span class="line">    <span class="keyword">return</span> effectRes;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 创建元素节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">eleName</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">props</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">attrs</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">children</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createElementNode</span>(<span class="params">tagName, props, attrs, children, options</span>) &#123;</span><br><span class="line">    <span class="comment">// 挂载状态</span></span><br><span class="line">    <span class="keyword">let</span> beforemount = <span class="title function_">ref</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 挂载状态</span></span><br><span class="line">    <span class="keyword">let</span> mounted = <span class="title function_">ref</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">const</span> &#123; onCreated, beforeCreat, onMounted, beforeMount &#125; = options || &#123;&#125;;</span><br><span class="line">    <span class="comment">// 订阅</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">subscribe</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; onMounted, beforeMount &#125; = e;</span><br><span class="line">        <span class="keyword">if</span> (beforeMount) &#123;</span><br><span class="line">            <span class="title function_">watch</span>(beforemount, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (beforemount.<span class="property">value</span>) &#123;</span><br><span class="line">                    <span class="title function_">beforeMount</span>();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (onMounted) &#123;</span><br><span class="line">            <span class="title function_">watch</span>(mounted, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (mounted.<span class="property">value</span>) &#123;</span><br><span class="line">                    <span class="title function_">onMounted</span>();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 取消订阅</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">unsubscribe</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">//懒得写</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 创建元素前</span></span><br><span class="line">    beforeCreat &amp;&amp; <span class="title function_">beforeCreat</span>();</span><br><span class="line">    <span class="comment">// 创建普通元素</span></span><br><span class="line">    <span class="keyword">const</span> ele = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(tagName);</span><br><span class="line">    <span class="comment">// 处理属性</span></span><br><span class="line">    <span class="title function_">handleProps</span>(ele, props);</span><br><span class="line">    <span class="comment">// 处理属性</span></span><br><span class="line">    <span class="title function_">handleAttributes</span>(ele, attrs, subscribe, unsubscribe);</span><br><span class="line">    <span class="comment">// 处理子元素</span></span><br><span class="line">    <span class="title function_">handleChildren</span>(ele, children, subscribe, unsubscribe);</span><br><span class="line">    <span class="comment">// 收集挂载前</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">collectBeforeMount</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        beforemount.<span class="property">value</span> = <span class="literal">true</span>;</span><br><span class="line">        beforeMount &amp;&amp; <span class="title function_">beforeMount</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 收集挂载</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">collectOnMounted</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        mounted.<span class="property">value</span> = <span class="literal">true</span>;</span><br><span class="line">        onMounted &amp;&amp; <span class="title function_">onMounted</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 创建元素后</span></span><br><span class="line">    onCreated &amp;&amp; <span class="title function_">onCreated</span>();</span><br><span class="line">    <span class="keyword">return</span> &#123; ele, <span class="attr">beforeMount</span>: collectBeforeMount, <span class="attr">onMounted</span>: collectOnMounted &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 创建svg元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">tagName</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">props</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">attrs</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">children</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createNSElementNode</span>(<span class="params">tagName, props, attrs, children, options</span>) &#123;</span><br><span class="line">    <span class="comment">// 挂载状态</span></span><br><span class="line">    <span class="keyword">let</span> beforemount = <span class="title function_">ref</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 挂载状态</span></span><br><span class="line">    <span class="keyword">let</span> mounted = <span class="title function_">ref</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">const</span> &#123; onCreated, beforeCreat, onMounted, beforeMount &#125; = options || &#123;&#125;;</span><br><span class="line">    <span class="comment">// 订阅</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">subscribe</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; onMounted, beforeMount &#125; = e;</span><br><span class="line">        <span class="keyword">if</span> (beforeMount) &#123;</span><br><span class="line">            <span class="title function_">watch</span>(beforemount, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (beforemount.<span class="property">value</span>) &#123;</span><br><span class="line">                    <span class="title function_">beforeMount</span>();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (onMounted) &#123;</span><br><span class="line">            <span class="title function_">watch</span>(mounted, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (mounted.<span class="property">value</span>) &#123;</span><br><span class="line">                    <span class="title function_">onMounted</span>();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 取消订阅</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">unsubscribe</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">//懒得写</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 创建元素前</span></span><br><span class="line">    beforeCreat &amp;&amp; <span class="title function_">beforeCreat</span>();</span><br><span class="line">    <span class="comment">// svg元素命名空间</span></span><br><span class="line">    <span class="keyword">const</span> ns = <span class="string">&#x27;http://www.w3.org/2000/svg&#x27;</span>;</span><br><span class="line">    <span class="comment">// 创建svg元素</span></span><br><span class="line">    <span class="keyword">const</span> ele = <span class="variable language_">document</span>.<span class="title function_">createElementNS</span>(ns, tagName);</span><br><span class="line">    <span class="comment">// 处理属性</span></span><br><span class="line">    <span class="title function_">handleProps</span>(ele, props);</span><br><span class="line">    <span class="comment">// 处理属性</span></span><br><span class="line">    <span class="title function_">handleAttributes</span>(ele, attrs, subscribe, unsubscribe);</span><br><span class="line">    <span class="comment">// 处理子元素</span></span><br><span class="line">    <span class="title function_">handleChildren</span>(ele, children, subscribe, unsubscribe);</span><br><span class="line">    <span class="comment">// 收集挂载前</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">collectBeforeMount</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        beforemount.<span class="property">value</span> = <span class="literal">true</span>;</span><br><span class="line">        beforeMount &amp;&amp; <span class="title function_">beforeMount</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 收集挂载</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">collectOnMounted</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        mounted.<span class="property">value</span> = <span class="literal">true</span>;</span><br><span class="line">        onMounted &amp;&amp; <span class="title function_">onMounted</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 创建元素后</span></span><br><span class="line">    onCreated &amp;&amp; <span class="title function_">onCreated</span>();</span><br><span class="line">    <span class="keyword">return</span> &#123; ele, <span class="attr">beforeMount</span>: collectBeforeMount, <span class="attr">onMounted</span>: collectOnMounted &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 处理属性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">ele</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">props</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleProps</span>(<span class="params">ele, props</span>) &#123;</span><br><span class="line">    <span class="comment">// props属性设置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">        <span class="comment">// Ref 属性</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isRef</span>(props[key])) &#123;</span><br><span class="line">            <span class="keyword">const</span> refVal = props[key];</span><br><span class="line">            <span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> (ele[key] = refVal.<span class="property">value</span>));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ele[key] = props[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 处理svg属性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">ele</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">attrs</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleAttributes</span>(<span class="params">ele, attrs, subscribe, unsubscribe</span>) &#123;</span><br><span class="line">    <span class="comment">// 属性存在</span></span><br><span class="line">    <span class="keyword">if</span> (attrs) &#123;</span><br><span class="line">        <span class="comment">// attrs属性设置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> attrs) &#123;</span><br><span class="line">            <span class="comment">// 处理普通属性</span></span><br><span class="line">            <span class="title function_">handleAttribute</span>(ele, key, attrs[key], subscribe, unsubscribe);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 处理事件选项</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleEventOptions</span>(<span class="params">option</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (option.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> options = &#123;</span><br><span class="line">            <span class="attr">capture</span>: option.<span class="title function_">includes</span>(<span class="string">&#x27;capture&#x27;</span>),</span><br><span class="line">            <span class="attr">once</span>: option.<span class="title function_">includes</span>(<span class="string">&#x27;once&#x27;</span>),</span><br><span class="line">            <span class="attr">passive</span>: option.<span class="title function_">includes</span>(<span class="string">&#x27;passive&#x27;</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> options;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 处理属性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">ele</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">key</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">value</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleAttribute</span>(<span class="params">ele, key, value, subscribe, unsubscribe</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理完的key</span></span><br><span class="line">    <span class="keyword">const</span> formatKey = key.<span class="title function_">toLowerCase</span>();</span><br><span class="line">    <span class="comment">// 事件绑定</span></span><br><span class="line">    <span class="keyword">if</span> (formatKey.<span class="title function_">startsWith</span>(<span class="string">&#x27;on&#x27;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 事件监听</span></span><br><span class="line">        <span class="keyword">const</span> [event] = formatKey.<span class="title function_">match</span>(<span class="regexp">/(?&lt;=on).*/</span>);</span><br><span class="line">        <span class="comment">// 事件类型</span></span><br><span class="line">        <span class="keyword">if</span> (event) &#123;</span><br><span class="line">            <span class="keyword">const</span> [eventType, ...option] = event.<span class="title function_">split</span>(<span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">            <span class="keyword">const</span> options = <span class="title function_">handleEventOptions</span>(option);</span><br><span class="line">            <span class="comment">// Ref 函数</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isRef</span>(value)) &#123;</span><br><span class="line">                <span class="keyword">const</span> refVal = value;</span><br><span class="line">                <span class="keyword">const</span> refListener = <span class="title function_">watchRef</span>(refVal, <span class="function">() =&gt;</span> refVal.<span class="property">value</span></span><br><span class="line">                    ? <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">                        option.<span class="title function_">includes</span>(<span class="string">&#x27;prevent&#x27;</span>) &amp;&amp; e.<span class="title function_">preventDefault</span>();</span><br><span class="line">                        option.<span class="title function_">includes</span>(<span class="string">&#x27;stop&#x27;</span>) &amp;&amp; e.<span class="title function_">stopPropagation</span>();</span><br><span class="line">                        <span class="keyword">const</span> callback = refVal.<span class="property">value</span>;</span><br><span class="line">                        <span class="title function_">callback</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    : <span class="literal">undefined</span>);</span><br><span class="line">                <span class="comment">// 设置事件监听</span></span><br><span class="line">                refListener.<span class="property">value</span> &amp;&amp;</span><br><span class="line">                    ele.<span class="title function_">addEventListener</span>(eventType, refListener.<span class="property">value</span>, options);</span><br><span class="line">                <span class="comment">// 监听事件变化</span></span><br><span class="line">                <span class="title function_">watch</span>(refListener, <span class="function">(<span class="params">newVal, oldVal</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 移除旧事件监听</span></span><br><span class="line">                    oldVal &amp;&amp; ele.<span class="title function_">removeEventListener</span>(eventType, oldVal);</span><br><span class="line">                    <span class="comment">// 设置新事件监听</span></span><br><span class="line">                    newVal &amp;&amp; ele.<span class="title function_">addEventListener</span>(eventType, newVal, options);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 普通函数</span></span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Function</span>) &#123;</span><br><span class="line">                <span class="comment">// 设置事件监听</span></span><br><span class="line">                ele.<span class="title function_">addEventListener</span>(eventType, value, options);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 特殊属性</span></span><br><span class="line">    <span class="keyword">const</span> specificAttrs = [<span class="string">&#x27;checked&#x27;</span>, <span class="string">&#x27;selected&#x27;</span>, <span class="string">&#x27;disabled&#x27;</span>, <span class="string">&#x27;enabled&#x27;</span>];</span><br><span class="line">    <span class="comment">// 特殊 key</span></span><br><span class="line">    <span class="keyword">if</span> (specificAttrs.<span class="title function_">includes</span>(formatKey)) &#123;</span><br><span class="line">        <span class="comment">// Ref</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isRef</span>(value)) &#123;</span><br><span class="line">            <span class="keyword">const</span> refVal = value;</span><br><span class="line">            <span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (refVal.<span class="property">value</span>) &#123;</span><br><span class="line">                    ele.<span class="title function_">setAttribute</span>(formatKey, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    ele.<span class="title function_">removeAttribute</span>(formatKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 普通属性值</span></span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            ele.<span class="title function_">setAttribute</span>(formatKey, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ele.<span class="title function_">removeAttribute</span>(formatKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ref 属性名</span></span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&#x27;ref&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// Ref</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isRef</span>(value)) &#123;</span><br><span class="line">            <span class="keyword">const</span> refVal = value;</span><br><span class="line">            subscribe &amp;&amp;</span><br><span class="line">                <span class="title function_">subscribe</span>(&#123;</span><br><span class="line">                    <span class="title function_">onMounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">                        refVal.<span class="property">value</span> = ele;</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Ref 函数</span></span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Function</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> refFn = value;</span><br><span class="line">            subscribe &amp;&amp;</span><br><span class="line">                <span class="title function_">subscribe</span>(&#123;</span><br><span class="line">                    <span class="title function_">onMounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">                        <span class="title function_">refFn</span>(ele);</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// xlink命名空间</span></span><br><span class="line">    <span class="keyword">if</span> (key.<span class="title function_">startsWith</span>(<span class="string">&#x27;xlink:&#x27;</span>)) &#123;</span><br><span class="line">        <span class="comment">// xlink属性命名空间</span></span><br><span class="line">        <span class="keyword">const</span> attrNS = <span class="string">&#x27;http://www.w3.org/1999/xlink&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            ele.<span class="title function_">setAttributeNS</span>(attrNS, key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ele.<span class="title function_">removeAttributeNS</span>(attrNS, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Ref 属性值</span></span><br><span class="line">    <span class="keyword">if</span> (key &amp;&amp; <span class="title function_">isRef</span>(value)) &#123;</span><br><span class="line">        <span class="keyword">const</span> refVal = value;</span><br><span class="line">        <span class="comment">// 监听影响</span></span><br><span class="line">        <span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            ele.<span class="title function_">setAttribute</span>(key, refVal.<span class="property">value</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 普通属性</span></span><br><span class="line">    <span class="keyword">if</span> (key) &#123;</span><br><span class="line">        <span class="comment">// 普通属性</span></span><br><span class="line">        ele.<span class="title function_">setAttribute</span>(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 处理子元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">ele</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">children</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleChildren</span>(<span class="params">ele, children, subscribe, unsubscribe</span>) &#123;</span><br><span class="line">    <span class="comment">// Ref</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isRef</span>(children)) &#123;</span><br><span class="line">        <span class="comment">// 注释元素</span></span><br><span class="line">        <span class="keyword">const</span> comment = <span class="variable language_">document</span>.<span class="title function_">createComment</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">        <span class="comment">// 监听元素变化</span></span><br><span class="line">        <span class="title function_">watch</span>(children, <span class="title function_">async</span> (newEle, oldEle) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (!newEle &amp;&amp; oldEle) &#123;</span><br><span class="line">                <span class="comment">// Promise</span></span><br><span class="line">                <span class="keyword">if</span> (oldEle <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> oldEleRes = <span class="keyword">await</span> oldEle;</span><br><span class="line">                    <span class="keyword">if</span> (oldEleRes) &#123;</span><br><span class="line">                        oldEleRes.<span class="title function_">forEach</span>(<span class="function">(<span class="params">ele</span>) =&gt;</span> &#123;</span><br><span class="line">                            unsubscribe &amp;&amp; <span class="title function_">unsubscribe</span>(ele);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// unPromise</span></span><br><span class="line">                <span class="keyword">if</span> (!(oldEle <span class="keyword">instanceof</span> <span class="title class_">Promise</span>)) &#123;</span><br><span class="line">                    oldEle.<span class="title function_">forEach</span>(<span class="function">(<span class="params">ele</span>) =&gt;</span> &#123;</span><br><span class="line">                        unsubscribe &amp;&amp; <span class="title function_">unsubscribe</span>(ele);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                ele.<span class="title function_">replaceChildren</span>(comment);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newEle) &#123;</span><br><span class="line">                <span class="keyword">if</span> (oldEle) &#123;</span><br><span class="line">                    <span class="comment">// Promise</span></span><br><span class="line">                    <span class="keyword">if</span> (oldEle <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">                        <span class="keyword">const</span> oldEleRes = <span class="keyword">await</span> oldEle;</span><br><span class="line">                        <span class="keyword">if</span> (oldEleRes) &#123;</span><br><span class="line">                            oldEleRes.<span class="title function_">forEach</span>(<span class="function">(<span class="params">ele</span>) =&gt;</span> &#123;</span><br><span class="line">                                unsubscribe &amp;&amp; <span class="title function_">unsubscribe</span>(ele);</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// unPromise</span></span><br><span class="line">                    <span class="keyword">if</span> (!(oldEle <span class="keyword">instanceof</span> <span class="title class_">Promise</span>)) &#123;</span><br><span class="line">                        oldEle.<span class="title function_">forEach</span>(<span class="function">(<span class="params">ele</span>) =&gt;</span> &#123;</span><br><span class="line">                            unsubscribe &amp;&amp; <span class="title function_">unsubscribe</span>(ele);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Promise</span></span><br><span class="line">                <span class="keyword">if</span> (newEle <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> newEleRes = <span class="keyword">await</span> newEle;</span><br><span class="line">                    <span class="keyword">if</span> (newEleRes) &#123;</span><br><span class="line">                        <span class="keyword">const</span> eles = newEleRes.<span class="title function_">map</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (v.<span class="property">beforeMount</span> || v.<span class="property">onMounted</span>) &#123;</span><br><span class="line">                                subscribe &amp;&amp; <span class="title function_">subscribe</span>(v);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">return</span> v.<span class="property">ele</span>;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        ele.<span class="title function_">replaceChildren</span>(<span class="title function_">createElementBlock</span>(eles));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// unPromise</span></span><br><span class="line">                <span class="keyword">const</span> eles = newEle.<span class="title function_">map</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v.<span class="property">beforeMount</span> || v.<span class="property">onMounted</span>) &#123;</span><br><span class="line">                        subscribe &amp;&amp; <span class="title function_">subscribe</span>(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> v.<span class="property">ele</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">                ele.<span class="title function_">replaceChildren</span>(<span class="title function_">createElementBlock</span>(eles));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// Promise</span></span><br><span class="line">        <span class="keyword">if</span> (children.<span class="property">value</span> <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">            <span class="comment">// 插入注释元素</span></span><br><span class="line">            ele.<span class="title function_">appendChild</span>(comment);</span><br><span class="line">            children.<span class="property">value</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">childrenEle</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (childrenEle) &#123;</span><br><span class="line">                    <span class="keyword">const</span> eles = childrenEle.<span class="title function_">map</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (v.<span class="property">beforeMount</span> || v.<span class="property">onMounted</span>) &#123;</span><br><span class="line">                            subscribe &amp;&amp; <span class="title function_">subscribe</span>(v);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> v.<span class="property">ele</span>;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    ele.<span class="title function_">replaceChildren</span>(<span class="title function_">createElementBlock</span>(eles));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// unPromise</span></span><br><span class="line">        <span class="keyword">if</span> (children.<span class="property">value</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> eles = children.<span class="property">value</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (v.<span class="property">beforeMount</span> || v.<span class="property">onMounted</span>) &#123;</span><br><span class="line">                    subscribe &amp;&amp; <span class="title function_">subscribe</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> v.<span class="property">ele</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            ele.<span class="title function_">appendChild</span>(<span class="title function_">createElementBlock</span>(eles));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入元素</span></span><br><span class="line">        ele.<span class="title function_">appendChild</span>(comment);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Promise</span></span><br><span class="line">    <span class="keyword">if</span> (children <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">        <span class="comment">// 注释元素</span></span><br><span class="line">        <span class="keyword">const</span> comment = <span class="variable language_">document</span>.<span class="title function_">createComment</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">        <span class="comment">// 插入注释元素</span></span><br><span class="line">        ele.<span class="title function_">appendChild</span>(comment);</span><br><span class="line">        <span class="comment">// 异步替换元素</span></span><br><span class="line">        children.<span class="title function_">then</span>(<span class="function">(<span class="params">childEle</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (childEle) &#123;</span><br><span class="line">                <span class="keyword">const</span> &#123; beforeMount, onMounted &#125; = childEle;</span><br><span class="line">                <span class="keyword">if</span> (beforeMount || onMounted) &#123;</span><br><span class="line">                    subscribe &amp;&amp; <span class="title function_">subscribe</span>(childEle);</span><br><span class="line">                &#125;</span><br><span class="line">                comment.<span class="title function_">replaceWith</span>(childEle.<span class="property">ele</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Array</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(children)) &#123;</span><br><span class="line">        <span class="comment">// 处理过后</span></span><br><span class="line">        <span class="keyword">const</span> resChildren = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">in</span> children) &#123;</span><br><span class="line">            <span class="keyword">const</span> child = children[i];</span><br><span class="line">            <span class="comment">// Ref</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isRef</span>(child)) &#123;</span><br><span class="line">                <span class="comment">// 注释</span></span><br><span class="line">                <span class="keyword">const</span> comment = <span class="variable language_">document</span>.<span class="title function_">createComment</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">                <span class="comment">// 监听影响</span></span><br><span class="line">                <span class="title function_">watch</span>(child, <span class="title function_">async</span> (newEle, oldEle) =&gt; &#123;</span><br><span class="line">                    <span class="comment">// 新元素为空</span></span><br><span class="line">                    <span class="keyword">if</span> (!newEle &amp;&amp; oldEle) &#123;</span><br><span class="line">                        <span class="comment">// Promise</span></span><br><span class="line">                        <span class="keyword">if</span> (oldEle <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">                            <span class="keyword">const</span> oldEleRes = <span class="keyword">await</span> oldEle;</span><br><span class="line">                            <span class="keyword">if</span> (oldEleRes) &#123;</span><br><span class="line">                                <span class="title function_">handleChangeElement</span>(newEle, oldEleRes, comment, subscribe, unsubscribe);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="title function_">handleChangeElement</span>(newEle, oldEle, comment, subscribe, unsubscribe);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 旧元素为空</span></span><br><span class="line">                    <span class="keyword">if</span> (newEle &amp;&amp; !oldEle) &#123;</span><br><span class="line">                        <span class="comment">// Promise</span></span><br><span class="line">                        <span class="keyword">if</span> (newEle <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">                            <span class="keyword">const</span> newEleRes = <span class="keyword">await</span> newEle;</span><br><span class="line">                            <span class="keyword">if</span> (newEleRes) &#123;</span><br><span class="line">                                <span class="title function_">handleChangeElement</span>(newEleRes, oldEle, comment, subscribe, unsubscribe);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="title function_">handleChangeElement</span>(newEle, oldEle, comment, subscribe, unsubscribe);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 存在</span></span><br><span class="line">                    <span class="keyword">if</span> (newEle &amp;&amp; oldEle) &#123;</span><br><span class="line">                        <span class="comment">// Promise</span></span><br><span class="line">                        <span class="keyword">if</span> (newEle <span class="keyword">instanceof</span> <span class="title class_">Promise</span> &amp;&amp; oldEle <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">                            <span class="keyword">const</span> newEleRes = <span class="keyword">await</span> newEle;</span><br><span class="line">                            <span class="keyword">const</span> oldEleRes = <span class="keyword">await</span> oldEle;</span><br><span class="line">                            <span class="comment">// 处理元素变化</span></span><br><span class="line">                            <span class="title function_">handleChangeElement</span>(newEleRes, oldEleRes, comment, subscribe, unsubscribe);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// Promise</span></span><br><span class="line">                        <span class="keyword">if</span> (newEle <span class="keyword">instanceof</span> <span class="title class_">Promise</span> &amp;&amp; !(oldEle <span class="keyword">instanceof</span> <span class="title class_">Promise</span>)) &#123;</span><br><span class="line">                            <span class="keyword">const</span> newEleRes = <span class="keyword">await</span> newEle;</span><br><span class="line">                            <span class="comment">// 处理元素变化</span></span><br><span class="line">                            <span class="title function_">handleChangeElement</span>(newEleRes, oldEle, comment, subscribe, unsubscribe);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// Promise</span></span><br><span class="line">                        <span class="keyword">if</span> (!(newEle <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &amp;&amp; oldEle <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">                            <span class="keyword">const</span> oldEleRes = <span class="keyword">await</span> oldEle;</span><br><span class="line">                            <span class="comment">// 处理元素变化</span></span><br><span class="line">                            <span class="title function_">handleChangeElement</span>(newEle, oldEleRes, comment, subscribe, unsubscribe);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 非 Promise</span></span><br><span class="line">                        <span class="keyword">if</span> (!(oldEle <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &amp;&amp; !(newEle <span class="keyword">instanceof</span> <span class="title class_">Promise</span>)) &#123;</span><br><span class="line">                            <span class="comment">// 处理元素变化</span></span><br><span class="line">                            <span class="title function_">handleChangeElement</span>(newEle, oldEle, comment, subscribe, unsubscribe);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">// Promise</span></span><br><span class="line">                <span class="keyword">if</span> (child.<span class="property">value</span> <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">                    <span class="comment">// 注释</span></span><br><span class="line">                    resChildren[i] = &#123; <span class="attr">ele</span>: comment &#125;;</span><br><span class="line">                    <span class="comment">// 异步替换</span></span><br><span class="line">                    child.<span class="property">value</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">childEle</span>) =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (childEle) &#123;</span><br><span class="line">                            <span class="keyword">const</span> &#123; beforeMount, onMounted &#125; = childEle;</span><br><span class="line">                            <span class="keyword">if</span> (beforeMount || onMounted) &#123;</span><br><span class="line">                                subscribe &amp;&amp; <span class="title function_">subscribe</span>(childEle);</span><br><span class="line">                            &#125;</span><br><span class="line">                            comment.<span class="title function_">replaceWith</span>(childEle.<span class="property">ele</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// unPromise</span></span><br><span class="line">                <span class="keyword">if</span> (child.<span class="property">value</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> &#123; beforeMount, onMounted, ele &#125; = child.<span class="property">value</span>;</span><br><span class="line">                    resChildren[i] = &#123; ele, beforeMount, onMounted &#125;;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                resChildren[i] = &#123; <span class="attr">ele</span>: comment &#125;;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Promise</span></span><br><span class="line">            <span class="keyword">if</span> (child <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">                <span class="comment">// 注释</span></span><br><span class="line">                <span class="keyword">const</span> comment = <span class="variable language_">document</span>.<span class="title function_">createComment</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">                resChildren[i] = &#123; <span class="attr">ele</span>: comment &#125;;</span><br><span class="line">                <span class="comment">// 异步替换元素</span></span><br><span class="line">                child.<span class="title function_">then</span>(<span class="function">(<span class="params">childEle</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (childEle) &#123;</span><br><span class="line">                        <span class="keyword">const</span> &#123; beforeMount, onMounted &#125; = childEle;</span><br><span class="line">                        <span class="keyword">if</span> (beforeMount || onMounted) &#123;</span><br><span class="line">                            subscribe &amp;&amp; <span class="title function_">subscribe</span>(childEle);</span><br><span class="line">                        &#125;</span><br><span class="line">                        comment.<span class="title function_">replaceWith</span>(childEle.<span class="property">ele</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 普通元素</span></span><br><span class="line">            <span class="keyword">if</span> (child) &#123;</span><br><span class="line">                <span class="keyword">const</span> &#123; beforeMount, onMounted, ele &#125; = child;</span><br><span class="line">                resChildren[i] = &#123; ele, beforeMount, onMounted &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> eles = resChildren.<span class="title function_">map</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (v.<span class="property">beforeMount</span> || v.<span class="property">onMounted</span>) &#123;</span><br><span class="line">                subscribe &amp;&amp; <span class="title function_">subscribe</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> v.<span class="property">ele</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 插入元素</span></span><br><span class="line">        ele.<span class="title function_">appendChild</span>(<span class="title function_">createElementBlock</span>(eles));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 普通元素</span></span><br><span class="line">    <span class="keyword">if</span> (children) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; beforeMount, onMounted &#125; = children;</span><br><span class="line">        <span class="keyword">if</span> (beforeMount || onMounted) &#123;</span><br><span class="line">            subscribe &amp;&amp; <span class="title function_">subscribe</span>(children);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入元素</span></span><br><span class="line">        ele.<span class="title function_">appendChild</span>(children.<span class="property">ele</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 元素变化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">newEle</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">oldEle</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">comment</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleChangeElement</span>(<span class="params">newEle, oldEle, comment, subscribe, unsubscribe</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newEle &amp;&amp; oldEle) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; beforeMount, onMounted &#125; = newEle;</span><br><span class="line">        <span class="keyword">if</span> (beforeMount || onMounted) &#123;</span><br><span class="line">            subscribe &amp;&amp; <span class="title function_">subscribe</span>(newEle);</span><br><span class="line">        &#125;</span><br><span class="line">        oldEle.<span class="property">ele</span>.<span class="title function_">replaceWith</span>(newEle.<span class="property">ele</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newEle &amp;&amp; !oldEle) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; beforeMount, onMounted &#125; = newEle;</span><br><span class="line">        <span class="keyword">if</span> (beforeMount || onMounted) &#123;</span><br><span class="line">            subscribe &amp;&amp; <span class="title function_">subscribe</span>(newEle);</span><br><span class="line">        &#125;</span><br><span class="line">        comment.<span class="title function_">replaceWith</span>(newEle.<span class="property">ele</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!newEle &amp;&amp; oldEle) &#123;</span><br><span class="line">        unsubscribe &amp;&amp; <span class="title function_">unsubscribe</span>(oldEle);</span><br><span class="line">        oldEle.<span class="property">ele</span>.<span class="title function_">replaceWith</span>(comment);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 创建文字节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">text</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createTextNode</span>(<span class="params">text, options</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; onCreated, beforeCreat, onMounted, beforeMount &#125; = options || &#123;&#125;;</span><br><span class="line">    <span class="comment">// 创建元素前</span></span><br><span class="line">    beforeCreat &amp;&amp; <span class="title function_">beforeCreat</span>();</span><br><span class="line">    <span class="comment">// Ref</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isRef</span>(text)) &#123;</span><br><span class="line">        <span class="comment">// ref</span></span><br><span class="line">        <span class="keyword">const</span> refVal = text;</span><br><span class="line">        <span class="comment">// 元素</span></span><br><span class="line">        <span class="keyword">const</span> ele = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">        <span class="comment">// 订阅变化</span></span><br><span class="line">        <span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            ele.<span class="property">data</span> = refVal.<span class="property">value</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 创建元素后</span></span><br><span class="line">        onCreated &amp;&amp; <span class="title function_">onCreated</span>();</span><br><span class="line">        <span class="keyword">return</span> &#123; ele, beforeMount, onMounted &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建元素后</span></span><br><span class="line">    onCreated &amp;&amp; <span class="title function_">onCreated</span>();</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">ele</span>: <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="title class_">String</span>(text)), beforeMount, onMounted &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 挂载元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">eleOptions</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">parent</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mountElement</span>(<span class="params">eleOptions, parent = <span class="variable language_">document</span>.body</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; ele, beforeMount, onMounted &#125; = eleOptions;</span><br><span class="line">    <span class="keyword">if</span> (ele) &#123;</span><br><span class="line">        <span class="comment">// 触发挂载前事件</span></span><br><span class="line">        beforeMount &amp;&amp; <span class="title function_">beforeMount</span>();</span><br><span class="line">        parent.<span class="title function_">appendChild</span>(ele);</span><br><span class="line">        <span class="comment">// 挂在后</span></span><br><span class="line">        onMounted &amp;&amp; <span class="title function_">onMounted</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 选择器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">selector</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">$$</span>(<span class="params">selector, parent = <span class="variable language_">document</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(parent.<span class="title function_">querySelectorAll</span>(selector));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 异步选择器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">selector</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">$_</span>(<span class="params">selector, parent = <span class="variable language_">document</span>, timeout</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> selectors = <span class="title class_">Array</span>.<span class="title function_">from</span>(parent.<span class="title function_">querySelectorAll</span>(selector));</span><br><span class="line">            <span class="comment">// 存在元素</span></span><br><span class="line">            <span class="keyword">if</span> (selectors.<span class="property">length</span>) &#123;</span><br><span class="line">                <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">                <span class="title function_">resolve</span>(selectors);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 超时</span></span><br><span class="line">        <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">                <span class="title function_">resolve</span>([]);</span><br><span class="line">            &#125;, timeout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 创建元素块</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">eles</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createElementBlock</span>(<span class="params">eles</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> fragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">in</span> eles) &#123;</span><br><span class="line">        fragment.<span class="title function_">appendChild</span>(eles[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fragment;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 打印日志</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">text</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">...text</span>) &#123;</span><br><span class="line">    <span class="title function_">printColor</span>(<span class="string">&#x27;dodgerblue&#x27;</span>, ...text);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 打印错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">text</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">...text</span>) &#123;</span><br><span class="line">    <span class="title function_">printColor</span>(<span class="string">&#x27;red&#x27;</span>, ...text);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 打印信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">text</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">info</span>(<span class="params">...text</span>) &#123;</span><br><span class="line">    <span class="title function_">printColor</span>(<span class="string">&#x27;yellow&#x27;</span>, ...text);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 打印颜色</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">text</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">color</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printColor</span>(<span class="params">color, ...text</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> textFormatted = text</span><br><span class="line">        .<span class="title function_">map</span>(<span class="function">(<span class="params">t</span>) =&gt;</span> (<span class="keyword">typeof</span> t === <span class="string">&#x27;object&#x27;</span> ? <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(t) : <span class="title class_">String</span>(t)))</span><br><span class="line">        .<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`%c[<span class="subst">$&#123;formatDateTime()&#125;</span>] %c<span class="subst">$&#123;textFormatted&#125;</span>`</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">`color: <span class="subst">$&#123;color&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> html进度条</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">title</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">percent</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getProgressHTML</span>(<span class="params">title, percent</span>) &#123;</span><br><span class="line">    <span class="comment">// html</span></span><br><span class="line">    <span class="keyword">const</span> progressHTML = <span class="string">`&lt;div</span></span><br><span class="line"><span class="string">    style=&quot;</span></span><br><span class="line"><span class="string">      display: flex;</span></span><br><span class="line"><span class="string">      align-items: center;</span></span><br><span class="line"><span class="string">      justify-content: space-between;</span></span><br><span class="line"><span class="string">      padding: 1px 0;</span></span><br><span class="line"><span class="string">    &quot;</span></span><br><span class="line"><span class="string">  &gt;</span></span><br><span class="line"><span class="string">    &lt;span&gt;<span class="subst">$&#123;title&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">    &lt;span&gt;<span class="subst">$&#123;getHighlightHTML(percent)&#125;</span> %&lt;/span&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;div</span></span><br><span class="line"><span class="string">    style=&quot;</span></span><br><span class="line"><span class="string">      background: white;</span></span><br><span class="line"><span class="string">      border-radius: 10px;</span></span><br><span class="line"><span class="string">      height: 10px;</span></span><br><span class="line"><span class="string">      border: 1px solid #eee;</span></span><br><span class="line"><span class="string">      flex-shrink: 1;</span></span><br><span class="line"><span class="string">    &quot;</span></span><br><span class="line"><span class="string">  &gt;</span></span><br><span class="line"><span class="string">    &lt;div</span></span><br><span class="line"><span class="string">      style=&quot;</span></span><br><span class="line"><span class="string">        background: linear-gradient(to left, #188fff80, #1890ff);</span></span><br><span class="line"><span class="string">        height: 100%;</span></span><br><span class="line"><span class="string">        width: <span class="subst">$&#123;percent&#125;</span>%;</span></span><br><span class="line"><span class="string">        border-radius: 10px;</span></span><br><span class="line"><span class="string">      &quot;</span></span><br><span class="line"><span class="string">    &gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;`</span>;</span><br><span class="line">    <span class="keyword">return</span> progressHTML;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> html高亮文本</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">text</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getHighlightHTML</span>(<span class="params">text</span>) &#123;</span><br><span class="line">    <span class="comment">// html</span></span><br><span class="line">    <span class="keyword">const</span> highlightHTML = <span class="string">`&lt;span style=&quot;color: #1890ff&quot;&gt;<span class="subst">$&#123;text&#125;</span>&lt;/span&gt;`</span>;</span><br><span class="line">    <span class="keyword">return</span> highlightHTML;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 二维码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">src</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getImgHTML</span>(<span class="params">src</span>) &#123;</span><br><span class="line">    <span class="comment">// 图片</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">     &lt;div style=&quot;padding: 10px 0&quot;&gt;</span></span><br><span class="line"><span class="string">     &lt;div</span></span><br><span class="line"><span class="string">       style=&quot;</span></span><br><span class="line"><span class="string">         display: flex;</span></span><br><span class="line"><span class="string">         justify-content: center;</span></span><br><span class="line"><span class="string">         align-items: center;</span></span><br><span class="line"><span class="string">         padding: 20px;</span></span><br><span class="line"><span class="string">         background: #f7f7f7;</span></span><br><span class="line"><span class="string">         border-radius: 10px;</span></span><br><span class="line"><span class="string">       &quot;</span></span><br><span class="line"><span class="string">     &gt;</span></span><br><span class="line"><span class="string">         &lt;img src=&quot;<span class="subst">$&#123;src&#125;</span>&quot; style=&quot;width:200px;height:200px;&quot; /&gt;</span></span><br><span class="line"><span class="string">       &lt;/div&gt;</span></span><br><span class="line"><span class="string">     &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 创建模态框</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> options 选项</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createModal</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="comment">// 配置</span></span><br><span class="line">    <span class="keyword">const</span> &#123; title, subTitle = <span class="string">&#x27;&#x27;</span>, to = <span class="string">&#x27;用户&#x27;</span>, content, type, <span class="keyword">from</span> = <span class="string">&#x27;tech-study.js&#x27;</span>, &#125; = options;</span><br><span class="line">    <span class="comment">// 内容文本</span></span><br><span class="line">    <span class="keyword">let</span> contentText = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(content)) &#123;</span><br><span class="line">        contentText = content.<span class="title function_">map</span>(<span class="function">(<span class="params">ct</span>) =&gt;</span> <span class="string">`&lt;div&gt;<span class="subst">$&#123;ct&#125;</span>&lt;/div&gt;`</span>).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        contentText = content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 日期</span></span><br><span class="line">    <span class="keyword">const</span> dateTime = <span class="title function_">formatDateTime</span>();</span><br><span class="line">    <span class="comment">// 类型html</span></span><br><span class="line">    <span class="keyword">let</span> typeHTML = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (type &amp;&amp; type.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type === <span class="string">&#x27;info&#x27;</span>) &#123;</span><br><span class="line">            typeHTML = <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;svg</span></span><br><span class="line"><span class="string">       viewBox=&quot;64 64 896 896&quot;</span></span><br><span class="line"><span class="string">       style=&quot;color: #1890ff; width: 18px; height: 18px&quot;</span></span><br><span class="line"><span class="string">       fill=&quot;currentColor&quot;</span></span><br><span class="line"><span class="string">       aria-hidden=&quot;true&quot;</span></span><br><span class="line"><span class="string">     &gt;</span></span><br><span class="line"><span class="string">       &lt;path</span></span><br><span class="line"><span class="string">         d=&quot;M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z&quot;</span></span><br><span class="line"><span class="string">       &gt;&lt;/path&gt;</span></span><br><span class="line"><span class="string">     &lt;/svg&gt;`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type === <span class="string">&#x27;warn&#x27;</span>) &#123;</span><br><span class="line">            typeHTML = <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;svg</span></span><br><span class="line"><span class="string">        viewBox=&quot;64 64 896 896&quot;</span></span><br><span class="line"><span class="string">        style=&quot;color: #faad14; width: 18px; height: 18px&quot;</span></span><br><span class="line"><span class="string">        fill=&quot;currentColor&quot;</span></span><br><span class="line"><span class="string">        aria-hidden=&quot;true&quot;</span></span><br><span class="line"><span class="string">      &gt;</span></span><br><span class="line"><span class="string">        &lt;path</span></span><br><span class="line"><span class="string">          d=&quot;M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z&quot;</span></span><br><span class="line"><span class="string">        &gt;&lt;/path&gt;</span></span><br><span class="line"><span class="string">      &lt;/svg&gt;</span></span><br><span class="line"><span class="string">      `</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type === <span class="string">&#x27;success&#x27;</span>) &#123;</span><br><span class="line">            typeHTML = <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;svg</span></span><br><span class="line"><span class="string">        viewBox=&quot;64 64 896 896&quot;</span></span><br><span class="line"><span class="string">        style=&quot;color: #52c41a; width: 18px; height: 18px&quot;</span></span><br><span class="line"><span class="string">        fill=&quot;currentColor&quot;</span></span><br><span class="line"><span class="string">        aria-hidden=&quot;true&quot;</span></span><br><span class="line"><span class="string">      &gt;</span></span><br><span class="line"><span class="string">        &lt;path</span></span><br><span class="line"><span class="string">          d=&quot;M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z&quot;</span></span><br><span class="line"><span class="string">        &gt;&lt;/path&gt;</span></span><br><span class="line"><span class="string">      &lt;/svg&gt;</span></span><br><span class="line"><span class="string">      `</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type === <span class="string">&#x27;fail&#x27;</span>) &#123;</span><br><span class="line">            typeHTML = <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;svg</span></span><br><span class="line"><span class="string">        viewBox=&quot;64 64 896 896&quot;</span></span><br><span class="line"><span class="string">        style=&quot;color: #ff4d4f; width: 18px; height: 18px&quot;</span></span><br><span class="line"><span class="string">        fill=&quot;currentColor&quot;</span></span><br><span class="line"><span class="string">        aria-hidden=&quot;true&quot;</span></span><br><span class="line"><span class="string">      &gt;</span></span><br><span class="line"><span class="string">        &lt;path</span></span><br><span class="line"><span class="string">          d=&quot;M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm165.4 618.2l-66-.3L512 563.4l-99.3 118.4-66.1.3c-4.4 0-8-3.5-8-8 0-1.9.7-3.7 1.9-5.2l130.1-155L340.5 359a8.32 8.32 0 01-1.9-5.2c0-4.4 3.6-8 8-8l66.1.3L512 464.6l99.3-118.4 66-.3c4.4 0 8 3.5 8 8 0 1.9-.7 3.7-1.9 5.2L553.5 514l130 155c1.2 1.5 1.9 3.3 1.9 5.2 0 4.4-3.6 8-8 8z&quot;</span></span><br><span class="line"><span class="string">        &gt;&lt;/path&gt;</span></span><br><span class="line"><span class="string">      &lt;/svg&gt;</span></span><br><span class="line"><span class="string">      `</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">const</span> typeWrap = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;span</span></span><br><span class="line"><span class="string">    style=&quot;</span></span><br><span class="line"><span class="string">      padding-right: 5px;</span></span><br><span class="line"><span class="string">      display: flex;</span></span><br><span class="line"><span class="string">      justify-content: center;</span></span><br><span class="line"><span class="string">      align-items: center;</span></span><br><span class="line"><span class="string">    &quot;</span></span><br><span class="line"><span class="string">  &gt;</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;typeHTML&#125;</span></span></span><br><span class="line"><span class="string">  &lt;/span&gt;</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">    <span class="comment">// 基础html</span></span><br><span class="line">    <span class="keyword">const</span> baseHTML = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div</span></span><br><span class="line"><span class="string">  style=&quot;</span></span><br><span class="line"><span class="string">    padding: 5px;</span></span><br><span class="line"><span class="string">    display: flex;</span></span><br><span class="line"><span class="string">    justify-content: center;</span></span><br><span class="line"><span class="string">    align-items: center;</span></span><br><span class="line"><span class="string">  &quot;</span></span><br><span class="line"><span class="string">&gt;</span></span><br><span class="line"><span class="string">  &lt;div</span></span><br><span class="line"><span class="string">    style=&quot;</span></span><br><span class="line"><span class="string">      background: #ffffff;</span></span><br><span class="line"><span class="string">      box-shadow: 1px 1px 8px -1px #dadada;</span></span><br><span class="line"><span class="string">      padding: 5px 10px;</span></span><br><span class="line"><span class="string">      border-radius: 5px;</span></span><br><span class="line"><span class="string">      width: 100%;</span></span><br><span class="line"><span class="string">    &quot;</span></span><br><span class="line"><span class="string">  &gt;</span></span><br><span class="line"><span class="string">    &lt;div</span></span><br><span class="line"><span class="string">      style=&quot;</span></span><br><span class="line"><span class="string">        display: flex;</span></span><br><span class="line"><span class="string">        justify-content: space-between;</span></span><br><span class="line"><span class="string">        padding: 5px;</span></span><br><span class="line"><span class="string">        border-bottom: 1px solid #eee;</span></span><br><span class="line"><span class="string">      &quot;</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">      &lt;div style=&quot;display: flex; justify-content: center; align-items: center&quot;&gt;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;typeWrap&#125;</span></span></span><br><span class="line"><span class="string">        &lt;span style=&quot;padding-left: 5px; font-size: 18px&quot;&gt;<span class="subst">$&#123;title&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;div style=&quot;font-size: 16px; color: #999&quot;&gt;<span class="subst">$&#123;subTitle&#125;</span>&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div style=&quot;padding:10px 5px; font-size: 16px; min-height: 80px&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;getHighlightHTML(to)&#125;</span>, 你好!</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;div style=&quot;line-height: 28px;&quot;&gt;<span class="subst">$&#123;contentText&#125;</span>&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div</span></span><br><span class="line"><span class="string">      style=&quot;</span></span><br><span class="line"><span class="string">        font-size: 14px;</span></span><br><span class="line"><span class="string">        padding: 5px;</span></span><br><span class="line"><span class="string">        border-top: 1px solid #eee;</span></span><br><span class="line"><span class="string">        display: flex;</span></span><br><span class="line"><span class="string">        justify-content: space-between;</span></span><br><span class="line"><span class="string">        align-items: center;</span></span><br><span class="line"><span class="string">      &quot;</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">      &lt;div style=&quot;color: #999&quot;&gt;<span class="subst">$&#123;dateTime&#125;</span>&lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;span&gt;来自&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;span style=&quot;color: #1890ff; padding-left: 1px&quot;&gt;<span class="subst">$&#123;<span class="keyword">from</span>&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">    <span class="keyword">return</span> baseHTML;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 推送消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">pushMessage</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="comment">// 选项</span></span><br><span class="line">    <span class="keyword">const</span> &#123; title, content, template, fromToken, toToken &#125; = options;</span><br><span class="line">    <span class="comment">// 推送</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">pushPlus</span>(fromToken, title, content, template, toToken);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 推送模态框</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">pushModal</span>(<span class="params">options, fromToken, toToken</span>) &#123;</span><br><span class="line">    <span class="comment">// html</span></span><br><span class="line">    <span class="keyword">const</span> html = <span class="title function_">createModal</span>(options);</span><br><span class="line">    <span class="comment">// 推送</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">pushMessage</span>(&#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;消息提示&#x27;</span>,</span><br><span class="line">        <span class="attr">content</span>: html,</span><br><span class="line">        fromToken,</span><br><span class="line">        toToken,</span><br><span class="line">        <span class="attr">template</span>: <span class="string">&#x27;html&#x27;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (res &amp;&amp; res.<span class="property">code</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 创建随机点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bounds 范围</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createRandomPoint</span>(<span class="params">bounds</span>) &#123;</span><br><span class="line">    <span class="comment">// 范围</span></span><br><span class="line">    <span class="keyword">const</span> &#123; x, y, width, height &#125; = bounds;</span><br><span class="line">    <span class="comment">// 横坐标</span></span><br><span class="line">    <span class="keyword">const</span> randX = x + <span class="title class_">Math</span>.<span class="title function_">random</span>() * width * <span class="number">0.5</span> + width * <span class="number">0.25</span>;</span><br><span class="line">    <span class="comment">// 纵坐标</span></span><br><span class="line">    <span class="keyword">const</span> randY = y + <span class="title class_">Math</span>.<span class="title function_">random</span>() * height * <span class="number">0.5</span> + height * <span class="number">0.25</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">x</span>: randX,</span><br><span class="line">        <span class="attr">y</span>: randY,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 生成随机路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">start</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">end</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">steps</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createRandomPath</span>(<span class="params">start, end, steps</span>) &#123;</span><br><span class="line">    <span class="comment">// 最小水平增量</span></span><br><span class="line">    <span class="keyword">const</span> minDeltaX = (end.<span class="property">x</span> - start.<span class="property">x</span>) / steps;</span><br><span class="line">    <span class="comment">// 最大垂直增量</span></span><br><span class="line">    <span class="keyword">const</span> maxDeltaY = (end.<span class="property">y</span> - start.<span class="property">y</span>) / steps;</span><br><span class="line">    <span class="keyword">const</span> path = [];</span><br><span class="line">    <span class="comment">// 开始节点</span></span><br><span class="line">    path.<span class="title function_">push</span>(start);</span><br><span class="line">    <span class="comment">// 插入点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; steps; i++) &#123;</span><br><span class="line">        <span class="comment">// 横坐标</span></span><br><span class="line">        <span class="keyword">const</span> x = path[i].<span class="property">x</span> + <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">5</span> + minDeltaX;</span><br><span class="line">        <span class="comment">// 纵坐标</span></span><br><span class="line">        <span class="keyword">const</span> y = path[i].<span class="property">y</span> +</span><br><span class="line">            <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">5</span> * <span class="title class_">Math</span>.<span class="title function_">pow</span>(-<span class="number">1</span>, ~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">2</span> + <span class="number">1</span>)) +</span><br><span class="line">            maxDeltaY;</span><br><span class="line">        path.<span class="title function_">push</span>(&#123;</span><br><span class="line">            x,</span><br><span class="line">            y,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 随机数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateNumAsChar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">10</span>)).<span class="title function_">toString</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 随机大写字母</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateUpperAsChar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">26</span>) + <span class="number">65</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 随机小写字母</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateLowerAsChar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">26</span>) + <span class="number">97</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 随机混合字符</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">length</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateMix</span>(<span class="params">length = <span class="number">6</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 随机字符串</span></span><br><span class="line">    <span class="keyword">const</span> randomText = [];</span><br><span class="line">    <span class="comment">// 生成器</span></span><br><span class="line">    <span class="keyword">const</span> typeGenerator = [</span><br><span class="line">        generateNumAsChar,</span><br><span class="line">        generateUpperAsChar,</span><br><span class="line">        generateLowerAsChar,</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">if</span> (length) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 随机位置</span></span><br><span class="line">            <span class="keyword">const</span> randomIndex = ~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * typeGenerator.<span class="property">length</span>);</span><br><span class="line">            randomText.<span class="title function_">push</span>(typeGenerator[randomIndex]());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> randomText.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 格式化日期时间数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">num</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">formatDateNum</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num &lt; <span class="number">10</span> ? <span class="string">`0<span class="subst">$&#123;num&#125;</span>`</span> : <span class="string">`<span class="subst">$&#123;num&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 格式化日期时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">time</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@example</span></span></span><br><span class="line"><span class="comment"> * formatDateTime() -&gt; &quot;2022-09-01 08:00:00&quot;</span></span><br><span class="line"><span class="comment"> * formatDateTime(new Date()) -&gt; &quot;2022-09-01 08:00:00&quot;</span></span><br><span class="line"><span class="comment"> * formatDateTime(Date.now()) -&gt; &quot;2022-09-01 08:00:00&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">formatDateTime</span>(<span class="params">time = <span class="built_in">Date</span>.now()</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>(time);</span><br><span class="line">    <span class="keyword">const</span> s = date.<span class="title function_">getSeconds</span>();</span><br><span class="line">    <span class="keyword">const</span> min = date.<span class="title function_">getMinutes</span>();</span><br><span class="line">    <span class="keyword">const</span> h = date.<span class="title function_">getHours</span>();</span><br><span class="line">    <span class="keyword">const</span> d = date.<span class="title function_">getDate</span>();</span><br><span class="line">    <span class="keyword">const</span> m = date.<span class="title function_">getMonth</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> y = date.<span class="title function_">getFullYear</span>();</span><br><span class="line">    <span class="comment">// 日期</span></span><br><span class="line">    <span class="keyword">const</span> dateText = [y, m, d].<span class="title function_">map</span>(formatDateNum).<span class="title function_">join</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    <span class="comment">// 时间</span></span><br><span class="line">    <span class="keyword">const</span> timeText = [h, min, s].<span class="title function_">map</span>(formatDateNum).<span class="title function_">join</span>(<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">    <span class="comment">// 日期时间</span></span><br><span class="line">    <span class="keyword">const</span> dateTimeText = <span class="string">`<span class="subst">$&#123;dateText&#125;</span> <span class="subst">$&#123;timeText&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">return</span> dateTimeText;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 格式化时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">time</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@example</span></span></span><br><span class="line"><span class="comment"> * formatTime() -&gt; &quot;08:00:00&quot;</span></span><br><span class="line"><span class="comment"> * formatTime(new Date()) -&gt; &quot;08:00:00&quot;</span></span><br><span class="line"><span class="comment"> * formatTime(Date.now()) -&gt; &quot;08:00:00&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">formatTime</span> = (<span class="params">time = <span class="built_in">Date</span>.now()</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>(time);</span><br><span class="line">    <span class="keyword">const</span> s = date.<span class="title function_">getSeconds</span>();</span><br><span class="line">    <span class="keyword">const</span> min = date.<span class="title function_">getMinutes</span>();</span><br><span class="line">    <span class="keyword">const</span> h = date.<span class="title function_">getHours</span>();</span><br><span class="line">    <span class="comment">// 时间</span></span><br><span class="line">    <span class="keyword">const</span> timeText = [h, min, s].<span class="title function_">map</span>(formatDateNum).<span class="title function_">join</span>(<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> timeText;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 时间已过</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">hour</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">minute</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isLate</span>(<span class="params">&#123; hour, minute &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="keyword">const</span> h = date.<span class="title function_">getHours</span>();</span><br><span class="line">    <span class="keyword">const</span> min = date.<span class="title function_">getMinutes</span>();</span><br><span class="line">    <span class="keyword">return</span> h &gt; hour || (h === hour &amp;&amp; min &gt;= minute);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 时间已过</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">hour</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">minute</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isNow</span>(<span class="params">&#123; hour, minute &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="keyword">const</span> h = date.<span class="title function_">getHours</span>();</span><br><span class="line">    <span class="keyword">const</span> min = date.<span class="title function_">getMinutes</span>();</span><br><span class="line">    <span class="keyword">const</span> s = date.<span class="title function_">getSeconds</span>();</span><br><span class="line">    <span class="keyword">return</span> h === hour &amp;&amp; min === minute &amp;&amp; s === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 工具函数 */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 设置cookie</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">name</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">value</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">expires</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setCookie</span>(<span class="params">name, value, expires, domain</span>) &#123;</span><br><span class="line">    <span class="comment">// 当前日期</span></span><br><span class="line">    <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="comment">// 过期日期</span></span><br><span class="line">    date.<span class="title function_">setTime</span>(date.<span class="title function_">getTime</span>() + expires);</span><br><span class="line">    <span class="comment">// 设置cookie</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">`<span class="subst">$&#123;name&#125;</span>=<span class="subst">$&#123;value&#125;</span>;expires=<span class="subst">$&#123;date.toUTCString()&#125;</span>;path=/;domain=<span class="subst">$&#123;domain&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 获取cookie</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">name</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getCookie</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取当前所有cookie</span></span><br><span class="line">    <span class="keyword">const</span> strCookies = <span class="variable language_">document</span>.<span class="property">cookie</span>;</span><br><span class="line">    <span class="comment">// 截取变成cookie数组</span></span><br><span class="line">    <span class="keyword">const</span> cookieText = strCookies.<span class="title function_">split</span>(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">    <span class="comment">// 循环每个cookie</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">in</span> cookieText) &#123;</span><br><span class="line">        <span class="comment">// 将cookie截取成两部分</span></span><br><span class="line">        <span class="keyword">const</span> item = cookieText[i].<span class="title function_">split</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="comment">// 判断cookie的name 是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (item[<span class="number">0</span>].<span class="title function_">trim</span>() === name) &#123;</span><br><span class="line">            <span class="keyword">return</span> item[<span class="number">1</span>].<span class="title function_">trim</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 删除cookie</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">name</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">delCookie</span>(<span class="params">name, domain</span>) &#123;</span><br><span class="line">    <span class="comment">// 存在cookie</span></span><br><span class="line">    <span class="keyword">const</span> value = <span class="title function_">getCookie</span>(name);</span><br><span class="line">    <span class="keyword">if</span> (value !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="title function_">setCookie</span>(name, <span class="string">&#x27;&#x27;</span>, -<span class="number">1</span>, domain);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 防抖</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">callback</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">delay</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">callback, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer !== -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            callback.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 判断是否为移动端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hasMobile</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> isMobile = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (navigator.<span class="property">userAgent</span>.<span class="title function_">match</span>(<span class="regexp">/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i</span>)) &#123;</span><br><span class="line">        <span class="title function_">log</span>(<span class="string">&#x27;移动端&#x27;</span>);</span><br><span class="line">        isMobile = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span> &lt; <span class="number">800</span>) &#123;</span><br><span class="line">        <span class="title function_">log</span>(<span class="string">&#x27;小尺寸设备端&#x27;</span>);</span><br><span class="line">        isMobile = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isMobile;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 等待时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">time</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">time</span>) &#123;</span><br><span class="line">    <span class="comment">// 延时</span></span><br><span class="line">    <span class="keyword">let</span> timeDelay = <span class="title class_">Number</span>(time);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(timeDelay)) &#123;</span><br><span class="line">        timeDelay = <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    timeDelay += <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">500</span> - <span class="number">250</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="literal">undefined</span>);</span><br><span class="line">        &#125;, timeDelay);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 暂停学习锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">studyPauseLock</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 暂停</span></span><br><span class="line">        <span class="keyword">const</span> pauseStudy = <span class="title function_">GM_getValue</span>(<span class="string">&#x27;pauseStudy&#x27;</span>) || <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (pauseStudy) &#123;</span><br><span class="line">            <span class="keyword">const</span> doing = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 暂停</span></span><br><span class="line">                <span class="keyword">const</span> pauseStudy = <span class="title function_">GM_getValue</span>(<span class="string">&#x27;pauseStudy&#x27;</span>) || <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (!pauseStudy) &#123;</span><br><span class="line">                    <span class="comment">// 停止定时器</span></span><br><span class="line">                    <span class="built_in">clearInterval</span>(doing);</span><br><span class="line">                    <span class="title function_">log</span>(<span class="string">&#x27;学习等待结束!&#x27;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (callback &amp;&amp; callback <span class="keyword">instanceof</span> <span class="title class_">Function</span>) &#123;</span><br><span class="line">                        <span class="title function_">callback</span>(<span class="literal">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="title function_">resolve</span>(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (callback &amp;&amp; callback <span class="keyword">instanceof</span> <span class="title class_">Function</span>) &#123;</span><br><span class="line">                    <span class="title function_">callback</span>(<span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_">log</span>(<span class="string">&#x27;学习等待...&#x27;</span>);</span><br><span class="line">            &#125;, <span class="number">500</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 加载</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">match</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">callback</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">load</span>(<span class="params">match, callback</span>) &#123;</span><br><span class="line">    <span class="comment">// 链接</span></span><br><span class="line">    <span class="keyword">const</span> &#123; href &#125; = <span class="variable language_">window</span>.<span class="property">location</span>;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 函数</span></span><br><span class="line">        <span class="keyword">if</span> (match <span class="keyword">instanceof</span> <span class="title class_">Function</span>) &#123;</span><br><span class="line">            <span class="title function_">match</span>(href) &amp;&amp; <span class="title function_">callback</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 布尔</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> match === <span class="string">&#x27;boolean&#x27;</span>) &#123;</span><br><span class="line">            match &amp;&amp; <span class="title function_">callback</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 字符正则</span></span><br><span class="line">        <span class="keyword">if</span> (href.<span class="title function_">match</span>(match)) &#123;</span><br><span class="line">            <span class="title function_">callback</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 变量 */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 链接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> href = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 任务配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> taskConfig = <span class="title function_">reactive</span>([</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;登录&#x27;</span>,</span><br><span class="line">        <span class="attr">currentScore</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">dayMaxScore</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">need</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">status</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">tip</span>: <span class="string">&#x27;每日首次登录积1分。&#x27;</span>,</span><br><span class="line">        <span class="attr">percent</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">score</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">active</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">immutable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">TaskType</span>.<span class="property">LOGIN</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;文章选读&#x27;</span>,</span><br><span class="line">        <span class="attr">currentScore</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">dayMaxScore</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">need</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">status</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">tip</span>: <span class="string">&#x27;每有效阅读一篇文章积1分，上限6分。有效阅读文章累计1分钟积1分，上限6分。每日上限积12分。&#x27;</span>,</span><br><span class="line">        <span class="attr">percent</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">score</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">active</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">immutable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">TaskType</span>.<span class="property">READ</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;视听学习&#x27;</span>,</span><br><span class="line">        <span class="attr">currentScore</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">dayMaxScore</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">need</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">status</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">tip</span>: <span class="string">&#x27;每有效一个音频或观看一个视频积1分，上限6分。有效收听音频或观看视频累计1分钟积1分，上限6分。每日上限积12分。&#x27;</span>,</span><br><span class="line">        <span class="attr">percent</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">score</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">active</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">immutable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">TaskType</span>.<span class="property">WATCH</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;每日答题&#x27;</span>,</span><br><span class="line">        <span class="attr">currentScore</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">dayMaxScore</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">need</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">status</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">tip</span>: <span class="string">&#x27;每组答题每答对1道积1分。每日上限积5分。&#x27;</span>,</span><br><span class="line">        <span class="attr">percent</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">score</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">active</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">immutable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">TaskType</span>.<span class="property">PRACTICE</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">]);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 设置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> settings = <span class="title function_">reactive</span>([<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>]);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 总分</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> totalScore = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 当天分数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> todayScore = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 用户信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> userinfo = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">nick</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">avatar</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 进度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> taskStatus = <span class="title function_">ref</span>(<span class="title class_">TaskStatusType</span>.<span class="property">LOADING</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 答题暂停</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> examPause = <span class="title function_">ref</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 登录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> login = <span class="title function_">ref</span>(!!<span class="title function_">getCookie</span>(<span class="string">&#x27;token&#x27;</span>));</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 窗口id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> id = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 定时刷新列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> scheduleList = <span class="title function_">shallowReactive</span>([]);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 推送token</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> pushToken = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 刷新次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> refreshCount = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 窗口关闭</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> frame = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">show</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">exist</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">closed</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">ele</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">src</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 页面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> page = <span class="title function_">ref</span>(<span class="literal">undefined</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 开始登录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> loginQRCodeShow = <span class="title function_">ref</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 最大选读时长</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> maxRead = <span class="title function_">ref</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 最大视听时长</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> maxWatch = <span class="title function_">ref</span>(<span class="number">120</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 运行其他任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> running = <span class="title function_">ref</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 主题色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> themeColor = <span class="title function_">ref</span>(<span class="string">&#x27;#fa3333&#x27;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>  考试类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ExamType</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">ExamType</span>) &#123;</span><br><span class="line">    <span class="title class_">ExamType</span>[<span class="title class_">ExamType</span>[<span class="string">&quot;PRACTICE&quot;</span>] = <span class="number">0</span>] = <span class="string">&quot;PRACTICE&quot;</span>;</span><br><span class="line">    <span class="title class_">ExamType</span>[<span class="title class_">ExamType</span>[<span class="string">&quot;PAPER&quot;</span>] = <span class="number">1</span>] = <span class="string">&quot;PAPER&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">ExamType</span> || (<span class="title class_">ExamType</span> = &#123;&#125;));</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 获取答题按钮</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getNextButton</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 答题按钮</span></span><br><span class="line">            <span class="keyword">const</span> nextAll = $$(<span class="string">&#x27;.ant-btn&#x27;</span>).<span class="title function_">filter</span>(<span class="function">(<span class="params">next</span>) =&gt;</span> next.<span class="property">innerText</span>);</span><br><span class="line">            <span class="keyword">if</span> (nextAll.<span class="property">length</span>) &#123;</span><br><span class="line">                <span class="comment">// 停止定时器</span></span><br><span class="line">                <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">                <span class="keyword">if</span> (nextAll.<span class="property">length</span> === <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(nextAll[<span class="number">1</span>]);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_">resolve</span>(nextAll[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 处理滑动验证</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleSlideVerify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="title function_">async</span> (resolve) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 滑动验证</span></span><br><span class="line">        <span class="keyword">const</span> mask = $$(<span class="string">&#x27;#nc_mask&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (mask &amp;&amp; <span class="title function_">getComputedStyle</span>(mask).<span class="property">display</span> !== <span class="string">&#x27;none&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建提示</span></span><br><span class="line">            <span class="title function_">createTip</span>(<span class="string">&#x27;等待滑动验证&#x27;</span>);</span><br><span class="line">            <span class="comment">// 提高层级</span></span><br><span class="line">            mask.<span class="property">style</span>.<span class="property">zIndex</span> = <span class="string">&#x27;999&#x27;</span>;</span><br><span class="line">            <span class="comment">// 轨道</span></span><br><span class="line">            <span class="keyword">const</span> track = (<span class="keyword">await</span> $_(<span class="string">&#x27;.nc_scale&#x27;</span>, <span class="literal">undefined</span>, <span class="number">3000</span>))[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 滑块</span></span><br><span class="line">            <span class="keyword">const</span> slide = (<span class="keyword">await</span> $_(<span class="string">&#x27;.btn_slide&#x27;</span>, <span class="literal">undefined</span>, <span class="number">3000</span>))[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 延时</span></span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">2000</span>);</span><br><span class="line">            <span class="comment">// 矩形范围</span></span><br><span class="line">            <span class="keyword">const</span> rectTrack = track.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line">            <span class="comment">// 矩形范围</span></span><br><span class="line">            <span class="keyword">const</span> rectSlide = slide.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line">            <span class="comment">// 窗口</span></span><br><span class="line">            <span class="keyword">const</span> <span class="variable language_">window</span> = unsafeWindow;</span><br><span class="line">            <span class="comment">// 范围内随机起点</span></span><br><span class="line">            <span class="keyword">const</span> start = <span class="title function_">createRandomPoint</span>(rectSlide);</span><br><span class="line">            <span class="comment">// 终点</span></span><br><span class="line">            <span class="keyword">const</span> end = &#123;</span><br><span class="line">                <span class="attr">x</span>: rectTrack.<span class="property">x</span> + rectTrack.<span class="property">width</span>,</span><br><span class="line">                <span class="attr">y</span>: rectTrack.<span class="property">y</span> + rectTrack.<span class="property">height</span> / <span class="number">2</span>,</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 路径</span></span><br><span class="line">            <span class="keyword">const</span> path = <span class="title function_">createRandomPath</span>(start, end, <span class="number">10</span>);</span><br><span class="line">            <span class="comment">// 移动端</span></span><br><span class="line">            <span class="keyword">const</span> mobile = <span class="title function_">hasMobile</span>();</span><br><span class="line">            <span class="keyword">if</span> (mobile) &#123;</span><br><span class="line">                slide.<span class="property">style</span>.<span class="property">touchAction</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">                <span class="keyword">const</span> touchstartTouch = <span class="keyword">new</span> <span class="title class_">Touch</span>(&#123;</span><br><span class="line">                    <span class="attr">identifier</span>: <span class="number">0</span>,</span><br><span class="line">                    <span class="attr">target</span>: slide,</span><br><span class="line">                    <span class="attr">clientX</span>: path[<span class="number">0</span>].<span class="property">x</span>,</span><br><span class="line">                    <span class="attr">clientY</span>: path[<span class="number">0</span>].<span class="property">y</span>,</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">const</span> touchstartList = [touchstartTouch];</span><br><span class="line">                <span class="comment">// 开始触摸</span></span><br><span class="line">                <span class="keyword">const</span> touchstart = <span class="keyword">new</span> <span class="title class_">TouchEvent</span>(<span class="string">&#x27;touchstart&#x27;</span>, &#123;</span><br><span class="line">                    <span class="attr">targetTouches</span>: touchstartList,</span><br><span class="line">                    <span class="attr">touches</span>: touchstartList,</span><br><span class="line">                    <span class="attr">changedTouches</span>: touchstartList,</span><br><span class="line">                    <span class="attr">view</span>: <span class="variable language_">window</span>,</span><br><span class="line">                    <span class="attr">bubbles</span>: <span class="literal">true</span>,</span><br><span class="line">                &#125;);</span><br><span class="line">                slide.<span class="title function_">dispatchEvent</span>(touchstart);</span><br><span class="line">                <span class="comment">// 触摸滑动</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">in</span> path) &#123;</span><br><span class="line">                    <span class="keyword">const</span> touchmoveTouch = <span class="keyword">new</span> <span class="title class_">Touch</span>(&#123;</span><br><span class="line">                        <span class="attr">identifier</span>: <span class="number">0</span>,</span><br><span class="line">                        <span class="attr">target</span>: slide,</span><br><span class="line">                        <span class="attr">clientX</span>: path[i].<span class="property">x</span>,</span><br><span class="line">                        <span class="attr">clientY</span>: path[i].<span class="property">y</span>,</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="keyword">const</span> touchmoveList = [touchmoveTouch];</span><br><span class="line">                    <span class="keyword">const</span> touchmove = <span class="keyword">new</span> <span class="title class_">TouchEvent</span>(<span class="string">&#x27;touchmove&#x27;</span>, &#123;</span><br><span class="line">                        <span class="attr">targetTouches</span>: touchmoveList,</span><br><span class="line">                        <span class="attr">touches</span>: touchmoveList,</span><br><span class="line">                        <span class="attr">changedTouches</span>: touchmoveList,</span><br><span class="line">                        <span class="attr">view</span>: <span class="variable language_">window</span>,</span><br><span class="line">                        <span class="attr">bubbles</span>: <span class="literal">true</span>,</span><br><span class="line">                    &#125;);</span><br><span class="line">                    slide.<span class="title function_">dispatchEvent</span>(touchmove);</span><br><span class="line">                    <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">10</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">const</span> touchendTouch = <span class="keyword">new</span> <span class="title class_">Touch</span>(&#123;</span><br><span class="line">                    <span class="attr">identifier</span>: <span class="number">0</span>,</span><br><span class="line">                    <span class="attr">target</span>: slide,</span><br><span class="line">                    <span class="attr">clientX</span>: path[path.<span class="property">length</span> - <span class="number">1</span>].<span class="property">x</span>,</span><br><span class="line">                    <span class="attr">clientY</span>: path[path.<span class="property">length</span> - <span class="number">1</span>].<span class="property">y</span>,</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">// 触摸结束</span></span><br><span class="line">                <span class="keyword">const</span> touchendList = [touchendTouch];</span><br><span class="line">                <span class="comment">// 开始触摸</span></span><br><span class="line">                <span class="keyword">const</span> touchend = <span class="keyword">new</span> <span class="title class_">TouchEvent</span>(<span class="string">&#x27;touchend&#x27;</span>, &#123;</span><br><span class="line">                    <span class="attr">targetTouches</span>: [],</span><br><span class="line">                    <span class="attr">touches</span>: [],</span><br><span class="line">                    <span class="attr">changedTouches</span>: touchendList,</span><br><span class="line">                    <span class="attr">view</span>: <span class="variable language_">window</span>,</span><br><span class="line">                    <span class="attr">bubbles</span>: <span class="literal">true</span>,</span><br><span class="line">                &#125;);</span><br><span class="line">                slide.<span class="title function_">dispatchEvent</span>(touchend);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 鼠标按下</span></span><br><span class="line">                <span class="keyword">const</span> mousedown = <span class="keyword">new</span> <span class="title class_">MouseEvent</span>(<span class="string">&#x27;mousedown&#x27;</span>, &#123;</span><br><span class="line">                    <span class="attr">clientX</span>: path[<span class="number">0</span>].<span class="property">x</span>,</span><br><span class="line">                    <span class="attr">clientY</span>: path[<span class="number">0</span>].<span class="property">y</span>,</span><br><span class="line">                    <span class="attr">bubbles</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">view</span>: <span class="variable language_">window</span>,</span><br><span class="line">                &#125;);</span><br><span class="line">                slide.<span class="title function_">dispatchEvent</span>(mousedown);</span><br><span class="line">                <span class="comment">// 鼠标滑动</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">in</span> path) &#123;</span><br><span class="line">                    <span class="keyword">const</span> mousemove = <span class="keyword">new</span> <span class="title class_">MouseEvent</span>(<span class="string">&#x27;mousemove&#x27;</span>, &#123;</span><br><span class="line">                        <span class="attr">clientX</span>: path[i].<span class="property">x</span>,</span><br><span class="line">                        <span class="attr">clientY</span>: path[i].<span class="property">y</span>,</span><br><span class="line">                        <span class="attr">bubbles</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="attr">view</span>: <span class="variable language_">window</span>,</span><br><span class="line">                    &#125;);</span><br><span class="line">                    slide.<span class="title function_">dispatchEvent</span>(mousemove);</span><br><span class="line">                    <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">10</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 鼠标抬起</span></span><br><span class="line">                <span class="keyword">const</span> mouseup = <span class="keyword">new</span> <span class="title class_">MouseEvent</span>(<span class="string">&#x27;mouseup&#x27;</span>, &#123;</span><br><span class="line">                    <span class="attr">clientX</span>: path[path.<span class="property">length</span> - <span class="number">1</span>].<span class="property">x</span>,</span><br><span class="line">                    <span class="attr">clientY</span>: path[path.<span class="property">length</span> - <span class="number">1</span>].<span class="property">y</span>,</span><br><span class="line">                    <span class="attr">bubbles</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">view</span>: <span class="variable language_">window</span>,</span><br><span class="line">                &#125;);</span><br><span class="line">                slide.<span class="title function_">dispatchEvent</span>(mouseup);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建提示</span></span><br><span class="line">            <span class="title function_">createTip</span>(<span class="string">&#x27;滑动验证完成!&#x27;</span>);</span><br><span class="line">            <span class="comment">// 定时器</span></span><br><span class="line">            <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 滑动验证</span></span><br><span class="line">                <span class="keyword">const</span> mask = $$(<span class="string">&#x27;#nc_mask&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span> (!mask || <span class="title function_">getComputedStyle</span>(mask).<span class="property">display</span> === <span class="string">&#x27;none&#x27;</span>) &#123;</span><br><span class="line">                    <span class="title function_">log</span>(<span class="string">&#x27;滑动验证成功!&#x27;</span>);</span><br><span class="line">                    <span class="comment">// 创建提示</span></span><br><span class="line">                    <span class="title function_">createTip</span>(<span class="string">&#x27;滑动验证成功!&#x27;</span>);</span><br><span class="line">                    <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">                    <span class="title function_">resolve</span>(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_">resolve</span>(<span class="literal">false</span>);</span><br><span class="line">                <span class="title function_">log</span>(<span class="string">&#x27;滑动验证失败!&#x27;</span>);</span><br><span class="line">                <span class="comment">// 创建提示</span></span><br><span class="line">                <span class="title function_">createTip</span>(<span class="string">&#x27;滑动验证失败!&#x27;</span>);</span><br><span class="line">            &#125;, <span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 处理选项</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleChoiceBtn</span>(<span class="params">answers</span>) &#123;</span><br><span class="line">    <span class="comment">// 选项按钮</span></span><br><span class="line">    <span class="keyword">const</span> allBtns = $$(<span class="string">&#x27;.q-answer&#x27;</span>);</span><br><span class="line">    <span class="comment">// 答案存在</span></span><br><span class="line">    <span class="keyword">if</span> (answers.<span class="property">length</span> &amp;&amp; allBtns.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="comment">// 作答</span></span><br><span class="line">        <span class="keyword">return</span> answers.<span class="title function_">every</span>(<span class="function">(<span class="params">answer</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 答案存在</span></span><br><span class="line">            <span class="keyword">if</span> (answer &amp;&amp; answer.<span class="property">length</span>) &#123;</span><br><span class="line">                <span class="comment">// 包含答案最短长度选项</span></span><br><span class="line">                <span class="keyword">let</span> minLengthChoice;</span><br><span class="line">                <span class="comment">// 遍历</span></span><br><span class="line">                allBtns.<span class="title function_">forEach</span>(<span class="function">(<span class="params">choice</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 选项文本</span></span><br><span class="line">                    <span class="keyword">const</span> choiceText = choice.<span class="property">innerText</span>.<span class="title function_">trim</span>();</span><br><span class="line">                    <span class="comment">// 无符号选项文本</span></span><br><span class="line">                    <span class="keyword">const</span> unsignedChoiceText = choiceText.<span class="title function_">replaceAll</span>(<span class="regexp">/[、，,。 ]/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">                    <span class="comment">// 无符号答案</span></span><br><span class="line">                    <span class="keyword">const</span> unsignedAnswer = answer.<span class="title function_">replaceAll</span>(<span class="regexp">/[、，,。 ]/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">                    <span class="comment">// 包含答案</span></span><br><span class="line">                    <span class="keyword">if</span> (choiceText === answer ||</span><br><span class="line">                        choiceText.<span class="title function_">includes</span>(answer) ||</span><br><span class="line">                        answer.<span class="title function_">includes</span>(choiceText) ||</span><br><span class="line">                        unsignedChoiceText.<span class="title function_">includes</span>(unsignedAnswer)) &#123;</span><br><span class="line">                        <span class="comment">// 最小长度选项有值</span></span><br><span class="line">                        <span class="keyword">if</span> (minLengthChoice) &#123;</span><br><span class="line">                            <span class="comment">// 最短长度选项与当前选项比较长度</span></span><br><span class="line">                            <span class="keyword">if</span> (minLengthChoice.<span class="property">innerText</span>.<span class="property">length</span> &gt; choiceText.<span class="property">length</span>) &#123;</span><br><span class="line">                                minLengthChoice = choice;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 最小长度选项赋值</span></span><br><span class="line">                            minLengthChoice = choice;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">// 存在选项</span></span><br><span class="line">                <span class="keyword">if</span> (minLengthChoice) &#123;</span><br><span class="line">                    <span class="comment">// 选择</span></span><br><span class="line">                    <span class="keyword">if</span> (!minLengthChoice.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&#x27;chosen&#x27;</span>)) &#123;</span><br><span class="line">                        minLengthChoice.<span class="title function_">click</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 随机处理单选</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleSingleChoiceRand</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 选项按钮</span></span><br><span class="line">    <span class="keyword">const</span> allBtns = $$(<span class="string">&#x27;.q-answer&#x27;</span>);</span><br><span class="line">    <span class="comment">// 按钮存在</span></span><br><span class="line">    <span class="keyword">if</span> (allBtns.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> index = ~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * allBtns.<span class="property">length</span>);</span><br><span class="line">        <span class="keyword">const</span> randBtn = allBtns[index];</span><br><span class="line">        <span class="comment">// 选择</span></span><br><span class="line">        <span class="keyword">if</span> (!randBtn.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&#x27;chosen&#x27;</span>)) &#123;</span><br><span class="line">            randBtn.<span class="title function_">click</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 随机处理多选</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleMutiplyChoiceRand</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 选项按钮</span></span><br><span class="line">    <span class="keyword">const</span> allBtns = $$(<span class="string">&#x27;.q-answer&#x27;</span>);</span><br><span class="line">    <span class="comment">// 按钮存在</span></span><br><span class="line">    <span class="keyword">if</span> (allBtns.<span class="property">length</span>) &#123;</span><br><span class="line">        allBtns.<span class="title function_">forEach</span>(<span class="function">(<span class="params">allBtn</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 选择</span></span><br><span class="line">            <span class="keyword">if</span> (!allBtn.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&#x27;chosen&#x27;</span>)) &#123;</span><br><span class="line">                allBtn.<span class="title function_">click</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 处理填空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleBlankInput</span> = (<span class="params">answers</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 所有填空</span></span><br><span class="line">    <span class="keyword">const</span> blanks = $$(<span class="string">&#x27;.blank&#x27;</span>);</span><br><span class="line">    <span class="comment">// 答案存在</span></span><br><span class="line">    <span class="keyword">if</span> (blanks.<span class="property">length</span> &amp;&amp; answers.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="comment">// 填空数量和答案数量一致</span></span><br><span class="line">        <span class="keyword">if</span> (answers.<span class="property">length</span> === blanks.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> answers.<span class="title function_">every</span>(<span class="function">(<span class="params">answer, i</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 答案存在</span></span><br><span class="line">                <span class="keyword">if</span> (answer &amp;&amp; answer.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="comment">// 输入事件</span></span><br><span class="line">                    <span class="keyword">const</span> inputEvent = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;input&#x27;</span>, &#123;</span><br><span class="line">                        <span class="attr">bubbles</span>: <span class="literal">true</span>,</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="comment">// 设置答案</span></span><br><span class="line">                    blanks[i].<span class="title function_">setAttribute</span>(<span class="string">&#x27;value&#x27;</span>, answer);</span><br><span class="line">                    <span class="comment">// 触发输入input</span></span><br><span class="line">                    blanks[i].<span class="title function_">dispatchEvent</span>(inputEvent);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 填空数量为1和提示数量大于1</span></span><br><span class="line">        <span class="keyword">if</span> (blanks.<span class="property">length</span> === <span class="number">1</span> &amp;&amp; answers.<span class="property">length</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 直接将所有答案整合填进去</span></span><br><span class="line">            <span class="keyword">const</span> answer = answers.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">            <span class="comment">// 答案存在</span></span><br><span class="line">            <span class="keyword">if</span> (answer &amp;&amp; answer.<span class="property">length</span>) &#123;</span><br><span class="line">                <span class="comment">// 输入事件</span></span><br><span class="line">                <span class="keyword">const</span> inputEvent = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;input&#x27;</span>, &#123;</span><br><span class="line">                    <span class="attr">bubbles</span>: <span class="literal">true</span>,</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">// 设置答案</span></span><br><span class="line">                blanks[<span class="number">0</span>].<span class="title function_">setAttribute</span>(<span class="string">&#x27;value&#x27;</span>, answer);</span><br><span class="line">                <span class="comment">// 触发输入input</span></span><br><span class="line">                blanks[<span class="number">0</span>].<span class="title function_">dispatchEvent</span>(inputEvent);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 处理填空随机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">handleBlankInputRand</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 所有填空</span></span><br><span class="line">    <span class="keyword">const</span> blanks = $$(<span class="string">&#x27;.blank&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (blanks.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="comment">// 输入事件</span></span><br><span class="line">        <span class="keyword">const</span> inputEvent = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;input&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">bubbles</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        blanks.<span class="title function_">forEach</span>(<span class="function">(<span class="params">blank</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 设置答案</span></span><br><span class="line">            blank.<span class="title function_">setAttribute</span>(<span class="string">&#x27;value&#x27;</span>, <span class="string">&#x27;答案&#x27;</span>);</span><br><span class="line">            <span class="comment">// 触发输入input</span></span><br><span class="line">            blank.<span class="title function_">dispatchEvent</span>(inputEvent);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 暂停锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">examPauseLock</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 学习暂停</span></span><br><span class="line">        <span class="keyword">const</span> pauseStudy = (<span class="title function_">GM_getValue</span>(<span class="string">&#x27;pauseStudy&#x27;</span>) || <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 全局暂停</span></span><br><span class="line">        <span class="keyword">if</span> (pauseStudy) &#123;</span><br><span class="line">            examPause.<span class="property">value</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 暂停</span></span><br><span class="line">        <span class="keyword">if</span> (examPause.<span class="property">value</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建提示</span></span><br><span class="line">            <span class="title function_">createTip</span>(<span class="string">&#x27;已暂停, 手动开启自动答题! &#x27;</span>, <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">const</span> doing = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!examPause.<span class="property">value</span>) &#123;</span><br><span class="line">                    <span class="comment">// 停止定时器</span></span><br><span class="line">                    <span class="built_in">clearInterval</span>(doing);</span><br><span class="line">                    <span class="title function_">log</span>(<span class="string">&#x27;答题等待结束!&#x27;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (callback &amp;&amp; callback <span class="keyword">instanceof</span> <span class="title class_">Function</span>) &#123;</span><br><span class="line">                        <span class="comment">// 创建提示</span></span><br><span class="line">                        <span class="title function_">createTip</span>(<span class="string">&#x27;已开启, 自动答题!&#x27;</span>);</span><br><span class="line">                        <span class="title function_">callback</span>(<span class="literal">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="title function_">resolve</span>(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (callback &amp;&amp; callback <span class="keyword">instanceof</span> <span class="title class_">Function</span>) &#123;</span><br><span class="line">                    <span class="title function_">callback</span>(<span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_">log</span>(<span class="string">&#x27;答题等待...&#x27;</span>);</span><br><span class="line">            &#125;, <span class="number">500</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 答题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">doingExam</span>(<span class="params">type</span>) &#123;</span><br><span class="line">    <span class="comment">// 下一个按钮</span></span><br><span class="line">    <span class="keyword">let</span> nextButton;</span><br><span class="line">    <span class="comment">// 下一个文本</span></span><br><span class="line">    <span class="keyword">let</span> nextText;</span><br><span class="line">    <span class="comment">// 保存答案</span></span><br><span class="line">    <span class="keyword">let</span> shouldSaveAnswer = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 先等等再开始做题</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">2500</span>);</span><br><span class="line">        <span class="comment">// 暂停</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">examPauseLock</span>();</span><br><span class="line">        <span class="comment">// 获取下一个按钮</span></span><br><span class="line">        nextButton = <span class="keyword">await</span> <span class="title function_">getNextButton</span>();</span><br><span class="line">        <span class="comment">// 下一个文本</span></span><br><span class="line">        nextText = nextButton.<span class="property">innerText</span>.<span class="title function_">replaceAll</span>(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">        <span class="comment">// 结束</span></span><br><span class="line">        <span class="keyword">const</span> finish = [<span class="string">&#x27;再练一次&#x27;</span>, <span class="string">&#x27;再来一组&#x27;</span>, <span class="string">&#x27;查看解析&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span> (finish.<span class="title function_">includes</span>(nextButton.<span class="property">innerText</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 点击提示</span></span><br><span class="line">        $$(<span class="string">&#x27;.tips&#x27;</span>)[<span class="number">0</span>]?.<span class="title function_">click</span>();</span><br><span class="line">        <span class="comment">// 所有提示</span></span><br><span class="line">        <span class="keyword">const</span> allTips = $$(<span class="string">&#x27;.line-feed font[color]&#x27;</span>);</span><br><span class="line">        <span class="comment">// 答案</span></span><br><span class="line">        <span class="keyword">const</span> answers = allTips.<span class="title function_">map</span>(<span class="function">(<span class="params">tip</span>) =&gt;</span> tip.<span class="property">innerText</span>.<span class="title function_">trim</span>());</span><br><span class="line">        <span class="comment">// 获取题目的文本内容</span></span><br><span class="line">        <span class="keyword">const</span> question = $$(<span class="string">&#x27;.q-body&#x27;</span>)[<span class="number">0</span>].<span class="property">innerText</span>;</span><br><span class="line">        <span class="comment">// 等待一段时间</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">1500</span>);</span><br><span class="line">        <span class="comment">// 暂停</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">examPauseLock</span>();</span><br><span class="line">        <span class="comment">// 选项按钮</span></span><br><span class="line">        <span class="keyword">const</span> allBtns = $$(<span class="string">&#x27;.q-answer&#x27;</span>);</span><br><span class="line">        <span class="comment">// 所有填空</span></span><br><span class="line">        <span class="keyword">const</span> blanks = $$(<span class="string">&#x27;input[type=text][class=blank]&#x27;</span>);</span><br><span class="line">        <span class="comment">// 问题类型</span></span><br><span class="line">        <span class="keyword">const</span> questionType = ($$(<span class="string">&#x27;.q-header&#x27;</span>)[<span class="number">0</span>].<span class="property">innerText</span>.<span class="title function_">substring</span>(<span class="number">0</span>, <span class="number">3</span>));</span><br><span class="line">        <span class="comment">// 暂停</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">examPauseLock</span>();</span><br><span class="line">        <span class="comment">// 题型分类作答</span></span><br><span class="line">        <span class="keyword">switch</span> (questionType) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;填空题&#x27;</span>: &#123;</span><br><span class="line">                <span class="comment">// 根据提示作答</span></span><br><span class="line">                <span class="keyword">if</span> (answers.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> res = <span class="title function_">handleBlankInput</span>(answers);</span><br><span class="line">                    <span class="comment">// 成功</span></span><br><span class="line">                    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 创建提示</span></span><br><span class="line">                <span class="title function_">createTip</span>(<span class="string">&#x27;答案异常, 尝试网络题库获取!&#x27;</span>);</span><br><span class="line">                <span class="title function_">log</span>(<span class="string">&#x27;正在获取答案...&#x27;</span>);</span><br><span class="line">                <span class="comment">// 尝试题库获取</span></span><br><span class="line">                <span class="keyword">const</span> answersNetwork = <span class="keyword">await</span> <span class="title function_">getAnswer</span>(question);</span><br><span class="line">                <span class="title function_">log</span>(<span class="string">`获取答案<span class="subst">$&#123;answersNetwork.length ? <span class="string">&#x27;成功&#x27;</span> : <span class="string">&#x27;失败&#x27;</span>&#125;</span>!`</span>, &#123;</span><br><span class="line">                    question,</span><br><span class="line">                    answersNetwork,</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">// 根据题库作答</span></span><br><span class="line">                <span class="keyword">if</span> (answersNetwork.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> res = <span class="title function_">handleBlankInput</span>(answersNetwork);</span><br><span class="line">                    <span class="comment">// 成功</span></span><br><span class="line">                    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 随机作答</span></span><br><span class="line">                <span class="keyword">if</span> (type === <span class="title class_">ExamType</span>.<span class="property">PRACTICE</span> || settings[<span class="title class_">SettingType</span>.<span class="property">RANDOM_EXAM</span>]) &#123;</span><br><span class="line">                    <span class="title function_">log</span>(<span class="string">&#x27;答案不存在, 随机作答!&#x27;</span>);</span><br><span class="line">                    <span class="comment">// 创建提示</span></span><br><span class="line">                    <span class="title function_">createTip</span>(<span class="string">&#x27;答案不存在, 随机作答!&#x27;</span>);</span><br><span class="line">                    <span class="keyword">await</span> <span class="title function_">handleBlankInputRand</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 推送</span></span><br><span class="line">                    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">pushModal</span>(&#123;</span><br><span class="line">                        <span class="attr">title</span>: <span class="string">&#x27;学习推送&#x27;</span>,</span><br><span class="line">                        <span class="attr">to</span>: userinfo.<span class="property">nick</span>,</span><br><span class="line">                        <span class="attr">content</span>: <span class="string">&#x27;答题存在异常, 已暂停答题!&#x27;</span>,</span><br><span class="line">                        <span class="attr">type</span>: <span class="string">&#x27;fail&#x27;</span>,</span><br><span class="line">                    &#125;, pushToken.<span class="property">value</span>);</span><br><span class="line">                    <span class="title function_">createTip</span>(<span class="string">`学习推送<span class="subst">$&#123;res ? <span class="string">&#x27;成功&#x27;</span> : <span class="string">&#x27;失败&#x27;</span>&#125;</span>!`</span>);</span><br><span class="line">                    <span class="comment">// 暂停</span></span><br><span class="line">                    examPause.<span class="property">value</span> = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 提交答案</span></span><br><span class="line">                    shouldSaveAnswer = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;多选题&#x27;</span>: &#123;</span><br><span class="line">                <span class="comment">// 根据提示作答</span></span><br><span class="line">                <span class="keyword">if</span> (answers.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="comment">// 选项文本</span></span><br><span class="line">                    <span class="keyword">const</span> choicesText = allBtns.<span class="title function_">map</span>(<span class="function">(<span class="params">btn</span>) =&gt;</span> btn.<span class="property">innerText</span>);</span><br><span class="line">                    <span class="comment">// 选项内容</span></span><br><span class="line">                    <span class="keyword">const</span> choicesContent = choicesText</span><br><span class="line">                        .<span class="title function_">map</span>(<span class="function">(<span class="params">choiceText</span>) =&gt;</span> choiceText.<span class="title function_">split</span>(<span class="regexp">/[A-Z]./</span>)[<span class="number">1</span>].<span class="title function_">trim</span>())</span><br><span class="line">                        .<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">                    <span class="comment">// 空格</span></span><br><span class="line">                    <span class="keyword">const</span> blanks = question.<span class="title function_">match</span>(<span class="regexp">/（）/g</span>);</span><br><span class="line">                    <span class="comment">// 填空数量、选项数量、答案数量相同 | 选项全文等于答案全文</span></span><br><span class="line">                    <span class="keyword">if</span> ((blanks &amp;&amp; allBtns.<span class="property">length</span> === blanks.<span class="property">length</span>) ||</span><br><span class="line">                        question === choicesContent ||</span><br><span class="line">                        allBtns.<span class="property">length</span> === <span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="comment">// 全选</span></span><br><span class="line">                        allBtns.<span class="title function_">forEach</span>(<span class="function">(<span class="params">choice</span>) =&gt;</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!choice.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&#x27;chosen&#x27;</span>)) &#123;</span><br><span class="line">                                choice.<span class="title function_">click</span>();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 选项数量大于等于答案</span></span><br><span class="line">                    <span class="keyword">if</span> (allBtns.<span class="property">length</span> &gt;= answers.<span class="property">length</span>) &#123;</span><br><span class="line">                        <span class="keyword">const</span> res = <span class="title function_">handleChoiceBtn</span>(answers);</span><br><span class="line">                        <span class="comment">// 成功</span></span><br><span class="line">                        <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 创建提示</span></span><br><span class="line">                <span class="title function_">createTip</span>(<span class="string">&#x27;答案异常, 尝试网络题库获取!&#x27;</span>);</span><br><span class="line">                <span class="title function_">log</span>(<span class="string">&#x27;正在获取答案...&#x27;</span>);</span><br><span class="line">                <span class="comment">// 尝试题库获取</span></span><br><span class="line">                <span class="keyword">const</span> answersNetwork = <span class="keyword">await</span> <span class="title function_">getAnswer</span>(question);</span><br><span class="line">                <span class="title function_">log</span>(<span class="string">`获取答案<span class="subst">$&#123;answersNetwork.length ? <span class="string">&#x27;成功&#x27;</span> : <span class="string">&#x27;失败&#x27;</span>&#125;</span>!`</span>, &#123;</span><br><span class="line">                    question,</span><br><span class="line">                    answersNetwork,</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">// 答案存在</span></span><br><span class="line">                <span class="keyword">if</span> (answersNetwork.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> res = <span class="title function_">handleChoiceBtn</span>(answersNetwork);</span><br><span class="line">                    <span class="comment">// 成功</span></span><br><span class="line">                    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 随机作答</span></span><br><span class="line">                <span class="keyword">if</span> (type === <span class="title class_">ExamType</span>.<span class="property">PRACTICE</span> || settings[<span class="title class_">SettingType</span>.<span class="property">RANDOM_EXAM</span>]) &#123;</span><br><span class="line">                    <span class="title function_">log</span>(<span class="string">&#x27;答案不存在, 随机作答!&#x27;</span>);</span><br><span class="line">                    <span class="comment">// 创建提示</span></span><br><span class="line">                    <span class="title function_">createTip</span>(<span class="string">&#x27;答案不存在, 随机作答!&#x27;</span>);</span><br><span class="line">                    <span class="keyword">await</span> <span class="title function_">handleMutiplyChoiceRand</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 推送</span></span><br><span class="line">                    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">pushModal</span>(&#123;</span><br><span class="line">                        <span class="attr">title</span>: <span class="string">&#x27;学习推送&#x27;</span>,</span><br><span class="line">                        <span class="attr">to</span>: userinfo.<span class="property">nick</span>,</span><br><span class="line">                        <span class="attr">content</span>: <span class="string">&#x27;答题存在异常, 已暂停答题!&#x27;</span>,</span><br><span class="line">                        <span class="attr">type</span>: <span class="string">&#x27;fail&#x27;</span>,</span><br><span class="line">                    &#125;, pushToken.<span class="property">value</span>);</span><br><span class="line">                    <span class="title function_">createTip</span>(<span class="string">`学习推送<span class="subst">$&#123;res ? <span class="string">&#x27;成功&#x27;</span> : <span class="string">&#x27;失败&#x27;</span>&#125;</span>!`</span>);</span><br><span class="line">                    <span class="comment">// 暂停</span></span><br><span class="line">                    examPause.<span class="property">value</span> = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 提交答案</span></span><br><span class="line">                    shouldSaveAnswer = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;单选题&#x27;</span>: &#123;</span><br><span class="line">                <span class="comment">// 根据提示作答</span></span><br><span class="line">                <span class="keyword">if</span> (answers.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="comment">// 创建提示为1</span></span><br><span class="line">                    <span class="keyword">if</span> (answers.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">const</span> res = <span class="title function_">handleChoiceBtn</span>(answers);</span><br><span class="line">                        <span class="comment">// 成功</span></span><br><span class="line">                        <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 可能的分隔符</span></span><br><span class="line">                        <span class="keyword">const</span> seperator = [</span><br><span class="line">                            <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                            <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">                            <span class="string">&#x27;,&#x27;</span>,</span><br><span class="line">                            <span class="string">&#x27;;&#x27;</span>,</span><br><span class="line">                            <span class="string">&#x27;,&#x27;</span>,</span><br><span class="line">                            <span class="string">&#x27;、&#x27;</span>,</span><br><span class="line">                            <span class="string">&#x27;-&#x27;</span>,</span><br><span class="line">                            <span class="string">&#x27;|&#x27;</span>,</span><br><span class="line">                            <span class="string">&#x27;+&#x27;</span>,</span><br><span class="line">                            <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">                        ];</span><br><span class="line">                        <span class="comment">// 可能的答案</span></span><br><span class="line">                        <span class="keyword">const</span> answersLike = seperator</span><br><span class="line">                            .<span class="title function_">map</span>(<span class="function">(<span class="params">s</span>) =&gt;</span> answers.<span class="title function_">join</span>(s).<span class="title function_">trim</span>())</span><br><span class="line">                            .<span class="title function_">filter</span>(<span class="function">(<span class="params">answer</span>) =&gt;</span> answer.<span class="property">length</span>);</span><br><span class="line">                        <span class="comment">// 答案存在</span></span><br><span class="line">                        <span class="keyword">if</span> (answersLike.<span class="property">length</span>) &#123;</span><br><span class="line">                            <span class="comment">// 可能答案是否正确</span></span><br><span class="line">                            <span class="keyword">const</span> res = answersLike.<span class="title function_">some</span>(<span class="function">(<span class="params">answer</span>) =&gt;</span> &#123;</span><br><span class="line">                                <span class="comment">// 尝试查找点击</span></span><br><span class="line">                                <span class="keyword">return</span> <span class="title function_">handleChoiceBtn</span>([answer]);</span><br><span class="line">                            &#125;);</span><br><span class="line">                            <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 创建提示</span></span><br><span class="line">                <span class="title function_">createTip</span>(<span class="string">&#x27;答案异常, 尝试网络题库获取!&#x27;</span>);</span><br><span class="line">                <span class="title function_">log</span>(<span class="string">&#x27;正在获取答案...&#x27;</span>);</span><br><span class="line">                <span class="comment">// 尝试题库获取</span></span><br><span class="line">                <span class="keyword">const</span> answersNetwork = <span class="keyword">await</span> <span class="title function_">getAnswer</span>(question);</span><br><span class="line">                <span class="title function_">log</span>(<span class="string">`获取答案<span class="subst">$&#123;answersNetwork.length ? <span class="string">&#x27;成功&#x27;</span> : <span class="string">&#x27;失败&#x27;</span>&#125;</span>!`</span>, &#123;</span><br><span class="line">                    question,</span><br><span class="line">                    answersNetwork,</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">// 存在答案</span></span><br><span class="line">                <span class="keyword">if</span> (answersNetwork.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="comment">// 单答案单选项</span></span><br><span class="line">                    <span class="keyword">if</span> (answersNetwork.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">// 尝试查找点击</span></span><br><span class="line">                        <span class="keyword">const</span> res = <span class="title function_">handleChoiceBtn</span>(answersNetwork);</span><br><span class="line">                        <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 多答案单选项 选项意外拆分</span></span><br><span class="line">                        <span class="comment">// 可能分隔符</span></span><br><span class="line">                        <span class="keyword">const</span> seperator = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27; &#x27;</span>];</span><br><span class="line">                        <span class="comment">// 可能答案</span></span><br><span class="line">                        <span class="keyword">const</span> answersLike = seperator.<span class="title function_">map</span>(<span class="function">(<span class="params">s</span>) =&gt;</span> answers.<span class="title function_">join</span>(s));</span><br><span class="line">                        <span class="comment">// 答案存在</span></span><br><span class="line">                        <span class="keyword">if</span> (answersLike.<span class="title function_">every</span>(<span class="function">(<span class="params">answer</span>) =&gt;</span> answer.<span class="property">length</span>)) &#123;</span><br><span class="line">                            <span class="comment">// 可能答案是否正确</span></span><br><span class="line">                            <span class="keyword">const</span> res = answersLike.<span class="title function_">some</span>(<span class="function">(<span class="params">answer</span>) =&gt;</span> &#123;</span><br><span class="line">                                <span class="comment">// 尝试查找点击</span></span><br><span class="line">                                <span class="keyword">return</span> <span class="title function_">handleChoiceBtn</span>([answer]);</span><br><span class="line">                            &#125;);</span><br><span class="line">                            <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 随机作答</span></span><br><span class="line">                <span class="keyword">if</span> (type === <span class="title class_">ExamType</span>.<span class="property">PRACTICE</span> || settings[<span class="title class_">SettingType</span>.<span class="property">RANDOM_EXAM</span>]) &#123;</span><br><span class="line">                    <span class="title function_">log</span>(<span class="string">&#x27;答案不存在, 随机作答!&#x27;</span>);</span><br><span class="line">                    <span class="comment">// 创建提示</span></span><br><span class="line">                    <span class="title function_">createTip</span>(<span class="string">&#x27;答案不存在, 随机作答!&#x27;</span>);</span><br><span class="line">                    <span class="keyword">await</span> <span class="title function_">handleSingleChoiceRand</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 推送</span></span><br><span class="line">                    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">pushModal</span>(&#123;</span><br><span class="line">                        <span class="attr">title</span>: <span class="string">&#x27;学习推送&#x27;</span>,</span><br><span class="line">                        <span class="attr">to</span>: userinfo.<span class="property">nick</span>,</span><br><span class="line">                        <span class="attr">content</span>: <span class="string">&#x27;答题存在异常, 已暂停答题!&#x27;</span>,</span><br><span class="line">                        <span class="attr">type</span>: <span class="string">&#x27;fail&#x27;</span>,</span><br><span class="line">                    &#125;, pushToken.<span class="property">value</span>);</span><br><span class="line">                    <span class="title function_">createTip</span>(<span class="string">`学习推送<span class="subst">$&#123;res ? <span class="string">&#x27;成功&#x27;</span> : <span class="string">&#x27;失败&#x27;</span>&#125;</span>!`</span>);</span><br><span class="line">                    <span class="comment">// 暂停</span></span><br><span class="line">                    examPause.<span class="property">value</span> = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 提交答案</span></span><br><span class="line">                    shouldSaveAnswer = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 暂停</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">examPauseLock</span>();</span><br><span class="line">        <span class="comment">// 获取下一个按钮</span></span><br><span class="line">        nextButton = <span class="keyword">await</span> <span class="title function_">getNextButton</span>();</span><br><span class="line">        <span class="comment">// 下一个文本</span></span><br><span class="line">        nextText = nextButton.<span class="property">innerText</span>.<span class="title function_">replaceAll</span>(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">        <span class="comment">// 需要提交答案</span></span><br><span class="line">        <span class="keyword">if</span> (shouldSaveAnswer) &#123;</span><br><span class="line">            <span class="comment">// 答案</span></span><br><span class="line">            <span class="keyword">const</span> answers = [];</span><br><span class="line">            <span class="keyword">if</span> (questionType === <span class="string">&#x27;填空题&#x27;</span>) &#123;</span><br><span class="line">                blanks.<span class="title function_">forEach</span>(<span class="function">(<span class="params">blank</span>) =&gt;</span> &#123;</span><br><span class="line">                    answers.<span class="title function_">push</span>(blank.<span class="property">value</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (questionType === <span class="string">&#x27;单选题&#x27;</span> || questionType === <span class="string">&#x27;多选题&#x27;</span>) &#123;</span><br><span class="line">                allBtns.<span class="title function_">forEach</span>(<span class="function">(<span class="params">choice</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (choice.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&#x27;chosen&#x27;</span>)) &#123;</span><br><span class="line">                        <span class="comment">// 带字母的选项</span></span><br><span class="line">                        <span class="keyword">const</span> answerTemp = choice.<span class="property">innerText</span>;</span><br><span class="line">                        <span class="comment">// 从字符串中拿出答案</span></span><br><span class="line">                        <span class="keyword">const</span> [, answer] = answerTemp.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (answer &amp;&amp; answer.<span class="property">length</span>) &#123;</span><br><span class="line">                            answers.<span class="title function_">push</span>(answer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 答案</span></span><br><span class="line">            <span class="keyword">const</span> answer = answers.<span class="title function_">join</span>(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">            <span class="comment">// 存在答案</span></span><br><span class="line">            <span class="keyword">if</span> (answer.<span class="property">length</span>) &#123;</span><br><span class="line">                <span class="title function_">log</span>(<span class="string">&#x27;正在上传答案...&#x27;</span>);</span><br><span class="line">                <span class="comment">// 上传答案</span></span><br><span class="line">                <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">saveAnswer</span>(question, answer);</span><br><span class="line">                <span class="title function_">log</span>(<span class="string">`上传答案<span class="subst">$&#123;res ? <span class="string">&#x27;成功&#x27;</span> : <span class="string">&#x27;失败&#x27;</span>&#125;</span>!`</span>, &#123; question, answer &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重置</span></span><br><span class="line">            shouldSaveAnswer = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确定</span></span><br><span class="line">        <span class="keyword">if</span> (nextText === <span class="string">&#x27;确定&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 确认</span></span><br><span class="line">            nextButton.<span class="title function_">click</span>();</span><br><span class="line">            <span class="comment">// 等待一段时间</span></span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">2000</span>);</span><br><span class="line">            <span class="comment">// 暂停</span></span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">examPauseLock</span>();</span><br><span class="line">            <span class="comment">// 答案解析</span></span><br><span class="line">            <span class="keyword">const</span> answerBox = $$(<span class="string">&#x27;.answer&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 答题错误</span></span><br><span class="line">            <span class="keyword">if</span> (answerBox) &#123;</span><br><span class="line">                <span class="keyword">const</span> answerTemp = answerBox.<span class="property">innerText</span>;</span><br><span class="line">                <span class="comment">// 从字符串中拿出答案</span></span><br><span class="line">                <span class="keyword">const</span> [, answerText] = answerTemp.<span class="title function_">split</span>(<span class="string">&#x27;：&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (answerText &amp;&amp; answerText.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> answer = answerText.<span class="title function_">replaceAll</span>(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">                    <span class="title function_">log</span>(<span class="string">&#x27;正在上传答案...&#x27;</span>);</span><br><span class="line">                    <span class="comment">// 上传答案</span></span><br><span class="line">                    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">saveAnswer</span>(question, answer);</span><br><span class="line">                    <span class="title function_">log</span>(<span class="string">`上传答案<span class="subst">$&#123;res ? <span class="string">&#x27;成功&#x27;</span> : <span class="string">&#x27;失败&#x27;</span>&#125;</span>!`</span>, &#123; question, answer &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取按钮</span></span><br><span class="line">        nextButton = <span class="keyword">await</span> <span class="title function_">getNextButton</span>();</span><br><span class="line">        <span class="comment">// 下一个文本</span></span><br><span class="line">        nextText = nextButton.<span class="property">innerText</span>.<span class="title function_">replaceAll</span>(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (nextText === <span class="string">&#x27;下一题&#x27;</span> || nextText === <span class="string">&#x27;完成&#x27;</span> || nextText === <span class="string">&#x27;交卷&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 等待一段时间</span></span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">2500</span>);</span><br><span class="line">            <span class="comment">// 下一题</span></span><br><span class="line">            nextButton.<span class="title function_">click</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 滑动验证</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">handleSlideVerify</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭任务窗口</span></span><br><span class="line">    <span class="title function_">handleCloseTaskWin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 每日答题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">doExamPractice</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 暂停</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">studyPauseLock</span>();</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;正在每日答题...&#x27;</span>);</span><br><span class="line">    <span class="comment">// 创建提示</span></span><br><span class="line">    <span class="title function_">createTip</span>(<span class="string">&#x27;正在每日答题&#x27;</span>);</span><br><span class="line">    <span class="comment">// 链接</span></span><br><span class="line">    <span class="keyword">const</span> url = <span class="variable constant_">URL_CONFIG</span>.<span class="property">examPractice</span>;</span><br><span class="line">    <span class="comment">// 等待任务窗口</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">waitTaskWin</span>(url, <span class="string">&#x27;每日答题&#x27;</span>);</span><br><span class="line">    <span class="comment">// 创建提示</span></span><br><span class="line">    <span class="title function_">createTip</span>(<span class="string">&#x27;完成每日答题!&#x27;</span>);</span><br><span class="line">    <span class="comment">// 等待一段时间</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">1500</span>);</span><br><span class="line">    <span class="comment">// 刷新分数数据</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">refreshScoreInfo</span>();</span><br><span class="line">    <span class="comment">// 刷新任务数据</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">refreshTaskList</span>();</span><br><span class="line">    <span class="comment">// 任务完成状况</span></span><br><span class="line">    <span class="keyword">if</span> (taskConfig[<span class="title class_">TaskType</span>.<span class="property">PRACTICE</span>].<span class="property">active</span> &amp;&amp;</span><br><span class="line">        !taskConfig[<span class="title class_">TaskType</span>.<span class="property">PRACTICE</span>].<span class="property">status</span>) &#123;</span><br><span class="line">        <span class="title function_">log</span>(<span class="string">&#x27;任务未完成, 继续每日答题!&#x27;</span>);</span><br><span class="line">        <span class="comment">// 创建提示</span></span><br><span class="line">        <span class="title function_">createTip</span>(<span class="string">&#x27;任务未完成, 继续每日答题!&#x27;</span>);</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">doExamPractice</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 专项练习</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">doExamPaper</span>(<span class="params"></span>) &#123;</span><br><span class="line">    running.<span class="property">value</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;正在专项练习...&#x27;</span>);</span><br><span class="line">    <span class="comment">// 创建提示</span></span><br><span class="line">    <span class="title function_">createTip</span>(<span class="string">&#x27;正在专项练习&#x27;</span>);</span><br><span class="line">    <span class="comment">// id</span></span><br><span class="line">    <span class="keyword">const</span> examPaperId = <span class="keyword">await</span> <span class="title function_">findExamPaper</span>();</span><br><span class="line">    <span class="keyword">if</span> (examPaperId) &#123;</span><br><span class="line">        <span class="comment">// 链接</span></span><br><span class="line">        <span class="keyword">const</span> url = <span class="string">`<span class="subst">$&#123;URL_CONFIG.examPaper&#125;</span>?id=<span class="subst">$&#123;examPaperId&#125;</span>`</span>;</span><br><span class="line">        <span class="title function_">log</span>(<span class="string">`链接: <span class="subst">$&#123;url&#125;</span>`</span>);</span><br><span class="line">        <span class="comment">// 等待窗口任务</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">waitTaskWin</span>(url, <span class="string">&#x27;专项练习&#x27;</span>);</span><br><span class="line">        <span class="comment">// 创建提示</span></span><br><span class="line">        <span class="title function_">createTip</span>(<span class="string">&#x27;完成专项练习!&#x27;</span>);</span><br><span class="line">        running.<span class="property">value</span> = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 同屏任务</span></span><br><span class="line">        <span class="keyword">if</span> (settings[<span class="title class_">SettingType</span>.<span class="property">SAME_TAB</span>]) &#123;</span><br><span class="line">            <span class="comment">// 窗口不存在</span></span><br><span class="line">            frame.<span class="property">exist</span> = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    running.<span class="property">value</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 创建提示</span></span><br><span class="line">    <span class="title function_">createTip</span>(<span class="string">&#x27;专项练习均已完成!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 初始化总页数属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">initExam</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 默认从第一页获取全部页属性</span></span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">getExamPaper</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="comment">// 等待</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> data.<span class="property">totalPageCount</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 查询专项练习列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">findExamPaper</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 获取总页数</span></span><br><span class="line">    <span class="keyword">const</span> total = <span class="keyword">await</span> <span class="title function_">initExam</span>();</span><br><span class="line">    <span class="comment">// 当前页数</span></span><br><span class="line">    <span class="keyword">let</span> current = <span class="number">1</span>;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">`正在寻找的专项练习...`</span>);</span><br><span class="line">    <span class="comment">// 创建提示</span></span><br><span class="line">    <span class="title function_">createTip</span>(<span class="string">`正在寻找的专项练习...`</span>);</span><br><span class="line">    <span class="keyword">while</span> (current &lt;= total &amp;&amp; current) &#123;</span><br><span class="line">        <span class="comment">// 请求数据</span></span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">getExamPaper</span>(current);</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            <span class="comment">// 获取专项练习的列表</span></span><br><span class="line">            <span class="keyword">const</span> examPapers = data.<span class="property">list</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">in</span> examPapers) &#123;</span><br><span class="line">                <span class="comment">// 遍历查询有没有没做过的</span></span><br><span class="line">                <span class="keyword">if</span> (examPapers[i].<span class="property">status</span> !== <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="comment">// status： 1 开始答题, 2 已满分/重新答题, 3 继续答题</span></span><br><span class="line">                    <span class="keyword">return</span> examPapers[i].<span class="property">id</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 增加页码</span></span><br><span class="line">            current += <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">3000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 初始化主页面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initMainListener</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 监听关闭</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; data &#125; = msg;</span><br><span class="line">        <span class="keyword">if</span> (data.<span class="property">id</span> === id.<span class="property">value</span> &amp;&amp; data.<span class="property">closed</span>) &#123;</span><br><span class="line">            <span class="comment">// 关闭窗口</span></span><br><span class="line">            <span class="title function_">closeFrame</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 初始化子页面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initChildListener</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; data &#125; = msg;</span><br><span class="line">        <span class="keyword">if</span> (data.<span class="property">id</span> &amp;&amp; !data.<span class="property">closed</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置窗口id</span></span><br><span class="line">            id.<span class="property">value</span> = data.<span class="property">id</span>;</span><br><span class="line">            <span class="title function_">log</span>(<span class="string">`初始化窗口 ID: <span class="subst">$&#123;id.value&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 打开窗口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">url</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">openFrame</span>(<span class="params">url, title</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置 URL</span></span><br><span class="line">    frame.<span class="property">src</span> = url;</span><br><span class="line">    <span class="comment">// 等待元素</span></span><br><span class="line">    <span class="keyword">await</span> $_(<span class="string">&#x27;.egg_frame&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (frame.<span class="property">ele</span>) &#123;</span><br><span class="line">        <span class="comment">// id</span></span><br><span class="line">        id.<span class="property">value</span> = <span class="title function_">generateMix</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 打开</span></span><br><span class="line">        frame.<span class="property">closed</span> = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 设置标题</span></span><br><span class="line">        frame.<span class="property">title</span> = title || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="comment">// 等待页面加载</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">waitFrameLoaded</span>(frame.<span class="property">ele</span>);</span><br><span class="line">        <span class="comment">// 发送窗口 ID</span></span><br><span class="line">        frame.<span class="property">ele</span>.<span class="property">contentWindow</span>?.<span class="title function_">postMessage</span>(&#123; <span class="attr">id</span>: id.<span class="property">value</span>, <span class="attr">closed</span>: <span class="literal">false</span> &#125;, url);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 关闭窗口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">closeFrame</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">`关闭窗口 ID: <span class="subst">$&#123;id.value&#125;</span>`</span>);</span><br><span class="line">    <span class="comment">// 窗口显示</span></span><br><span class="line">    frame.<span class="property">show</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    frame.<span class="property">closed</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 标题</span></span><br><span class="line">    frame.<span class="property">title</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// src</span></span><br><span class="line">    frame.<span class="property">src</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 关闭 frame</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleCloseFrame</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">parent</span>.<span class="title function_">postMessage</span>(&#123; <span class="attr">id</span>: id.<span class="property">value</span>, <span class="attr">closed</span>: <span class="literal">true</span> &#125;, <span class="variable constant_">URL_CONFIG</span>.<span class="property">homeOrigin</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 等待窗口任务结束</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">id</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">waitFrameClose</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 窗口关闭</span></span><br><span class="line">            <span class="keyword">if</span> (frame.<span class="property">closed</span>) &#123;</span><br><span class="line">                <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">                <span class="title function_">resolve</span>(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">100</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待窗口加载</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">waitFrameLoaded</span>(<span class="params">iframe</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        iframe.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 打开新窗口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">openWin</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">GM_openInTab</span>(url, &#123;</span><br><span class="line">        <span class="attr">active</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">insert</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">setParent</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 关闭窗口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">closeWin</span>(<span class="params"></span>) &#123;</span><br><span class="line">    page.<span class="property">value</span> &amp;&amp; page.<span class="property">value</span>.<span class="title function_">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 关闭子窗口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleCloseWin</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">opener</span> = <span class="variable language_">window</span>;</span><br><span class="line">        <span class="keyword">const</span> win = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;_self&#x27;</span>);</span><br><span class="line">        win?.<span class="title function_">close</span>();</span><br><span class="line">        top?.<span class="title function_">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (e) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 等待窗口关闭</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">newPage</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">waitWinClose</span>(<span class="params">newPage</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        newPage.<span class="property">onclose</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="literal">undefined</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 关闭任务窗口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">closeTaskWin</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 同屏任务</span></span><br><span class="line">    <span class="keyword">if</span> (settings[<span class="title class_">SettingType</span>.<span class="property">SAME_TAB</span>] &amp;&amp; id.<span class="property">value</span>) &#123;</span><br><span class="line">        <span class="title function_">closeFrame</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非同屏任务</span></span><br><span class="line">    <span class="title function_">closeWin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 关闭任务窗口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleCloseTaskWin</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 同屏任务</span></span><br><span class="line">    <span class="keyword">if</span> (settings[<span class="title class_">SettingType</span>.<span class="property">SAME_TAB</span>] &amp;&amp; id.<span class="property">value</span>) &#123;</span><br><span class="line">        <span class="title function_">handleCloseFrame</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子窗口</span></span><br><span class="line">    <span class="title function_">handleCloseWin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 打开并等待任务结束</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">waitTaskWin</span>(<span class="params">url, title</span>) &#123;</span><br><span class="line">    <span class="comment">// 同屏任务</span></span><br><span class="line">    <span class="keyword">if</span> (settings[<span class="title class_">SettingType</span>.<span class="property">SAME_TAB</span>]) &#123;</span><br><span class="line">        <span class="comment">// 窗口存在</span></span><br><span class="line">        frame.<span class="property">exist</span> = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 显示窗体</span></span><br><span class="line">        frame.<span class="property">show</span> = !settings[<span class="title class_">SettingType</span>.<span class="property">SILENT_RUN</span>];</span><br><span class="line">        <span class="comment">// 新窗口</span></span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">openFrame</span>(url, title);</span><br><span class="line">        <span class="keyword">if</span> (res) &#123;</span><br><span class="line">            <span class="comment">// 等待窗口关闭</span></span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">waitFrameClose</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子页面任务</span></span><br><span class="line">    page.<span class="property">value</span> = <span class="title function_">openWin</span>(url);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">waitWinClose</span>(page.<span class="property">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 二维码刷新定时器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> refreshTimer = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 尝试登录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> tryLoginTimer = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 生成二维码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getQRCode</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;正在生成登录二维码...&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> qrCode = <span class="keyword">await</span> <span class="title function_">generateQRCode</span>();</span><br><span class="line">    <span class="keyword">if</span> (qrCode) &#123;</span><br><span class="line">        <span class="title function_">log</span>(<span class="string">&#x27;生成登录二维码成功!&#x27;</span>);</span><br><span class="line">        <span class="comment">// 链接</span></span><br><span class="line">        <span class="keyword">const</span> url = <span class="string">`https://login.xuexi.cn/login/qrcommit?showmenu=false&amp;code=<span class="subst">$&#123;qrCode&#125;</span>&amp;appId=dingoankubyrfkttorhpou`</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">code</span>: qrCode,</span><br><span class="line">            <span class="attr">src</span>: <span class="string">`<span class="subst">$&#123;API_CONFIG.qrcode&#125;</span>?data=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(url)&#125;</span>`</span>,</span><br><span class="line">            url,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;生成登录二维码失败!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 验证登录二维码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">code</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">checkQRCode</span>(<span class="params">code</span>) &#123;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;尝试用二维码登录...&#x27;</span>);</span><br><span class="line">    <span class="comment">// 二维码登录</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">loginWithQRCode</span>(code);</span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; data, code, success &#125; = res;</span><br><span class="line">        <span class="comment">// 临时登录验证码</span></span><br><span class="line">        <span class="keyword">if</span> (success &amp;&amp; data) &#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 二维码失效</span></span><br><span class="line">        <span class="keyword">if</span> (code === <span class="string">&#x27;11019&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 清除定时</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(tryLoginTimer);</span><br><span class="line">        <span class="comment">// 设置定时</span></span><br><span class="line">        tryLoginTimer = <span class="built_in">setTimeout</span>(<span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="keyword">await</span> <span class="title function_">checkQRCode</span>(code));</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 尝试二维码登录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">tryLogin</span>(<span class="params">checkCode</span>) &#123;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;正在获取签名...&#x27;</span>);</span><br><span class="line">    <span class="comment">// 获取签名</span></span><br><span class="line">    <span class="keyword">const</span> sign = <span class="keyword">await</span> <span class="title function_">getSign</span>();</span><br><span class="line">    <span class="keyword">if</span> (sign) &#123;</span><br><span class="line">        <span class="comment">// 生成uuid</span></span><br><span class="line">        <span class="keyword">const</span> uuid = crypto.<span class="title function_">randomUUID</span>();</span><br><span class="line">        <span class="keyword">const</span> [, code] = checkCode.<span class="title function_">split</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> state = <span class="string">`<span class="subst">$&#123;sign&#125;</span><span class="subst">$&#123;uuid&#125;</span>`</span>;</span><br><span class="line">        <span class="comment">// 安全检查</span></span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">secureCheck</span>(&#123; code, state &#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 刷新登录二维码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">handleLogin</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 清除刷新</span></span><br><span class="line">    <span class="built_in">clearInterval</span>(refreshTimer);</span><br><span class="line">    <span class="comment">// 每隔一段时间刷新</span></span><br><span class="line">    refreshTimer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 刷新二维码</span></span><br><span class="line">        <span class="title function_">handleLogin</span>();</span><br><span class="line">    &#125;, autoRefreshQRCodeInterval);</span><br><span class="line">    <span class="comment">// 是否超出次数</span></span><br><span class="line">    <span class="keyword">if</span> (refreshCount.<span class="property">value</span> &gt;= maxRefreshCount) &#123;</span><br><span class="line">        <span class="title function_">createTip</span>(<span class="string">&#x27;超过最大重试次数, 登录失败!&#x27;</span>);</span><br><span class="line">        <span class="comment">// 重置刷新数</span></span><br><span class="line">        refreshCount.<span class="property">value</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 隐藏二维码</span></span><br><span class="line">        loginQRCodeShow.<span class="property">value</span> = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 远程推送</span></span><br><span class="line">        <span class="keyword">if</span> (settings[<span class="title class_">SettingType</span>.<span class="property">REMOTE_PUSH</span>]) &#123;</span><br><span class="line">            <span class="comment">// 推送</span></span><br><span class="line">            <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">pushModal</span>(&#123;</span><br><span class="line">                <span class="attr">title</span>: <span class="string">&#x27;登录推送&#x27;</span>,</span><br><span class="line">                <span class="attr">content</span>: <span class="string">&#x27;超过最大重试次数, 登录失败!&#x27;</span>,</span><br><span class="line">                <span class="attr">type</span>: <span class="string">&#x27;fail&#x27;</span>,</span><br><span class="line">            &#125;, pushToken.<span class="property">value</span>);</span><br><span class="line">            <span class="title function_">createTip</span>(<span class="string">`登录推送<span class="subst">$&#123;res ? <span class="string">&#x27;成功&#x27;</span> : <span class="string">&#x27;失败&#x27;</span>&#125;</span>!`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 配置</span></span><br><span class="line">    <span class="keyword">const</span> imgWrap = $$(<span class="string">&#x27;.egg_login_img_wrap&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 图片</span></span><br><span class="line">    <span class="keyword">const</span> img = $$(<span class="string">&#x27;.egg_login_img&#x27;</span>, imgWrap)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (imgWrap &amp;&amp; img) &#123;</span><br><span class="line">        <span class="comment">// 刷新二维码</span></span><br><span class="line">        <span class="title function_">log</span>(<span class="string">&#x27;刷新登录二维码!&#x27;</span>);</span><br><span class="line">        <span class="comment">// 刷新次数累加</span></span><br><span class="line">        refreshCount.<span class="property">value</span>++;</span><br><span class="line">        <span class="comment">// 获取二维码</span></span><br><span class="line">        <span class="keyword">const</span> qrCode = <span class="keyword">await</span> <span class="title function_">getQRCode</span>();</span><br><span class="line">        <span class="keyword">if</span> (qrCode) &#123;</span><br><span class="line">            <span class="comment">// 获取连接</span></span><br><span class="line">            <span class="keyword">const</span> &#123; src, code, url &#125; = qrCode;</span><br><span class="line">            <span class="comment">// src</span></span><br><span class="line">            img.<span class="property">src</span> = src;</span><br><span class="line">            <span class="comment">// 开始登录</span></span><br><span class="line">            loginQRCodeShow.<span class="property">value</span> = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 远程推送</span></span><br><span class="line">            <span class="keyword">if</span> (settings[<span class="title class_">SettingType</span>.<span class="property">REMOTE_PUSH</span>]) &#123;</span><br><span class="line">                <span class="comment">// img html</span></span><br><span class="line">                <span class="keyword">const</span> imgWrap = <span class="title function_">getImgHTML</span>(src);</span><br><span class="line">                <span class="comment">// 跳转链接</span></span><br><span class="line">                <span class="keyword">const</span> aWrap = <span class="string">`</span></span><br><span class="line"><span class="string">   &lt;div&gt;</span></span><br><span class="line"><span class="string">      或在浏览器</span></span><br><span class="line"><span class="string">      &lt;a</span></span><br><span class="line"><span class="string">        href=&quot;dtxuexi://appclient/page/study_feeds?url=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(url)&#125;</span>&quot;</span></span><br><span class="line"><span class="string">        style=&quot;text-decoration: none&quot;</span></span><br><span class="line"><span class="string">        &gt;<span class="subst">$&#123;getHighlightHTML(<span class="string">&#x27;打开学习强国APP&#x27;</span>)&#125;</span>&lt;/a</span></span><br><span class="line"><span class="string">      &gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">                <span class="comment">// 推送</span></span><br><span class="line">                <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">pushModal</span>(&#123;</span><br><span class="line">                    <span class="attr">title</span>: <span class="string">&#x27;登录推送&#x27;</span>,</span><br><span class="line">                    <span class="attr">content</span>: [<span class="string">&#x27;扫一扫, 登录学习强国!&#x27;</span>, aWrap, imgWrap],</span><br><span class="line">                    <span class="attr">type</span>: <span class="string">&#x27;info&#x27;</span>,</span><br><span class="line">                &#125;, pushToken.<span class="property">value</span>);</span><br><span class="line">                <span class="title function_">createTip</span>(<span class="string">`登录推送<span class="subst">$&#123;res ? <span class="string">&#x27;成功&#x27;</span> : <span class="string">&#x27;失败&#x27;</span>&#125;</span>!`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取验证码</span></span><br><span class="line">            <span class="keyword">const</span> checkCode = <span class="keyword">await</span> <span class="title function_">checkQRCode</span>(code);</span><br><span class="line">            <span class="comment">// 验证成功</span></span><br><span class="line">            <span class="keyword">if</span> (checkCode) &#123;</span><br><span class="line">                <span class="comment">// 尝试登录</span></span><br><span class="line">                <span class="keyword">const</span> loginRes = <span class="keyword">await</span> <span class="title function_">tryLogin</span>(checkCode);</span><br><span class="line">                <span class="keyword">if</span> (loginRes) &#123;</span><br><span class="line">                    <span class="comment">// 清除刷新</span></span><br><span class="line">                    <span class="built_in">clearInterval</span>(refreshTimer);</span><br><span class="line">                    <span class="comment">// 二维码显示</span></span><br><span class="line">                    loginQRCodeShow.<span class="property">value</span> = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">// 登录成功</span></span><br><span class="line">                    <span class="title function_">log</span>(<span class="string">&#x27;登录成功!&#x27;</span>);</span><br><span class="line">                    <span class="comment">// 创建提示</span></span><br><span class="line">                    <span class="title function_">createTip</span>(<span class="string">&#x27;登录成功!&#x27;</span>);</span><br><span class="line">                    <span class="comment">// 登录成功</span></span><br><span class="line">                    login.<span class="property">value</span> = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 刷新用户信息</span></span><br><span class="line">                    <span class="keyword">await</span> <span class="title function_">refreshUserInfo</span>();</span><br><span class="line">                    <span class="comment">// 刷新分数信息</span></span><br><span class="line">                    <span class="keyword">await</span> <span class="title function_">refreshScoreInfo</span>();</span><br><span class="line">                    <span class="comment">// 刷新任务信息</span></span><br><span class="line">                    <span class="keyword">await</span> <span class="title function_">refreshTaskList</span>();</span><br><span class="line">                    <span class="comment">// 远程推送</span></span><br><span class="line">                    <span class="keyword">if</span> (settings[<span class="title class_">SettingType</span>.<span class="property">REMOTE_PUSH</span>]) &#123;</span><br><span class="line">                        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">pushModal</span>(&#123;</span><br><span class="line">                            <span class="attr">title</span>: <span class="string">&#x27;登录推送&#x27;</span>,</span><br><span class="line">                            <span class="attr">to</span>: userinfo.<span class="property">nick</span>,</span><br><span class="line">                            <span class="attr">content</span>: [</span><br><span class="line">                                <span class="string">&#x27;学习强国, 登录成功!&#x27;</span>,</span><br><span class="line">                                <span class="string">`当天积分:  <span class="subst">$&#123;getHighlightHTML(todayScore.value)&#125;</span> 分`</span>,</span><br><span class="line">                                <span class="string">`总积分: <span class="subst">$&#123;getHighlightHTML(totalScore.value)&#125;</span> 分`</span>,</span><br><span class="line">                                ...taskConfig.<span class="title function_">map</span>(<span class="function">(<span class="params">task</span>) =&gt;</span> <span class="title function_">getProgressHTML</span>(task.<span class="property">title</span>, task.<span class="property">percent</span>)),</span><br><span class="line">                            ],</span><br><span class="line">                            <span class="attr">type</span>: <span class="string">&#x27;success&#x27;</span>,</span><br><span class="line">                        &#125;, pushToken.<span class="property">value</span>);</span><br><span class="line">                        <span class="title function_">createTip</span>(<span class="string">`登录推送<span class="subst">$&#123;res ? <span class="string">&#x27;成功&#x27;</span> : <span class="string">&#x27;失败&#x27;</span>&#125;</span>!`</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 二维码失效</span></span><br><span class="line">            <span class="title function_">log</span>(<span class="string">&#x27;登录二维码失效!&#x27;</span>);</span><br><span class="line">            <span class="comment">// 二维码失效刷新</span></span><br><span class="line">            <span class="title function_">handleLogin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 退出登录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleLogout</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 删除token</span></span><br><span class="line">    <span class="title function_">delCookie</span>(<span class="string">&#x27;token&#x27;</span>, <span class="string">&#x27;.xuexi.cn&#x27;</span>);</span><br><span class="line">    <span class="comment">// 关闭窗口</span></span><br><span class="line">    <span class="title function_">closeFrame</span>();</span><br><span class="line">    frame.<span class="property">exist</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 退出登录</span></span><br><span class="line">    login.<span class="property">value</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 清除用户信息</span></span><br><span class="line">    userinfo.<span class="property">nick</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    userinfo.<span class="property">avatar</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// 总分</span></span><br><span class="line">    totalScore.<span class="property">value</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当天分数</span></span><br><span class="line">    todayScore.<span class="property">value</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 任务进度重置</span></span><br><span class="line">    taskConfig.<span class="title function_">forEach</span>(<span class="function">(<span class="params">task</span>) =&gt;</span> &#123;</span><br><span class="line">        task.<span class="property">percent</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    taskStatus.<span class="property">value</span> = <span class="title class_">TaskStatusType</span>.<span class="property">LOADING</span>;</span><br><span class="line">    <span class="comment">// 退出登录</span></span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;退出登录&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 新闻</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> news = [];</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 视频</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> videos = [];</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 处理文章</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">handleNews</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// section</span></span><br><span class="line">    <span class="keyword">const</span> sections = <span class="keyword">await</span> $_(<span class="string">&#x27;section&#x27;</span>, <span class="literal">undefined</span>, <span class="number">5000</span>);</span><br><span class="line">    <span class="keyword">const</span> section = sections[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (!(section &amp;&amp; section.<span class="property">innerText</span>.<span class="title function_">includes</span>(<span class="string">&#x27;系统正在维护中&#x27;</span>))) &#123;</span><br><span class="line">        <span class="comment">// 文章选读</span></span><br><span class="line">        <span class="title function_">reading</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;未找到文章!&#x27;</span>);</span><br><span class="line">    <span class="comment">// 提示</span></span><br><span class="line">    <span class="title function_">createTip</span>(<span class="string">&#x27;未找到文章!&#x27;</span>);</span><br><span class="line">    <span class="comment">// 关闭页面</span></span><br><span class="line">    <span class="title function_">handleCloseTaskWin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 处理视频</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">handleVideo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// videos</span></span><br><span class="line">    <span class="keyword">const</span> videos = <span class="keyword">await</span> $_(<span class="string">&#x27;video&#x27;</span>, <span class="literal">undefined</span>, <span class="number">10000</span>);</span><br><span class="line">    <span class="comment">// 视频</span></span><br><span class="line">    <span class="keyword">const</span> video = videos[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 播放按键</span></span><br><span class="line">    <span class="keyword">const</span> playBtn = $$(<span class="string">&#x27;.prism-play-btn&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (video &amp;&amp; playBtn) &#123;</span><br><span class="line">        <span class="comment">// 设置是否静音</span></span><br><span class="line">        video.<span class="property">muted</span> = muted;</span><br><span class="line">        <span class="title function_">log</span>(<span class="string">&#x27;正在尝试播放视频...&#x27;</span>);</span><br><span class="line">        <span class="comment">// 播放超时</span></span><br><span class="line">        <span class="keyword">const</span> timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">log</span>(<span class="string">&#x27;视频播放超时!&#x27;</span>);</span><br><span class="line">            <span class="comment">// 提示</span></span><br><span class="line">            <span class="title function_">createTip</span>(<span class="string">&#x27;视频播放超时!&#x27;</span>);</span><br><span class="line">            <span class="comment">// 关闭页面</span></span><br><span class="line">            <span class="title function_">handleCloseTaskWin</span>();</span><br><span class="line">        &#125;, <span class="number">20000</span>);</span><br><span class="line">        <span class="comment">// 能播放</span></span><br><span class="line">        video.<span class="title function_">addEventListener</span>(<span class="string">&#x27;canplay&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">log</span>(<span class="string">&#x27;正在尝试播放视频...&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (video.<span class="property">paused</span>) &#123;</span><br><span class="line">                <span class="comment">// 尝试使用js的方式播放</span></span><br><span class="line">                video.<span class="title function_">play</span>();</span><br><span class="line">                <span class="keyword">if</span> (video.<span class="property">paused</span>) &#123;</span><br><span class="line">                    <span class="comment">// 尝试点击播放按钮播放</span></span><br><span class="line">                    playBtn.<span class="title function_">click</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 已经播放</span></span><br><span class="line">            <span class="keyword">if</span> (!video.<span class="property">paused</span>) &#123;</span><br><span class="line">                <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">                <span class="comment">// 视听学习</span></span><br><span class="line">                <span class="title function_">reading</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;未找到视频!&#x27;</span>);</span><br><span class="line">    <span class="comment">// 关闭页面</span></span><br><span class="line">    <span class="title function_">handleCloseTaskWin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 读新闻或者看视频</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type :0为新闻,1为视频</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">reading</span>(<span class="params">type</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> time = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 文章选读</span></span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 章节</span></span><br><span class="line">        <span class="keyword">const</span> sections = $$(<span class="string">&#x27;section&#x27;</span>);</span><br><span class="line">        <span class="comment">// 最大字数</span></span><br><span class="line">        <span class="keyword">const</span> maxTextCount = <span class="title class_">Math</span>.<span class="title function_">max</span>(...sections.<span class="title function_">map</span>(<span class="function">(<span class="params">s</span>) =&gt;</span> s.<span class="property">innerText</span>.<span class="property">length</span>), <span class="number">200</span>);</span><br><span class="line">        <span class="comment">// 预计时间</span></span><br><span class="line">        <span class="keyword">const</span> predictTime = ~~((<span class="number">60</span> * maxTextCount) / <span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// min(predictTime,  maxWatch.value) 秒后关闭页面</span></span><br><span class="line">        time = <span class="title class_">Math</span>.<span class="title function_">min</span>(predictTime, maxRead.<span class="property">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 视听学习</span></span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 视频</span></span><br><span class="line">        <span class="keyword">const</span> video = $$(<span class="string">&#x27;video&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 预计时间</span></span><br><span class="line">        <span class="keyword">const</span> predictTime = ~~video.<span class="property">duration</span>;</span><br><span class="line">        <span class="comment">// min(predictTime,  maxWatch.value) 秒后关闭页面</span></span><br><span class="line">        time = <span class="title class_">Math</span>.<span class="title function_">min</span>(predictTime, maxWatch.<span class="property">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 随机</span></span><br><span class="line">    time = time - ~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">10</span>) + <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 第一次滚动时间</span></span><br><span class="line">    <span class="keyword">const</span> firstTime = time - (~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">4</span>) + <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 第二次滚动时间</span></span><br><span class="line">    <span class="keyword">const</span> secendTime = ~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">4</span>) + <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 窗口</span></span><br><span class="line">    <span class="keyword">const</span> <span class="variable language_">window</span> = unsafeWindow;</span><br><span class="line">    <span class="comment">// 创建提示</span></span><br><span class="line">    <span class="keyword">const</span> tip = <span class="title function_">createTip</span>(<span class="string">&#x27;距离关闭页面还剩&#x27;</span>, time, <span class="literal">true</span>, <span class="title function_">async</span> (time) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 暂停锁</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">studyPauseLock</span>(<span class="function">(<span class="params">flag</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (type === <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 视频</span></span><br><span class="line">                <span class="keyword">const</span> video = $$(<span class="string">&#x27;video&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">// 排除反复设置</span></span><br><span class="line">                <span class="keyword">if</span> (video.<span class="property">paused</span> === !flag) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 设置播放状态</span></span><br><span class="line">                video[flag ? <span class="string">&#x27;play&#x27;</span> : <span class="string">&#x27;pause&#x27;</span>]();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 第一次滚动</span></span><br><span class="line">        <span class="keyword">if</span> (time === firstTime) &#123;</span><br><span class="line">            <span class="comment">// 滚动</span></span><br><span class="line">            <span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>, <span class="number">400</span>);</span><br><span class="line">            <span class="comment">// 模拟滚动</span></span><br><span class="line">            <span class="keyword">const</span> scroll = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;scroll&#x27;</span>, &#123;</span><br><span class="line">                <span class="attr">bubbles</span>: <span class="literal">true</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">dispatchEvent</span>(scroll);</span><br><span class="line">            <span class="comment">// 模拟滑动</span></span><br><span class="line">            <span class="keyword">const</span> mousemove = <span class="keyword">new</span> <span class="title class_">MouseEvent</span>(<span class="string">&#x27;mousemove&#x27;</span>, &#123;</span><br><span class="line">                <span class="attr">bubbles</span>: <span class="literal">true</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">dispatchEvent</span>(mousemove);</span><br><span class="line">            <span class="comment">// 模拟点击</span></span><br><span class="line">            <span class="keyword">const</span> click = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;click&#x27;</span>, &#123;</span><br><span class="line">                <span class="attr">bubbles</span>: <span class="literal">true</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">dispatchEvent</span>(click);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二次滚动</span></span><br><span class="line">        <span class="keyword">if</span> (time === secendTime) &#123;</span><br><span class="line">            <span class="comment">// 滚动长度</span></span><br><span class="line">            <span class="keyword">const</span> scrollLength = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollHeight</span> / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 滚动</span></span><br><span class="line">            <span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>, scrollLength);</span><br><span class="line">            <span class="comment">// 模拟滚动</span></span><br><span class="line">            <span class="keyword">const</span> scroll = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;scroll&#x27;</span>, &#123;</span><br><span class="line">                <span class="attr">bubbles</span>: <span class="literal">true</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">dispatchEvent</span>(scroll);</span><br><span class="line">            <span class="comment">// 模拟滑动</span></span><br><span class="line">            <span class="keyword">const</span> mousemove = <span class="keyword">new</span> <span class="title class_">MouseEvent</span>(<span class="string">&#x27;mousemove&#x27;</span>, &#123;</span><br><span class="line">                <span class="attr">bubbles</span>: <span class="literal">true</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">dispatchEvent</span>(mousemove);</span><br><span class="line">            <span class="comment">// 模拟点击</span></span><br><span class="line">            <span class="keyword">const</span> click = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;click&#x27;</span>, &#123;</span><br><span class="line">                <span class="attr">bubbles</span>: <span class="literal">true</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">dispatchEvent</span>(click);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 倒计时结束</span></span><br><span class="line">    <span class="keyword">await</span> tip.<span class="title function_">waitCountDown</span>();</span><br><span class="line">    <span class="comment">// 关闭任务窗口</span></span><br><span class="line">    <span class="title function_">handleCloseTaskWin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 获取新闻列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getNews</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 需要学习的新闻数量</span></span><br><span class="line">    <span class="keyword">const</span> need = taskConfig[<span class="title class_">TaskType</span>.<span class="property">READ</span>].<span class="property">need</span> &lt; maxNewsNum</span><br><span class="line">        ? taskConfig[<span class="title class_">TaskType</span>.<span class="property">READ</span>].<span class="property">need</span></span><br><span class="line">        : maxNewsNum;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">`剩余 <span class="subst">$&#123;need&#125;</span> 个新闻`</span>);</span><br><span class="line">    <span class="comment">// 获取新闻</span></span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">getNewsList</span>();</span><br><span class="line">    <span class="keyword">if</span> (data &amp;&amp; data.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="comment">// 索引</span></span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 最新新闻</span></span><br><span class="line">        <span class="keyword">const</span> latestItems = data.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 当前年份</span></span><br><span class="line">        <span class="keyword">const</span> currentYear = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>().<span class="title function_">toString</span>();</span><br><span class="line">        <span class="comment">// 查找今年新闻</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; need) &#123;</span><br><span class="line">            <span class="keyword">const</span> randomIndex = ~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * latestItems.<span class="property">length</span>);</span><br><span class="line">            <span class="comment">// 新闻</span></span><br><span class="line">            <span class="keyword">const</span> item = latestItems[randomIndex];</span><br><span class="line">            <span class="comment">// 是否存在</span></span><br><span class="line">            <span class="keyword">if</span> (item.<span class="property">publishTime</span>.<span class="title function_">startsWith</span>(currentYear) &amp;&amp; item.<span class="property">type</span> === <span class="string">&#x27;tuwen&#x27;</span>) &#123;</span><br><span class="line">                news[i] = item;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        news = [];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 获取视频列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getVideos</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 需要学习的视频数量</span></span><br><span class="line">    <span class="keyword">const</span> need = taskConfig[<span class="title class_">TaskType</span>.<span class="property">WATCH</span>].<span class="property">need</span> &lt; maxVideoNum</span><br><span class="line">        ? taskConfig[<span class="title class_">TaskType</span>.<span class="property">WATCH</span>].<span class="property">need</span></span><br><span class="line">        : maxVideoNum;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">`剩余 <span class="subst">$&#123;need&#125;</span> 个视频`</span>);</span><br><span class="line">    <span class="comment">// 获取视频</span></span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">getVideoList</span>();</span><br><span class="line">    <span class="keyword">if</span> (data &amp;&amp; data.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="comment">// 索引</span></span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 最新视频</span></span><br><span class="line">        <span class="keyword">const</span> latestItems = data.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 当前年份</span></span><br><span class="line">        <span class="keyword">const</span> currentYear = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>().<span class="title function_">toString</span>();</span><br><span class="line">        <span class="comment">// 查找今年视频</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; need) &#123;</span><br><span class="line">            <span class="keyword">const</span> randomIndex = ~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * latestItems.<span class="property">length</span>);</span><br><span class="line">            <span class="comment">// 新闻</span></span><br><span class="line">            <span class="keyword">const</span> item = latestItems[randomIndex];</span><br><span class="line">            <span class="comment">// 是否存在</span></span><br><span class="line">            <span class="keyword">if</span> (item.<span class="property">publishTime</span>.<span class="title function_">startsWith</span>(currentYear) &amp;&amp;</span><br><span class="line">                (item.<span class="property">type</span> === <span class="string">&#x27;shipin&#x27;</span> || item.<span class="property">type</span> === <span class="string">&#x27;juji&#x27;</span>)) &#123;</span><br><span class="line">                videos[i] = item;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        videos = [];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 阅读文章</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">readNews</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 获取文章</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">getNews</span>();</span><br><span class="line">    <span class="comment">// 观看文章</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">in</span> news) &#123;</span><br><span class="line">        <span class="comment">// 任务关闭跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (!taskConfig[<span class="title class_">TaskType</span>.<span class="property">READ</span>].<span class="property">active</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 暂停</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">studyPauseLock</span>();</span><br><span class="line">        <span class="title function_">log</span>(<span class="string">`正在阅读第 <span class="subst">$&#123;<span class="built_in">Number</span>(i) + <span class="number">1</span>&#125;</span> 个新闻...`</span>);</span><br><span class="line">        <span class="comment">// 创建提示</span></span><br><span class="line">        <span class="title function_">createTip</span>(<span class="string">`正在阅读第 <span class="subst">$&#123;<span class="built_in">Number</span>(i) + <span class="number">1</span>&#125;</span> 个新闻`</span>);</span><br><span class="line">        <span class="comment">// 链接</span></span><br><span class="line">        <span class="keyword">const</span> &#123; url &#125; = news[i];</span><br><span class="line">        <span class="comment">// 链接</span></span><br><span class="line">        <span class="title function_">GM_setValue</span>(<span class="string">&#x27;readingUrl&#x27;</span>, url);</span><br><span class="line">        <span class="comment">// 等待任务窗口</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">waitTaskWin</span>(url, <span class="string">&#x27;文章选读&#x27;</span>);</span><br><span class="line">        <span class="comment">// 清空链接</span></span><br><span class="line">        <span class="title function_">GM_setValue</span>(<span class="string">&#x27;readingUrl&#x27;</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 创建提示</span></span><br><span class="line">        <span class="title function_">createTip</span>(<span class="string">`完成阅读第 <span class="subst">$&#123;<span class="built_in">Number</span>(i) + <span class="number">1</span>&#125;</span> 个新闻!`</span>);</span><br><span class="line">        <span class="comment">// 等待一段时间</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">1500</span>);</span><br><span class="line">        <span class="comment">// 刷新分数数据</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">refreshScoreInfo</span>();</span><br><span class="line">        <span class="comment">// 刷新任务数据</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">refreshTaskList</span>();</span><br><span class="line">        <span class="comment">// 任务完成跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (taskConfig[<span class="title class_">TaskType</span>.<span class="property">READ</span>].<span class="property">active</span> &amp;&amp; taskConfig[<span class="title class_">TaskType</span>.<span class="property">READ</span>].<span class="property">status</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 任务关闭跳出循环</span></span><br><span class="line">    <span class="keyword">if</span> (!taskConfig[<span class="title class_">TaskType</span>.<span class="property">READ</span>].<span class="property">active</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 任务完成状况</span></span><br><span class="line">    <span class="keyword">if</span> (taskConfig[<span class="title class_">TaskType</span>.<span class="property">READ</span>].<span class="property">active</span> &amp;&amp; !taskConfig[<span class="title class_">TaskType</span>.<span class="property">READ</span>].<span class="property">status</span>) &#123;</span><br><span class="line">        <span class="title function_">log</span>(<span class="string">&#x27;任务未完成, 继续阅读新闻!&#x27;</span>);</span><br><span class="line">        <span class="comment">// 创建提示</span></span><br><span class="line">        <span class="title function_">createTip</span>(<span class="string">&#x27;任务未完成, 继续阅读新闻!&#x27;</span>);</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">readNews</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 观看视频</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">watchVideo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 获取视频</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">getVideos</span>();</span><br><span class="line">    <span class="comment">// 观看视频</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">in</span> videos) &#123;</span><br><span class="line">        <span class="comment">// 任务关闭跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (!taskConfig[<span class="title class_">TaskType</span>.<span class="property">WATCH</span>].<span class="property">active</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 暂停</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">studyPauseLock</span>();</span><br><span class="line">        <span class="title function_">log</span>(<span class="string">`正在观看第 <span class="subst">$&#123;<span class="built_in">Number</span>(i) + <span class="number">1</span>&#125;</span> 个视频...`</span>);</span><br><span class="line">        <span class="comment">// 创建提示</span></span><br><span class="line">        <span class="title function_">createTip</span>(<span class="string">`正在观看第 <span class="subst">$&#123;<span class="built_in">Number</span>(i) + <span class="number">1</span>&#125;</span> 个视频`</span>);</span><br><span class="line">        <span class="comment">// 链接</span></span><br><span class="line">        <span class="keyword">const</span> &#123; url &#125; = videos[i];</span><br><span class="line">        <span class="comment">// 链接</span></span><br><span class="line">        <span class="title function_">GM_setValue</span>(<span class="string">&#x27;watchingUrl&#x27;</span>, url);</span><br><span class="line">        <span class="comment">// 等待任务窗口</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">waitTaskWin</span>(url, <span class="string">&#x27;视听学习&#x27;</span>);</span><br><span class="line">        <span class="comment">// 清空链接</span></span><br><span class="line">        <span class="title function_">GM_setValue</span>(<span class="string">&#x27;watchingUrl&#x27;</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 创建提示</span></span><br><span class="line">        <span class="title function_">createTip</span>(<span class="string">`完成观看第 <span class="subst">$&#123;<span class="built_in">Number</span>(i) + <span class="number">1</span>&#125;</span> 个视频!`</span>);</span><br><span class="line">        <span class="comment">// 等待一段时间</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">1500</span>);</span><br><span class="line">        <span class="comment">// 刷新分数数据</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">refreshScoreInfo</span>();</span><br><span class="line">        <span class="comment">// 刷新任务数据</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">refreshTaskList</span>();</span><br><span class="line">        <span class="comment">// 任务完成跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (taskConfig[<span class="title class_">TaskType</span>.<span class="property">WATCH</span>].<span class="property">active</span> &amp;&amp;</span><br><span class="line">            taskConfig[<span class="title class_">TaskType</span>.<span class="property">WATCH</span>].<span class="property">status</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 任务关闭跳出循环</span></span><br><span class="line">    <span class="keyword">if</span> (!taskConfig[<span class="title class_">TaskType</span>.<span class="property">WATCH</span>].<span class="property">active</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 任务完成状况</span></span><br><span class="line">    <span class="keyword">if</span> (taskConfig[<span class="title class_">TaskType</span>.<span class="property">WATCH</span>].<span class="property">active</span> &amp;&amp; !taskConfig[<span class="title class_">TaskType</span>.<span class="property">WATCH</span>].<span class="property">status</span>) &#123;</span><br><span class="line">        <span class="title function_">log</span>(<span class="string">&#x27;任务未完成, 继续观看视频!&#x27;</span>);</span><br><span class="line">        <span class="comment">// 创建提示</span></span><br><span class="line">        <span class="title function_">createTip</span>(<span class="string">&#x27;任务未完成, 继续观看看视频!&#x27;</span>);</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">watchVideo</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 定时刷新定时器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> scheduleTimer = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 刷新定时任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">refreshScheduleTask</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 清除定时刷新</span></span><br><span class="line">    <span class="built_in">clearInterval</span>(scheduleTimer);</span><br><span class="line">    <span class="comment">// 未登录</span></span><br><span class="line">    <span class="keyword">if</span> (!login.<span class="property">value</span>) &#123;</span><br><span class="line">        <span class="comment">// 剩余定时任务</span></span><br><span class="line">        <span class="keyword">const</span> restList = scheduleList.<span class="title function_">filter</span>(<span class="function">(<span class="params">s</span>) =&gt;</span> !<span class="title function_">isLate</span>(s));</span><br><span class="line">        <span class="comment">// 存在剩余任务</span></span><br><span class="line">        <span class="keyword">if</span> (restList.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> rest = restList[<span class="number">0</span>];</span><br><span class="line">            <span class="title function_">log</span>(<span class="string">`已设置 <span class="subst">$&#123;rest.time&#125;</span> 的定时任务!`</span>);</span><br><span class="line">            <span class="comment">// 提示</span></span><br><span class="line">            <span class="title function_">createTip</span>(<span class="string">`已设置 <span class="subst">$&#123;rest.time&#125;</span> 的定时任务!`</span>);</span><br><span class="line">            <span class="comment">// 时间</span></span><br><span class="line">            <span class="keyword">let</span> time = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 刷新间隔</span></span><br><span class="line">            <span class="keyword">const</span> interval = <span class="number">10</span>;</span><br><span class="line">            scheduleTimer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(time++ % interval)) &#123;</span><br><span class="line">                    <span class="title function_">log</span>(<span class="string">&#x27;定时刷新正在运行...&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 到达定时</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_">isNow</span>(rest)) &#123;</span><br><span class="line">                    <span class="built_in">clearInterval</span>(scheduleTimer);</span><br><span class="line">                    <span class="title function_">log</span>(<span class="string">`执行 <span class="subst">$&#123;rest.time&#125;</span> 的定时任务!`</span>);</span><br><span class="line">                    <span class="comment">// 提示</span></span><br><span class="line">                    <span class="title function_">createTip</span>(<span class="string">`执行 <span class="subst">$&#123;rest.time&#125;</span> 的定时任务!`</span>);</span><br><span class="line">                    <span class="comment">// 登录</span></span><br><span class="line">                    <span class="title function_">handleLogin</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 清除定时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clearScheduleTask</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(scheduleTimer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 创建学习提示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createTip</span>(<span class="params">text, delay = <span class="number">2</span>, countShow = <span class="literal">false</span>, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> tipWrap = $$(<span class="string">&#x27;.egg_tip_wrap&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 提前去除</span></span><br><span class="line">    <span class="keyword">const</span> tips = $$(<span class="string">&#x27;.egg_tip&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (tips.<span class="property">length</span>) &#123;</span><br><span class="line">        tips.<span class="title function_">forEach</span>(<span class="function">(<span class="params">t</span>) =&gt;</span> t.<span class="title function_">delay</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 延迟</span></span><br><span class="line">    <span class="keyword">const</span> delayCount = <span class="title function_">ref</span>(delay);</span><br><span class="line">    <span class="comment">// 文字</span></span><br><span class="line">    <span class="keyword">const</span> textContent = <span class="title function_">ref</span>(text);</span><br><span class="line">    <span class="comment">//显示</span></span><br><span class="line">    <span class="keyword">const</span> show = <span class="title function_">ref</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 延迟显示</span></span><br><span class="line">    <span class="keyword">const</span> delayShow = <span class="title function_">ref</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 销毁</span></span><br><span class="line">    <span class="keyword">let</span> destroyed = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 倒计时结束</span></span><br><span class="line">    <span class="keyword">let</span> done = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 提示</span></span><br><span class="line">    <span class="keyword">const</span> tip = <span class="title class_">Tip</span>(&#123;</span><br><span class="line">        <span class="attr">text</span>: textContent,</span><br><span class="line">        <span class="attr">count</span>: delayCount,</span><br><span class="line">        show,</span><br><span class="line">        delayShow,</span><br><span class="line">        <span class="attr">countShow</span>: <span class="title function_">ref</span>(countShow),</span><br><span class="line">        <span class="attr">callback</span>: <span class="title function_">async</span> (count) =&gt; &#123;</span><br><span class="line">            callback &amp;&amp; (<span class="keyword">await</span> <span class="title function_">callback</span>(count));</span><br><span class="line">            <span class="comment">// 恢复显示</span></span><br><span class="line">            <span class="keyword">if</span> (delayShow.<span class="property">value</span> &amp;&amp; count === delay) &#123;</span><br><span class="line">                delayShow.<span class="property">value</span> = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 倒计时结束</span></span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                done = <span class="literal">true</span>;</span><br><span class="line">                operate.<span class="title function_">destroy</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 操作</span></span><br><span class="line">    <span class="keyword">const</span> operate = &#123;</span><br><span class="line">        <span class="title function_">destroy</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!destroyed) &#123;</span><br><span class="line">                <span class="comment">// 隐藏</span></span><br><span class="line">                operate.<span class="title function_">hide</span>();</span><br><span class="line">                <span class="comment">// 销毁</span></span><br><span class="line">                destroyed = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        tip.<span class="property">ele</span>.<span class="title function_">remove</span>();</span><br><span class="line">                        <span class="title function_">resolve</span>(<span class="literal">undefined</span>);</span><br><span class="line">                    &#125;, <span class="number">300</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">hide</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!destroyed) &#123;</span><br><span class="line">                show.<span class="property">value</span> = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!destroyed) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        show.<span class="property">value</span> = <span class="literal">true</span>;</span><br><span class="line">                        <span class="title function_">resolve</span>(<span class="literal">undefined</span>);</span><br><span class="line">                    &#125;, <span class="number">300</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">setText</span>(<span class="params">text</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!destroyed) &#123;</span><br><span class="line">                textContent.<span class="property">value</span> = text;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">waitCountDown</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 计时器</span></span><br><span class="line">                <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 结束</span></span><br><span class="line">                    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                        <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">                        <span class="title function_">resolve</span>(<span class="literal">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="number">100</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">delay</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!destroyed) &#123;</span><br><span class="line">                delayShow.<span class="property">value</span> = <span class="literal">true</span>;</span><br><span class="line">                delayCount.<span class="property">value</span> += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">assign</span>(tip.<span class="property">ele</span>, operate);</span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="title function_">mountElement</span>(tip, tipWrap);</span><br><span class="line">    <span class="comment">// 显示</span></span><br><span class="line">    operate.<span class="title function_">show</span>();</span><br><span class="line">    <span class="keyword">return</span> operate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 刷新用户信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">refreshUserInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 未登录</span></span><br><span class="line">    <span class="keyword">if</span> (!login.<span class="property">value</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;用户未登录!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 已存在信息</span></span><br><span class="line">    <span class="keyword">if</span> (userinfo.<span class="property">nick</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;加载用户信息...&#x27;</span>);</span><br><span class="line">    <span class="comment">// 获取用户信息</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">getUserInfo</span>();</span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; avatarMediaUrl = <span class="string">&#x27;&#x27;</span>, <span class="attr">nick</span>: nickRes &#125; = res;</span><br><span class="line">        <span class="keyword">if</span> (nickRes) &#123;</span><br><span class="line">            <span class="comment">// 设置昵称</span></span><br><span class="line">            userinfo.<span class="property">nick</span> = nickRes;</span><br><span class="line">            <span class="comment">// 设置头像</span></span><br><span class="line">            userinfo.<span class="property">avatar</span> = avatarMediaUrl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;加载用户信息失败!&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 刷新分数信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">refreshScoreInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 未登录</span></span><br><span class="line">    <span class="keyword">if</span> (!login.<span class="property">value</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;用户未登录!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;加载分数信息...&#x27;</span>);</span><br><span class="line">    <span class="comment">// 获取总分</span></span><br><span class="line">    <span class="keyword">const</span> totalScoreRes = <span class="keyword">await</span> <span class="title function_">getTotalScore</span>();</span><br><span class="line">    <span class="comment">// 获取当天总分</span></span><br><span class="line">    <span class="keyword">const</span> todayScoreRes = <span class="keyword">await</span> <span class="title function_">getTodayScore</span>();</span><br><span class="line">    <span class="comment">// 整数值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(totalScoreRes) &amp;&amp; <span class="title class_">Number</span>.<span class="title function_">isInteger</span>(todayScoreRes)) &#123;</span><br><span class="line">        <span class="comment">// 设置分数</span></span><br><span class="line">        totalScore.<span class="property">value</span> = totalScoreRes;</span><br><span class="line">        todayScore.<span class="property">value</span> = todayScoreRes;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;加载分数信息失败!&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 刷新任务列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">refreshTaskList</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 未登录</span></span><br><span class="line">    <span class="keyword">if</span> (!login.<span class="property">value</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;用户未登录!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;加载任务进度...&#x27;</span>);</span><br><span class="line">    <span class="comment">// 原始任务进度</span></span><br><span class="line">    <span class="keyword">const</span> taskProgress = <span class="keyword">await</span> <span class="title function_">getTaskList</span>();</span><br><span class="line">    <span class="keyword">if</span> (taskProgress) &#123;</span><br><span class="line">        <span class="comment">// 登录</span></span><br><span class="line">        taskConfig[<span class="title class_">TaskType</span>.<span class="property">LOGIN</span>].<span class="property">currentScore</span> = taskProgress[<span class="number">2</span>].<span class="property">currentScore</span>;</span><br><span class="line">        taskConfig[<span class="title class_">TaskType</span>.<span class="property">LOGIN</span>].<span class="property">dayMaxScore</span> = taskProgress[<span class="number">2</span>].<span class="property">dayMaxScore</span>;</span><br><span class="line">        taskConfig[<span class="title class_">TaskType</span>.<span class="property">LOGIN</span>].<span class="property">need</span> =</span><br><span class="line">            taskProgress[<span class="number">2</span>].<span class="property">dayMaxScore</span> - taskProgress[<span class="number">2</span>].<span class="property">currentScore</span>;</span><br><span class="line">        <span class="comment">// 文章选读</span></span><br><span class="line">        taskConfig[<span class="title class_">TaskType</span>.<span class="property">READ</span>].<span class="property">currentScore</span> = taskProgress[<span class="number">0</span>].<span class="property">currentScore</span>;</span><br><span class="line">        taskConfig[<span class="title class_">TaskType</span>.<span class="property">READ</span>].<span class="property">dayMaxScore</span> = taskProgress[<span class="number">0</span>].<span class="property">dayMaxScore</span>;</span><br><span class="line">        taskConfig[<span class="title class_">TaskType</span>.<span class="property">READ</span>].<span class="property">need</span> =</span><br><span class="line">            taskProgress[<span class="number">0</span>].<span class="property">dayMaxScore</span> - taskProgress[<span class="number">0</span>].<span class="property">currentScore</span>;</span><br><span class="line">        <span class="comment">// 视听学习</span></span><br><span class="line">        taskConfig[<span class="title class_">TaskType</span>.<span class="property">WATCH</span>].<span class="property">currentScore</span> = taskProgress[<span class="number">1</span>].<span class="property">currentScore</span>;</span><br><span class="line">        taskConfig[<span class="title class_">TaskType</span>.<span class="property">WATCH</span>].<span class="property">dayMaxScore</span> = taskProgress[<span class="number">1</span>].<span class="property">dayMaxScore</span>;</span><br><span class="line">        taskConfig[<span class="title class_">TaskType</span>.<span class="property">WATCH</span>].<span class="property">need</span> =</span><br><span class="line">            taskProgress[<span class="number">1</span>].<span class="property">dayMaxScore</span> - taskProgress[<span class="number">1</span>].<span class="property">currentScore</span>;</span><br><span class="line">        <span class="comment">// 每日答题</span></span><br><span class="line">        taskConfig[<span class="title class_">TaskType</span>.<span class="property">PRACTICE</span>].<span class="property">currentScore</span> = taskProgress[<span class="number">3</span>].<span class="property">currentScore</span>;</span><br><span class="line">        taskConfig[<span class="title class_">TaskType</span>.<span class="property">PRACTICE</span>].<span class="property">dayMaxScore</span> = taskProgress[<span class="number">3</span>].<span class="property">dayMaxScore</span>;</span><br><span class="line">        taskConfig[<span class="title class_">TaskType</span>.<span class="property">PRACTICE</span>].<span class="property">need</span> = taskProgress[<span class="number">3</span>].<span class="property">dayMaxScore</span>;</span><br><span class="line">        <span class="comment">// 更新数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">in</span> taskConfig) &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; currentScore, dayMaxScore &#125; = taskConfig[i];</span><br><span class="line">            <span class="comment">// 进度</span></span><br><span class="line">            <span class="keyword">const</span> rate = <span class="title class_">Number</span>(((<span class="number">100</span> * currentScore) / dayMaxScore).<span class="title function_">toFixed</span>(<span class="number">1</span>));</span><br><span class="line">            <span class="comment">// 百分比</span></span><br><span class="line">            taskConfig[i].<span class="property">percent</span> = rate;</span><br><span class="line">            <span class="comment">// 分数</span></span><br><span class="line">            taskConfig[i].<span class="property">score</span> = currentScore;</span><br><span class="line">            <span class="comment">// 完成状态</span></span><br><span class="line">            taskConfig[i].<span class="property">status</span> = rate === <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重试</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">2000</span>);</span><br><span class="line">    <span class="title function_">refreshTaskList</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Tip</span>(<span class="params">&#123; text, count, show, delayShow, countShow, callback, &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">        <span class="attr">class</span>: <span class="title function_">watchRef</span>([show, delayShow], <span class="function">() =&gt;</span> <span class="string">`egg_tip<span class="subst">$&#123;show.value ? (delayShow.value ? <span class="string">&#x27; active delay&#x27;</span> : <span class="string">&#x27; active&#x27;</span>) : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>),</span><br><span class="line">    &#125;, [</span><br><span class="line">        <span class="title function_">createElementNode</span>(<span class="string">&#x27;span&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">            <span class="attr">class</span>: <span class="string">&#x27;egg_text&#x27;</span>,</span><br><span class="line">        &#125;, <span class="title function_">createTextNode</span>(text)),</span><br><span class="line">        <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> countShow.<span class="property">value</span></span><br><span class="line">            ? <span class="title function_">createElementNode</span>(<span class="string">&#x27;span&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                <span class="attr">class</span>: <span class="string">&#x27;egg_countdown&#x27;</span>,</span><br><span class="line">            &#125;, <span class="title function_">createTextNode</span>(<span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> <span class="string">`<span class="subst">$&#123;count.value&#125;</span>s`</span>)))</span><br><span class="line">            : <span class="literal">undefined</span>),</span><br><span class="line">    ], &#123;</span><br><span class="line">        <span class="title function_">onMounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">// 倒计时</span></span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">countDown</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">                <span class="comment">// 倒计时回调</span></span><br><span class="line">                <span class="keyword">await</span> <span class="title function_">callback</span>(count.<span class="property">value</span>);</span><br><span class="line">                <span class="comment">// 倒计时结束</span></span><br><span class="line">                <span class="keyword">if</span> (!count.<span class="property">value</span>) &#123;</span><br><span class="line">                    show.<span class="property">value</span> = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count.<span class="property">value</span>--;</span><br><span class="line">                <span class="built_in">setTimeout</span>(countDown, <span class="number">1000</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="title function_">countDown</span>();</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 分隔符</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Hr</span>(<span class="params">&#123; text &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">        <span class="attr">class</span>: <span class="string">&#x27;egg_hr_wrap&#x27;</span>,</span><br><span class="line">    &#125;, [</span><br><span class="line">        <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_hr&#x27;</span> &#125;),</span><br><span class="line">        <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_hr_title&#x27;</span> &#125;, <span class="title function_">createTextNode</span>(text)),</span><br><span class="line">        <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_hr&#x27;</span> &#125;),</span><br><span class="line">    ]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Select</span>(<span class="params">&#123; data, maxlength, placeholder = <span class="string">&#x27;&#x27;</span>, onchange, onblur, value, keep, &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> selectData = <span class="title function_">reactive</span>(data.<span class="title function_">map</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> (&#123; <span class="attr">selected</span>: <span class="literal">false</span>, <span class="attr">active</span>: <span class="literal">false</span>, <span class="attr">ele</span>: <span class="literal">undefined</span>, ...v &#125;)));</span><br><span class="line">    <span class="keyword">const</span> focus = <span class="title function_">ref</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">const</span> input = <span class="title function_">shallowRef</span>(<span class="literal">undefined</span>);</span><br><span class="line">    <span class="keyword">const</span> list = <span class="title function_">shallowRef</span>(<span class="literal">undefined</span>);</span><br><span class="line">    <span class="keyword">const</span> valueRef = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    value &amp;&amp;</span><br><span class="line">        <span class="title function_">watch</span>(value, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> item = selectData.<span class="title function_">find</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> v.<span class="property">value</span> === value.<span class="property">value</span>);</span><br><span class="line">            valueRef.<span class="property">value</span> = item ? item.<span class="property">label</span> : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!item) &#123;</span><br><span class="line">                selectData.<span class="title function_">forEach</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> (v.<span class="property">selected</span> = <span class="literal">false</span>));</span><br><span class="line">                list.<span class="property">value</span> &amp;&amp; (list.<span class="property">value</span>.<span class="property">scrollTop</span> = <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">        <span class="attr">class</span>: <span class="string">&#x27;egg_select&#x27;</span>,</span><br><span class="line">    &#125;, [</span><br><span class="line">        <span class="title function_">createElementNode</span>(<span class="string">&#x27;input&#x27;</span>, &#123; <span class="attr">value</span>: valueRef &#125;, &#123;</span><br><span class="line">            <span class="attr">class</span>: <span class="string">&#x27;egg_select_input&#x27;</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;text&#x27;</span>,</span><br><span class="line">            placeholder,</span><br><span class="line">            maxlength,</span><br><span class="line">            <span class="attr">ref</span>: input,</span><br><span class="line">            <span class="title function_">onfocus</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (list.<span class="property">value</span> &amp;&amp; input.<span class="property">value</span>) &#123;</span><br><span class="line">                    focus.<span class="property">value</span> = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (input.<span class="property">value</span>.<span class="property">value</span> &amp;&amp; valueRef.<span class="property">value</span>) &#123;</span><br><span class="line">                        <span class="keyword">const</span> index = selectData.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> v.<span class="property">label</span> === valueRef.<span class="property">value</span>);</span><br><span class="line">                        <span class="keyword">if</span> (index + <span class="number">1</span>) &#123;</span><br><span class="line">                            list.<span class="property">value</span>.<span class="property">scrollTop</span> = selectData[index].<span class="property">ele</span>?.<span class="property">offsetTop</span> || <span class="number">0</span>;</span><br><span class="line">                            selectData.<span class="title function_">forEach</span>(<span class="function">(<span class="params">v, i</span>) =&gt;</span> (v.<span class="property">selected</span> = i === index));</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">oninput</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (list.<span class="property">value</span> &amp;&amp; input.<span class="property">value</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> &#123; value &#125; = input.<span class="property">value</span>;</span><br><span class="line">                    <span class="comment">// 文本存在</span></span><br><span class="line">                    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">                        <span class="keyword">const</span> index = selectData.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> v.<span class="property">label</span>.<span class="title function_">includes</span>(value));</span><br><span class="line">                        <span class="comment">// 存在匹配</span></span><br><span class="line">                        <span class="keyword">if</span> (index + <span class="number">1</span>) &#123;</span><br><span class="line">                            list.<span class="property">value</span>.<span class="property">scrollTop</span> = selectData[index].<span class="property">ele</span>?.<span class="property">offsetTop</span> || <span class="number">0</span>;</span><br><span class="line">                            selectData.<span class="title function_">forEach</span>(<span class="function">(<span class="params">v, i</span>) =&gt;</span> &#123;</span><br><span class="line">                                v.<span class="property">active</span> = i === index;</span><br><span class="line">                                v.<span class="property">active</span> &amp;&amp;</span><br><span class="line">                                    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                                        v.<span class="property">active</span> = <span class="literal">false</span>;</span><br><span class="line">                                    &#125;, <span class="number">300</span>);</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 清除</span></span><br><span class="line">                    selectData.<span class="title function_">forEach</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> (v.<span class="property">active</span> = v.<span class="property">selected</span> = <span class="literal">false</span>));</span><br><span class="line">                    list.<span class="property">value</span>.<span class="property">scrollTop</span> = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">onblur</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (list.<span class="property">value</span> &amp;&amp; input.<span class="property">value</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> item = selectData.<span class="title function_">find</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> v.<span class="property">selected</span>);</span><br><span class="line">                    <span class="comment">// 关闭选项</span></span><br><span class="line">                    <span class="keyword">if</span> (item || !input.<span class="property">value</span>.<span class="property">value</span>) &#123;</span><br><span class="line">                        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                            focus.<span class="property">value</span> = <span class="literal">false</span>;</span><br><span class="line">                        &#125;, <span class="number">100</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 恢复文本</span></span><br><span class="line">                    <span class="keyword">if</span> (item &amp;&amp; input.<span class="property">value</span>.<span class="property">value</span> !== item.<span class="property">label</span>) &#123;</span><br><span class="line">                        input.<span class="property">value</span>.<span class="property">value</span> = item.<span class="property">label</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 保留文本</span></span><br><span class="line">                    <span class="keyword">if</span> (!item &amp;&amp; keep) &#123;</span><br><span class="line">                        input.<span class="property">value</span>.<span class="property">value</span> = valueRef.<span class="property">value</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    onblur &amp;&amp;</span><br><span class="line">                        <span class="title function_">onblur</span>(item ? &#123; <span class="attr">label</span>: item.<span class="property">label</span>, <span class="attr">value</span>: item.<span class="property">value</span> &#125; : <span class="literal">undefined</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">            <span class="attr">class</span>: <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> <span class="string">`egg_select_list<span class="subst">$&#123;focus.value ? <span class="string">&#x27;&#x27;</span> : <span class="string">&#x27; hide&#x27;</span>&#125;</span>`</span>),</span><br><span class="line">            <span class="attr">ref</span>: list,</span><br><span class="line">        &#125;, selectData.<span class="title function_">map</span>(<span class="function">(<span class="params">v, index</span>) =&gt;</span> <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">            <span class="attr">class</span>: <span class="title function_">watchRef</span>(<span class="function">() =&gt;</span> [v.<span class="property">selected</span>, v.<span class="property">active</span>], <span class="function">() =&gt;</span> <span class="string">`egg_select_item<span class="subst">$&#123;v.selected ? <span class="string">&#x27; selected&#x27;</span> : v.active ? <span class="string">&#x27; active&#x27;</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>),</span><br><span class="line">            <span class="attr">ref</span>: <span class="function">(<span class="params">e</span>) =&gt;</span> (v.<span class="property">ele</span> = e),</span><br><span class="line">            <span class="attr">onclick</span>: <span class="title function_">debounce</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (valueRef.<span class="property">value</span> !== v.<span class="property">label</span>) &#123;</span><br><span class="line">                    onchange &amp;&amp; <span class="title function_">onchange</span>(&#123; <span class="attr">label</span>: v.<span class="property">label</span>, <span class="attr">value</span>: v.<span class="property">value</span> &#125;);</span><br><span class="line">                    selectData.<span class="title function_">forEach</span>(<span class="function">(<span class="params">v, i</span>) =&gt;</span> &#123;</span><br><span class="line">                        v.<span class="property">selected</span> = i === index;</span><br><span class="line">                        v.<span class="property">selected</span> &amp;&amp; (valueRef.<span class="property">value</span> = v.<span class="property">label</span>);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                focus.<span class="property">value</span> = <span class="literal">false</span>;</span><br><span class="line">            &#125;, <span class="number">300</span>),</span><br><span class="line">        &#125;, <span class="title function_">createTextNode</span>(v.<span class="property">label</span>)))),</span><br><span class="line">    ]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 答题按钮</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ExamBtn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createElementNode</span>(<span class="string">&#x27;button&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">        <span class="attr">class</span>: <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> <span class="string">`egg_exam_btn<span class="subst">$&#123;examPause.value ? <span class="string">&#x27; manual&#x27;</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>),</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">        <span class="attr">onclick</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            examPause.<span class="property">value</span> = !examPause.<span class="property">value</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;, <span class="title function_">createTextNode</span>(<span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> <span class="string">`<span class="subst">$&#123;examPause.value ? <span class="string">&#x27;开启自动答题&#x27;</span> : <span class="string">&#x27;关闭自动答题&#x27;</span>&#125;</span>`</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 任务窗口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Frame</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 最大化</span></span><br><span class="line">    <span class="keyword">const</span> max = <span class="title function_">ref</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 容器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">        <span class="attr">class</span>: <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> <span class="string">`egg_frame_wrap<span class="subst">$&#123;frame.show ? <span class="string">&#x27;&#x27;</span> : <span class="string">&#x27; hide&#x27;</span>&#125;</span>`</span>),</span><br><span class="line">    &#125;, <span class="title function_">watchRef</span>(<span class="function">() =&gt;</span> [login.<span class="property">value</span>, settings[<span class="title class_">SettingType</span>.<span class="property">SAME_TAB</span>]], <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 同屏任务</span></span><br><span class="line">        <span class="keyword">if</span> (login.<span class="property">value</span> &amp;&amp; settings[<span class="title class_">SettingType</span>.<span class="property">SAME_TAB</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> [</span><br><span class="line">                <span class="comment">// 遮罩</span></span><br><span class="line">                <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_frame_mask&#x27;</span> &#125;),</span><br><span class="line">                <span class="comment">// 窗口内容</span></span><br><span class="line">                <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                    <span class="attr">class</span>: <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> <span class="string">`egg_frame_content_wrap <span class="subst">$&#123;max.value ? <span class="string">&#x27; max&#x27;</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>),</span><br><span class="line">                &#125;, [</span><br><span class="line">                    <span class="comment">// 窗口控制</span></span><br><span class="line">                    <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_frame_controls_wrap&#x27;</span> &#125;, [</span><br><span class="line">                        <span class="comment">// 标题</span></span><br><span class="line">                        <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                            <span class="attr">class</span>: <span class="string">&#x27;egg_frame_title&#x27;</span>,</span><br><span class="line">                        &#125;),</span><br><span class="line">                        <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                            <span class="attr">class</span>: <span class="string">&#x27;egg_frame_controls&#x27;</span>,</span><br><span class="line">                        &#125;, [</span><br><span class="line">                            <span class="comment">// 隐藏</span></span><br><span class="line">                            <span class="title function_">createElementNode</span>(<span class="string">&#x27;button&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                                <span class="attr">class</span>: <span class="string">&#x27;egg_frame_btn&#x27;</span>,</span><br><span class="line">                                <span class="attr">type</span>: <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">                                <span class="attr">title</span>: <span class="string">&#x27;隐藏&#x27;</span>,</span><br><span class="line">                                <span class="attr">onclick</span>: <span class="title function_">debounce</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                                    <span class="comment">// 隐藏窗口</span></span><br><span class="line">                                    frame.<span class="property">show</span> = <span class="literal">false</span>;</span><br><span class="line">                                &#125;, <span class="number">300</span>),</span><br><span class="line">                            &#125;, <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;svg&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                                <span class="attr">viewBox</span>: <span class="string">&#x27;0 0 1024 1024&#x27;</span>,</span><br><span class="line">                                <span class="attr">class</span>: <span class="string">&#x27;egg_icon&#x27;</span>,</span><br><span class="line">                            &#125;, <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;path&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                                <span class="attr">d</span>: <span class="string">&#x27;M863.7 552.5H160.3c-10.6 0-19.2-8.6-19.2-19.2v-41.7c0-10.6 8.6-19.2 19.2-19.2h703.3c10.6 0 19.2 8.6 19.2 19.2v41.7c0 10.6-8.5 19.2-19.1 19.2z&#x27;</span>,</span><br><span class="line">                            &#125;))),</span><br><span class="line">                            <span class="comment">// 改变大小</span></span><br><span class="line">                            <span class="title function_">createElementNode</span>(<span class="string">&#x27;button&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                                <span class="attr">class</span>: <span class="string">&#x27;egg_frame_btn&#x27;</span>,</span><br><span class="line">                                <span class="attr">type</span>: <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">                                <span class="attr">title</span>: <span class="string">&#x27;缩放&#x27;</span>,</span><br><span class="line">                                <span class="attr">onclick</span>: <span class="title function_">debounce</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                                    max.<span class="property">value</span> = !max.<span class="property">value</span>;</span><br><span class="line">                                &#125;, <span class="number">300</span>),</span><br><span class="line">                            &#125;, <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;svg&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                                <span class="attr">viewBox</span>: <span class="string">&#x27;0 0 1024 1024&#x27;</span>,</span><br><span class="line">                                <span class="attr">class</span>: <span class="string">&#x27;egg_icon&#x27;</span>,</span><br><span class="line">                            &#125;, <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;path&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                                <span class="attr">d</span>: <span class="string">&#x27;M609.52 584.92a35.309 35.309 0 0 1 24.98-10.36c9.37 0 18.36 3.73 24.98 10.36l189.29 189.22-0.07-114.3 0.57-6.35c3.25-17.98 19.7-30.5 37.9-28.85 18.2 1.65 32.12 16.92 32.09 35.2v200.23c-0.05 1.49-0.19 2.97-0.42 4.45l-0.21 1.13c-0.22 1.44-0.55 2.85-0.99 4.24l-0.57 1.62-0.56 1.41a34.163 34.163 0 0 1-7.62 11.36l2.12-2.4-0.14 0.14-0.92 1.06-1.06 1.2-0.57 0.57-0.56 0.57a36.378 36.378 0 0 1-16.23 8.39l-3.53 0.5-4.02 0.35h-199.6l-6.35-0.63c-16.73-3.06-28.9-17.63-28.93-34.64l0.56-6.35c3.07-16.76 17.67-28.93 34.71-28.92l114.29-0.14-189.07-189.1-4.09-4.94c-9.71-14.01-8.01-32.95 4.02-45.02z m-162.06 0c12.06 12.05 13.78 30.99 4.09 45.01l-4.09 4.94-189.15 189.08 114.3 0.14c17.04-0.01 31.65 12.17 34.71 28.92l0.57 6.35c-0.03 17.01-12.19 31.58-28.92 34.64l-6.35 0.63H173.09l-4.23-0.42-3.39-0.49a36.38 36.38 0 0 1-17.36-9.52l-1.06-1.13-0.98-1.13 0.98 1.06-1.97-2.26 0.85 1.06-0.42-0.56a35.137 35.137 0 0 1-3.74-5.64l-1.13-2.68a34.71 34.71 0 0 1-2.11-7.33l-0.28-1.13c-0.21-1.47-0.33-2.96-0.36-4.45V659.78c-0.03-18.28 13.89-33.55 32.09-35.2 18.2-1.65 34.65 10.87 37.9 28.85l0.57 6.35-0.07 114.36 189.29-189.22c13.77-13.77 36.11-13.77 49.88 0h-0.09z m-74.71-471.71l6.35 0.57c16.76 3.06 28.93 17.67 28.92 34.71l-0.63 6.35c-3.07 16.76-17.67 28.93-34.71 28.92l-114.3 0.14 189.15 189.08 4.09 4.94c10.26 15.02 7.42 35.37-6.55 47.01-13.98 11.63-34.51 10.74-47.42-2.07L208.29 233.71l0.07 114.3-0.57 6.35c-3.25 17.98-19.7 30.5-37.9 28.85-18.2-1.65-32.12-16.92-32.09-35.2V147.78c0-1.55 0.14-3.03 0.35-4.51l0.21-1.13c0.24-1.44 0.59-2.85 1.06-4.23a34.97 34.97 0 0 1 8.68-14.39l-2.12 2.4-0.42 0.57 1.55-1.84-0.99 1.06 0.92-0.98 2.26-2.33c3.04-2.73 6.52-4.92 10.3-6.49l2.82-1.06c3.45-1.07 7.04-1.62 10.65-1.62l-3.6 0.14h0.49l1.48-0.14h201.31z m512.91 0l1.41 0.14h0.42c2.43 0.29 4.84 0.79 7.19 1.48l2.82 1.06 2.61 1.2 3.04 1.76c2.09 1.33 4.03 2.89 5.78 4.66l1.13 1.2 0.78 0.98 0.21 0.14 0.49 0.64 2.33 3.17c2.35 3.83 3.98 8.07 4.8 12.49l0.21 1.13c0.21 1.48 0.35 2.96 0.35 4.44v200.37c-0.16 18.13-14.03 33.19-32.08 34.83-18.06 1.64-34.42-10.67-37.83-28.48l-0.57-6.35V233.65L659.54 422.87c-12.9 12.95-33.56 13.91-47.59 2.2-14.04-11.71-16.81-32.2-6.38-47.22l4.02-4.86 189.22-189.08-114.29-0.14c-17.06 0.04-31.71-12.14-34.78-28.92l-0.63-6.35c-0.01-17.04 12.16-31.65 28.93-34.71l6.35-0.57h201.27z m0 0&#x27;</span>,</span><br><span class="line">                            &#125;))),</span><br><span class="line">                            <span class="comment">// 关闭</span></span><br><span class="line">                            <span class="title function_">createElementNode</span>(<span class="string">&#x27;button&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                                <span class="attr">class</span>: <span class="string">&#x27;egg_frame_btn&#x27;</span>,</span><br><span class="line">                                <span class="attr">type</span>: <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">                                <span class="attr">title</span>: <span class="string">&#x27;关闭&#x27;</span>,</span><br><span class="line">                                <span class="attr">onclick</span>: <span class="title function_">debounce</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                                    <span class="comment">// 关闭窗口</span></span><br><span class="line">                                    <span class="title function_">closeFrame</span>();</span><br><span class="line">                                &#125;, <span class="number">300</span>),</span><br><span class="line">                            &#125;, <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;svg&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                                <span class="attr">viewBox</span>: <span class="string">&#x27;0 0 1024 1024&#x27;</span>,</span><br><span class="line">                                <span class="attr">class</span>: <span class="string">&#x27;egg_icon&#x27;</span>,</span><br><span class="line">                            &#125;, <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;path&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                                <span class="attr">d</span>: <span class="string">&#x27;M453.44 512L161.472 220.032a41.408 41.408 0 0 1 58.56-58.56L512 453.44 803.968 161.472a41.408 41.408 0 0 1 58.56 58.56L570.56 512l291.968 291.968a41.408 41.408 0 0 1-58.56 58.56L512 570.56 220.032 862.528a41.408 41.408 0 0 1-58.56-58.56L453.44 512z&#x27;</span>,</span><br><span class="line">                            &#125;))),</span><br><span class="line">                        ]),</span><br><span class="line">                    ]),</span><br><span class="line">                    <span class="comment">// 窗口内容</span></span><br><span class="line">                    <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                        <span class="attr">class</span>: <span class="string">&#x27;egg_frame_content&#x27;</span>,</span><br><span class="line">                    &#125;, <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> frame.<span class="property">src</span></span><br><span class="line">                        ? [</span><br><span class="line">                            <span class="title function_">createElementNode</span>(<span class="string">&#x27;iframe&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                                <span class="attr">class</span>: <span class="string">&#x27;egg_frame&#x27;</span>,</span><br><span class="line">                                <span class="attr">src</span>: frame.<span class="property">src</span>,</span><br><span class="line">                                <span class="title function_">ref</span>(<span class="params">ele</span>) &#123;</span><br><span class="line">                                    frame.<span class="property">ele</span> = ele;</span><br><span class="line">                                &#125;,</span><br><span class="line">                            &#125;, <span class="literal">undefined</span>),</span><br><span class="line">                        ]</span><br><span class="line">                        : <span class="literal">undefined</span>)),</span><br><span class="line">                ], &#123;</span><br><span class="line">                    <span class="title function_">onMounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">                        <span class="comment">// 隐藏窗口</span></span><br><span class="line">                        <span class="title function_">watch</span>(<span class="function">() =&gt;</span> [</span><br><span class="line">                            taskStatus.<span class="property">value</span>,</span><br><span class="line">                            running.<span class="property">value</span>,</span><br><span class="line">                            settings[<span class="title class_">SettingType</span>.<span class="property">SAME_TAB</span>],</span><br><span class="line">                            settings[<span class="title class_">SettingType</span>.<span class="property">SILENT_RUN</span>],</span><br><span class="line">                        ], <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                            <span class="comment">// 同屏任务</span></span><br><span class="line">                            <span class="keyword">if</span> (settings[<span class="title class_">SettingType</span>.<span class="property">SAME_TAB</span>] &amp;&amp;</span><br><span class="line">                                (taskStatus.<span class="property">value</span> === <span class="title class_">TaskStatusType</span>.<span class="property">START</span> ||</span><br><span class="line">                                    taskStatus.<span class="property">value</span> === <span class="title class_">TaskStatusType</span>.<span class="property">PAUSE</span> ||</span><br><span class="line">                                    running.<span class="property">value</span>)) &#123;</span><br><span class="line">                                <span class="comment">// 设置窗口显示</span></span><br><span class="line">                                frame.<span class="property">show</span> = !settings[<span class="title class_">SettingType</span>.<span class="property">SILENT_RUN</span>];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;),</span><br><span class="line">            ];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;), &#123;</span><br><span class="line">        <span class="title function_">onMounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">// 关闭窗口</span></span><br><span class="line">            <span class="title function_">watch</span>(<span class="function">() =&gt;</span> [login.<span class="property">value</span>, settings[<span class="title class_">SettingType</span>.<span class="property">SAME_TAB</span>]], <span class="function">() =&gt;</span> login.<span class="property">value</span> &amp;&amp;</span><br><span class="line">                (settings[<span class="title class_">SettingType</span>.<span class="property">SAME_TAB</span>] ? <span class="title function_">closeWin</span>() : <span class="title function_">closeFrame</span>()));</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 登录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">LoginItem</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> login.<span class="property">value</span></span><br><span class="line">            ? <span class="literal">undefined</span></span><br><span class="line">            : <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                <span class="attr">class</span>: <span class="string">&#x27;egg_login_item&#x27;</span>,</span><br><span class="line">            &#125;, [</span><br><span class="line">                <span class="comment">// 登录按钮</span></span><br><span class="line">                <span class="title function_">createElementNode</span>(<span class="string">&#x27;button&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                    <span class="attr">type</span>: <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">                    <span class="attr">class</span>: <span class="string">&#x27;egg_login_btn&#x27;</span>,</span><br><span class="line">                    <span class="attr">onclick</span>: <span class="title function_">debounce</span>(<span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">                        <span class="comment">// 开始登录</span></span><br><span class="line">                        <span class="title function_">handleLogin</span>();</span><br><span class="line">                    &#125;, <span class="number">300</span>),</span><br><span class="line">                &#125;, <span class="title function_">createTextNode</span>(<span class="string">&#x27;扫码登录&#x27;</span>)),</span><br><span class="line">                <span class="comment">// 窗口</span></span><br><span class="line">                <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                    <span class="attr">class</span>: <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> <span class="string">`egg_login_img_wrap<span class="subst">$&#123;loginQRCodeShow.value ? <span class="string">&#x27; active&#x27;</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>),</span><br><span class="line">                &#125;, <span class="title function_">createElementNode</span>(<span class="string">&#x27;img&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                    <span class="attr">class</span>: <span class="string">&#x27;egg_login_img&#x27;</span>,</span><br><span class="line">                &#125;)),</span><br><span class="line">            ], &#123;</span><br><span class="line">                <span class="title function_">onMounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">                    <span class="title function_">watch</span>(<span class="function">() =&gt;</span> settings[<span class="title class_">SettingType</span>.<span class="property">SCHEDULE_RUN</span>], <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="comment">// 未开启定时展示二维码</span></span><br><span class="line">                        <span class="keyword">if</span> (!settings[<span class="title class_">SettingType</span>.<span class="property">SCHEDULE_RUN</span>]) &#123;</span><br><span class="line">                            <span class="comment">// 开始登录</span></span><br><span class="line">                            <span class="title function_">handleLogin</span>();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="literal">true</span>);</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">InfoItem</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (login.<span class="property">value</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                <span class="attr">class</span>: <span class="string">&#x27;egg_info_item&#x27;</span>,</span><br><span class="line">            &#125;, [</span><br><span class="line">                <span class="comment">// 用户信息</span></span><br><span class="line">                <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_userinfo&#x27;</span> &#125;, [</span><br><span class="line">                    <span class="comment">// 头像</span></span><br><span class="line">                    <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_avatar&#x27;</span> &#125;, <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> [</span><br><span class="line">                            userinfo.<span class="property">avatar</span></span><br><span class="line">                                ? <span class="title function_">createElementNode</span>(<span class="string">&#x27;img&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                                    <span class="attr">src</span>: userinfo.<span class="property">avatar</span>,</span><br><span class="line">                                    <span class="attr">class</span>: <span class="string">&#x27;egg_avatar_img&#x27;</span>,</span><br><span class="line">                                &#125;)</span><br><span class="line">                                : <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                                    <span class="attr">class</span>: <span class="string">&#x27;egg_avatar_nick&#x27;</span>,</span><br><span class="line">                                &#125;, <span class="title function_">createTextNode</span>(<span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> userinfo.<span class="property">nick</span>.<span class="title function_">substring</span>(<span class="number">1</span>, <span class="number">3</span>)))),</span><br><span class="line">                        ];</span><br><span class="line">                    &#125;)),</span><br><span class="line">                    <span class="comment">// 昵称</span></span><br><span class="line">                    <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_nick&#x27;</span> &#125;, <span class="title function_">createTextNode</span>(<span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> userinfo.<span class="property">nick</span>))),</span><br><span class="line">                ]),</span><br><span class="line">                <span class="comment">// 退出按钮</span></span><br><span class="line">                <span class="title function_">createElementNode</span>(<span class="string">&#x27;button&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                    <span class="attr">type</span>: <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">                    <span class="attr">class</span>: <span class="string">&#x27;egg_login_btn&#x27;</span>,</span><br><span class="line">                    <span class="attr">onclick</span>: <span class="title function_">debounce</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="comment">// 退出登录</span></span><br><span class="line">                        <span class="title function_">handleLogout</span>();</span><br><span class="line">                    &#125;, <span class="number">300</span>),</span><br><span class="line">                &#125;, <span class="title function_">createTextNode</span>(<span class="string">&#x27;退出&#x27;</span>)),</span><br><span class="line">            ], &#123;</span><br><span class="line">                <span class="title function_">onMounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">                    <span class="comment">// 刷新用户信息</span></span><br><span class="line">                    <span class="title function_">refreshUserInfo</span>();</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 分数详情</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ScoreItem</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (login.<span class="property">value</span>) &#123;</span><br><span class="line">            <span class="comment">// 分数显示</span></span><br><span class="line">            <span class="keyword">const</span> scoreShow = <span class="title function_">ref</span>(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">// 分数信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                <span class="attr">class</span>: <span class="string">&#x27;egg_score_item&#x27;</span>,</span><br><span class="line">            &#125;, <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_scoreinfo&#x27;</span> &#125;, [</span><br><span class="line">                <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                    <span class="attr">class</span>: <span class="string">&#x27;egg_totalscore&#x27;</span>,</span><br><span class="line">                &#125;, [</span><br><span class="line">                    <span class="title function_">createTextNode</span>(<span class="string">&#x27;总积分&#x27;</span>),</span><br><span class="line">                    <span class="title function_">createElementNode</span>(<span class="string">&#x27;span&#x27;</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="title function_">createTextNode</span>(totalScore)),</span><br><span class="line">                ]),</span><br><span class="line">                <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                    <span class="attr">class</span>: <span class="string">&#x27;egg_todayscore&#x27;</span>,</span><br><span class="line">                &#125;, [</span><br><span class="line">                    <span class="title function_">createElementNode</span>(<span class="string">&#x27;button&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                        <span class="attr">type</span>: <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">                        <span class="attr">class</span>: <span class="string">&#x27;egg_todayscore_btn&#x27;</span>,</span><br><span class="line">                        <span class="attr">title</span>: <span class="string">&#x27;查看分数详情&#x27;</span>,</span><br><span class="line">                        <span class="attr">onclick</span>: <span class="title function_">debounce</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                            scoreShow.<span class="property">value</span> = !scoreShow.<span class="property">value</span>;</span><br><span class="line">                        &#125;, <span class="number">300</span>),</span><br><span class="line">                        <span class="attr">onblur</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                            scoreShow.<span class="property">value</span> = <span class="literal">false</span>;</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &#125;, [</span><br><span class="line">                        <span class="title function_">createTextNode</span>(<span class="string">&#x27;当天分数&#x27;</span>),</span><br><span class="line">                        <span class="comment">// 当天分数</span></span><br><span class="line">                        <span class="title function_">createElementNode</span>(<span class="string">&#x27;span&#x27;</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="title function_">createTextNode</span>(todayScore)),</span><br><span class="line">                        <span class="comment">// icon</span></span><br><span class="line">                        <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;svg&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                            <span class="attr">viewBox</span>: <span class="string">&#x27;0 0 1024 1024&#x27;</span>,</span><br><span class="line">                            <span class="attr">class</span>: <span class="string">&#x27;egg_icon&#x27;</span>,</span><br><span class="line">                        &#125;, <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;path&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                            <span class="attr">d</span>: <span class="string">&#x27;M332.16 883.84a40.96 40.96 0 0 0 58.24 0l338.56-343.04a40.96 40.96 0 0 0 0-58.24L390.4 140.16a40.96 40.96 0 0 0-58.24 58.24L640 512l-307.84 314.24a40.96 40.96 0 0 0 0 57.6z&#x27;</span>,</span><br><span class="line">                        &#125;)),</span><br><span class="line">                        <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                            <span class="attr">class</span>: <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> <span class="string">`egg_score_details<span class="subst">$&#123;scoreShow.value ? <span class="string">&#x27;&#x27;</span> : <span class="string">&#x27; hide&#x27;</span>&#125;</span>`</span>),</span><br><span class="line">                        &#125;, [</span><br><span class="line">                            <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_score_title&#x27;</span> &#125;, [</span><br><span class="line">                                <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;svg&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                                    <span class="attr">viewBox</span>: <span class="string">&#x27;0 0 1024 1024&#x27;</span>,</span><br><span class="line">                                    <span class="attr">class</span>: <span class="string">&#x27;egg_icon&#x27;</span>,</span><br><span class="line">                                &#125;, [</span><br><span class="line">                                    <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;path&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                                        <span class="attr">d</span>: <span class="string">&#x27;M314.81 304.01h415.86v58.91H314.81zM314.81 440.24h415.86v58.91H314.81z&#x27;</span>,</span><br><span class="line">                                    &#125;),</span><br><span class="line">                                    <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;path&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                                        <span class="attr">d</span>: <span class="string">&#x27;M814.8 892.74h-8.64l-283.51-182-283.51 182h-8.64A69.85 69.85 0 0 1 160.72 823V188.22a69.85 69.85 0 0 1 69.77-69.77H814.8a69.85 69.85 0 0 1 69.77 69.77V823a69.85 69.85 0 0 1-69.77 69.74zM230.5 177.35a10.87 10.87 0 0 0-10.86 10.86V823a10.86 10.86 0 0 0 5 9.11l298.01-191.42 298.06 191.38a10.86 10.86 0 0 0 5-9.11V188.22a10.87 10.87 0 0 0-10.86-10.86z&#x27;</span>,</span><br><span class="line">                                    &#125;),</span><br><span class="line">                                ]),</span><br><span class="line">                                <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                                    <span class="attr">class</span>: <span class="string">&#x27;egg_score_title_text&#x27;</span>,</span><br><span class="line">                                &#125;, <span class="title function_">createTextNode</span>(<span class="string">&#x27;积分详情&#x27;</span>)),</span><br><span class="line">                            ]),</span><br><span class="line">                            ...taskConfig.<span class="title function_">map</span>(<span class="function">(<span class="params">task</span>) =&gt;</span> <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_score_item&#x27;</span> &#125;, [</span><br><span class="line">                                <span class="title function_">createTextNode</span>(task.<span class="property">title</span>),</span><br><span class="line">                                <span class="title function_">createElementNode</span>(<span class="string">&#x27;span&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                                    <span class="attr">class</span>: <span class="string">&#x27;egg_score_detail&#x27;</span>,</span><br><span class="line">                                &#125;, <span class="title function_">createTextNode</span>(<span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> task.<span class="property">score</span>))),</span><br><span class="line">                            ])),</span><br><span class="line">                        ]),</span><br><span class="line">                    ]),</span><br><span class="line">                ]),</span><br><span class="line">            ]), &#123;</span><br><span class="line">                <span class="title function_">onMounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">                    <span class="comment">// 刷新分数信息</span></span><br><span class="line">                    <span class="title function_">refreshScoreInfo</span>();</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 设置普通项</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">NomalItem</span>(<span class="params">&#123; title, tip, checked, onchange, &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_setting_item&#x27;</span> &#125;, [</span><br><span class="line">        <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_label_wrap&#x27;</span> &#125;, [</span><br><span class="line">            <span class="title function_">createElementNode</span>(<span class="string">&#x27;label&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_task_title&#x27;</span> &#125;, [</span><br><span class="line">                <span class="title function_">createTextNode</span>(title),</span><br><span class="line">                <span class="title function_">createElementNode</span>(<span class="string">&#x27;span&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                    <span class="attr">class</span>: <span class="string">&#x27;egg_detail&#x27;</span>,</span><br><span class="line">                    <span class="attr">title</span>: tip,</span><br><span class="line">                &#125;, <span class="title function_">createTextNode</span>(<span class="string">&#x27;i&#x27;</span>)),</span><br><span class="line">            ]),</span><br><span class="line">        ]),</span><br><span class="line">        <span class="title function_">createElementNode</span>(<span class="string">&#x27;input&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">            <span class="attr">title</span>: tip,</span><br><span class="line">            <span class="attr">class</span>: <span class="string">&#x27;egg_switch&#x27;</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;checkbox&#x27;</span>,</span><br><span class="line">            checked,</span><br><span class="line">            onchange,</span><br><span class="line">        &#125;),</span><br><span class="line">    ]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 设置任务项</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">TaskItem</span>(<span class="params">&#123; title, tip, checked, percent, currentScore, dayMaxScore, onchange, immutable, &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">        <span class="attr">class</span>: <span class="string">&#x27;egg_task_item&#x27;</span>,</span><br><span class="line">    &#125;, [</span><br><span class="line">        <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_label_wrap&#x27;</span> &#125;, [</span><br><span class="line">            <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_task_title_wrap&#x27;</span> &#125;, [</span><br><span class="line">                <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_task_title&#x27;</span> &#125;, <span class="title function_">createTextNode</span>(title)),</span><br><span class="line">                <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_task_progress_wrap&#x27;</span> &#125;, [</span><br><span class="line">                    <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                        <span class="attr">class</span>: <span class="string">&#x27;egg_task_current&#x27;</span>,</span><br><span class="line">                    &#125;, <span class="title function_">createTextNode</span>(currentScore)),</span><br><span class="line">                    <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                        <span class="attr">class</span>: <span class="string">&#x27;egg_task_max&#x27;</span>,</span><br><span class="line">                    &#125;, <span class="title function_">createTextNode</span>(<span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> <span class="string">`/<span class="subst">$&#123;dayMaxScore.value&#125;</span>`</span>))),</span><br><span class="line">                ]),</span><br><span class="line">            ]),</span><br><span class="line">            <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_progress&#x27;</span> &#125;, [</span><br><span class="line">                <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_track&#x27;</span> &#125;, <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                    <span class="attr">class</span>: <span class="string">&#x27;egg_bar&#x27;</span>,</span><br><span class="line">                    <span class="attr">style</span>: <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> <span class="string">`width: <span class="subst">$&#123;percent.value&#125;</span>%;`</span>),</span><br><span class="line">                &#125;)),</span><br><span class="line">            ]),</span><br><span class="line">        ]),</span><br><span class="line">        <span class="title function_">createElementNode</span>(<span class="string">&#x27;input&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">            <span class="attr">title</span>: tip,</span><br><span class="line">            <span class="attr">class</span>: <span class="string">&#x27;egg_switch&#x27;</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;checkbox&#x27;</span>,</span><br><span class="line">            checked,</span><br><span class="line">            onchange,</span><br><span class="line">            <span class="attr">disabled</span>: immutable,</span><br><span class="line">        &#125;),</span><br><span class="line">    ]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">TaskList</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 处理任务设置变化</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleTaskChange</span> = (<span class="params">e, type, title</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 开关</span></span><br><span class="line">        <span class="keyword">const</span> &#123; checked &#125; = e.<span class="property">target</span>;</span><br><span class="line">        <span class="keyword">if</span> (taskConfig[type].<span class="property">active</span> !== checked) &#123;</span><br><span class="line">            taskConfig[type].<span class="property">active</span> = checked;</span><br><span class="line">            <span class="comment">// 设置</span></span><br><span class="line">            <span class="title function_">GM_setValue</span>(<span class="string">&#x27;taskConfig&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(taskConfig));</span><br><span class="line">            <span class="comment">// 创建提示</span></span><br><span class="line">            <span class="title function_">createTip</span>(<span class="string">`<span class="subst">$&#123;title&#125;</span> <span class="subst">$&#123;checked ? <span class="string">&#x27;打开&#x27;</span> : <span class="string">&#x27;关闭&#x27;</span>&#125;</span>!`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 登录加载</span></span><br><span class="line">    <span class="title function_">watch</span>(login, <span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (login.<span class="property">value</span>) &#123;</span><br><span class="line">            <span class="comment">// 加载任务列表</span></span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">refreshTaskList</span>();</span><br><span class="line">            <span class="comment">// 未完成任务</span></span><br><span class="line">            <span class="keyword">if</span> (taskConfig.<span class="title function_">some</span>(<span class="function">(<span class="params">task</span>) =&gt;</span> task.<span class="property">active</span> &amp;&amp; !task.<span class="property">status</span>)) &#123;</span><br><span class="line">                <span class="comment">// 全局暂停</span></span><br><span class="line">                <span class="title function_">GM_setValue</span>(<span class="string">&#x27;pauseStudy&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">                <span class="comment">// 加载完毕</span></span><br><span class="line">                taskStatus.<span class="property">value</span> = <span class="title class_">TaskStatusType</span>.<span class="property">LOADED</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 任务完毕</span></span><br><span class="line">            taskStatus.<span class="property">value</span> = <span class="title class_">TaskStatusType</span>.<span class="property">FINISH</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">        <span class="attr">class</span>: <span class="string">&#x27;egg_task_list&#x27;</span>,</span><br><span class="line">    &#125;, taskConfig.<span class="title function_">map</span>(<span class="function">(<span class="params">label</span>) =&gt;</span> label.<span class="property">immutable</span></span><br><span class="line">        ? <span class="title class_">TaskItem</span>(&#123;</span><br><span class="line">            <span class="attr">title</span>: label.<span class="property">title</span>,</span><br><span class="line">            <span class="attr">tip</span>: label.<span class="property">tip</span>,</span><br><span class="line">            <span class="attr">checked</span>: <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> label.<span class="property">active</span>),</span><br><span class="line">            <span class="attr">percent</span>: <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> label.<span class="property">percent</span>),</span><br><span class="line">            <span class="attr">currentScore</span>: <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> label.<span class="property">currentScore</span>),</span><br><span class="line">            <span class="attr">dayMaxScore</span>: <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> label.<span class="property">dayMaxScore</span>),</span><br><span class="line">            <span class="attr">onchange</span>: <span class="title function_">debounce</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">handleTaskChange</span>(e, label.<span class="property">type</span>, label.<span class="property">title</span>);</span><br><span class="line">            &#125;, <span class="number">300</span>),</span><br><span class="line">            <span class="attr">immutable</span>: label.<span class="property">immutable</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        : <span class="title class_">TaskItem</span>(&#123;</span><br><span class="line">            <span class="attr">title</span>: label.<span class="property">title</span>,</span><br><span class="line">            <span class="attr">tip</span>: label.<span class="property">tip</span>,</span><br><span class="line">            <span class="attr">checked</span>: <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> label.<span class="property">active</span>),</span><br><span class="line">            <span class="attr">percent</span>: <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> label.<span class="property">percent</span>),</span><br><span class="line">            <span class="attr">currentScore</span>: <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> label.<span class="property">currentScore</span>),</span><br><span class="line">            <span class="attr">dayMaxScore</span>: <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> label.<span class="property">dayMaxScore</span>),</span><br><span class="line">            <span class="attr">onchange</span>: <span class="title function_">debounce</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">handleTaskChange</span>(e, label.<span class="property">type</span>, label.<span class="property">title</span>);</span><br><span class="line">            &#125;, <span class="number">300</span>),</span><br><span class="line">            <span class="attr">immutable</span>: label.<span class="property">immutable</span>,</span><br><span class="line">        &#125;)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 任务按钮</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">TaskBtn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (login.<span class="property">value</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@description</span> 学习</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">study</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="comment">// 创建提示</span></span><br><span class="line">                <span class="title function_">createTip</span>(<span class="string">&#x27;开始学习!&#x27;</span>);</span><br><span class="line">                <span class="comment">// 暂停</span></span><br><span class="line">                <span class="keyword">await</span> <span class="title function_">studyPauseLock</span>();</span><br><span class="line">                <span class="comment">// 文章选读</span></span><br><span class="line">                <span class="keyword">if</span> (taskConfig[<span class="title class_">TaskType</span>.<span class="property">READ</span>].<span class="property">active</span> &amp;&amp;</span><br><span class="line">                    !taskConfig[<span class="title class_">TaskType</span>.<span class="property">READ</span>].<span class="property">status</span>) &#123;</span><br><span class="line">                    <span class="title function_">log</span>(<span class="string">&#x27;任务一: 文章选读&#x27;</span>);</span><br><span class="line">                    <span class="comment">// 创建提示</span></span><br><span class="line">                    <span class="title function_">createTip</span>(<span class="string">&#x27;任务一: 文章选读&#x27;</span>);</span><br><span class="line">                    <span class="comment">// 暂停</span></span><br><span class="line">                    <span class="keyword">await</span> <span class="title function_">studyPauseLock</span>();</span><br><span class="line">                    <span class="comment">// 看新闻</span></span><br><span class="line">                    <span class="keyword">await</span> <span class="title function_">readNews</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_">log</span>(<span class="string">&#x27;任务一: 文章选读已完成!&#x27;</span>);</span><br><span class="line">                <span class="comment">// 视听学习</span></span><br><span class="line">                <span class="keyword">if</span> (taskConfig[<span class="title class_">TaskType</span>.<span class="property">WATCH</span>].<span class="property">active</span> &amp;&amp;</span><br><span class="line">                    !taskConfig[<span class="title class_">TaskType</span>.<span class="property">WATCH</span>].<span class="property">status</span>) &#123;</span><br><span class="line">                    <span class="title function_">log</span>(<span class="string">&#x27;任务二: 视听学习&#x27;</span>);</span><br><span class="line">                    <span class="comment">// 创建提示</span></span><br><span class="line">                    <span class="title function_">createTip</span>(<span class="string">&#x27;任务二: 视听学习&#x27;</span>);</span><br><span class="line">                    <span class="comment">// 暂停</span></span><br><span class="line">                    <span class="keyword">await</span> <span class="title function_">studyPauseLock</span>();</span><br><span class="line">                    <span class="comment">// 看视频</span></span><br><span class="line">                    <span class="keyword">await</span> <span class="title function_">watchVideo</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_">log</span>(<span class="string">&#x27;任务二: 视听学习已完成!&#x27;</span>);</span><br><span class="line">                <span class="comment">// 每日答题</span></span><br><span class="line">                <span class="keyword">if</span> (taskConfig[<span class="title class_">TaskType</span>.<span class="property">PRACTICE</span>].<span class="property">active</span> &amp;&amp;</span><br><span class="line">                    !taskConfig[<span class="title class_">TaskType</span>.<span class="property">PRACTICE</span>].<span class="property">status</span>) &#123;</span><br><span class="line">                    <span class="title function_">log</span>(<span class="string">&#x27;任务三: 每日答题&#x27;</span>);</span><br><span class="line">                    <span class="comment">// 创建提示</span></span><br><span class="line">                    <span class="title function_">createTip</span>(<span class="string">&#x27;任务三: 每日答题&#x27;</span>);</span><br><span class="line">                    <span class="comment">// 暂停</span></span><br><span class="line">                    <span class="keyword">await</span> <span class="title function_">studyPauseLock</span>();</span><br><span class="line">                    <span class="comment">// 做每日答题</span></span><br><span class="line">                    <span class="keyword">await</span> <span class="title function_">doExamPractice</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_">log</span>(<span class="string">&#x27;任务三: 每日答题已完成!&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@description</span> 暂停任务</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">function</span> <span class="title function_">pauseTask</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="comment">// 全局暂停</span></span><br><span class="line">                <span class="title function_">GM_setValue</span>(<span class="string">&#x27;pauseStudy&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">                taskStatus.<span class="property">value</span> = <span class="title class_">TaskStatusType</span>.<span class="property">PAUSE</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@description</span> 继续任务</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">function</span> <span class="title function_">continueTask</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="comment">// 全局暂停</span></span><br><span class="line">                <span class="title function_">GM_setValue</span>(<span class="string">&#x27;pauseStudy&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">                taskStatus.<span class="property">value</span> = <span class="title class_">TaskStatusType</span>.<span class="property">START</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@description</span> 开始任务</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">startTask</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="comment">// 未完成任务</span></span><br><span class="line">                <span class="keyword">if</span> (taskConfig.<span class="title function_">some</span>(<span class="function">(<span class="params">task</span>) =&gt;</span> task.<span class="property">active</span> &amp;&amp; !task.<span class="property">status</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 开始任务</span></span><br><span class="line">                    taskStatus.<span class="property">value</span> = <span class="title class_">TaskStatusType</span>.<span class="property">START</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 学习</span></span><br><span class="line">                        <span class="keyword">await</span> <span class="title function_">study</span>();</span><br><span class="line">                        <span class="comment">// 同屏任务</span></span><br><span class="line">                        <span class="keyword">if</span> (settings[<span class="title class_">SettingType</span>.<span class="property">SAME_TAB</span>]) &#123;</span><br><span class="line">                            <span class="comment">// 关闭窗口</span></span><br><span class="line">                            <span class="title function_">closeFrame</span>();</span><br><span class="line">                            <span class="comment">// 窗口不存在</span></span><br><span class="line">                            frame.<span class="property">exist</span> = <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (err <span class="keyword">instanceof</span> <span class="title class_">Error</span>) &#123;</span><br><span class="line">                            <span class="comment">// 提示</span></span><br><span class="line">                            <span class="title function_">createTip</span>(err.<span class="property">message</span>);</span><br><span class="line">                            <span class="comment">// 错误</span></span><br><span class="line">                            <span class="title function_">error</span>(err.<span class="property">message</span>);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 提示</span></span><br><span class="line">                        <span class="title function_">createTip</span>(err);</span><br><span class="line">                        <span class="comment">// 错误</span></span><br><span class="line">                        <span class="title function_">error</span>(err);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 刷新任务</span></span><br><span class="line">                taskStatus.<span class="property">value</span> = <span class="title class_">TaskStatusType</span>.<span class="property">FINISH</span>;</span><br><span class="line">                <span class="title function_">log</span>(<span class="string">&#x27;已完成&#x27;</span>);</span><br><span class="line">                <span class="comment">// 创建提示</span></span><br><span class="line">                <span class="title function_">createTip</span>(<span class="string">&#x27;完成学习!&#x27;</span>);</span><br><span class="line">                <span class="comment">// 远程推送</span></span><br><span class="line">                <span class="keyword">if</span> (settings[<span class="title class_">SettingType</span>.<span class="property">REMOTE_PUSH</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 推送</span></span><br><span class="line">                    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">pushModal</span>(&#123;</span><br><span class="line">                        <span class="attr">title</span>: <span class="string">&#x27;学习推送&#x27;</span>,</span><br><span class="line">                        <span class="attr">to</span>: userinfo.<span class="property">nick</span>,</span><br><span class="line">                        <span class="attr">content</span>: [</span><br><span class="line">                            <span class="string">&#x27;学习强国, 学习完成!&#x27;</span>,</span><br><span class="line">                            <span class="string">`当天积分:  <span class="subst">$&#123;getHighlightHTML(todayScore.value)&#125;</span> 分`</span>,</span><br><span class="line">                            <span class="string">`总积分: <span class="subst">$&#123;getHighlightHTML(totalScore.value)&#125;</span> 分`</span>,</span><br><span class="line">                            ...taskConfig.<span class="title function_">map</span>(<span class="function">(<span class="params">task</span>) =&gt;</span> <span class="title function_">getProgressHTML</span>(task.<span class="property">title</span>, task.<span class="property">percent</span>)),</span><br><span class="line">                        ],</span><br><span class="line">                        <span class="attr">type</span>: <span class="string">&#x27;success&#x27;</span>,</span><br><span class="line">                    &#125;, pushToken.<span class="property">value</span>);</span><br><span class="line">                    <span class="title function_">createTip</span>(<span class="string">`学习推送<span class="subst">$&#123;res ? <span class="string">&#x27;成功&#x27;</span> : <span class="string">&#x27;失败&#x27;</span>&#125;</span>!`</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 已在等待</span></span><br><span class="line">            <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 自动答题</span></span><br><span class="line">            <span class="title function_">watch</span>(<span class="function">() =&gt;</span> [taskStatus.<span class="property">value</span>, settings[<span class="title class_">SettingType</span>.<span class="property">AUTO_START</span>]], <span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">                <span class="comment">// 加载完毕</span></span><br><span class="line">                <span class="keyword">if</span> (!flag &amp;&amp; taskStatus.<span class="property">value</span> === <span class="title class_">TaskStatusType</span>.<span class="property">LOADED</span>) &#123;</span><br><span class="line">                    <span class="comment">// 自动答题</span></span><br><span class="line">                    <span class="keyword">if</span> (settings[<span class="title class_">SettingType</span>.<span class="property">AUTO_START</span>]) &#123;</span><br><span class="line">                        <span class="comment">// 等待中</span></span><br><span class="line">                        flag = <span class="literal">true</span>;</span><br><span class="line">                        <span class="comment">// 创建提示</span></span><br><span class="line">                        <span class="keyword">const</span> tip = <span class="title function_">createTip</span>(<span class="string">&#x27;即将自动开始任务&#x27;</span>, <span class="number">5</span>, <span class="literal">true</span>);</span><br><span class="line">                        <span class="comment">// 等待倒计时结束</span></span><br><span class="line">                        <span class="keyword">await</span> tip.<span class="title function_">waitCountDown</span>();</span><br><span class="line">                        <span class="comment">// 再次查看是否开启</span></span><br><span class="line">                        <span class="keyword">if</span> (settings[<span class="title class_">SettingType</span>.<span class="property">AUTO_START</span>] &amp;&amp;</span><br><span class="line">                            taskStatus.<span class="property">value</span> !== <span class="title class_">TaskStatusType</span>.<span class="property">START</span>) &#123;</span><br><span class="line">                            <span class="comment">// 创建提示</span></span><br><span class="line">                            <span class="title function_">createTip</span>(<span class="string">&#x27;自动开始任务&#x27;</span>);</span><br><span class="line">                            <span class="comment">// 开始任务</span></span><br><span class="line">                            <span class="title function_">startTask</span>();</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 取消等待</span></span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="comment">// 创建提示</span></span><br><span class="line">                        <span class="title function_">createTip</span>(<span class="string">&#x27;已取消自动开始任务!&#x27;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 切换开关任务未完成</span></span><br><span class="line">            taskConfig.<span class="title function_">forEach</span>(<span class="function">(<span class="params">task</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">watch</span>(<span class="function">() =&gt;</span> [task.<span class="property">active</span>], <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (taskStatus.<span class="property">value</span> === <span class="title class_">TaskStatusType</span>.<span class="property">FINISH</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (task.<span class="property">active</span> &amp;&amp; !task.<span class="property">status</span>) &#123;</span><br><span class="line">                            taskStatus.<span class="property">value</span> = <span class="title class_">TaskStatusType</span>.<span class="property">LOADED</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_study_item&#x27;</span> &#125;, <span class="title function_">createElementNode</span>(<span class="string">&#x27;button&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                <span class="attr">class</span>: <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> <span class="string">`egg_study_btn<span class="subst">$&#123;taskStatus.value === TaskStatusType.START ? <span class="string">&#x27; loading&#x27;</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>),</span><br><span class="line">                <span class="attr">type</span>: <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">                <span class="attr">disabled</span>: <span class="title function_">watchRef</span>(<span class="function">() =&gt;</span> [running.<span class="property">value</span>, taskStatus.<span class="property">value</span>], <span class="function">() =&gt;</span> running.<span class="property">value</span> ||</span><br><span class="line">                    taskStatus.<span class="property">value</span> === <span class="title class_">TaskStatusType</span>.<span class="property">LOADING</span> ||</span><br><span class="line">                    taskStatus.<span class="property">value</span> === <span class="title class_">TaskStatusType</span>.<span class="property">FINISH</span>),</span><br><span class="line">                <span class="attr">onclick</span>: <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> taskStatus.<span class="property">value</span> === <span class="title class_">TaskStatusType</span>.<span class="property">LOADED</span></span><br><span class="line">                    ? <span class="title function_">debounce</span>(startTask, <span class="number">300</span>)</span><br><span class="line">                    : taskStatus.<span class="property">value</span> === <span class="title class_">TaskStatusType</span>.<span class="property">START</span></span><br><span class="line">                        ? <span class="title function_">debounce</span>(pauseTask, <span class="number">300</span>)</span><br><span class="line">                        : taskStatus.<span class="property">value</span> === <span class="title class_">TaskStatusType</span>.<span class="property">PAUSE</span></span><br><span class="line">                            ? <span class="title function_">debounce</span>(continueTask, <span class="number">300</span>)</span><br><span class="line">                            : <span class="literal">undefined</span>),</span><br><span class="line">            &#125;, <span class="title function_">createTextNode</span>(<span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> <span class="string">`<span class="subst">$&#123;taskStatus.value === TaskStatusType.LOADING</span></span></span><br><span class="line"><span class="subst"><span class="string">                ? <span class="string">&#x27;等待中&#x27;</span></span></span></span><br><span class="line"><span class="subst"><span class="string">                : taskStatus.value === TaskStatusType.LOADED</span></span></span><br><span class="line"><span class="subst"><span class="string">                    ? <span class="string">&#x27;开始学习&#x27;</span></span></span></span><br><span class="line"><span class="subst"><span class="string">                    : taskStatus.value === TaskStatusType.START</span></span></span><br><span class="line"><span class="subst"><span class="string">                        ? <span class="string">&#x27;正在学习, 点击暂停&#x27;</span></span></span></span><br><span class="line"><span class="subst"><span class="string">                        : taskStatus.value === TaskStatusType.PAUSE</span></span></span><br><span class="line"><span class="subst"><span class="string">                            ? <span class="string">&#x27;继续学习&#x27;</span></span></span></span><br><span class="line"><span class="subst"><span class="string">                            : taskStatus.value === TaskStatusType.FINISH</span></span></span><br><span class="line"><span class="subst"><span class="string">                                ? <span class="string">&#x27;已完成&#x27;</span></span></span></span><br><span class="line"><span class="subst"><span class="string">                                : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>))));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 定时项目</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ScheduleList</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_schedule_list&#x27;</span> &#125;, <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> scheduleList.<span class="property">length</span></span><br><span class="line">            ? scheduleList.<span class="title function_">map</span>(<span class="function">(<span class="params">schedule</span>) =&gt;</span> <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_schedule_item&#x27;</span> &#125;, [</span><br><span class="line">                <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                    <span class="attr">class</span>: <span class="string">`egg_schedule_detail_time_wrap<span class="subst">$&#123;isLate(schedule) ? <span class="string">&#x27; inactive&#x27;</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>,</span><br><span class="line">                &#125;, [</span><br><span class="line">                    <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                        <span class="attr">class</span>: <span class="string">&#x27;egg_schedule_detail_icon&#x27;</span>,</span><br><span class="line">                    &#125;, <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;svg&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                        <span class="attr">viewBox</span>: <span class="string">&#x27;0 0 1024 1024&#x27;</span>,</span><br><span class="line">                        <span class="attr">class</span>: <span class="string">&#x27;egg_icon&#x27;</span>,</span><br><span class="line">                    &#125;, [</span><br><span class="line">                        <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;path&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                            <span class="attr">d</span>: <span class="string">&#x27;M810.137703 213.860762c-164.388001-164.4187-431.887404-164.4187-596.277452 0-164.417677 164.388001-164.417677 431.889451 0 596.278475 164.390048 164.417677 431.890474 164.417677 596.277452 0C974.557426 645.750213 974.557426 378.248763 810.137703 213.860762zM767.347131 767.345596c-140.797723 140.829446-369.927237 140.797723-510.693238 0-140.828422-140.797723-140.828422-369.895515 0-510.708588 140.767024-140.783397 369.896538-140.813073 510.693238 0C908.14383 397.420405 908.14383 626.578572 767.347131 767.345596z&#x27;</span>,</span><br><span class="line">                        &#125;),</span><br><span class="line">                        <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;path&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                            <span class="attr">d</span>: <span class="string">&#x27;M721.450824 521.495258 515.404028 521.495258l0.028653-227.948619c0-15.124466-12.362562-27.458375-27.501354-27.458375s-27.443026 12.33391-27.443026 27.458375l0 235.115855c0 0.835018-1.013073 20.48659 12.094456 34.459836 8.331759 8.809643 20.038382 13.288654 35.148521 13.288654l213.720569 0.031722c15.140839 0 27.472702-12.304234 27.472702-27.474748C748.922503 533.887496 736.620315 521.584286 721.450824 521.495258z&#x27;</span>,</span><br><span class="line">                        &#125;),</span><br><span class="line">                    ])),</span><br><span class="line">                    <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_schedule_detail_time&#x27;</span> &#125;, <span class="title function_">createTextNode</span>(schedule.<span class="property">time</span>)),</span><br><span class="line">                ]),</span><br><span class="line">                <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_schedule_detail_del_wrap&#x27;</span> &#125;, [</span><br><span class="line">                    <span class="title function_">createElementNode</span>(<span class="string">&#x27;button&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                        <span class="attr">class</span>: <span class="string">&#x27;egg_schedule_del_btn&#x27;</span>,</span><br><span class="line">                        <span class="attr">onclick</span>: <span class="title function_">debounce</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                            <span class="comment">// 定时刷新</span></span><br><span class="line">                            <span class="keyword">if</span> (!settings[<span class="title class_">SettingType</span>.<span class="property">SCHEDULE_RUN</span>]) &#123;</span><br><span class="line">                                <span class="title function_">createTip</span>(<span class="string">&#x27;未开启定时刷新!&#x27;</span>);</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 索引</span></span><br><span class="line">                            <span class="keyword">const</span> index = scheduleList.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">s</span>) =&gt;</span> s === schedule);</span><br><span class="line">                            <span class="comment">// 删除元素</span></span><br><span class="line">                            scheduleList.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">                            <span class="comment">// 存储</span></span><br><span class="line">                            <span class="title function_">GM_setValue</span>(<span class="string">&#x27;scheduleList&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(scheduleList));</span><br><span class="line">                            <span class="comment">// 刷新任务</span></span><br><span class="line">                            <span class="title function_">refreshScheduleTask</span>();</span><br><span class="line">                        &#125;, <span class="number">300</span>),</span><br><span class="line">                    &#125;, <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;svg&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                        <span class="attr">viewBox</span>: <span class="string">&#x27;0 0 1024 1024&#x27;</span>,</span><br><span class="line">                        <span class="attr">class</span>: <span class="string">&#x27;egg_icon&#x27;</span>,</span><br><span class="line">                    &#125;, [</span><br><span class="line">                        <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;path&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                            <span class="attr">d</span>: <span class="string">&#x27;M896.22 896.22c14.262-14.263 11.263-40.449-6.583-58.295L230.473 178.76c-17.847-17.847-44.105-20.846-58.295-6.583-14.263 14.19-11.264 40.448 6.583 58.295l659.164 659.164c17.846 17.846 44.032 20.845 58.294 6.582&#x27;</span>,</span><br><span class="line">                        &#125;),</span><br><span class="line">                        <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;path&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                            <span class="attr">d</span>: <span class="string">&#x27;M172.178 896.22c-14.263-14.263-11.264-40.449 6.583-58.295L837.925 178.76c17.846-17.847 44.032-20.846 58.294-6.583 14.263 14.19 11.264 40.448-6.582 58.295L230.4 889.637c-17.847 17.846-44.105 20.845-58.295 6.582&#x27;</span>,</span><br><span class="line">                        &#125;),</span><br><span class="line">                    ])),</span><br><span class="line">                ]),</span><br><span class="line">            ]))</span><br><span class="line">            : [</span><br><span class="line">                <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_schedule_list_none&#x27;</span> &#125;, [</span><br><span class="line">                    <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;svg&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                        <span class="attr">viewBox</span>: <span class="string">&#x27;0 0 1024 1024&#x27;</span>,</span><br><span class="line">                        <span class="attr">class</span>: <span class="string">&#x27;egg_icon&#x27;</span>,</span><br><span class="line">                    &#125;, [</span><br><span class="line">                        <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;path&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                            <span class="attr">d</span>: <span class="string">&#x27;M238.1 520.5c-17.6 0-31.9-14.3-31.9-31.9 0-17.6 14.3-31.9 31.9-31.9h293c17.6 0 31.9 14.3 31.9 31.9 0 17.6-14.3 31.9-31.9 31.9h-293zM238.1 733.6c-17.6 0-31.9-14.3-31.9-31.9s14.3-31.9 31.9-31.9h186.5c17.6 0 31.9 14.3 31.9 31.9s-14.3 31.9-31.9 31.9H238.1zM241.6 314.9c-17.6 0-31.9-14.3-31.9-31.9s14.3-31.9 31.9-31.9h426.1c17.6 0 31.9 14.3 31.9 31.9 0 17.5-14.3 31.7-31.8 31.9H241.6z&#x27;</span>,</span><br><span class="line">                        &#125;),</span><br><span class="line">                        <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;path&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                            <span class="attr">d</span>: <span class="string">&#x27;M160 926.6c-46.9 0-85.1-38.2-85.1-85.1V149.1c0-46.9 38.2-85.1 85.1-85.1h586c46.9 0 85.1 38.2 85.1 85.1v297.4c0 17.6-14.3 31.9-31.9 31.9-17.6 0-31.9-14.3-31.9-31.9V149.1c0-11.8-9.6-21.4-21.4-21.4H160c-11.8 0-21.4 9.6-21.4 21.4v692.4c0 11.8 9.6 21.4 21.4 21.4h304.5c17.5 0 31.8 14.2 31.9 31.8 0 17.6-14.3 31.8-31.9 31.8H160z&#x27;</span>,</span><br><span class="line">                        &#125;),</span><br><span class="line">                        <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;path&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                            <span class="attr">d</span>: <span class="string">&#x27;M917.2 959.9c-8.5 0-16.5-3.3-22.5-9.3l-78.5-78.5-5.3-0.5-0.6 0.4c-31.7 21.6-68.7 33-107 33-105.2 0-190.8-85.6-190.8-190.8s85.6-190.8 190.8-190.8c105.2 0 190.8 85.6 190.8 190.8 0 38.2-11.4 75.2-33 107l-0.4 0.6 0.5 5.3 78.5 78.5c6 6 9.3 14 9.3 22.5s-3.4 16.5-9.4 22.5c-5.9 6-13.9 9.3-22.4 9.3zM703.4 587c-70.1 0-127.2 57.1-127.2 127.2s57.1 127.2 127.2 127.2 127.2-57.1 127.2-127.2S773.6 587 703.4 587z&#x27;</span>,</span><br><span class="line">                        &#125;),</span><br><span class="line">                    ]),</span><br><span class="line">                    <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                        <span class="attr">class</span>: <span class="string">&#x27;egg_schedule_list_none_text&#x27;</span>,</span><br><span class="line">                    &#125;, <span class="title function_">createTextNode</span>(<span class="string">&#x27;暂无定时任务&#x27;</span>)),</span><br><span class="line">                ]),</span><br><span class="line">            ];</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 时间输入</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">TimeInput</span>(<span class="params">&#123; hour, minute, onchange, &#125;</span>) &#123;</span><br><span class="line">    <span class="comment">// 小时</span></span><br><span class="line">    <span class="keyword">const</span> hours = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">24</span>).<span class="title function_">fill</span>(<span class="literal">undefined</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">v, i</span>) =&gt;</span> (&#123;</span><br><span class="line">        <span class="attr">value</span>: i,</span><br><span class="line">        <span class="attr">label</span>: <span class="title function_">formatDateNum</span>(i),</span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="comment">// 分钟</span></span><br><span class="line">    <span class="keyword">const</span> minutes = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">60</span>).<span class="title function_">fill</span>(<span class="literal">undefined</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">v, i</span>) =&gt;</span> (&#123;</span><br><span class="line">        <span class="attr">value</span>: i,</span><br><span class="line">        <span class="attr">label</span>: <span class="title function_">formatDateNum</span>(i),</span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="keyword">const</span> valueRef = <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> h = hours.<span class="title function_">find</span>(<span class="function">(<span class="params">h</span>) =&gt;</span> h.<span class="property">value</span> === hour.<span class="property">value</span>);</span><br><span class="line">        <span class="keyword">const</span> min = minutes.<span class="title function_">find</span>(<span class="function">(<span class="params">min</span>) =&gt;</span> min.<span class="property">value</span> === minute.<span class="property">value</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">hour</span>: h ? h.<span class="property">value</span> : -<span class="number">1</span>,</span><br><span class="line">            <span class="attr">minute</span>: min ? min.<span class="property">value</span> : -<span class="number">1</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_time_input&#x27;</span> &#125;, [</span><br><span class="line">        <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_hour_wrap&#x27;</span> &#125;, [</span><br><span class="line">            <span class="title class_">Select</span>(&#123;</span><br><span class="line">                <span class="attr">data</span>: hours,</span><br><span class="line">                <span class="attr">placeholder</span>: <span class="string">&#x27;00&#x27;</span>,</span><br><span class="line">                <span class="attr">maxlength</span>: <span class="number">2</span>,</span><br><span class="line">                <span class="attr">value</span>: hour,</span><br><span class="line">                <span class="title function_">onchange</span>(<span class="params">&#123; value &#125;</span>) &#123;</span><br><span class="line">                    valueRef.<span class="property">value</span>.<span class="property">hour</span> = value;</span><br><span class="line">                    onchange &amp;&amp; <span class="title function_">onchange</span>(valueRef.<span class="property">value</span>);</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="title function_">onblur</span>(<span class="params">res</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">                        valueRef.<span class="property">value</span>.<span class="property">hour</span> = -<span class="number">1</span>;</span><br><span class="line">                        onchange &amp;&amp; <span class="title function_">onchange</span>(valueRef.<span class="property">value</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;),</span><br><span class="line">        ]),</span><br><span class="line">        <span class="title function_">createElementNode</span>(<span class="string">&#x27;span&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_separator&#x27;</span> &#125;, <span class="title function_">createTextNode</span>(<span class="string">&#x27;:&#x27;</span>)),</span><br><span class="line">        <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_minute_wrap&#x27;</span> &#125;, [</span><br><span class="line">            <span class="title class_">Select</span>(&#123;</span><br><span class="line">                <span class="attr">data</span>: minutes,</span><br><span class="line">                <span class="attr">placeholder</span>: <span class="string">&#x27;00&#x27;</span>,</span><br><span class="line">                <span class="attr">maxlength</span>: <span class="number">2</span>,</span><br><span class="line">                <span class="attr">value</span>: minute,</span><br><span class="line">                <span class="title function_">onchange</span>(<span class="params">&#123; value &#125;</span>) &#123;</span><br><span class="line">                    valueRef.<span class="property">value</span>.<span class="property">minute</span> = value;</span><br><span class="line">                    onchange &amp;&amp; <span class="title function_">onchange</span>(valueRef.<span class="property">value</span>);</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="title function_">onblur</span>(<span class="params">res</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">                        valueRef.<span class="property">value</span>.<span class="property">minute</span> = -<span class="number">1</span>;</span><br><span class="line">                        onchange &amp;&amp; <span class="title function_">onchange</span>(valueRef.<span class="property">value</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;),</span><br><span class="line">        ]),</span><br><span class="line">    ]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 设置面板组件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SettingsPanel</span>(<span class="params">&#123; show &#125;</span>) &#123;</span><br><span class="line">    <span class="comment">// token</span></span><br><span class="line">    <span class="keyword">let</span> token = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// 小时</span></span><br><span class="line">    <span class="keyword">let</span> hour = <span class="title function_">ref</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 分钟</span></span><br><span class="line">    <span class="keyword">let</span> minute = <span class="title function_">ref</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">        <span class="attr">class</span>: <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> <span class="string">`egg_settings<span class="subst">$&#123;show.value ? <span class="string">&#x27; active&#x27;</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>),</span><br><span class="line">    &#125;, [</span><br><span class="line">        <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_settings_version_wrap&#x27;</span> &#125;, [</span><br><span class="line">            <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_settings_label&#x27;</span> &#125;, <span class="title function_">createTextNode</span>(<span class="string">&#x27;版本信息&#x27;</span>)),</span><br><span class="line">            <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                <span class="attr">class</span>: <span class="string">&#x27;egg_settings_version&#x27;</span>,</span><br><span class="line">            &#125;, [</span><br><span class="line">                <span class="title function_">createTextNode</span>(<span class="string">`v<span class="subst">$&#123;version&#125;</span>`</span>),</span><br><span class="line">                <span class="title function_">createElementNode</span>(<span class="string">&#x27;a&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                    <span class="attr">class</span>: <span class="string">&#x27;egg_settings_version_detail&#x27;</span>,</span><br><span class="line">                    <span class="attr">title</span>: <span class="string">&#x27;GitHub Xu22Web/tech-study-js&#x27;</span>,</span><br><span class="line">                    <span class="attr">href</span>: <span class="string">&#x27;https://github.com/Xu22Web/tech-study-js&#x27;</span>,</span><br><span class="line">                &#125;, <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;svg&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                    <span class="attr">viewBox</span>: <span class="string">&#x27;0 0 16 16&#x27;</span>,</span><br><span class="line">                    <span class="attr">class</span>: <span class="string">&#x27;egg_icon&#x27;</span>,</span><br><span class="line">                &#125;, <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;path&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                    <span class="attr">d</span>: <span class="string">&#x27;M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z&#x27;</span>,</span><br><span class="line">                &#125;))),</span><br><span class="line">            ]),</span><br><span class="line">        ]),</span><br><span class="line">        <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_settings_theme_wrap&#x27;</span> &#125;, [</span><br><span class="line">            <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_settings_label&#x27;</span> &#125;, <span class="title function_">createTextNode</span>(<span class="string">&#x27;主题预设&#x27;</span>)),</span><br><span class="line">            <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_settings_theme_colors&#x27;</span> &#125;, [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="string">&#x27;#fa3333&#x27;</span>,</span><br><span class="line">                    <span class="attr">title</span>: <span class="string">&#x27;强国红&#x27;</span>,</span><br><span class="line">                    <span class="attr">detail</span>: <span class="string">&#x27;XueXi Red&#x27;</span>,</span><br><span class="line">                    <span class="attr">code</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="string">&#x27;#bb2649&#x27;</span>,</span><br><span class="line">                    <span class="attr">title</span>: <span class="string">&#x27;非凡洋红&#x27;</span>,</span><br><span class="line">                    <span class="attr">detail</span>: <span class="string">&#x27;Viva Magenta&#x27;</span>,</span><br><span class="line">                    <span class="attr">code</span>: <span class="string">&#x27;18-1750&#x27;</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="string">&#x27;#35548a&#x27;</span>,</span><br><span class="line">                    <span class="attr">title</span>: <span class="string">&#x27;经典蓝&#x27;</span>,</span><br><span class="line">                    <span class="attr">detail</span>: <span class="string">&#x27;Classic Blue&#x27;</span>,</span><br><span class="line">                    <span class="attr">code</span>: <span class="string">&#x27;19-4052&#x27;</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="string">&#x27;#f36f63&#x27;</span>,</span><br><span class="line">                    <span class="attr">title</span>: <span class="string">&#x27;活珊瑚橘&#x27;</span>,</span><br><span class="line">                    <span class="attr">detail</span>: <span class="string">&#x27;Living Coral&#x27;</span>,</span><br><span class="line">                    <span class="attr">code</span>: <span class="string">&#x27;16-1546&#x27;</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="string">&#x27;#6d5b97&#x27;</span>,</span><br><span class="line">                    <span class="attr">title</span>: <span class="string">&#x27;紫外光色&#x27;</span>,</span><br><span class="line">                    <span class="attr">detail</span>: <span class="string">&#x27;Ultra Violet&#x27;</span>,</span><br><span class="line">                    <span class="attr">code</span>: <span class="string">&#x27;18-3838&#x27;</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="string">&#x27;#86af49&#x27;</span>,</span><br><span class="line">                    <span class="attr">title</span>: <span class="string">&#x27;草木绿&#x27;</span>,</span><br><span class="line">                    <span class="attr">detail</span>: <span class="string">&#x27;Greenery&#x27;</span>,</span><br><span class="line">                    <span class="attr">code</span>: <span class="string">&#x27;15-0343&#x27;</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="string">&#x27;#fc8bab&#x27;</span>,</span><br><span class="line">                    <span class="attr">title</span>: <span class="string">&#x27;B站粉&#x27;</span>,</span><br><span class="line">                    <span class="attr">detail</span>: <span class="string">&#x27;Bilibili Pink&#x27;</span>,</span><br><span class="line">                    <span class="attr">code</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="string">&#x27;#056de8&#x27;</span>,</span><br><span class="line">                    <span class="attr">title</span>: <span class="string">&#x27;知乎蓝&#x27;</span>,</span><br><span class="line">                    <span class="attr">detail</span>: <span class="string">&#x27;Zhihu Blue&#x27;</span>,</span><br><span class="line">                    <span class="attr">code</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">            ].<span class="title function_">map</span>(<span class="function">(<span class="params">color</span>) =&gt;</span> <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                <span class="attr">class</span>: <span class="string">&#x27;egg_settings_theme_color_wrap&#x27;</span>,</span><br><span class="line">            &#125;, <span class="title function_">createElementNode</span>(<span class="string">&#x27;button&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                <span class="attr">class</span>: <span class="string">&#x27;egg_settings_theme_color&#x27;</span>,</span><br><span class="line">                <span class="attr">type</span>: <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">                <span class="attr">style</span>: <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> <span class="string">`color: <span class="subst">$&#123;color.value&#125;</span>;<span class="subst">$&#123;themeColor.value === color.value</span></span></span><br><span class="line"><span class="subst"><span class="string">                    ? <span class="string">&#x27;&#x27;</span></span></span></span><br><span class="line"><span class="subst"><span class="string">                    : <span class="string">` box-shadow: 0rem 0.4rem 0.1rem 0.1rem <span class="subst">$&#123;color.value&#125;</span>30;`</span>&#125;</span>`</span>),</span><br><span class="line">                <span class="attr">title</span>: color.<span class="property">title</span>,</span><br><span class="line">                <span class="attr">onclick</span>: <span class="title function_">debounce</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (themeColor.<span class="property">value</span> !== color.<span class="property">value</span>) &#123;</span><br><span class="line">                        themeColor.<span class="property">value</span> = color.<span class="property">value</span>;</span><br><span class="line">                        <span class="comment">// 存储</span></span><br><span class="line">                        <span class="title function_">GM_setValue</span>(<span class="string">&#x27;themeColor&#x27;</span>, themeColor.<span class="property">value</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="number">300</span>),</span><br><span class="line">            &#125;)))),</span><br><span class="line">        ]),</span><br><span class="line">        <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">            <span class="attr">class</span>: <span class="string">&#x27;egg_settings_read_time_wrap&#x27;</span>,</span><br><span class="line">        &#125;, [</span><br><span class="line">            <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_settings_label&#x27;</span> &#125;, <span class="title function_">createTextNode</span>(<span class="string">&#x27;最大文章时长&#x27;</span>)),</span><br><span class="line">            <span class="title class_">Select</span>(&#123;</span><br><span class="line">                <span class="attr">data</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">label</span>: <span class="string">&#x27;40s&#x27;</span>,</span><br><span class="line">                        <span class="attr">value</span>: <span class="number">40</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">label</span>: <span class="string">&#x27;60s&#x27;</span>,</span><br><span class="line">                        <span class="attr">value</span>: <span class="number">60</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">label</span>: <span class="string">&#x27;80s&#x27;</span>,</span><br><span class="line">                        <span class="attr">value</span>: <span class="number">80</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">label</span>: <span class="string">&#x27;100s&#x27;</span>,</span><br><span class="line">                        <span class="attr">value</span>: <span class="number">100</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">value</span>: maxRead,</span><br><span class="line">                <span class="attr">placeholder</span>: <span class="string">&#x27;100s&#x27;</span>,</span><br><span class="line">                <span class="attr">maxlength</span>: <span class="number">4</span>,</span><br><span class="line">                <span class="attr">keep</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="title function_">onchange</span>(<span class="params">&#123; value &#125;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 创建提示</span></span><br><span class="line">                    <span class="title function_">createTip</span>(<span class="string">&#x27;最大文章时长 已保存!&#x27;</span>);</span><br><span class="line">                    maxRead.<span class="property">value</span> = value;</span><br><span class="line">                    <span class="comment">// 存储</span></span><br><span class="line">                    <span class="title function_">GM_setValue</span>(<span class="string">&#x27;maxRead&#x27;</span>, value);</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;),</span><br><span class="line">        ], &#123;</span><br><span class="line">            <span class="title function_">onMounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> maxReadTemp = <span class="title function_">GM_getValue</span>(<span class="string">&#x27;maxRead&#x27;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (maxReadTemp) &#123;</span><br><span class="line">                        maxRead.<span class="property">value</span> = maxReadTemp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (e) &#123; &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">            <span class="attr">class</span>: <span class="string">&#x27;egg_settings_watch_time_wrap&#x27;</span>,</span><br><span class="line">        &#125;, [</span><br><span class="line">            <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_settings_label&#x27;</span> &#125;, <span class="title function_">createTextNode</span>(<span class="string">&#x27;最大视听时长&#x27;</span>)),</span><br><span class="line">            <span class="title class_">Select</span>(&#123;</span><br><span class="line">                <span class="attr">data</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">label</span>: <span class="string">&#x27;40s&#x27;</span>,</span><br><span class="line">                        <span class="attr">value</span>: <span class="number">40</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">label</span>: <span class="string">&#x27;60s&#x27;</span>,</span><br><span class="line">                        <span class="attr">value</span>: <span class="number">60</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">label</span>: <span class="string">&#x27;80s&#x27;</span>,</span><br><span class="line">                        <span class="attr">value</span>: <span class="number">80</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">label</span>: <span class="string">&#x27;100s&#x27;</span>,</span><br><span class="line">                        <span class="attr">value</span>: <span class="number">100</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">label</span>: <span class="string">&#x27;120s&#x27;</span>,</span><br><span class="line">                        <span class="attr">value</span>: <span class="number">120</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">value</span>: maxWatch,</span><br><span class="line">                <span class="attr">placeholder</span>: <span class="string">&#x27;120s&#x27;</span>,</span><br><span class="line">                <span class="attr">maxlength</span>: <span class="number">4</span>,</span><br><span class="line">                <span class="attr">keep</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="title function_">onchange</span>(<span class="params">&#123; value &#125;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 创建提示</span></span><br><span class="line">                    <span class="title function_">createTip</span>(<span class="string">&#x27;最大视听时长 已保存!&#x27;</span>);</span><br><span class="line">                    maxWatch.<span class="property">value</span> = value;</span><br><span class="line">                    <span class="comment">// 存储</span></span><br><span class="line">                    <span class="title function_">GM_setValue</span>(<span class="string">&#x27;maxWatch&#x27;</span>, value);</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;),</span><br><span class="line">        ], &#123;</span><br><span class="line">            <span class="title function_">onMounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> maxWatchTemp = <span class="title function_">GM_getValue</span>(<span class="string">&#x27;maxWatch&#x27;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (maxWatchTemp) &#123;</span><br><span class="line">                        maxWatch.<span class="property">value</span> = maxWatchTemp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (e) &#123; &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> settings[<span class="title class_">SettingType</span>.<span class="property">REMOTE_PUSH</span>]</span><br><span class="line">            ? <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_settings_token_wrap&#x27;</span> &#125;, [</span><br><span class="line">                <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_settings_token&#x27;</span> &#125;, [</span><br><span class="line">                    <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_settings_label&#x27;</span> &#125;, <span class="title function_">createTextNode</span>(<span class="string">&#x27;我的 token&#x27;</span>)),</span><br><span class="line">                    <span class="title function_">createElementNode</span>(<span class="string">&#x27;input&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                        <span class="attr">class</span>: <span class="string">&#x27;egg_settings_token_input&#x27;</span>,</span><br><span class="line">                        <span class="attr">placeholder</span>: <span class="string">&#x27;用户 token&#x27;</span>,</span><br><span class="line">                        <span class="attr">maxlength</span>: <span class="number">32</span>,</span><br><span class="line">                        <span class="attr">value</span>: pushToken.<span class="property">value</span>,</span><br><span class="line">                        <span class="attr">onfocus</span>: <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">                            <span class="keyword">const</span> input = e.<span class="property">target</span>;</span><br><span class="line">                            input.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;active&#x27;</span>);</span><br><span class="line">                            <span class="keyword">const</span> btnWrap = $$(<span class="string">&#x27;.egg_settings_submit_btn_wrap&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">                            btnWrap.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;active&#x27;</span>);</span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">onblur</span>: <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">                            <span class="keyword">const</span> input = e.<span class="property">target</span>;</span><br><span class="line">                            <span class="comment">// 去除空格</span></span><br><span class="line">                            <span class="keyword">const</span> value = input.<span class="property">value</span>.<span class="title function_">trim</span>();</span><br><span class="line">                            <span class="keyword">if</span> (<span class="regexp">/^[0-9a-z]&#123;32&#125;$/</span>.<span class="title function_">test</span>(value)) &#123;</span><br><span class="line">                                token = value;</span><br><span class="line">                                input.<span class="property">value</span> = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                token = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            input.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;active&#x27;</span>);</span><br><span class="line">                            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                                <span class="keyword">const</span> btnWrap = $$(<span class="string">&#x27;.egg_settings_submit_btn_wrap&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">                                btnWrap.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;active&#x27;</span>);</span><br><span class="line">                                input.<span class="property">value</span> = pushToken.<span class="property">value</span>;</span><br><span class="line">                            &#125;, <span class="number">200</span>);</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &#125;),</span><br><span class="line">                ]),</span><br><span class="line">                <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_settings_submit_btn_wrap&#x27;</span> &#125;, <span class="title function_">createElementNode</span>(<span class="string">&#x27;button&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                    <span class="attr">class</span>: <span class="string">&#x27;egg_settings_submit_btn&#x27;</span>,</span><br><span class="line">                    <span class="attr">onclick</span>: <span class="title function_">debounce</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="comment">// 创建提示</span></span><br><span class="line">                        <span class="title function_">createTip</span>(<span class="string">&#x27;用户 token 已保存!&#x27;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (token !== pushToken.<span class="property">value</span>) &#123;</span><br><span class="line">                            pushToken.<span class="property">value</span> = token;</span><br><span class="line">                            <span class="comment">// 存储</span></span><br><span class="line">                            <span class="title function_">GM_setValue</span>(<span class="string">&#x27;pushToken&#x27;</span>, token);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="number">300</span>),</span><br><span class="line">                &#125;, <span class="title function_">createTextNode</span>(<span class="string">&#x27;保存&#x27;</span>))),</span><br><span class="line">            ])</span><br><span class="line">            : <span class="literal">undefined</span>),</span><br><span class="line">        <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> settings[<span class="title class_">SettingType</span>.<span class="property">SCHEDULE_RUN</span>]</span><br><span class="line">            ? <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_schedule&#x27;</span> &#125;, [</span><br><span class="line">                <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_schedule_time_wrap&#x27;</span> &#125;, [</span><br><span class="line">                    <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_schedule_time&#x27;</span> &#125;, [</span><br><span class="line">                        <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_schedule_label&#x27;</span> &#125;, <span class="title function_">createTextNode</span>(<span class="string">&#x27;设置时间&#x27;</span>)),</span><br><span class="line">                        <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_schedule_time_input_wrap&#x27;</span> &#125;, [</span><br><span class="line">                            <span class="title class_">TimeInput</span>(&#123;</span><br><span class="line">                                hour,</span><br><span class="line">                                minute,</span><br><span class="line">                                <span class="title function_">onchange</span>(<span class="params">&#123; hour: h, minute: min &#125;</span>) &#123;</span><br><span class="line">                                    hour.<span class="property">value</span> = h;</span><br><span class="line">                                    minute.<span class="property">value</span> = min;</span><br><span class="line">                                &#125;,</span><br><span class="line">                            &#125;),</span><br><span class="line">                            <span class="title function_">createElementNode</span>(<span class="string">&#x27;button&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                                <span class="attr">class</span>: <span class="string">&#x27;egg_schedule_add_btn&#x27;</span>,</span><br><span class="line">                                <span class="attr">onclick</span>: <span class="title function_">debounce</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                                    <span class="comment">// 定时刷新</span></span><br><span class="line">                                    <span class="keyword">if</span> (!settings[<span class="title class_">SettingType</span>.<span class="property">SCHEDULE_RUN</span>]) &#123;</span><br><span class="line">                                        <span class="title function_">createTip</span>(<span class="string">&#x27;未开启定时刷新!&#x27;</span>);</span><br><span class="line">                                        <span class="keyword">return</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="keyword">if</span> (hour.<span class="property">value</span> === -<span class="number">1</span> || minute.<span class="property">value</span> === -<span class="number">1</span>) &#123;</span><br><span class="line">                                        <span class="title function_">createTip</span>(<span class="string">&#x27;时间格式不符合要求!&#x27;</span>);</span><br><span class="line">                                        <span class="keyword">return</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="comment">// 重复定时存在</span></span><br><span class="line">                                    <span class="keyword">const</span> exists = scheduleList.<span class="title function_">find</span>(<span class="function">(<span class="params">schedule</span>) =&gt;</span> schedule.<span class="property">hour</span> === hour.<span class="property">value</span> &amp;&amp;</span><br><span class="line">                                        schedule.<span class="property">minute</span> === minute.<span class="property">value</span>);</span><br><span class="line">                                    <span class="keyword">if</span> (exists) &#123;</span><br><span class="line">                                        <span class="title function_">createTip</span>(<span class="string">&#x27;设置定时任务重复!&#x27;</span>);</span><br><span class="line">                                        <span class="keyword">return</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="title function_">createTip</span>(<span class="string">&#x27;设置定时任务成功!&#x27;</span>);</span><br><span class="line">                                    <span class="comment">// 添加</span></span><br><span class="line">                                    scheduleList.<span class="title function_">push</span>(&#123;</span><br><span class="line">                                        <span class="attr">hour</span>: hour.<span class="property">value</span>,</span><br><span class="line">                                        <span class="attr">minute</span>: minute.<span class="property">value</span>,</span><br><span class="line">                                        <span class="attr">time</span>: <span class="string">`<span class="subst">$&#123;formatDateNum(hour.value)&#125;</span>:<span class="subst">$&#123;formatDateNum(minute.value)&#125;</span>`</span>,</span><br><span class="line">                                    &#125;);</span><br><span class="line">                                    <span class="comment">// 排序</span></span><br><span class="line">                                    scheduleList.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">hour</span> === b.<span class="property">hour</span></span><br><span class="line">                                        ? a.<span class="property">minute</span> - b.<span class="property">minute</span></span><br><span class="line">                                        : a.<span class="property">hour</span> - b.<span class="property">hour</span>);</span><br><span class="line">                                    <span class="comment">// 存储</span></span><br><span class="line">                                    <span class="title function_">GM_setValue</span>(<span class="string">&#x27;scheduleList&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(scheduleList));</span><br><span class="line">                                    <span class="comment">// 清空</span></span><br><span class="line">                                    hour.<span class="property">value</span> = -<span class="number">1</span>;</span><br><span class="line">                                    minute.<span class="property">value</span> = -<span class="number">1</span>;</span><br><span class="line">                                    <span class="keyword">const</span> inputs = $$(<span class="string">&#x27;.egg_time_input input&#x27;</span>);</span><br><span class="line">                                    inputs.<span class="title function_">forEach</span>(<span class="function">(<span class="params">i</span>) =&gt;</span> (i.<span class="property">value</span> = <span class="string">&#x27;&#x27;</span>));</span><br><span class="line">                                    <span class="comment">// 刷新任务</span></span><br><span class="line">                                    <span class="title function_">refreshScheduleTask</span>();</span><br><span class="line">                                &#125;, <span class="number">300</span>),</span><br><span class="line">                            &#125;, <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;svg&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                                <span class="attr">viewBox</span>: <span class="string">&#x27;0 0 1024 1024&#x27;</span>,</span><br><span class="line">                                <span class="attr">class</span>: <span class="string">&#x27;egg_icon&#x27;</span>,</span><br><span class="line">                            &#125;, <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;path&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                                <span class="attr">d</span>: <span class="string">&#x27;M801.171 483.589H544V226.418c0-17.673-14.327-32-32-32s-32 14.327-32 32v257.171H222.83c-17.673 0-32 14.327-32 32s14.327 32 32 32H480v257.17c0 17.673 14.327 32 32 32s32-14.327 32-32v-257.17h257.171c17.673 0 32-14.327 32-32s-14.327-32-32-32z&#x27;</span>,</span><br><span class="line">                            &#125;))),</span><br><span class="line">                        ]),</span><br><span class="line">                    ]),</span><br><span class="line">                ]),</span><br><span class="line">                <span class="title class_">ScheduleList</span>(),</span><br><span class="line">            ])</span><br><span class="line">            : <span class="literal">undefined</span>),</span><br><span class="line">    ], &#123;</span><br><span class="line">        <span class="title function_">onMounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">// 刷新token</span></span><br><span class="line">            <span class="title function_">watch</span>(<span class="function">() =&gt;</span> settings[<span class="title class_">SettingType</span>.<span class="property">REMOTE_PUSH</span>], <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 远程推送</span></span><br><span class="line">                <span class="keyword">if</span> (settings[<span class="title class_">SettingType</span>.<span class="property">REMOTE_PUSH</span>]) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">const</span> tokenTemp = <span class="title function_">GM_getValue</span>(<span class="string">&#x27;pushToken&#x27;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (tokenTemp) &#123;</span><br><span class="line">                            pushToken.<span class="property">value</span> = tokenTemp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (e) &#123; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// 刷新定时任务</span></span><br><span class="line">            <span class="title function_">watch</span>(<span class="function">() =&gt;</span> settings[<span class="title class_">SettingType</span>.<span class="property">SCHEDULE_RUN</span>], <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 定时任务打开</span></span><br><span class="line">                <span class="keyword">if</span> (settings[<span class="title class_">SettingType</span>.<span class="property">SCHEDULE_RUN</span>]) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">const</span> scheduleTemp = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title function_">GM_getValue</span>(<span class="string">&#x27;scheduleList&#x27;</span>));</span><br><span class="line">                        <span class="keyword">if</span> (scheduleTemp &amp;&amp; <span class="title class_">Array</span>.<span class="title function_">isArray</span>(scheduleTemp)) &#123;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">in</span> scheduleTemp) &#123;</span><br><span class="line">                                scheduleList[i] = scheduleTemp[i];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (e) &#123; &#125;</span><br><span class="line">                    <span class="comment">// 刷新定时任务</span></span><br><span class="line">                    <span class="title function_">refreshScheduleTask</span>();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 清除任务</span></span><br><span class="line">                <span class="title function_">clearScheduleTask</span>();</span><br><span class="line">            &#125;, <span class="literal">true</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 面板</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Panel</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 运行设置标签</span></span><br><span class="line">    <span class="keyword">const</span> runLabels = [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;自动开始&#x27;</span>,</span><br><span class="line">            <span class="attr">tip</span>: <span class="string">&#x27;启动时, 自动开始任务, 在倒计时结束前自动开始可随时取消; 如果在自动开始前手动开始任务, 此次自动开始将取消&#x27;</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="title class_">SettingType</span>.<span class="property">AUTO_START</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;同屏任务&#x27;</span>,</span><br><span class="line">            <span class="attr">tip</span>: <span class="string">&#x27;运行任务时，所有任务均在当前页面以弹窗方式运行&#x27;</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="title class_">SettingType</span>.<span class="property">SAME_TAB</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;静默运行&#x27;</span>,</span><br><span class="line">            <span class="attr">tip</span>: <span class="string">&#x27;同屏任务时, 不显示任务弹窗静默运行&#x27;</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="title class_">SettingType</span>.<span class="property">SILENT_RUN</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;定时刷新&#x27;</span>,</span><br><span class="line">            <span class="attr">tip</span>: <span class="string">&#x27;定时刷新页面，重新进行任务，此功能需要长时间占用浏览器&#x27;</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="title class_">SettingType</span>.<span class="property">SCHEDULE_RUN</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    ];</span><br><span class="line">    <span class="comment">// 运行设置标签</span></span><br><span class="line">    <span class="keyword">const</span> examLabels = [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;随机作答&#x27;</span>,</span><br><span class="line">            <span class="attr">tip</span>: <span class="string">&#x27;无答案时, 随机选择或者填入答案, 不保证正确&#x27;</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="title class_">SettingType</span>.<span class="property">RANDOM_EXAM</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    ];</span><br><span class="line">    <span class="comment">// 推送设置标签</span></span><br><span class="line">    <span class="keyword">const</span> pushLabels = [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;远程推送&#x27;</span>,</span><br><span class="line">            <span class="attr">tip</span>: <span class="string">&#x27;利用 pushplus 推送, 将登录二维码直接推送到微信公众号&#x27;</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="title class_">SettingType</span>.<span class="property">REMOTE_PUSH</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    ];</span><br><span class="line">    <span class="comment">// 处理设置变化</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleSettingsChange</span> = (<span class="params">e, type, title</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 开关</span></span><br><span class="line">        <span class="keyword">const</span> &#123; checked &#125; = e.<span class="property">target</span>;</span><br><span class="line">        <span class="keyword">if</span> (settings[type] !== checked) &#123;</span><br><span class="line">            settings[type] = checked;</span><br><span class="line">            <span class="comment">// 设置</span></span><br><span class="line">            <span class="title function_">GM_setValue</span>(<span class="string">&#x27;studySettings&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(settings));</span><br><span class="line">            <span class="comment">// 创建提示</span></span><br><span class="line">            <span class="title function_">createTip</span>(<span class="string">`<span class="subst">$&#123;title&#125;</span> <span class="subst">$&#123;checked ? <span class="string">&#x27;打开&#x27;</span> : <span class="string">&#x27;关闭&#x27;</span>&#125;</span>!`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 任务显示</span></span><br><span class="line">    <span class="keyword">const</span> scheduleShow = <span class="title function_">ref</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 面板显示</span></span><br><span class="line">    <span class="keyword">const</span> panelShow = <span class="title function_">ref</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">        <span class="attr">class</span>: <span class="string">`egg_panel_wrap<span class="subst">$&#123;hasMobile() ? <span class="string">&#x27; mobile&#x27;</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>,</span><br><span class="line">    &#125;, <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">        <span class="attr">class</span>: <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> <span class="string">`egg_panel<span class="subst">$&#123;panelShow.value ? <span class="string">&#x27; hide&#x27;</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>),</span><br><span class="line">    &#125;, [</span><br><span class="line">        <span class="comment">// 登录</span></span><br><span class="line">        <span class="title class_">LoginItem</span>(),</span><br><span class="line">        <span class="comment">// 信息</span></span><br><span class="line">        <span class="title class_">InfoItem</span>(),</span><br><span class="line">        <span class="comment">// 分数</span></span><br><span class="line">        <span class="title class_">ScoreItem</span>(),</span><br><span class="line">        <span class="comment">// 任务部分</span></span><br><span class="line">        <span class="title class_">Hr</span>(&#123; <span class="attr">text</span>: <span class="string">&#x27;任务&#x27;</span> &#125;),</span><br><span class="line">        <span class="title class_">TaskList</span>(),</span><br><span class="line">        <span class="comment">// 运行部分</span></span><br><span class="line">        <span class="title class_">Hr</span>(&#123; <span class="attr">text</span>: <span class="string">&#x27;运行&#x27;</span> &#125;),</span><br><span class="line">        <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_run_list&#x27;</span> &#125;, runLabels.<span class="title function_">map</span>(<span class="function">(<span class="params">label</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">NomalItem</span>(&#123;</span><br><span class="line">                <span class="attr">title</span>: label.<span class="property">title</span>,</span><br><span class="line">                <span class="attr">tip</span>: label.<span class="property">tip</span>,</span><br><span class="line">                <span class="attr">checked</span>: settings[label.<span class="property">type</span>],</span><br><span class="line">                <span class="attr">onchange</span>: <span class="title function_">debounce</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="title function_">handleSettingsChange</span>(e, label.<span class="property">type</span>, label.<span class="property">title</span>);</span><br><span class="line">                &#125;, <span class="number">300</span>),</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)),</span><br><span class="line">        <span class="comment">// 答题部分</span></span><br><span class="line">        <span class="title class_">Hr</span>(&#123; <span class="attr">text</span>: <span class="string">&#x27;答题&#x27;</span> &#125;),</span><br><span class="line">        <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_exam_list&#x27;</span> &#125;, examLabels.<span class="title function_">map</span>(<span class="function">(<span class="params">label</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">NomalItem</span>(&#123;</span><br><span class="line">                <span class="attr">title</span>: label.<span class="property">title</span>,</span><br><span class="line">                <span class="attr">tip</span>: label.<span class="property">tip</span>,</span><br><span class="line">                <span class="attr">checked</span>: settings[label.<span class="property">type</span>],</span><br><span class="line">                <span class="attr">onchange</span>: <span class="title function_">debounce</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="title function_">handleSettingsChange</span>(e, label.<span class="property">type</span>, label.<span class="property">title</span>);</span><br><span class="line">                &#125;, <span class="number">300</span>),</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)),</span><br><span class="line">        <span class="comment">// 推送部分</span></span><br><span class="line">        <span class="title class_">Hr</span>(&#123; <span class="attr">text</span>: <span class="string">&#x27;推送&#x27;</span> &#125;),</span><br><span class="line">        <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_push_list&#x27;</span> &#125;, pushLabels.<span class="title function_">map</span>(<span class="function">(<span class="params">label</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">NomalItem</span>(&#123;</span><br><span class="line">                <span class="attr">title</span>: label.<span class="property">title</span>,</span><br><span class="line">                <span class="attr">tip</span>: label.<span class="property">tip</span>,</span><br><span class="line">                <span class="attr">checked</span>: settings[label.<span class="property">type</span>],</span><br><span class="line">                <span class="attr">onchange</span>: <span class="title function_">debounce</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="title function_">handleSettingsChange</span>(e, label.<span class="property">type</span>, label.<span class="property">title</span>);</span><br><span class="line">                &#125;, <span class="number">300</span>),</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)),</span><br><span class="line">        <span class="comment">// 提示部分</span></span><br><span class="line">        <span class="title class_">Hr</span>(&#123; <span class="attr">text</span>: <span class="string">&#x27;提示&#x27;</span> &#125;),</span><br><span class="line">        <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_tip_list&#x27;</span> &#125;, [</span><br><span class="line">            <span class="title function_">createTextNode</span>(<span class="string">&#x27;专项练习已被移除, 如需使用, 请点击&#x27;</span>),</span><br><span class="line">            <span class="title function_">createElementNode</span>(<span class="string">&#x27;button&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                <span class="attr">class</span>: <span class="string">&#x27;egg_tip_btn&#x27;</span>,</span><br><span class="line">                <span class="attr">type</span>: <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">                <span class="attr">onclick</span>: <span class="title function_">debounce</span>(doExamPaper, <span class="number">300</span>),</span><br><span class="line">                <span class="attr">disabled</span>: <span class="title function_">watchRef</span>(<span class="function">() =&gt;</span> [running.<span class="property">value</span>, taskStatus.<span class="property">value</span>], <span class="function">() =&gt;</span> running.<span class="property">value</span> ||</span><br><span class="line">                    taskStatus.<span class="property">value</span> === <span class="title class_">TaskStatusType</span>.<span class="property">START</span> ||</span><br><span class="line">                    taskStatus.<span class="property">value</span> === <span class="title class_">TaskStatusType</span>.<span class="property">PAUSE</span>),</span><br><span class="line">            &#125;, <span class="title function_">createTextNode</span>(<span class="string">&#x27;去完成&#x27;</span>)),</span><br><span class="line">        ]),</span><br><span class="line">        <span class="comment">// 按钮集合</span></span><br><span class="line">        <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">            <span class="attr">class</span>: <span class="string">&#x27;egg_btns_wrap&#x27;</span>,</span><br><span class="line">        &#125;, [</span><br><span class="line">            <span class="title function_">createElementNode</span>(<span class="string">&#x27;button&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                <span class="attr">class</span>: <span class="title function_">watchRef</span>(<span class="function">() =&gt;</span> [frame.<span class="property">exist</span>, frame.<span class="property">show</span>], <span class="function">() =&gt;</span> <span class="string">`egg_frame_show_btn<span class="subst">$&#123;!frame.exist || frame.show ? <span class="string">&#x27; hide&#x27;</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>),</span><br><span class="line">                <span class="attr">title</span>: <span class="string">&#x27;窗口&#x27;</span>,</span><br><span class="line">                <span class="attr">type</span>: <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">                <span class="attr">onclick</span>: <span class="title function_">debounce</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 窗口显示</span></span><br><span class="line">                    frame.<span class="property">show</span> = <span class="literal">true</span>;</span><br><span class="line">                &#125;, <span class="number">300</span>),</span><br><span class="line">            &#125;, <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;svg&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                <span class="attr">viewBox</span>: <span class="string">&#x27;0 0 1024 1024&#x27;</span>,</span><br><span class="line">                <span class="attr">class</span>: <span class="string">&#x27;egg_icon&#x27;</span>,</span><br><span class="line">            &#125;, <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;path&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                <span class="attr">d</span>: <span class="string">&#x27;M836.224 106.666667h-490.666667a85.589333 85.589333 0 0 0-85.333333 85.333333V256h-64a85.589333 85.589333 0 0 0-85.333333 85.333333v490.666667a85.589333 85.589333 0 0 0 85.333333 85.333333h490.666667a85.589333 85.589333 0 0 0 85.333333-85.333333V768h64a85.589333 85.589333 0 0 0 85.333333-85.333333V192a85.589333 85.589333 0 0 0-85.333333-85.333333z m-132.266667 725.333333a20.138667 20.138667 0 0 1-21.333333 21.333333h-490.666667a20.138667 20.138667 0 0 1-21.333333-21.333333V341.333333a20.138667 20.138667 0 0 1 21.333333-21.333333h494.933334a20.138667 20.138667 0 0 1 21.333333 21.333333v490.666667z m153.6-149.333333a20.138667 20.138667 0 0 1-21.333333 21.333333h-64V341.333333a85.589333 85.589333 0 0 0-85.333333-85.333333h-362.666667V192a20.138667 20.138667 0 0 1 21.333333-21.333333h490.666667a20.138667 20.138667 0 0 1 21.333333 21.333333z&#x27;</span>,</span><br><span class="line">            &#125;))),</span><br><span class="line">            <span class="title function_">createElementNode</span>(<span class="string">&#x27;button&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                <span class="attr">class</span>: <span class="string">&#x27;egg_panel_show_btn&#x27;</span>,</span><br><span class="line">                <span class="attr">title</span>: <span class="string">&#x27;面板&#x27;</span>,</span><br><span class="line">                <span class="attr">type</span>: <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">                <span class="attr">onclick</span>: <span class="title function_">debounce</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    panelShow.<span class="property">value</span> = !panelShow.<span class="property">value</span>;</span><br><span class="line">                &#125;, <span class="number">300</span>),</span><br><span class="line">            &#125;, <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;svg&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                <span class="attr">viewBox</span>: <span class="string">&#x27;0 0 1024 1024&#x27;</span>,</span><br><span class="line">                <span class="attr">class</span>: <span class="string">&#x27;egg_icon&#x27;</span>,</span><br><span class="line">            &#125;, <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;path&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                <span class="attr">d</span>: <span class="string">&#x27;M332.16 883.84a40.96 40.96 0 0 0 58.24 0l338.56-343.04a40.96 40.96 0 0 0 0-58.24L390.4 140.16a40.96 40.96 0 0 0-58.24 58.24L640 512l-307.84 314.24a40.96 40.96 0 0 0 0 57.6z&#x27;</span>,</span><br><span class="line">            &#125;))),</span><br><span class="line">            <span class="title function_">createElementNode</span>(<span class="string">&#x27;button&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                <span class="attr">class</span>: <span class="title function_">watchEffectRef</span>(<span class="function">() =&gt;</span> <span class="string">`egg_settings_show_btn<span class="subst">$&#123;scheduleShow.value ? <span class="string">&#x27; active&#x27;</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>),</span><br><span class="line">                <span class="attr">title</span>: <span class="string">&#x27;设置&#x27;</span>,</span><br><span class="line">                <span class="attr">type</span>: <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">                <span class="attr">onclick</span>: <span class="title function_">debounce</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    scheduleShow.<span class="property">value</span> = !scheduleShow.<span class="property">value</span>;</span><br><span class="line">                &#125;, <span class="number">300</span>),</span><br><span class="line">            &#125;, <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;svg&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                <span class="attr">viewBox</span>: <span class="string">&#x27;0 0 1024 1024&#x27;</span>,</span><br><span class="line">                <span class="attr">class</span>: <span class="string">&#x27;egg_icon&#x27;</span>,</span><br><span class="line">            &#125;, [</span><br><span class="line">                <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;path&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                    <span class="attr">d</span>: <span class="string">&#x27;M7.25325 705.466473a503.508932 503.508932 0 0 0 75.26742 121.391295 95.499302 95.499302 0 0 0 93.211173 31.07039 168.59902 168.59902 0 0 1 114.526906 16.257763 148.487566 148.487566 0 0 1 71.052444 83.456515 91.163899 91.163899 0 0 0 75.989987 61.538643 578.053784 578.053784 0 0 0 148.969278 0A91.163899 91.163899 0 0 0 662.380873 957.642436a148.487566 148.487566 0 0 1 72.256723-83.456515 168.59902 168.59902 0 0 1 114.406478-16.257763 95.61973 95.61973 0 0 0 93.331601-31.07039 503.508932 503.508932 0 0 0 75.267419-121.391295 84.29951 84.29951 0 0 0-18.545892-94.897163 138.251197 138.251197 0 0 1 0-197.140426 84.29951 84.29951 0 0 0 18.545892-94.897163 503.508932 503.508932 0 0 0-75.869559-121.391295 95.499302 95.499302 0 0 0-93.211173-31.070391A168.59902 168.59902 0 0 1 734.637596 149.812272a148.848849 148.848849 0 0 1-72.256723-83.456515A91.163899 91.163899 0 0 0 586.631741 4.817115a581.907476 581.907476 0 0 0-148.969277 0A91.163899 91.163899 0 0 0 361.311193 66.355757a148.848849 148.848849 0 0 1-71.413728 83.456515 168.59902 168.59902 0 0 1-114.406478 16.257763 95.378874 95.378874 0 0 0-93.3316 31.070391A503.508932 503.508932 0 0 0 7.25325 318.531721a84.29951 84.29951 0 0 0 18.545893 94.897163 140.057615 140.057615 0 0 1 41.30676 98.509999 140.057615 140.057615 0 0 1-41.30676 98.630427A84.29951 84.29951 0 0 0 7.25325 705.466473z m929.462315-349.240828a219.901294 219.901294 0 0 0 0 312.028615c0.842995 0.842995 2.649413 3.010697 1.806418 5.057971a427.398517 427.398517 0 0 1-63.104205 101.520696 9.513802 9.513802 0 0 1-9.032091 2.167702 255.547944 255.547944 0 0 0-173.777418 24.928569 231.823653 231.823653 0 0 0-111.275354 130.302957 6.984817 6.984817 0 0 1-6.021394 4.937543 492.790851 492.790851 0 0 1-126.328837 0 6.984817 6.984817 0 0 1-6.021394-4.937543 231.823653 231.823653 0 0 0-111.275353-130.302957 255.668372 255.668372 0 0 0-120.427872-30.468252 258.919924 258.919924 0 0 0-52.747408 5.539683 9.513802 9.513802 0 0 1-9.03209-2.167702 427.398517 427.398517 0 0 1-63.104205-101.520696c-0.842995-2.047274 0.963423-4.214976 1.806418-5.057971a221.82814 221.82814 0 0 0 64.910623-156.556233 221.707712 221.707712 0 0 0-65.512762-155.713238c-0.842995-0.842995-2.649413-3.010697-1.806418-5.057971a427.398517 427.398517 0 0 1 63.104205-101.520696 9.393374 9.393374 0 0 1 8.911662-2.167701 255.7888 255.7888 0 0 0 173.897847-24.92857 231.823653 231.823653 0 0 0 111.275353-130.302957 6.984817 6.984817 0 0 1 6.021394-4.937543 492.790851 492.790851 0 0 1 126.328837 0 6.984817 6.984817 0 0 1 6.021394 4.937543 231.823653 231.823653 0 0 0 111.275354 130.302957 255.547944 255.547944 0 0 0 173.777418 24.92857 9.513802 9.513802 0 0 1 9.032091 2.167701 423.063113 423.063113 0 0 1 62.983777 101.520696c0.963423 2.047274-0.842995 4.214976-1.68599 5.057971z&#x27;</span>,</span><br><span class="line">                &#125;),</span><br><span class="line">                <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;path&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                    <span class="attr">d</span>: <span class="string">&#x27;M512.086889 305.766366a206.292944 206.292944 0 1 0 206.172516 206.172517 206.413372 206.413372 0 0 0-206.172516-206.172517z m123.197713 206.172517a123.197713 123.197713 0 1 1-123.197713-123.077285 123.318141 123.318141 0 0 1 123.197713 123.077285z&#x27;</span>,</span><br><span class="line">                &#125;),</span><br><span class="line">            ])),</span><br><span class="line">            <span class="title function_">createElementNode</span>(<span class="string">&#x27;button&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                <span class="attr">class</span>: <span class="string">&#x27;egg_settings_reset_btn&#x27;</span>,</span><br><span class="line">                <span class="attr">title</span>: <span class="string">&#x27;重置&#x27;</span>,</span><br><span class="line">                <span class="attr">type</span>: <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">                <span class="attr">onclick</span>: <span class="title function_">debounce</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 任务配置</span></span><br><span class="line">                    <span class="title function_">GM_setValue</span>(<span class="string">&#x27;taskConfig&#x27;</span>, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 设置</span></span><br><span class="line">                    <span class="title function_">GM_setValue</span>(<span class="string">&#x27;studySettings&#x27;</span>, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 最大阅读</span></span><br><span class="line">                    <span class="title function_">GM_setValue</span>(<span class="string">&#x27;maxRead&#x27;</span>, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 最大观看</span></span><br><span class="line">                    <span class="title function_">GM_setValue</span>(<span class="string">&#x27;maxWatch&#x27;</span>, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 主题色</span></span><br><span class="line">                    <span class="title function_">GM_setValue</span>(<span class="string">&#x27;themeColor&#x27;</span>, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 刷新页面</span></span><br><span class="line">                    location.<span class="title function_">reload</span>();</span><br><span class="line">                &#125;, <span class="number">300</span>),</span><br><span class="line">            &#125;, <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;svg&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                <span class="attr">viewBox</span>: <span class="string">&#x27;0 0 1024 1024&#x27;</span>,</span><br><span class="line">                <span class="attr">class</span>: <span class="string">&#x27;egg_icon&#x27;</span>,</span><br><span class="line">            &#125;, [</span><br><span class="line">                <span class="title function_">createNSElementNode</span>(<span class="string">&#x27;path&#x27;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">                    <span class="attr">d</span>: <span class="string">&#x27;M943.8 484.1c-17.5-13.7-42.8-10.7-56.6 6.8-5.7 7.3-8.5 15.8-8.6 24.4h-0.4c-0.6 78.3-26.1 157-78 223.3-124.9 159.2-356 187.1-515.2 62.3-31.7-24.9-58.2-54-79.3-85.9h77.1c22.4 0 40.7-18.3 40.7-40.7v-3c0-22.4-18.3-40.7-40.7-40.7H105.5c-22.4 0-40.7 18.3-40.7 40.7v177.3c0 22.4 18.3 40.7 40.7 40.7h3c22.4 0 40.7-18.3 40.7-40.7v-73.1c24.2 33.3 53 63.1 86 89 47.6 37.3 101 64.2 158.9 79.9 55.9 15.2 113.5 19.3 171.2 12.3 57.7-7 112.7-24.7 163.3-52.8 52.5-29 98-67.9 135.3-115.4 37.3-47.6 64.2-101 79.9-158.9 10.2-37.6 15.4-76 15.6-114.6h-0.1c-0.3-11.6-5.5-23.1-15.5-30.9zM918.7 135.2h-3c-22.4 0-40.7 18.3-40.7 40.7V249c-24.2-33.3-53-63.1-86-89-47.6-37.3-101-64.2-158.9-79.9-55.9-15.2-113.5-19.3-171.2-12.3-57.7 7-112.7 24.7-163.3 52.8-52.5 29-98 67.9-135.3 115.4-37.3 47.5-64.2 101-79.9 158.8-10.2 37.6-15.4 76-15.6 114.6h0.1c0.2 11.7 5.5 23.2 15.4 30.9 17.5 13.7 42.8 10.7 56.6-6.8 5.7-7.3 8.5-15.8 8.6-24.4h0.4c0.6-78.3 26.1-157 78-223.3 124.9-159.2 356-187.1 515.2-62.3 31.7 24.9 58.2 54 79.3 85.9h-77.1c-22.4 0-40.7 18.3-40.7 40.7v3c0 22.4 18.3 40.7 40.7 40.7h177.3c22.4 0 40.7-18.3 40.7-40.7V175.8c0.1-22.3-18.2-40.6-40.6-40.6z&#x27;</span>,</span><br><span class="line">                &#125;),</span><br><span class="line">            ])),</span><br><span class="line">        ]),</span><br><span class="line">        <span class="comment">// 任务按钮</span></span><br><span class="line">        <span class="title class_">TaskBtn</span>(),</span><br><span class="line">        <span class="title function_">createElementNode</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;egg_settings_item&#x27;</span> &#125;, [</span><br><span class="line">            <span class="title class_">SettingsPanel</span>(&#123; <span class="attr">show</span>: scheduleShow &#125;),</span><br><span class="line">        ]),</span><br><span class="line">    ]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 日常工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 学习工具 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
